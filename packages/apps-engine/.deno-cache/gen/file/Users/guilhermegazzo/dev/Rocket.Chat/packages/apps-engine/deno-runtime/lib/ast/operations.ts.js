// @deno-types="../../acorn.d.ts"
export function getFunctionIdentifier(ancestors, functionNodeIndex) {
  const parent = ancestors[functionNodeIndex - 1];
  // If there is a parent node and it's not a computed property, we can try to
  // extract an identifier for our function from it. This needs to be done first
  // because when functions are assigned to named symbols, this will be the only
  // way to call it, even if the function itself has an identifier
  // Consider the following block:
  //
  // const foo = function bar() {}
  //
  // Even though the function itself has a name, the only way to call it in the
  // program is wiht `foo()`
  if (parent && !parent.computed) {
    // Several node types can have an id prop of type Identifier
    const { id } = parent;
    if (id?.type === 'Identifier') {
      return id.name;
    }
    // Usually assignments to object properties (MethodDefinition, Property)
    const { key } = parent;
    if (key?.type === 'Identifier') {
      return key.name;
    }
    // Variable assignments have left hand side that can be used as Identifier
    const { left } = parent;
    // Simple assignment: `const fn = () => {}`
    if (left?.type === 'Identifier') {
      return left.name;
    }
    // Object property assignment: `obj.fn = () => {}`
    if (left?.type === 'MemberExpression' && !left.computed) {
      return left.property.name;
    }
  }
  // nodeIndex needs to be the index of a Function node (either FunctionDeclaration or FunctionExpression)
  const currentNode = ancestors[functionNodeIndex];
  // Function declarations or expressions can be directly named
  if (currentNode.id?.type === 'Identifier') {
    return currentNode.id.name;
  }
}
export function wrapWithAwait(node) {
  if (!node.type.endsWith('Expression')) {
    throw new Error(`Can't wrap "${node.type}" with await`);
  }
  const innerNode = {
    ...node
  };
  node.type = 'AwaitExpression';
  // starting here node has become an AwaitExpression
  node.argument = innerNode;
  Object.keys(node).forEach((key)=>![
      'type',
      'argument'
    ].includes(key) && delete node[key]);
}
export function asyncifyScope(ancestors, state) {
  const functionNodeIndex = ancestors.findLastIndex((n)=>'async' in n);
  if (functionNodeIndex === -1) return;
  // At this point this is a node with an "async" property, so it has to be
  // of type Function - let TS know about that
  const functionScopeNode = ancestors[functionNodeIndex];
  if (functionScopeNode.async) {
    return;
  }
  functionScopeNode.async = true;
  // If the parent of a function node is a call expression, we're talking about an IIFE
  // Should we care about this case as well?
  // const parentNode = ancestors[functionScopeIndex-1];
  // if (parentNode?.type === 'CallExpression' && ancestors[functionScopeIndex-2] && ancestors[functionScopeIndex-2].type !== 'AwaitExpression') {
  //   pendingOperations.push(buildFunctionPredicate(getFunctionIdentifier(ancestors, functionScopeIndex-2)));
  // }
  const identifier = getFunctionIdentifier(ancestors, functionNodeIndex);
  // We can't fix calls of functions which name we can't determine at compile time
  if (!identifier) return;
  state.functionIdentifiers.add(identifier);
}
export function buildFixModifiedFunctionsOperation(functionIdentifiers) {
  return function _fixModifiedFunctionsOperation(node, state, ancestors) {
    if (node.type !== 'CallExpression') return;
    let isWrappable = false;
    // This node is a simple call to a function, like `fn()`
    isWrappable = node.callee.type === 'Identifier' && functionIdentifiers.has(node.callee.name);
    // This node is a call to an object property or instance method, like `obj.fn()`, but not computed like `obj[fn]()`
    isWrappable ||= node.callee.type === 'MemberExpression' && !node.callee.computed && node.callee.property?.type === 'Identifier' && functionIdentifiers.has(node.callee.property.name);
    // This is a weird dereferencing technique used by bundlers, and since we'll be dealing with bundled sources we have to check for it
    // e.g. `r=(0,fn)(e)`
    if (!isWrappable && node.callee.type === 'SequenceExpression') {
      const [, secondExpression] = node.callee.expressions;
      isWrappable = secondExpression?.type === 'Identifier' && functionIdentifiers.has(secondExpression.name);
      isWrappable ||= secondExpression?.type === 'MemberExpression' && !secondExpression.computed && secondExpression.property.type === 'Identifier' && functionIdentifiers.has(secondExpression.property.name);
    }
    if (!isWrappable) return;
    // ancestors[ancestors.length-1] === node, so here we're checking for parent node
    const parentNode = ancestors[ancestors.length - 2];
    if (!parentNode || parentNode.type === 'AwaitExpression') return;
    wrapWithAwait(node);
    asyncifyScope(ancestors, state);
    state.isModified = true;
  };
}
export const checkReassignmentOfModifiedIdentifiers = (node, { functionIdentifiers }, _ancestors)=>{
  if (node.type === 'AssignmentExpression') {
    if (node.operator !== '=') return;
    let identifier = '';
    if (node.left.type === 'Identifier') identifier = node.left.name;
    if (node.left.type === 'MemberExpression' && !node.left.computed) {
      identifier = node.left.property.name;
    }
    if (!identifier || node.right.type !== 'Identifier' || !functionIdentifiers.has(node.right.name)) return;
    functionIdentifiers.add(identifier);
    return;
  }
  if (node.type === 'VariableDeclarator') {
    if (node.id.type !== 'Identifier' || functionIdentifiers.has(node.id.name)) return;
    if (node.init?.type !== 'Identifier' || !functionIdentifiers.has(node.init?.name)) return;
    functionIdentifiers.add(node.id.name);
    return;
  }
  // "Property" is for plain objects, "PropertyDefinition" is for classes
  // but both share the same structure
  if (node.type === 'Property' || node.type === 'PropertyDefinition') {
    if (node.key.type !== 'Identifier' || functionIdentifiers.has(node.key.name)) return;
    if (node.value?.type !== 'Identifier' || !functionIdentifiers.has(node.value.name)) return;
    functionIdentifiers.add(node.key.name);
    return;
  }
};
export const fixLivechatIsOnlineCalls = (node, state, ancestors)=>{
  if (node.type !== 'MemberExpression' || node.computed) return;
  if (node.property.name !== 'isOnline') return;
  if (node.object.type !== 'CallExpression') return;
  if (node.object.callee.type !== 'MemberExpression') return;
  if (node.object.callee.property.name !== 'getLivechatReader') return;
  let parentIndex = ancestors.length - 2;
  let targetNode = ancestors[parentIndex];
  if (targetNode.type !== 'CallExpression') {
    targetNode = node;
  } else {
    parentIndex--;
  }
  // If we're already wrapped with an await, nothing to do
  if (ancestors[parentIndex].type === 'AwaitExpression') return;
  // If we're in the middle of a chained member access, we can't wrap with await
  if (ancestors[parentIndex].type === 'MemberExpression') return;
  wrapWithAwait(targetNode);
  asyncifyScope(ancestors, state);
  state.isModified = true;
};
export const fixRoomUsernamesCalls = (node, state, ancestors)=>{
  if (node.type !== 'MemberExpression' || node.computed) return;
  if (node.property.name !== 'usernames') return;
  let parentIndex = ancestors.length - 2;
  let targetNode = ancestors[parentIndex];
  if (targetNode.type !== 'CallExpression') {
    targetNode = node;
  } else {
    parentIndex--;
  }
  // If we're already wrapped with an await, nothing to do
  if (ancestors[parentIndex].type === 'AwaitExpression') return;
  wrapWithAwait(targetNode);
  asyncifyScope(ancestors, state);
  state.isModified = true;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vVXNlcnMvZ3VpbGhlcm1lZ2F6em8vZGV2L1JvY2tldC5DaGF0L3BhY2thZ2VzL2FwcHMtZW5naW5lL2Rlbm8tcnVudGltZS9saWIvYXN0L29wZXJhdGlvbnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQGRlbm8tdHlwZXM9XCIuLi8uLi9hY29ybi5kLnRzXCJcbmltcG9ydCB7IEFueU5vZGUsIEFzc2lnbm1lbnRFeHByZXNzaW9uLCBBd2FpdEV4cHJlc3Npb24sIEV4cHJlc3Npb24sIEZ1bmN0aW9uLCBJZGVudGlmaWVyLCBNZXRob2REZWZpbml0aW9uLCBQcm9wZXJ0eSB9IGZyb20gJ2Fjb3JuJztcbi8vIEBkZW5vLXR5cGVzPVwiLi4vLi4vYWNvcm4td2Fsay5kLnRzXCJcbmltcG9ydCB7IEZ1bGxBbmNlc3RvcldhbGtlckNhbGxiYWNrIH0gZnJvbSAnYWNvcm4td2Fsayc7XG5cbmV4cG9ydCB0eXBlIFdhbGtlclN0YXRlID0ge1xuICAgIGlzTW9kaWZpZWQ6IGJvb2xlYW47XG4gICAgZnVuY3Rpb25JZGVudGlmaWVyczogU2V0PHN0cmluZz47XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnVuY3Rpb25JZGVudGlmaWVyKGFuY2VzdG9yczogQW55Tm9kZVtdLCBmdW5jdGlvbk5vZGVJbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgcGFyZW50ID0gYW5jZXN0b3JzW2Z1bmN0aW9uTm9kZUluZGV4IC0gMV07XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHBhcmVudCBub2RlIGFuZCBpdCdzIG5vdCBhIGNvbXB1dGVkIHByb3BlcnR5LCB3ZSBjYW4gdHJ5IHRvXG4gICAgLy8gZXh0cmFjdCBhbiBpZGVudGlmaWVyIGZvciBvdXIgZnVuY3Rpb24gZnJvbSBpdC4gVGhpcyBuZWVkcyB0byBiZSBkb25lIGZpcnN0XG4gICAgLy8gYmVjYXVzZSB3aGVuIGZ1bmN0aW9ucyBhcmUgYXNzaWduZWQgdG8gbmFtZWQgc3ltYm9scywgdGhpcyB3aWxsIGJlIHRoZSBvbmx5XG4gICAgLy8gd2F5IHRvIGNhbGwgaXQsIGV2ZW4gaWYgdGhlIGZ1bmN0aW9uIGl0c2VsZiBoYXMgYW4gaWRlbnRpZmllclxuICAgIC8vIENvbnNpZGVyIHRoZSBmb2xsb3dpbmcgYmxvY2s6XG4gICAgLy9cbiAgICAvLyBjb25zdCBmb28gPSBmdW5jdGlvbiBiYXIoKSB7fVxuICAgIC8vXG4gICAgLy8gRXZlbiB0aG91Z2ggdGhlIGZ1bmN0aW9uIGl0c2VsZiBoYXMgYSBuYW1lLCB0aGUgb25seSB3YXkgdG8gY2FsbCBpdCBpbiB0aGVcbiAgICAvLyBwcm9ncmFtIGlzIHdpaHQgYGZvbygpYFxuICAgIGlmIChwYXJlbnQgJiYgIShwYXJlbnQgYXMgUHJvcGVydHkgfCBNZXRob2REZWZpbml0aW9uKS5jb21wdXRlZCkge1xuICAgICAgICAvLyBTZXZlcmFsIG5vZGUgdHlwZXMgY2FuIGhhdmUgYW4gaWQgcHJvcCBvZiB0eXBlIElkZW50aWZpZXJcbiAgICAgICAgY29uc3QgeyBpZCB9ID0gcGFyZW50IGFzIHVua25vd24gYXMgeyBpZD86IElkZW50aWZpZXIgfTtcbiAgICAgICAgaWYgKGlkPy50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpZC5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXN1YWxseSBhc3NpZ25tZW50cyB0byBvYmplY3QgcHJvcGVydGllcyAoTWV0aG9kRGVmaW5pdGlvbiwgUHJvcGVydHkpXG4gICAgICAgIGNvbnN0IHsga2V5IH0gPSBwYXJlbnQgYXMgTWV0aG9kRGVmaW5pdGlvbiB8IFByb3BlcnR5O1xuICAgICAgICBpZiAoa2V5Py50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkubmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhcmlhYmxlIGFzc2lnbm1lbnRzIGhhdmUgbGVmdCBoYW5kIHNpZGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBJZGVudGlmaWVyXG4gICAgICAgIGNvbnN0IHsgbGVmdCB9ID0gcGFyZW50IGFzIEFzc2lnbm1lbnRFeHByZXNzaW9uO1xuXG4gICAgICAgIC8vIFNpbXBsZSBhc3NpZ25tZW50OiBgY29uc3QgZm4gPSAoKSA9PiB7fWBcbiAgICAgICAgaWYgKGxlZnQ/LnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQubmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9iamVjdCBwcm9wZXJ0eSBhc3NpZ25tZW50OiBgb2JqLmZuID0gKCkgPT4ge31gXG4gICAgICAgIGlmIChsZWZ0Py50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiYgIWxlZnQuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAobGVmdC5wcm9wZXJ0eSBhcyBJZGVudGlmaWVyKS5uYW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm9kZUluZGV4IG5lZWRzIHRvIGJlIHRoZSBpbmRleCBvZiBhIEZ1bmN0aW9uIG5vZGUgKGVpdGhlciBGdW5jdGlvbkRlY2xhcmF0aW9uIG9yIEZ1bmN0aW9uRXhwcmVzc2lvbilcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IGFuY2VzdG9yc1tmdW5jdGlvbk5vZGVJbmRleF0gYXMgRnVuY3Rpb247XG5cbiAgICAvLyBGdW5jdGlvbiBkZWNsYXJhdGlvbnMgb3IgZXhwcmVzc2lvbnMgY2FuIGJlIGRpcmVjdGx5IG5hbWVkXG4gICAgaWYgKGN1cnJlbnROb2RlLmlkPy50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnROb2RlLmlkLm5hbWU7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcFdpdGhBd2FpdChub2RlOiBFeHByZXNzaW9uKSB7XG4gICAgaWYgKCFub2RlLnR5cGUuZW5kc1dpdGgoJ0V4cHJlc3Npb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHdyYXAgXCIke25vZGUudHlwZX1cIiB3aXRoIGF3YWl0YCk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5uZXJOb2RlOiBFeHByZXNzaW9uID0geyAuLi5ub2RlIH07XG5cbiAgICBub2RlLnR5cGUgPSAnQXdhaXRFeHByZXNzaW9uJztcbiAgICAvLyBzdGFydGluZyBoZXJlIG5vZGUgaGFzIGJlY29tZSBhbiBBd2FpdEV4cHJlc3Npb25cbiAgICAobm9kZSBhcyBBd2FpdEV4cHJlc3Npb24pLmFyZ3VtZW50ID0gaW5uZXJOb2RlO1xuXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZm9yRWFjaCgoa2V5KSA9PiAhWyd0eXBlJywgJ2FyZ3VtZW50J10uaW5jbHVkZXMoa2V5KSAmJiBkZWxldGUgbm9kZVtrZXkgYXMga2V5b2YgQW55Tm9kZV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXN5bmNpZnlTY29wZShhbmNlc3RvcnM6IEFueU5vZGVbXSwgc3RhdGU6IFdhbGtlclN0YXRlKSB7XG4gICAgY29uc3QgZnVuY3Rpb25Ob2RlSW5kZXggPSBhbmNlc3RvcnMuZmluZExhc3RJbmRleCgobikgPT4gJ2FzeW5jJyBpbiBuKTtcbiAgICBpZiAoZnVuY3Rpb25Ob2RlSW5kZXggPT09IC0xKSByZXR1cm47XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoaXMgaXMgYSBub2RlIHdpdGggYW4gXCJhc3luY1wiIHByb3BlcnR5LCBzbyBpdCBoYXMgdG8gYmVcbiAgICAvLyBvZiB0eXBlIEZ1bmN0aW9uIC0gbGV0IFRTIGtub3cgYWJvdXQgdGhhdFxuICAgIGNvbnN0IGZ1bmN0aW9uU2NvcGVOb2RlID0gYW5jZXN0b3JzW2Z1bmN0aW9uTm9kZUluZGV4XSBhcyBGdW5jdGlvbjtcblxuICAgIGlmIChmdW5jdGlvblNjb3BlTm9kZS5hc3luYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb25TY29wZU5vZGUuYXN5bmMgPSB0cnVlO1xuXG4gICAgLy8gSWYgdGhlIHBhcmVudCBvZiBhIGZ1bmN0aW9uIG5vZGUgaXMgYSBjYWxsIGV4cHJlc3Npb24sIHdlJ3JlIHRhbGtpbmcgYWJvdXQgYW4gSUlGRVxuICAgIC8vIFNob3VsZCB3ZSBjYXJlIGFib3V0IHRoaXMgY2FzZSBhcyB3ZWxsP1xuICAgIC8vIGNvbnN0IHBhcmVudE5vZGUgPSBhbmNlc3RvcnNbZnVuY3Rpb25TY29wZUluZGV4LTFdO1xuICAgIC8vIGlmIChwYXJlbnROb2RlPy50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nICYmIGFuY2VzdG9yc1tmdW5jdGlvblNjb3BlSW5kZXgtMl0gJiYgYW5jZXN0b3JzW2Z1bmN0aW9uU2NvcGVJbmRleC0yXS50eXBlICE9PSAnQXdhaXRFeHByZXNzaW9uJykge1xuICAgIC8vICAgcGVuZGluZ09wZXJhdGlvbnMucHVzaChidWlsZEZ1bmN0aW9uUHJlZGljYXRlKGdldEZ1bmN0aW9uSWRlbnRpZmllcihhbmNlc3RvcnMsIGZ1bmN0aW9uU2NvcGVJbmRleC0yKSkpO1xuICAgIC8vIH1cblxuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBnZXRGdW5jdGlvbklkZW50aWZpZXIoYW5jZXN0b3JzLCBmdW5jdGlvbk5vZGVJbmRleCk7XG5cbiAgICAvLyBXZSBjYW4ndCBmaXggY2FsbHMgb2YgZnVuY3Rpb25zIHdoaWNoIG5hbWUgd2UgY2FuJ3QgZGV0ZXJtaW5lIGF0IGNvbXBpbGUgdGltZVxuICAgIGlmICghaWRlbnRpZmllcikgcmV0dXJuO1xuXG4gICAgc3RhdGUuZnVuY3Rpb25JZGVudGlmaWVycy5hZGQoaWRlbnRpZmllcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEZpeE1vZGlmaWVkRnVuY3Rpb25zT3BlcmF0aW9uKGZ1bmN0aW9uSWRlbnRpZmllcnM6IFNldDxzdHJpbmc+KTogRnVsbEFuY2VzdG9yV2Fsa2VyQ2FsbGJhY2s8V2Fsa2VyU3RhdGU+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gX2ZpeE1vZGlmaWVkRnVuY3Rpb25zT3BlcmF0aW9uKG5vZGUsIHN0YXRlLCBhbmNlc3RvcnMpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ0NhbGxFeHByZXNzaW9uJykgcmV0dXJuO1xuXG4gICAgICAgIGxldCBpc1dyYXBwYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFRoaXMgbm9kZSBpcyBhIHNpbXBsZSBjYWxsIHRvIGEgZnVuY3Rpb24sIGxpa2UgYGZuKClgXG4gICAgICAgIGlzV3JhcHBhYmxlID0gbm9kZS5jYWxsZWUudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmIGZ1bmN0aW9uSWRlbnRpZmllcnMuaGFzKG5vZGUuY2FsbGVlLm5hbWUpO1xuXG4gICAgICAgIC8vIFRoaXMgbm9kZSBpcyBhIGNhbGwgdG8gYW4gb2JqZWN0IHByb3BlcnR5IG9yIGluc3RhbmNlIG1ldGhvZCwgbGlrZSBgb2JqLmZuKClgLCBidXQgbm90IGNvbXB1dGVkIGxpa2UgYG9ialtmbl0oKWBcbiAgICAgICAgaXNXcmFwcGFibGUgfHw9XG4gICAgICAgICAgICBub2RlLmNhbGxlZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiZcbiAgICAgICAgICAgICFub2RlLmNhbGxlZS5jb21wdXRlZCAmJlxuICAgICAgICAgICAgbm9kZS5jYWxsZWUucHJvcGVydHk/LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuICAgICAgICAgICAgZnVuY3Rpb25JZGVudGlmaWVycy5oYXMobm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSk7XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIHdlaXJkIGRlcmVmZXJlbmNpbmcgdGVjaG5pcXVlIHVzZWQgYnkgYnVuZGxlcnMsIGFuZCBzaW5jZSB3ZSdsbCBiZSBkZWFsaW5nIHdpdGggYnVuZGxlZCBzb3VyY2VzIHdlIGhhdmUgdG8gY2hlY2sgZm9yIGl0XG4gICAgICAgIC8vIGUuZy4gYHI9KDAsZm4pKGUpYFxuICAgICAgICBpZiAoIWlzV3JhcHBhYmxlICYmIG5vZGUuY2FsbGVlLnR5cGUgPT09ICdTZXF1ZW5jZUV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICBjb25zdCBbLCBzZWNvbmRFeHByZXNzaW9uXSA9IG5vZGUuY2FsbGVlLmV4cHJlc3Npb25zO1xuICAgICAgICAgICAgaXNXcmFwcGFibGUgPSBzZWNvbmRFeHByZXNzaW9uPy50eXBlID09PSAnSWRlbnRpZmllcicgJiYgZnVuY3Rpb25JZGVudGlmaWVycy5oYXMoc2Vjb25kRXhwcmVzc2lvbi5uYW1lKTtcbiAgICAgICAgICAgIGlzV3JhcHBhYmxlIHx8PVxuICAgICAgICAgICAgICAgIHNlY29uZEV4cHJlc3Npb24/LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJlxuICAgICAgICAgICAgICAgICFzZWNvbmRFeHByZXNzaW9uLmNvbXB1dGVkICYmXG4gICAgICAgICAgICAgICAgc2Vjb25kRXhwcmVzc2lvbi5wcm9wZXJ0eS50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgICAgICAgICAgICBmdW5jdGlvbklkZW50aWZpZXJzLmhhcyhzZWNvbmRFeHByZXNzaW9uLnByb3BlcnR5Lm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1dyYXBwYWJsZSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGFuY2VzdG9yc1thbmNlc3RvcnMubGVuZ3RoLTFdID09PSBub2RlLCBzbyBoZXJlIHdlJ3JlIGNoZWNraW5nIGZvciBwYXJlbnQgbm9kZVxuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jZXN0b3JzW2FuY2VzdG9ycy5sZW5ndGggLSAyXTtcbiAgICAgICAgaWYgKCFwYXJlbnROb2RlIHx8IHBhcmVudE5vZGUudHlwZSA9PT0gJ0F3YWl0RXhwcmVzc2lvbicpIHJldHVybjtcblxuICAgICAgICB3cmFwV2l0aEF3YWl0KG5vZGUpO1xuICAgICAgICBhc3luY2lmeVNjb3BlKGFuY2VzdG9ycywgc3RhdGUpO1xuXG4gICAgICAgIHN0YXRlLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgIH07XG59XG5cbmV4cG9ydCBjb25zdCBjaGVja1JlYXNzaWdubWVudE9mTW9kaWZpZWRJZGVudGlmaWVyczogRnVsbEFuY2VzdG9yV2Fsa2VyQ2FsbGJhY2s8V2Fsa2VyU3RhdGU+ID0gKG5vZGUsIHsgZnVuY3Rpb25JZGVudGlmaWVycyB9LCBfYW5jZXN0b3JzKSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJykge1xuICAgICAgICBpZiAobm9kZS5vcGVyYXRvciAhPT0gJz0nKSByZXR1cm47XG5cbiAgICAgICAgbGV0IGlkZW50aWZpZXIgPSAnJztcblxuICAgICAgICBpZiAobm9kZS5sZWZ0LnR5cGUgPT09ICdJZGVudGlmaWVyJykgaWRlbnRpZmllciA9IG5vZGUubGVmdC5uYW1lO1xuXG4gICAgICAgIGlmIChub2RlLmxlZnQudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmICFub2RlLmxlZnQuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXIgPSAobm9kZS5sZWZ0LnByb3BlcnR5IGFzIElkZW50aWZpZXIpLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlkZW50aWZpZXIgfHwgbm9kZS5yaWdodC50eXBlICE9PSAnSWRlbnRpZmllcicgfHwgIWZ1bmN0aW9uSWRlbnRpZmllcnMuaGFzKG5vZGUucmlnaHQubmFtZSkpIHJldHVybjtcblxuICAgICAgICBmdW5jdGlvbklkZW50aWZpZXJzLmFkZChpZGVudGlmaWVyKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRvcicpIHtcbiAgICAgICAgaWYgKG5vZGUuaWQudHlwZSAhPT0gJ0lkZW50aWZpZXInIHx8IGZ1bmN0aW9uSWRlbnRpZmllcnMuaGFzKG5vZGUuaWQubmFtZSkpIHJldHVybjtcblxuICAgICAgICBpZiAobm9kZS5pbml0Py50eXBlICE9PSAnSWRlbnRpZmllcicgfHwgIWZ1bmN0aW9uSWRlbnRpZmllcnMuaGFzKG5vZGUuaW5pdD8ubmFtZSkpIHJldHVybjtcblxuICAgICAgICBmdW5jdGlvbklkZW50aWZpZXJzLmFkZChub2RlLmlkLm5hbWUpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBcIlByb3BlcnR5XCIgaXMgZm9yIHBsYWluIG9iamVjdHMsIFwiUHJvcGVydHlEZWZpbml0aW9uXCIgaXMgZm9yIGNsYXNzZXNcbiAgICAvLyBidXQgYm90aCBzaGFyZSB0aGUgc2FtZSBzdHJ1Y3R1cmVcbiAgICBpZiAobm9kZS50eXBlID09PSAnUHJvcGVydHknIHx8IG5vZGUudHlwZSA9PT0gJ1Byb3BlcnR5RGVmaW5pdGlvbicpIHtcbiAgICAgICAgaWYgKG5vZGUua2V5LnR5cGUgIT09ICdJZGVudGlmaWVyJyB8fCBmdW5jdGlvbklkZW50aWZpZXJzLmhhcyhub2RlLmtleS5uYW1lKSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChub2RlLnZhbHVlPy50eXBlICE9PSAnSWRlbnRpZmllcicgfHwgIWZ1bmN0aW9uSWRlbnRpZmllcnMuaGFzKG5vZGUudmFsdWUubmFtZSkpIHJldHVybjtcblxuICAgICAgICBmdW5jdGlvbklkZW50aWZpZXJzLmFkZChub2RlLmtleS5uYW1lKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGZpeExpdmVjaGF0SXNPbmxpbmVDYWxsczogRnVsbEFuY2VzdG9yV2Fsa2VyQ2FsbGJhY2s8V2Fsa2VyU3RhdGU+ID0gKG5vZGUsIHN0YXRlLCBhbmNlc3RvcnMpID0+IHtcbiAgICBpZiAobm9kZS50eXBlICE9PSAnTWVtYmVyRXhwcmVzc2lvbicgfHwgbm9kZS5jb21wdXRlZCkgcmV0dXJuO1xuXG4gICAgaWYgKChub2RlLnByb3BlcnR5IGFzIElkZW50aWZpZXIpLm5hbWUgIT09ICdpc09ubGluZScpIHJldHVybjtcblxuICAgIGlmIChub2RlLm9iamVjdC50eXBlICE9PSAnQ2FsbEV4cHJlc3Npb24nKSByZXR1cm47XG5cbiAgICBpZiAobm9kZS5vYmplY3QuY2FsbGVlLnR5cGUgIT09ICdNZW1iZXJFeHByZXNzaW9uJykgcmV0dXJuO1xuXG4gICAgaWYgKChub2RlLm9iamVjdC5jYWxsZWUucHJvcGVydHkgYXMgSWRlbnRpZmllcikubmFtZSAhPT0gJ2dldExpdmVjaGF0UmVhZGVyJykgcmV0dXJuO1xuXG4gICAgbGV0IHBhcmVudEluZGV4ID0gYW5jZXN0b3JzLmxlbmd0aCAtIDI7XG4gICAgbGV0IHRhcmdldE5vZGUgPSBhbmNlc3RvcnNbcGFyZW50SW5kZXhdO1xuXG4gICAgaWYgKHRhcmdldE5vZGUudHlwZSAhPT0gJ0NhbGxFeHByZXNzaW9uJykge1xuICAgICAgICB0YXJnZXROb2RlID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRJbmRleC0tO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgd3JhcHBlZCB3aXRoIGFuIGF3YWl0LCBub3RoaW5nIHRvIGRvXG4gICAgaWYgKGFuY2VzdG9yc1twYXJlbnRJbmRleF0udHlwZSA9PT0gJ0F3YWl0RXhwcmVzc2lvbicpIHJldHVybjtcblxuICAgIC8vIElmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSBjaGFpbmVkIG1lbWJlciBhY2Nlc3MsIHdlIGNhbid0IHdyYXAgd2l0aCBhd2FpdFxuICAgIGlmIChhbmNlc3RvcnNbcGFyZW50SW5kZXhdLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykgcmV0dXJuO1xuXG4gICAgd3JhcFdpdGhBd2FpdCh0YXJnZXROb2RlKTtcbiAgICBhc3luY2lmeVNjb3BlKGFuY2VzdG9ycywgc3RhdGUpO1xuXG4gICAgc3RhdGUuaXNNb2RpZmllZCA9IHRydWU7XG59O1xuXG5leHBvcnQgY29uc3QgZml4Um9vbVVzZXJuYW1lc0NhbGxzOiBGdWxsQW5jZXN0b3JXYWxrZXJDYWxsYmFjazxXYWxrZXJTdGF0ZT4gPSAobm9kZSwgc3RhdGUsIGFuY2VzdG9ycykgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgIT09ICdNZW1iZXJFeHByZXNzaW9uJyB8fCBub2RlLmNvbXB1dGVkKSByZXR1cm47XG5cbiAgICBpZiAoKG5vZGUucHJvcGVydHkgYXMgSWRlbnRpZmllcikubmFtZSAhPT0gJ3VzZXJuYW1lcycpIHJldHVybjtcblxuICAgIGxldCBwYXJlbnRJbmRleCA9IGFuY2VzdG9ycy5sZW5ndGggLSAyO1xuICAgIGxldCB0YXJnZXROb2RlID0gYW5jZXN0b3JzW3BhcmVudEluZGV4XTtcblxuICAgIGlmICh0YXJnZXROb2RlLnR5cGUgIT09ICdDYWxsRXhwcmVzc2lvbicpIHtcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50SW5kZXgtLTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHdyYXBwZWQgd2l0aCBhbiBhd2FpdCwgbm90aGluZyB0byBkb1xuICAgIGlmIChhbmNlc3RvcnNbcGFyZW50SW5kZXhdLnR5cGUgPT09ICdBd2FpdEV4cHJlc3Npb24nKSByZXR1cm47XG5cbiAgICB3cmFwV2l0aEF3YWl0KHRhcmdldE5vZGUpO1xuICAgIGFzeW5jaWZ5U2NvcGUoYW5jZXN0b3JzLCBzdGF0ZSk7XG5cbiAgICBzdGF0ZS5pc01vZGlmaWVkID0gdHJ1ZTtcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUM7QUFVakMsT0FBTyxTQUFTLHNCQUFzQixTQUFvQixFQUFFLGlCQUF5QjtFQUNqRixNQUFNLFNBQVMsU0FBUyxDQUFDLG9CQUFvQixFQUFFO0VBRS9DLDRFQUE0RTtFQUM1RSw4RUFBOEU7RUFDOUUsOEVBQThFO0VBQzlFLGdFQUFnRTtFQUNoRSxnQ0FBZ0M7RUFDaEMsRUFBRTtFQUNGLGdDQUFnQztFQUNoQyxFQUFFO0VBQ0YsNkVBQTZFO0VBQzdFLDBCQUEwQjtFQUMxQixJQUFJLFVBQVUsQ0FBQyxBQUFDLE9BQXVDLFFBQVEsRUFBRTtJQUM3RCw0REFBNEQ7SUFDNUQsTUFBTSxFQUFFLEVBQUUsRUFBRSxHQUFHO0lBQ2YsSUFBSSxJQUFJLFNBQVMsY0FBYztNQUMzQixPQUFPLEdBQUcsSUFBSTtJQUNsQjtJQUVBLHdFQUF3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