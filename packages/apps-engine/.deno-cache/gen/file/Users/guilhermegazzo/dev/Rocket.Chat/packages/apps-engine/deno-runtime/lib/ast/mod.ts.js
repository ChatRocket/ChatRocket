import { generate } from "astring";
// @deno-types="../../acorn.d.ts"
import { parse } from "acorn";
// @deno-types="../../acorn-walk.d.ts"
import { fullAncestor } from "acorn-walk";
import * as operations from "./operations.ts";
function fixAst(ast) {
  const pendingOperations = [
    operations.fixLivechatIsOnlineCalls,
    operations.checkReassignmentOfModifiedIdentifiers,
    operations.fixRoomUsernamesCalls
  ];
  // Have we touched the tree?
  let isModified = false;
  while(pendingOperations.length){
    const ops = pendingOperations.splice(0);
    const state = {
      isModified: false,
      functionIdentifiers: new Set()
    };
    fullAncestor(ast, (node, state, ancestors, type)=>{
      ops.forEach((operation)=>operation(node, state, ancestors, type));
    }, undefined, state);
    if (state.isModified) {
      isModified = true;
    }
    if (state.functionIdentifiers.size) {
      pendingOperations.push(operations.buildFixModifiedFunctionsOperation(state.functionIdentifiers), operations.checkReassignmentOfModifiedIdentifiers);
    }
  }
  return isModified;
}
export function fixBrokenSynchronousAPICalls(appSource) {
  const astRootNode = parse(appSource, {
    ecmaVersion: 2017,
    // Allow everything, we don't want to complain if code is badly written
    // Also, since the code itself has been transpiled, the chance of getting
    // shenanigans is lower
    allowReserved: true,
    allowReturnOutsideFunction: true,
    allowImportExportEverywhere: true,
    allowAwaitOutsideFunction: true,
    allowSuperOutsideMethod: true
  });
  if (fixAst(astRootNode)) {
    return generate(astRootNode);
  }
  return appSource;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vVXNlcnMvZ3VpbGhlcm1lZ2F6em8vZGV2L1JvY2tldC5DaGF0L3BhY2thZ2VzL2FwcHMtZW5naW5lL2Rlbm8tcnVudGltZS9saWIvYXN0L21vZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZW5lcmF0ZSB9IGZyb20gXCJhc3RyaW5nXCI7XG4vLyBAZGVuby10eXBlcz1cIi4uLy4uL2Fjb3JuLmQudHNcIlxuaW1wb3J0IHsgUHJvZ3JhbSwgcGFyc2UgfSBmcm9tIFwiYWNvcm5cIjtcbi8vIEBkZW5vLXR5cGVzPVwiLi4vLi4vYWNvcm4td2Fsay5kLnRzXCJcbmltcG9ydCB7IGZ1bGxBbmNlc3RvciB9IGZyb20gXCJhY29ybi13YWxrXCI7XG5cbmltcG9ydCAqIGFzIG9wZXJhdGlvbnMgZnJvbSBcIi4vb3BlcmF0aW9ucy50c1wiO1xuaW1wb3J0IHR5cGUgeyBXYWxrZXJTdGF0ZSB9IGZyb20gXCIuL29wZXJhdGlvbnMudHNcIjtcblxuZnVuY3Rpb24gZml4QXN0KGFzdDogUHJvZ3JhbSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHBlbmRpbmdPcGVyYXRpb25zID0gW1xuICAgICAgICBvcGVyYXRpb25zLmZpeExpdmVjaGF0SXNPbmxpbmVDYWxscyxcbiAgICAgICAgb3BlcmF0aW9ucy5jaGVja1JlYXNzaWdubWVudE9mTW9kaWZpZWRJZGVudGlmaWVycyxcbiAgICAgICAgb3BlcmF0aW9ucy5maXhSb29tVXNlcm5hbWVzQ2FsbHMsXG4gICAgXTtcblxuICAgIC8vIEhhdmUgd2UgdG91Y2hlZCB0aGUgdHJlZT9cbiAgICBsZXQgaXNNb2RpZmllZCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBvcHMgPSBwZW5kaW5nT3BlcmF0aW9ucy5zcGxpY2UoMCk7XG4gICAgICAgIGNvbnN0IHN0YXRlOiBXYWxrZXJTdGF0ZSA9IHtcbiAgICAgICAgICAgIGlzTW9kaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZnVuY3Rpb25JZGVudGlmaWVyczogbmV3IFNldDxzdHJpbmc+KCksXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVsbEFuY2VzdG9yKGFzdCwgKG5vZGUsIHN0YXRlLCBhbmNlc3RvcnMsIHR5cGUpID0+IHtcbiAgICAgICAgICAgIG9wcy5mb3JFYWNoKG9wZXJhdGlvbiA9PiBvcGVyYXRpb24obm9kZSwgc3RhdGUsIGFuY2VzdG9ycywgdHlwZSkpO1xuICAgICAgICB9LCB1bmRlZmluZWQsIHN0YXRlKTtcblxuICAgICAgICBpZiAoc3RhdGUuaXNNb2RpZmllZCkge1xuICAgICAgICAgICAgaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuZnVuY3Rpb25JZGVudGlmaWVycy5zaXplKSB7XG4gICAgICAgICAgICBwZW5kaW5nT3BlcmF0aW9ucy5wdXNoKFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMuYnVpbGRGaXhNb2RpZmllZEZ1bmN0aW9uc09wZXJhdGlvbihzdGF0ZS5mdW5jdGlvbklkZW50aWZpZXJzKSxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25zLmNoZWNrUmVhc3NpZ25tZW50T2ZNb2RpZmllZElkZW50aWZpZXJzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzTW9kaWZpZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXhCcm9rZW5TeW5jaHJvbm91c0FQSUNhbGxzKGFwcFNvdXJjZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBhc3RSb290Tm9kZSA9IHBhcnNlKGFwcFNvdXJjZSwge1xuICAgICAgICBlY21hVmVyc2lvbjogMjAxNyxcbiAgICAgICAgLy8gQWxsb3cgZXZlcnl0aGluZywgd2UgZG9uJ3Qgd2FudCB0byBjb21wbGFpbiBpZiBjb2RlIGlzIGJhZGx5IHdyaXR0ZW5cbiAgICAgICAgLy8gQWxzbywgc2luY2UgdGhlIGNvZGUgaXRzZWxmIGhhcyBiZWVuIHRyYW5zcGlsZWQsIHRoZSBjaGFuY2Ugb2YgZ2V0dGluZ1xuICAgICAgICAvLyBzaGVuYW5pZ2FucyBpcyBsb3dlclxuICAgICAgICBhbGxvd1Jlc2VydmVkOiB0cnVlLFxuICAgICAgICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogdHJ1ZSxcbiAgICAgICAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiB0cnVlLFxuICAgICAgICBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiB0cnVlLFxuICAgICAgICBhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIGlmIChmaXhBc3QoYXN0Um9vdE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZShhc3RSb290Tm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFwcFNvdXJjZTtcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLFFBQVEsUUFBUSxVQUFVO0FBQ25DLGlDQUFpQztBQUNqQyxTQUFrQixLQUFLLFFBQVEsUUFBUTtBQUN2QyxzQ0FBc0M7QUFDdEMsU0FBUyxZQUFZLFFBQVEsYUFBYTtBQUUxQyxZQUFZLGdCQUFnQixrQkFBa0I7QUFHOUMsU0FBUyxPQUFPLEdBQVk7RUFDeEIsTUFBTSxvQkFBb0I7SUFDdEIsV0FBVyx3QkFBd0I7SUFDbkMsV0FBVyxzQ0FBc0M7SUFDakQsV0FBVyxxQkFBcUI7R0FDbkM7RUFFRCw0QkFBNEI7RUFDNUIsSUFBSSxhQUFhO0VBRWpCLE1BQU8sa0JBQWtCLE1BQU0sQ0FBRTtJQUM3QixNQUFNLE1BQU0sa0JBQWtCLE1BQU0sQ0FBQztJQUNyQyxNQUFNLFFBQXFCO01BQ3ZCLFlBQVk7TUFDWixxQkFBcUIsSUFBSTtJQUM3QjtJQUVBLGFBQWEsS0FBSyxDQUFDLE1BQU0sT0FBTyxXQUFXO01BQ3ZDLElBQUksT0FBTyxDQUFDLENBQUEsWUFBYSxVQUFVLE1BQU0sT0FBTyxXQUFXO0lBQy9ELEdBQUcsV0FBVztJQUVkLElBQUksTUFBTSxVQUFVLEVBQUU7TUFDbEIsYUFBYTtJQUNqQjtJQUVBLElBQUksTUFBTSxtQkFBbUIsQ0FBQyxJQUFJLEVBQUU7TUFDaEMsa0JBQWtCLElBQUksQ0FDbEIsV0FBVyxrQ0FBa0MsQ0FBQyxNQUFNLG1CQUFtQixHQUN2RSxXQUFXLHNDQUFzQztJQUV6RDtFQUNKO0VBRUEsT0FBTztBQUNYO0FBRUEsT0FBTyxTQUFTLDZCQUE2QixTQUFpQjtFQUMxRCxNQUFNLGNBQWMsTUFBTSxXQUFXO0lBQ2pDLGFBQWE7SUFDYix1RUFBdUU7SUFDdkUseUVBQXlFO0lBQ3pFLHVCQUF1QjtJQUN2QixlQUFlO0lBQ2YsNEJBQTRCO0lBQzVCLDZCQUE2QjtJQUM3QiwyQkFBMkI7SUFDM0IseUJBQXlCO0VBQzdCO0VBRUEsSUFBSSxPQUFPLGNBQWM7SUFDckIsT0FBTyxTQUFTO0VBQ3BCO0VBRUEsT0FBTztBQUNYIn0=