[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\nPackage[\"core-runtime\"].queue(\"kadira:flow-router\",function () {/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar ReactiveDict = Package['reactive-dict'].ReactiveDict;\nvar ReactiveVar = Package['reactive-var'].ReactiveVar;\nvar EJSON = Package.ejson.EJSON;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package.modules.meteorBabelHelpers;\n\n/* Package-scope variables */\nvar page, qs, Triggers, Router, Group, Route, FlowRouter;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"kadira:flow-router\":{\"client\":{\"modules.js\":function module(require){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/kadira_flow-router/client/modules.js                                                                      //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\npage = require('page');\nqs = require('qs');\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"triggers.js\":function module(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/kadira_flow-router/client/triggers.js                                                                     //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n// a set of utility functions for triggers\n\nTriggers = {};\n\n// Apply filters for a set of triggers\n// @triggers - a set of triggers\n// @filter - filter with array fileds with `only` and `except`\n//           support only either `only` or `except`, but not both\nTriggers.applyFilters = function (triggers, filter) {\n\tif (!(triggers instanceof Array)) {\n\t\ttriggers = [triggers];\n\t}\n\n\tif (!filter) {\n\t\treturn triggers;\n\t}\n\n\tif (filter.only && filter.except) {\n\t\tthrow new Error(\"Triggers don't support only and except filters at once\");\n\t}\n\n\tif (filter.only && !(filter.only instanceof Array)) {\n\t\tthrow new Error('only filters needs to be an array');\n\t}\n\n\tif (filter.except && !(filter.except instanceof Array)) {\n\t\tthrow new Error('except filters needs to be an array');\n\t}\n\n\tif (filter.only) {\n\t\treturn Triggers.createRouteBoundTriggers(triggers, filter.only);\n\t}\n\n\tif (filter.except) {\n\t\treturn Triggers.createRouteBoundTriggers(triggers, filter.except, true);\n\t}\n\n\tthrow new Error('Provided a filter but not supported');\n};\n\n//  create triggers by bounding them to a set of route names\n//  @triggers - a set of triggers\n//  @names - list of route names to be bound (trigger runs only for these names)\n//  @negate - negate the result (triggers won't run for above names)\nTriggers.createRouteBoundTriggers = function (triggers, names, negate) {\n\tvar namesMap = {};\n\t_.each(names, function (name) {\n\t\tnamesMap[name] = true;\n\t});\n\n\tvar filteredTriggers = _.map(triggers, function (originalTrigger) {\n\t\tvar modifiedTrigger = function (context, next) {\n\t\t\tvar routeName = context.route.name;\n\t\t\tvar matched = namesMap[routeName] ? 1 : -1;\n\t\t\tmatched = negate ? matched * -1 : matched;\n\n\t\t\tif (matched === 1) {\n\t\t\t\toriginalTrigger(context, next);\n\t\t\t}\n\t\t};\n\t\treturn modifiedTrigger;\n\t});\n\n\treturn filteredTriggers;\n};\n\n//  run triggers and abort if redirected or callback stopped\n//  @triggers - a set of triggers\n//  @context - context we need to pass (it must have the route)\n//  @redirectFn - function which used to redirect\n//  @after - called after if only all the triggers runs\nTriggers.runTriggers = function (triggers, context, redirectFn, after) {\n\tvar abort = false;\n\tvar inCurrentLoop = true;\n\tvar alreadyRedirected = false;\n\n\tfor (var lc = 0; lc < triggers.length; lc++) {\n\t\tvar trigger = triggers[lc];\n\t\ttrigger(context, doRedirect, doStop);\n\n\t\tif (abort) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// mark that, we've exceeds the currentEventloop for\n\t// this set of triggers.\n\tinCurrentLoop = false;\n\tafter();\n\n\tfunction doRedirect(url, params, queryParams) {\n\t\tif (alreadyRedirected) {\n\t\t\tthrow new Error('already redirected');\n\t\t}\n\n\t\tif (!inCurrentLoop) {\n\t\t\tthrow new Error('redirect needs to be done in sync');\n\t\t}\n\n\t\tif (!url) {\n\t\t\tthrow new Error('trigger redirect requires an URL');\n\t\t}\n\n\t\tabort = true;\n\t\talreadyRedirected = true;\n\t\tredirectFn(url, params, queryParams);\n\t}\n\n\tfunction doStop() {\n\t\tabort = true;\n\t}\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"router.js\":function module(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/kadira_flow-router/client/router.js                                                                       //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nRouter = function () {\n\tvar self = this;\n\tthis.globals = [];\n\tthis.subscriptions = Function.prototype;\n\n\tthis._tracker = this._buildTracker();\n\tthis._current = {};\n\n\t// tracks the current path change\n\tthis._onEveryPath = new Tracker.Dependency();\n\n\tthis._globalRoute = new Route(this);\n\n\t// holds onRoute callbacks\n\tthis._onRouteCallbacks = [];\n\n\t// if _askedToWait is true. We don't automatically start the router\n\t// in Meteor.startup callback. (see client/_init.js)\n\t// Instead user need to call `.initialize()\n\tthis._askedToWait = false;\n\tthis._initialized = false;\n\tthis._triggersEnter = [];\n\tthis._triggersExit = [];\n\tthis._routes = [];\n\tthis._routesMap = {};\n\tthis._updateCallbacks();\n\tthis.notFound = this.notfound = null;\n\t// indicate it's okay (or not okay) to run the tracker\n\t// when doing subscriptions\n\t// using a number and increment it help us to support FlowRouter.go()\n\t// and legitimate reruns inside tracker on the same event loop.\n\t// this is a solution for #145\n\tthis.safeToRun = 0;\n\n\t// Meteor exposes to the client the path prefix that was defined using the\n\t// ROOT_URL environement variable on the server using the global runtime\n\t// configuration. See #315.\n\tthis._basePath = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || '';\n\n\t// this is a chain contains a list of old routes\n\t// most of the time, there is only one old route\n\t// but when it's the time for a trigger redirect we've a chain\n\tthis._oldRouteChain = [];\n\n\tthis.env = {\n\t\treplaceState: new Meteor.EnvironmentVariable(),\n\t\treload: new Meteor.EnvironmentVariable(),\n\t\ttrailingSlash: new Meteor.EnvironmentVariable(),\n\t};\n\n\t// redirect function used inside triggers\n\tthis._redirectFn = function (pathDef, fields, queryParams) {\n\t\tif (/^http(s)?:\\/\\//.test(pathDef)) {\n\t\t\tvar message =\n\t\t\t\t\"Redirects to URLs outside of the app are not supported in this version of Flow Router. Use 'window.location = yourUrl' instead\";\n\t\t\tthrow new Error(message);\n\t\t}\n\t\tself.withReplaceState(function () {\n\t\t\tvar path = FlowRouter.path(pathDef, fields, queryParams);\n\t\t\tself._page.redirect(path);\n\t\t});\n\t};\n\tthis._initTriggersAPI();\n};\n\nRouter.prototype.route = function (pathDef, options, group) {\n\tif (!/^\\/.*/.test(pathDef)) {\n\t\tvar message = \"route's path must start with '/'\";\n\t\tthrow new Error(message);\n\t}\n\n\toptions = options || {};\n\tvar self = this;\n\tvar route = new Route(this, pathDef, options, group);\n\n\t// calls when the page route being activates\n\troute._actionHandle = function (context, next) {\n\t\tvar oldRoute = self._current.route;\n\t\tself._oldRouteChain.push(oldRoute);\n\n\t\tvar queryParams = self._qs.parse(context.querystring);\n\t\t// _qs.parse() gives us a object without prototypes,\n\t\t// created with Object.create(null)\n\t\t// Meteor's check doesn't play nice with it.\n\t\t// So, we need to fix it by cloning it.\n\t\t// see more: https://github.com/meteorhacks/flow-router/issues/164\n\t\tqueryParams = JSON.parse(JSON.stringify(queryParams));\n\n\t\tself._current = {\n\t\t\tpath: context.path,\n\t\t\tcontext: context,\n\t\t\tparams: context.params,\n\t\t\tqueryParams: queryParams,\n\t\t\troute: route,\n\t\t\toldRoute: oldRoute,\n\t\t};\n\n\t\t// we need to invalidate if all the triggers have been completed\n\t\t// if not that means, we've been redirected to another path\n\t\t// then we don't need to invalidate\n\t\tvar afterAllTriggersRan = function () {\n\t\t\tself._invalidateTracker();\n\t\t};\n\n\t\tvar triggers = self._triggersEnter.concat(route._triggersEnter);\n\t\tTriggers.runTriggers(triggers, self._current, self._redirectFn, afterAllTriggersRan);\n\t};\n\n\t// calls when you exit from the page js route\n\troute._exitHandle = function (context, next) {\n\t\tvar triggers = self._triggersExit.concat(route._triggersExit);\n\t\tTriggers.runTriggers(triggers, self._current, self._redirectFn, next);\n\t};\n\n\tthis._routes.push(route);\n\tif (options.name) {\n\t\tthis._routesMap[options.name] = route;\n\t}\n\n\tthis._updateCallbacks();\n\tthis._triggerRouteRegister(route);\n\n\treturn route;\n};\n\nRouter.prototype.group = function (options) {\n\treturn new Group(this, options);\n};\n\nRouter.prototype.path = function (pathDef, fields, queryParams) {\n\tif (this._routesMap[pathDef]) {\n\t\tpathDef = this._routesMap[pathDef].pathDef;\n\t}\n\n\tvar path = '';\n\n\t// Prefix the path with the router global prefix\n\tif (this._basePath) {\n\t\tpath += '/' + this._basePath + '/';\n\t}\n\n\tfields = fields || {};\n\tvar regExp = /(:[\\w\\(\\)\\\\\\+\\*\\.\\?]+)+/g;\n\tpath += pathDef.replace(regExp, function (key) {\n\t\tvar firstRegexpChar = key.indexOf('(');\n\t\t// get the content behind : and (\\\\d+/)\n\t\tkey = key.substring(1, firstRegexpChar > 0 ? firstRegexpChar : undefined);\n\t\t// remove +?*\n\t\tkey = key.replace(/[\\+\\*\\?]+/g, '');\n\n\t\t// this is to allow page js to keep the custom characters as it is\n\t\t// we need to encode 2 times otherwise \"/\" char does not work properly\n\t\t// So, in that case, when I includes \"/\" it will think it's a part of the\n\t\t// route. encoding 2times fixes it\n\t\treturn encodeURIComponent(encodeURIComponent(fields[key] || ''));\n\t});\n\n\t// Replace multiple slashes with single slash\n\tpath = path.replace(/\\/\\/+/g, '/');\n\n\t// remove trailing slash\n\t// but keep the root slash if it's the only one\n\tpath = path.match(/^\\/{1}$/) ? path : path.replace(/\\/$/, '');\n\n\t// explictly asked to add a trailing slash\n\tif (this.env.trailingSlash.get() && _.last(path) !== '/') {\n\t\tpath += '/';\n\t}\n\n\tvar strQueryParams = this._qs.stringify(queryParams || {});\n\tif (strQueryParams) {\n\t\tpath += '?' + strQueryParams;\n\t}\n\n\treturn path;\n};\n\nRouter.prototype.go = function (pathDef, fields, queryParams) {\n\tvar path = this.path(pathDef, fields, queryParams);\n\n\tvar useReplaceState = this.env.replaceState.get();\n\tif (useReplaceState) {\n\t\tthis._page.replace(path);\n\t} else {\n\t\tthis._page(path);\n\t}\n};\n\nRouter.prototype.reload = function () {\n\tvar self = this;\n\n\tself.env.reload.withValue(true, function () {\n\t\tself._page.replace(self._current.path);\n\t});\n};\n\nRouter.prototype.redirect = function (path) {\n\tthis._page.redirect(path);\n};\n\nRouter.prototype.setParams = function (newParams) {\n\tif (!this._current.route) {\n\t\treturn false;\n\t}\n\n\tvar pathDef = this._current.route.pathDef;\n\tvar existingParams = this._current.params;\n\tvar params = {};\n\t_.each(_.keys(existingParams), function (key) {\n\t\tparams[key] = existingParams[key];\n\t});\n\n\tparams = _.extend(params, newParams);\n\tvar queryParams = this._current.queryParams;\n\n\tthis.go(pathDef, params, queryParams);\n\treturn true;\n};\n\nRouter.prototype.setQueryParams = function (newParams) {\n\tif (!this._current.route) {\n\t\treturn false;\n\t}\n\n\tvar queryParams = _.clone(this._current.queryParams);\n\t_.extend(queryParams, newParams);\n\n\tfor (var k in queryParams) {\n\t\tif (queryParams[k] === null || queryParams[k] === undefined) {\n\t\t\tdelete queryParams[k];\n\t\t}\n\t}\n\n\tvar pathDef = this._current.route.pathDef;\n\tvar params = this._current.params;\n\tthis.go(pathDef, params, queryParams);\n\treturn true;\n};\n\n// .current is not reactive\n// This is by design. use .getParam() instead\n// If you really need to watch the path change, use .watchPathChange()\nRouter.prototype.current = function () {\n\t// We can't trust outside, that's why we clone this\n\t// Anyway, we can't clone the whole object since it has non-jsonable values\n\t// That's why we clone what's really needed.\n\tvar current = _.clone(this._current);\n\tcurrent.queryParams = EJSON.clone(current.queryParams);\n\tcurrent.params = EJSON.clone(current.params);\n\treturn current;\n};\n\n// Implementing Reactive APIs\nvar reactiveApis = ['getParam', 'getQueryParam', 'getRouteName', 'watchPathChange'];\nreactiveApis.forEach(function (api) {\n\tRouter.prototype[api] = function (arg1) {\n\t\t// when this is calling, there may not be any route initiated\n\t\t// so we need to handle it\n\t\tvar currentRoute = this._current.route;\n\t\tif (!currentRoute) {\n\t\t\tthis._onEveryPath.depend();\n\t\t\treturn;\n\t\t}\n\n\t\t// currently, there is only one argument. If we've more let's add more args\n\t\t// this is not clean code, but better in performance\n\t\treturn currentRoute[api].call(currentRoute, arg1);\n\t};\n});\n\nRouter.prototype.subsReady = function () {\n\tvar callback = null;\n\tvar args = _.toArray(arguments);\n\n\tif (typeof _.last(args) === 'function') {\n\t\tcallback = args.pop();\n\t}\n\n\tvar currentRoute = this.current().route;\n\tvar globalRoute = this._globalRoute;\n\n\t// we need to depend for every route change and\n\t// rerun subscriptions to check the ready state\n\tthis._onEveryPath.depend();\n\n\tif (!currentRoute) {\n\t\treturn false;\n\t}\n\n\tvar subscriptions;\n\tif (args.length === 0) {\n\t\tsubscriptions = _.values(globalRoute.getAllSubscriptions());\n\t\tsubscriptions = subscriptions.concat(_.values(currentRoute.getAllSubscriptions()));\n\t} else {\n\t\tsubscriptions = _.map(args, function (subName) {\n\t\t\treturn globalRoute.getSubscription(subName) || currentRoute.getSubscription(subName);\n\t\t});\n\t}\n\n\tvar isReady = function () {\n\t\tvar ready = _.every(subscriptions, function (sub) {\n\t\t\treturn sub && sub.ready();\n\t\t});\n\n\t\treturn ready;\n\t};\n\n\tif (callback) {\n\t\tTracker.autorun(function (c) {\n\t\t\tif (isReady()) {\n\t\t\t\tcallback();\n\t\t\t\tc.stop();\n\t\t\t}\n\t\t});\n\t} else {\n\t\treturn isReady();\n\t}\n};\n\nRouter.prototype.withReplaceState = function (fn) {\n\treturn this.env.replaceState.withValue(true, fn);\n};\n\nRouter.prototype.withTrailingSlash = function (fn) {\n\treturn this.env.trailingSlash.withValue(true, fn);\n};\n\nRouter.prototype._notfoundRoute = function (context) {\n\tthis._current = {\n\t\tpath: context.path,\n\t\tcontext: context,\n\t\tparams: [],\n\t\tqueryParams: {},\n\t};\n\n\t// XXX this.notfound kept for backwards compatibility\n\tthis.notFound = this.notFound || this.notfound;\n\tif (!this.notFound) {\n\t\tconsole.error('There is no route for the path:', context.path);\n\t\treturn;\n\t}\n\n\tthis._current.route = new Route(this, '*', this.notFound);\n\tthis._invalidateTracker();\n};\n\nRouter.prototype.initialize = function (options) {\n\toptions = options || {};\n\n\tif (this._initialized) {\n\t\tthrow new Error('FlowRouter is already initialized');\n\t}\n\n\tvar self = this;\n\tthis._updateCallbacks();\n\n\t// Implementing idempotent routing\n\t// by overriding page.js`s \"show\" method.\n\t// Why?\n\t// It is impossible to bypass exit triggers,\n\t// because they execute before the handler and\n\t// can not know what the next path is, inside exit trigger.\n\t//\n\t// we need override both show, replace to make this work\n\t// since we use redirect when we are talking about withReplaceState\n\t_.each(['show', 'replace'], function (fnName) {\n\t\tvar original = self._page[fnName];\n\t\tself._page[fnName] = function (path, state, dispatch, push) {\n\t\t\tvar reload = self.env.reload.get();\n\t\t\tif (!reload && self._current.path === path) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\toriginal.call(this, path, state, dispatch, push);\n\t\t};\n\t});\n\n\t// this is very ugly part of pagejs and it does decoding few times\n\t// in unpredicatable manner. See #168\n\t// this is the default behaviour and we need keep it like that\n\t// we are doing a hack. see .path()\n\tthis._page.base(this._basePath);\n\tthis._page({\n\t\tdecodeURLComponents: true,\n\t\thashbang: !!options.hashbang,\n\t});\n\n\tthis._initialized = true;\n};\n\nRouter.prototype._buildTracker = function () {\n\tvar self = this;\n\n\t// main autorun function\n\tvar tracker = Tracker.autorun(function () {\n\t\tif (!self._current || !self._current.route) {\n\t\t\treturn;\n\t\t}\n\n\t\t// see the definition of `this._processingContexts`\n\t\tvar currentContext = self._current;\n\t\tvar route = currentContext.route;\n\t\tvar path = currentContext.path;\n\n\t\tif (self.safeToRun === 0) {\n\t\t\tvar message = \"You can't use reactive data sources like Session\" + ' inside the `.subscriptions` method!';\n\t\t\tthrow new Error(message);\n\t\t}\n\n\t\t// We need to run subscriptions inside a Tracker\n\t\t// to stop subs when switching between routes\n\t\t// But we don't need to run this tracker with\n\t\t// other reactive changes inside the .subscription method\n\t\t// We tackle this with the `safeToRun` variable\n\t\tself._globalRoute.clearSubscriptions();\n\t\tself.subscriptions.call(self._globalRoute, path);\n\t\troute.callSubscriptions(currentContext);\n\n\t\t// otherwise, computations inside action will trigger to re-run\n\t\t// this computation. which we do not need.\n\t\tTracker.nonreactive(function () {\n\t\t\tvar isRouteChange = currentContext.oldRoute !== currentContext.route;\n\t\t\tvar isFirstRoute = !currentContext.oldRoute;\n\t\t\t// first route is not a route change\n\t\t\tif (isFirstRoute) {\n\t\t\t\tisRouteChange = false;\n\t\t\t}\n\n\t\t\t// Clear oldRouteChain just before calling the action\n\t\t\t// We still need to get a copy of the oldestRoute first\n\t\t\t// It's very important to get the oldest route and registerRouteClose() it\n\t\t\t// See: https://github.com/kadirahq/flow-router/issues/314\n\t\t\tvar oldestRoute = self._oldRouteChain[0];\n\t\t\tself._oldRouteChain = [];\n\n\t\t\tcurrentContext.route.registerRouteChange(currentContext, isRouteChange);\n\t\t\troute.callAction(currentContext);\n\n\t\t\tTracker.afterFlush(function () {\n\t\t\t\tself._onEveryPath.changed();\n\t\t\t\tif (isRouteChange) {\n\t\t\t\t\t// We need to trigger that route (definition itself) has changed.\n\t\t\t\t\t// So, we need to re-run all the register callbacks to current route\n\t\t\t\t\t// This is pretty important, otherwise tracker\n\t\t\t\t\t// can't identify new route's items\n\n\t\t\t\t\t// We also need to afterFlush, otherwise this will re-run\n\t\t\t\t\t// helpers on templates which are marked for destroying\n\t\t\t\t\tif (oldestRoute) {\n\t\t\t\t\t\toldestRoute.registerRouteClose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tself.safeToRun--;\n\t});\n\n\treturn tracker;\n};\n\nRouter.prototype._invalidateTracker = function () {\n\tvar self = this;\n\tthis.safeToRun++;\n\tthis._tracker.invalidate();\n\t// After the invalidation we need to flush to make changes imediately\n\t// otherwise, we have face some issues context mix-maches and so on.\n\t// But there are some cases we can't flush. So we need to ready for that.\n\n\t// we clearly know, we can't flush inside an autorun\n\t// this may leads some issues on flow-routing\n\t// we may need to do some warning\n\tif (!Tracker.currentComputation) {\n\t\t// Still there are some cases where we can't flush\n\t\t//  eg:- when there is a flush currently\n\t\t// But we've no public API or hacks to get that state\n\t\t// So, this is the only solution\n\t\ttry {\n\t\t\tTracker.flush();\n\t\t} catch (ex) {\n\t\t\t// only handling \"while flushing\" errors\n\t\t\tif (!/Tracker\\.flush while flushing/.test(ex.message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// XXX: fix this with a proper solution by removing subscription mgt.\n\t\t\t// from the router. Then we don't need to run invalidate using a tracker\n\n\t\t\t// this happens when we are trying to invoke a route change\n\t\t\t// with inside a route chnage. (eg:- Template.onCreated)\n\t\t\t// Since we use page.js and tracker, we don't have much control\n\t\t\t// over this process.\n\t\t\t// only solution is to defer route execution.\n\n\t\t\t// It's possible to have more than one path want to defer\n\t\t\t// But, we only need to pick the last one.\n\t\t\t// self._nextPath = self._current.path;\n\t\t\tMeteor.defer(function () {\n\t\t\t\tvar path = self._nextPath;\n\t\t\t\tif (!path) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdelete self._nextPath;\n\t\t\t\tself.env.reload.withValue(true, function () {\n\t\t\t\t\tself.go(path);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n};\n\nRouter.prototype._updateCallbacks = function () {\n\tvar self = this;\n\n\tself._page.callbacks = [];\n\tself._page.exits = [];\n\n\t_.each(self._routes, function (route) {\n\t\tself._page(route.pathDef, route._actionHandle);\n\t\tself._page.exit(route.pathDef, route._exitHandle);\n\t});\n\n\tself._page('*', function (context) {\n\t\tself._notfoundRoute(context);\n\t});\n};\n\nRouter.prototype._initTriggersAPI = function () {\n\tvar self = this;\n\tthis.triggers = {\n\t\tenter: function (triggers, filter) {\n\t\t\ttriggers = Triggers.applyFilters(triggers, filter);\n\t\t\tif (triggers.length) {\n\t\t\t\tself._triggersEnter = self._triggersEnter.concat(triggers);\n\t\t\t}\n\t\t},\n\n\t\texit: function (triggers, filter) {\n\t\t\ttriggers = Triggers.applyFilters(triggers, filter);\n\t\t\tif (triggers.length) {\n\t\t\t\tself._triggersExit = self._triggersExit.concat(triggers);\n\t\t\t}\n\t\t},\n\t};\n};\n\nRouter.prototype.wait = function () {\n\tif (this._initialized) {\n\t\tthrow new Error(\"can't wait after FlowRouter has been initialized\");\n\t}\n\n\tthis._askedToWait = true;\n};\n\nRouter.prototype.onRouteRegister = function (cb) {\n\tthis._onRouteCallbacks.push(cb);\n};\n\nRouter.prototype._triggerRouteRegister = function (currentRoute) {\n\t// We should only need to send a safe set of fields on the route\n\t// object.\n\t// This is not to hide what's inside the route object, but to show\n\t// these are the public APIs\n\tvar routePublicApi = _.pick(currentRoute, 'name', 'pathDef', 'path');\n\tvar omittingOptionFields = ['triggersEnter', 'triggersExit', 'action', 'subscriptions', 'name'];\n\troutePublicApi.options = _.omit(currentRoute.options, omittingOptionFields);\n\n\t_.each(this._onRouteCallbacks, function (cb) {\n\t\tcb(routePublicApi);\n\t});\n};\n\nRouter.prototype._page = page;\nRouter.prototype._qs = qs;\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"group.js\":function module(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/kadira_flow-router/client/group.js                                                                        //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nGroup = function (router, options, parent) {\n\toptions = options || {};\n\n\tif (options.prefix && !/^\\/.*/.test(options.prefix)) {\n\t\tvar message = \"group's prefix must start with '/'\";\n\t\tthrow new Error(message);\n\t}\n\n\tthis._router = router;\n\tthis.prefix = options.prefix || '';\n\tthis.name = options.name;\n\tthis.options = options;\n\n\tthis._triggersEnter = options.triggersEnter || [];\n\tthis._triggersExit = options.triggersExit || [];\n\tthis._subscriptions = options.subscriptions || Function.prototype;\n\n\tthis.parent = parent;\n\tif (this.parent) {\n\t\tthis.prefix = parent.prefix + this.prefix;\n\n\t\tthis._triggersEnter = parent._triggersEnter.concat(this._triggersEnter);\n\t\tthis._triggersExit = this._triggersExit.concat(parent._triggersExit);\n\t}\n};\n\nGroup.prototype.route = function (pathDef, options, group) {\n\toptions = options || {};\n\n\tif (!/^\\/.*/.test(pathDef)) {\n\t\tvar message = \"route's path must start with '/'\";\n\t\tthrow new Error(message);\n\t}\n\n\tgroup = group || this;\n\tpathDef = this.prefix + pathDef;\n\n\tvar triggersEnter = options.triggersEnter || [];\n\toptions.triggersEnter = this._triggersEnter.concat(triggersEnter);\n\n\tvar triggersExit = options.triggersExit || [];\n\toptions.triggersExit = triggersExit.concat(this._triggersExit);\n\n\treturn this._router.route(pathDef, options, group);\n};\n\nGroup.prototype.group = function (options) {\n\treturn new Group(this._router, options, this);\n};\n\nGroup.prototype.callSubscriptions = function (current) {\n\tif (this.parent) {\n\t\tthis.parent.callSubscriptions(current);\n\t}\n\n\tthis._subscriptions.call(current.route, current.params, current.queryParams);\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"route.js\":function module(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/kadira_flow-router/client/route.js                                                                        //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nRoute = function (router, pathDef, options, group) {\n\toptions = options || {};\n\n\tthis.options = options;\n\tthis.pathDef = pathDef;\n\n\t// Route.path is deprecated and will be removed in 3.0\n\tthis.path = pathDef;\n\n\tif (options.name) {\n\t\tthis.name = options.name;\n\t}\n\n\tthis._action = options.action || Function.prototype;\n\tthis._subscriptions = options.subscriptions || Function.prototype;\n\tthis._triggersEnter = options.triggersEnter || [];\n\tthis._triggersExit = options.triggersExit || [];\n\tthis._subsMap = {};\n\tthis._router = router;\n\n\tthis._params = new ReactiveDict();\n\tthis._queryParams = new ReactiveDict();\n\tthis._routeCloseDep = new Tracker.Dependency();\n\n\t// tracks the changes in the URL\n\tthis._pathChangeDep = new Tracker.Dependency();\n\n\tthis.group = group;\n};\n\nRoute.prototype.clearSubscriptions = function () {\n\tthis._subsMap = {};\n};\n\nRoute.prototype.register = function (name, sub, options) {\n\tthis._subsMap[name] = sub;\n};\n\nRoute.prototype.getSubscription = function (name) {\n\treturn this._subsMap[name];\n};\n\nRoute.prototype.getAllSubscriptions = function () {\n\treturn this._subsMap;\n};\n\nRoute.prototype.callAction = function (current) {\n\tvar self = this;\n\tself._action(current.params, current.queryParams);\n};\n\nRoute.prototype.callSubscriptions = function (current) {\n\tthis.clearSubscriptions();\n\tif (this.group) {\n\t\tthis.group.callSubscriptions(current);\n\t}\n\n\tthis._subscriptions(current.params, current.queryParams);\n};\n\nRoute.prototype.getRouteName = function () {\n\tthis._routeCloseDep.depend();\n\treturn this.name;\n};\n\nRoute.prototype.getParam = function (key) {\n\tthis._routeCloseDep.depend();\n\treturn this._params.get(key);\n};\n\nRoute.prototype.getQueryParam = function (key) {\n\tthis._routeCloseDep.depend();\n\treturn this._queryParams.get(key);\n};\n\nRoute.prototype.watchPathChange = function () {\n\tthis._pathChangeDep.depend();\n};\n\nRoute.prototype.registerRouteClose = function () {\n\tthis._params = new ReactiveDict();\n\tthis._queryParams = new ReactiveDict();\n\tthis._routeCloseDep.changed();\n\tthis._pathChangeDep.changed();\n};\n\nRoute.prototype.registerRouteChange = function (currentContext, routeChanging) {\n\t// register params\n\tvar params = currentContext.params;\n\tthis._updateReactiveDict(this._params, params);\n\n\t// register query params\n\tvar queryParams = currentContext.queryParams;\n\tthis._updateReactiveDict(this._queryParams, queryParams);\n\n\t// if the route is changing, we need to defer triggering path changing\n\t// if we did this, old route's path watchers will detect this\n\t// Real issue is, above watcher will get removed with the new route\n\t// So, we don't need to trigger it now\n\t// We are doing it on the route close event. So, if they exists they'll\n\t// get notify that\n\tif (!routeChanging) {\n\t\tthis._pathChangeDep.changed();\n\t}\n};\n\nRoute.prototype._updateReactiveDict = function (dict, newValues) {\n\tvar currentKeys = _.keys(newValues);\n\tvar oldKeys = _.keys(dict.keyDeps);\n\n\t// set new values\n\t//  params is an array. So, _.each(params) does not works\n\t//  to iterate params\n\t_.each(currentKeys, function (key) {\n\t\tdict.set(key, newValues[key]);\n\t});\n\n\t// remove keys which does not exisits here\n\tvar removedKeys = _.difference(oldKeys, currentKeys);\n\t_.each(removedKeys, function (key) {\n\t\tdict.set(key, undefined);\n\t});\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"_init.js\":function module(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/kadira_flow-router/client/_init.js                                                                        //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n// Export Router Instance\nFlowRouter = new Router();\nFlowRouter.Router = Router;\nFlowRouter.Route = Route;\n\n// Initialize FlowRouter\nMeteor.startup(function () {\n\tif (!FlowRouter._askedToWait) {\n\t\tFlowRouter.initialize();\n\t}\n});\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"lib\":{\"router.js\":function module(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/kadira_flow-router/lib/router.js                                                                          //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nRouter.prototype.url = function () {\n\t// We need to remove the leading base path, or \"/\", as it will be inserted\n\t// automatically by `Meteor.absoluteUrl` as documented in:\n\t// http://docs.meteor.com/#/full/meteor_absoluteurl\n\tvar completePath = this.path.apply(this, arguments);\n\tvar basePath = this._basePath || '/';\n\tvar pathWithoutBase = completePath.replace(new RegExp('^' + basePath), '');\n\treturn Meteor.absoluteUrl(pathWithoutBase);\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"node_modules\":{\"page\":{\"package.json\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// node_modules/meteor/kadira_flow-router/node_modules/page/package.json                                              //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nmodule.exports = {\n  \"name\": \"page\",\n  \"version\": \"1.6.4\"\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// node_modules/meteor/kadira_flow-router/node_modules/page/index.js                                                  //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n  /* globals require, module */\n\n  'use strict';\n\n  /**\n   * Module dependencies.\n   */\n\n  var pathtoRegexp = require('path-to-regexp');\n\n  /**\n   * Module exports.\n   */\n\n  module.exports = page;\n\n  /**\n   * Detect click event\n   */\n  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n\n  var location = ('undefined' !== typeof window) && (window.history.location || window.location);\n\n  /**\n   * Perform initial dispatch.\n   */\n\n  var dispatch = true;\n\n\n  /**\n   * Decode URL components (query string, pathname, hash).\n   * Accommodates both regular percent encoding and x-www-form-urlencoded format.\n   */\n  var decodeURLComponents = true;\n\n  /**\n   * Base path.\n   */\n\n  var base = '';\n\n  /**\n   * Running flag.\n   */\n\n  var running;\n\n  /**\n   * HashBang option\n   */\n\n  var hashbang = false;\n\n  /**\n   * Previous context, for capturing\n   * page exit events.\n   */\n\n  var prevContext;\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or redirection,\n   * or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page('/from', '/to')\n   *   page();\n   *\n   * @param {string|!Function|!Object} path\n   * @param {Function=} fn\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' === typeof path) {\n      return page('*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' === typeof fn) {\n      var route = new Route(/** @type {string} */ (path));\n      for (var i = 1; i < arguments.length; ++i) {\n        page.callbacks.push(route.middleware(arguments[i]));\n      }\n      // show <path> with [state]\n    } else if ('string' === typeof path) {\n      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);\n      // start [options]\n    } else {\n      page.start(path);\n    }\n  }\n\n  /**\n   * Callback functions.\n   */\n\n  page.callbacks = [];\n  page.exits = [];\n\n  /**\n   * Current path being processed\n   * @type {string}\n   */\n  page.current = '';\n\n  /**\n   * Number of pages navigated to.\n   * @type {number}\n   *\n   *     page.len == 0;\n   *     page('/login');\n   *     page.len == 1;\n   */\n\n  page.len = 0;\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {string} path\n   * @api public\n   */\n\n  page.base = function(path) {\n    if (0 === arguments.length) return base;\n    base = path;\n  };\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  page.start = function(options) {\n    options = options || {};\n    if (running) return;\n    running = true;\n    if (false === options.dispatch) dispatch = false;\n    if (false === options.decodeURLComponents) decodeURLComponents = false;\n    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);\n    if (false !== options.click) {\n      document.addEventListener(clickEvent, onclick, false);\n    }\n    if (true === options.hashbang) hashbang = true;\n    if (!dispatch) return;\n    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;\n    page.replace(url, null, true, dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  page.stop = function() {\n    if (!running) return;\n    page.current = '';\n    page.len = 0;\n    running = false;\n    document.removeEventListener(clickEvent, onclick, false);\n    window.removeEventListener('popstate', onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} dispatch\n   * @param {boolean=} push\n   * @return {!Context}\n   * @api public\n   */\n\n  page.show = function(path, state, dispatch, push) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    if (false !== dispatch) page.dispatch(ctx);\n    if (false !== ctx.handled && false !== push) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Goes back in the history\n   * Back should always let the current route push state and then go back.\n   *\n   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base\n   * @param {Object=} state\n   * @api public\n   */\n\n  page.back = function(path, state) {\n    if (page.len > 0) {\n      // this may need more testing to see if all browsers\n      // wait for the next tick to go back in history\n      history.back();\n      page.len--;\n    } else if (path) {\n      setTimeout(function() {\n        page.show(path, state);\n      });\n    }else{\n      setTimeout(function() {\n        page.show(base, state);\n      });\n    }\n  };\n\n\n  /**\n   * Register route to redirect from one path to other\n   * or just redirect to another route\n   *\n   * @param {string} from - if param 'to' is undefined redirects to 'from'\n   * @param {string=} to\n   * @api public\n   */\n  page.redirect = function(from, to) {\n    // Define route from a path to another\n    if ('string' === typeof from && 'string' === typeof to) {\n      page(from, function(e) {\n        setTimeout(function() {\n          page.replace(/** @type {!string} */ (to));\n        }, 0);\n      });\n    }\n\n    // Wait for the push state and replace it with another\n    if ('string' === typeof from && 'undefined' === typeof to) {\n      setTimeout(function() {\n        page.replace(from);\n      }, 0);\n    }\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} init\n   * @param {boolean=} dispatch\n   * @return {!Context}\n   * @api public\n   */\n\n\n  page.replace = function(path, state, init, dispatch) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    ctx.init = init;\n    ctx.save(); // save before dispatching, which may redirect\n    if (false !== dispatch) page.dispatch(ctx);\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n  page.dispatch = function(ctx) {\n    var prev = prevContext,\n      i = 0,\n      j = 0;\n\n    prevContext = ctx;\n\n    function nextExit() {\n      var fn = page.exits[j++];\n      if (!fn) return nextEnter();\n      fn(prev, nextExit);\n    }\n\n    function nextEnter() {\n      var fn = page.callbacks[i++];\n\n      if (ctx.path !== page.current) {\n        ctx.handled = false;\n        return;\n      }\n      if (!fn) return unhandled(ctx);\n      fn(ctx, nextEnter);\n    }\n\n    if (prev) {\n      nextExit();\n    } else {\n      nextEnter();\n    }\n  };\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n  function unhandled(ctx) {\n    if (ctx.handled) return;\n    var current;\n\n    if (hashbang) {\n      current = base + location.hash.replace('#!', '');\n    } else {\n      current = location.pathname + location.search;\n    }\n\n    if (current === ctx.canonicalPath) return;\n    page.stop();\n    ctx.handled = false;\n    location.href = ctx.canonicalPath;\n  }\n\n  /**\n   * Register an exit route on `path` with\n   * callback `fn()`, which will be called\n   * on the previous context when a new\n   * page is visited.\n   */\n  page.exit = function(path, fn) {\n    if (typeof path === 'function') {\n      return page.exit('*', path);\n    }\n\n    var route = new Route(path);\n    for (var i = 1; i < arguments.length; ++i) {\n      page.exits.push(route.middleware(arguments[i]));\n    }\n  };\n\n  /**\n   * Remove URL encoding from the given `str`.\n   * Accommodates whitespace in both x-www-form-urlencoded\n   * and regular percent-encoded form.\n   *\n   * @param {string} val - URL component to decode\n   */\n  function decodeURLEncodedURIComponent(val) {\n    if (typeof val !== 'string') { return val; }\n    return decodeURLComponents ? decodeURIComponent(val.replace(/\\+/g, ' ')) : val;\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} state\n   * @api public\n   */\n\n  function Context(path, state) {\n    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    this.path = path.replace(base, '') || '/';\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\n\n    this.title = document.title;\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\n    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\n    this.params = {};\n\n    // fragment\n    this.hash = '';\n    if (!hashbang) {\n      if (!~this.path.indexOf('#')) return;\n      var parts = this.path.split('#');\n      this.path = parts[0];\n      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';\n      this.querystring = this.querystring.split('#')[0];\n    }\n  }\n\n  /**\n   * Expose `Context`.\n   */\n\n  page.Context = Context;\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function() {\n    page.len++;\n    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function() {\n    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} options\n   * @api private\n   */\n\n  function Route(path, options) {\n    options = options || {};\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathtoRegexp(this.path,\n      this.keys = [],\n      options);\n  }\n\n  /**\n   * Expose `Route`.\n   */\n\n  page.Route = Route;\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn) {\n    var self = this;\n    return function(ctx, next) {\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {string} path\n   * @param {Object} params\n   * @return {boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params) {\n    var keys = this.keys,\n      qsIndex = path.indexOf('?'),\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\n      m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n      var val = decodeURLEncodedURIComponent(m[i]);\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Handle \"populate\" events.\n   */\n\n  var onpopstate = (function () {\n    var loaded = false;\n    if ('undefined' === typeof window) {\n      return;\n    }\n    if (document.readyState === 'complete') {\n      loaded = true;\n    } else {\n      window.addEventListener('load', function() {\n        setTimeout(function() {\n          loaded = true;\n        }, 0);\n      });\n    }\n    return function onpopstate(e) {\n      if (!loaded) return;\n      if (e.state) {\n        var path = e.state.path;\n        page.replace(path, e.state);\n      } else {\n        page.show(location.pathname + location.hash, undefined, undefined, false);\n      }\n    };\n  })();\n  /**\n   * Handle \"click\" events.\n   */\n\n  function onclick(e) {\n\n    if (1 !== which(e)) return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n\n\n    // ensure link\n    var el = e.target;\n    while (el && 'A' !== el.nodeName) el = el.parentNode;\n    if (!el || 'A' !== el.nodeName) return;\n\n\n\n    // Ignore if tag has\n    // 1. \"download\" attribute\n    // 2. rel=\"external\" attribute\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;\n\n\n\n    // Check for mailto: in the href\n    if (link && link.indexOf('mailto:') > -1) return;\n\n    // check target\n    if (el.target) return;\n\n    // x-origin\n    if (!sameOrigin(el.href)) return;\n\n\n\n    // rebuild path\n    var path = el.pathname + el.search + (el.hash || '');\n\n    path = path[0] !== '/' ? '/' + path : path;\n\n    // strip leading \"/[drive letter]:\" on NW.js on Windows\n    if (typeof process !== 'undefined' && path.match(/^\\/[a-zA-Z]:\\//)) {\n      path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n    }\n\n    // same page\n    var orig = path;\n\n    if (path.indexOf(base) === 0) {\n      path = path.substr(base.length);\n    }\n\n    if (hashbang) path = path.replace('#!', '');\n\n    if (base && orig === path) return;\n\n    e.preventDefault();\n    page.show(orig);\n  }\n\n  /**\n   * Event button.\n   */\n\n  function which(e) {\n    e = e || window.event;\n    return null === e.which ? e.button : e.which;\n  }\n\n  /**\n   * Check if `href` is the same origin.\n   */\n\n  function sameOrigin(href) {\n    var origin = location.protocol + '//' + location.hostname;\n    if (location.port) origin += ':' + location.port;\n    return (href && (0 === href.indexOf(origin)));\n  }\n\n  page.sameOrigin = sameOrigin;\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"path-to-regexp\":{\"package.json\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// node_modules/meteor/kadira_flow-router/node_modules/path-to-regexp/package.json                                    //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nmodule.exports = {\n  \"name\": \"path-to-regexp\",\n  \"version\": \"1.2.1\"\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// node_modules/meteor/kadira_flow-router/node_modules/path-to-regexp/index.js                                        //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var suffix = res[6]\n    var asterisk = res[7]\n\n    var repeat = suffix === '+' || suffix === '*'\n    var optional = suffix === '?' || suffix === '*'\n    var delimiter = prefix || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$')\n    }\n  }\n\n  return function (obj) {\n    var path = ''\n    var data = obj || {}\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.pattern\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = keys\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"isarray\":{\"package.json\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// node_modules/meteor/kadira_flow-router/node_modules/isarray/package.json                                           //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nmodule.exports = {\n  \"name\": \"isarray\",\n  \"version\": \"0.0.1\",\n  \"main\": \"index.js\"\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// node_modules/meteor/kadira_flow-router/node_modules/isarray/index.js                                               //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"qs\":{\"package.json\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// node_modules/meteor/kadira_flow-router/node_modules/qs/package.json                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nmodule.exports = {\n  \"name\": \"qs\",\n  \"version\": \"5.2.0\",\n  \"main\": \"lib/index.js\"\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lib\":{\"index.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// node_modules/meteor/kadira_flow-router/node_modules/qs/lib/index.js                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n// Load modules\n\nvar Stringify = require('./stringify');\nvar Parse = require('./parse');\n\n\n// Declare internals\n\nvar internals = {};\n\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"stringify.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// node_modules/meteor/kadira_flow-router/node_modules/qs/lib/stringify.js                                            //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n// Load modules\n\nvar Utils = require('./utils');\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&',\n    arrayPrefixGenerators: {\n        brackets: function (prefix, key) {\n\n            return prefix + '[]';\n        },\n        indices: function (prefix, key) {\n\n            return prefix + '[' + key + ']';\n        },\n        repeat: function (prefix, key) {\n\n            return prefix;\n        }\n    },\n    strictNullHandling: false,\n    skipNulls: false,\n    encode: true\n};\n\n\ninternals.stringify = function (obj, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort) {\n\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    }\n    else if (Utils.isBuffer(obj)) {\n        obj = obj.toString();\n    }\n    else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    }\n    else if (obj === null) {\n        if (strictNullHandling) {\n            return encode ? Utils.encode(prefix) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' ||\n        typeof obj === 'number' ||\n        typeof obj === 'boolean') {\n\n        if (encode) {\n            return [Utils.encode(prefix) + '=' + Utils.encode(obj)];\n        }\n        return [prefix + '=' + obj];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (Array.isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0, il = objKeys.length; i < il; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls &&\n            obj[key] === null) {\n\n            continue;\n        }\n\n        if (Array.isArray(obj)) {\n            values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));\n        }\n        else {\n            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));\n        }\n    }\n\n    return values;\n};\n\n\nmodule.exports = function (obj, options) {\n\n    options = options || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;\n    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : internals.skipNulls;\n    var encode = typeof options.encode === 'boolean' ? options.encode : internals.encode;\n    var sort = typeof options.sort === 'function' ? options.sort : null;\n    var objKeys;\n    var filter;\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    }\n    else if (Array.isArray(options.filter)) {\n        objKeys = filter = options.filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return '';\n    }\n\n    var arrayFormat;\n    if (options.arrayFormat in internals.arrayPrefixGenerators) {\n        arrayFormat = options.arrayFormat;\n    }\n    else if ('indices' in options) {\n        arrayFormat = options.indices ? 'indices' : 'repeat';\n    }\n    else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (sort) {\n        objKeys.sort(sort);\n    }\n\n    for (var i = 0, il = objKeys.length; i < il; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls &&\n            obj[key] === null) {\n\n            continue;\n        }\n\n        keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort));\n    }\n\n    return keys.join(delimiter);\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"utils.js\":function module(require,exports){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// node_modules/meteor/kadira_flow-router/node_modules/qs/lib/utils.js                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n// Load modules\n\n\n// Declare internals\n\nvar internals = {};\ninternals.hexTable = new Array(256);\nfor (var h = 0; h < 256; ++h) {\n    internals.hexTable[h] = '%' + ((h < 16 ? '0' : '') + h.toString(16)).toUpperCase();\n}\n\n\nexports.arrayToObject = function (source, options) {\n\n    var obj = options.plainObjects ? Object.create(null) : {};\n    for (var i = 0, il = source.length; i < il; ++i) {\n        if (typeof source[i] !== 'undefined') {\n\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\n\nexports.merge = function (target, source, options) {\n\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (Array.isArray(target)) {\n            target.push(source);\n        }\n        else if (typeof target === 'object') {\n            target[source] = true;\n        }\n        else {\n            target = [target, source];\n        }\n\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        target = [target].concat(source);\n        return target;\n    }\n\n    if (Array.isArray(target) &&\n        !Array.isArray(source)) {\n\n        target = exports.arrayToObject(target, options);\n    }\n\n    var keys = Object.keys(source);\n    for (var k = 0, kl = keys.length; k < kl; ++k) {\n        var key = keys[k];\n        var value = source[key];\n\n        if (!Object.prototype.hasOwnProperty.call(target, key)) {\n            target[key] = value;\n        }\n        else {\n            target[key] = exports.merge(target[key], value, options);\n        }\n    }\n\n    return target;\n};\n\n\nexports.decode = function (str) {\n\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\nexports.encode = function (str) {\n\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    if (typeof str !== 'string') {\n        str = '' + str;\n    }\n\n    var out = '';\n    for (var i = 0, il = str.length; i < il; ++i) {\n        var c = str.charCodeAt(i);\n\n        if (c === 0x2D || // -\n            c === 0x2E || // .\n            c === 0x5F || // _\n            c === 0x7E || // ~\n            (c >= 0x30 && c <= 0x39) || // 0-9\n            (c >= 0x41 && c <= 0x5A) || // a-z\n            (c >= 0x61 && c <= 0x7A)) { // A-Z\n\n            out += str[i];\n            continue;\n        }\n\n        if (c < 0x80) {\n            out += internals.hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out += internals.hexTable[0xC0 | (c >> 6)] + internals.hexTable[0x80 | (c & 0x3F)];\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out += internals.hexTable[0xE0 | (c >> 12)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];\n            continue;\n        }\n\n        ++i;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));\n        out += internals.hexTable[0xF0 | (c >> 18)] + internals.hexTable[0x80 | ((c >> 12) & 0x3F)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nexports.compact = function (obj, refs) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    refs = refs || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0, il = obj.length; i < il; ++i) {\n            if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\n\nexports.isRegExp = function (obj) {\n\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\n\nexports.isBuffer = function (obj) {\n\n    if (obj === null ||\n        typeof obj === 'undefined') {\n\n        return false;\n    }\n\n    return !!(obj.constructor &&\n              obj.constructor.isBuffer &&\n              obj.constructor.isBuffer(obj));\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"parse.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// node_modules/meteor/kadira_flow-router/node_modules/qs/lib/parse.js                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n// Load modules\n\nvar Utils = require('./utils');\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000,\n    strictNullHandling: false,\n    plainObjects: false,\n    allowPrototypes: false,\n    allowDots: false\n};\n\n\ninternals.parseValues = function (str, options) {\n\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0, il = parts.length; i < il; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        if (pos === -1) {\n            obj[Utils.decode(part)] = '';\n\n            if (options.strictNullHandling) {\n                obj[Utils.decode(part)] = null;\n            }\n        }\n        else {\n            var key = Utils.decode(part.slice(0, pos));\n            var val = Utils.decode(part.slice(pos + 1));\n\n            if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n                obj[key] = val;\n            }\n            else {\n                obj[key] = [].concat(obj[key]).concat(val);\n            }\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseObject = function (chain, val, options) {\n\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj;\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(internals.parseObject(chain, val, options));\n    }\n    else {\n        obj = options.plainObjects ? Object.create(null) : {};\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n        var index = parseInt(cleanRoot, 10);\n        var indexString = '' + index;\n        if (!isNaN(index) &&\n            root !== cleanRoot &&\n            indexString === cleanRoot &&\n            index >= 0 &&\n            (options.parseArrays &&\n             index <= options.arrayLimit)) {\n\n            obj = [];\n            obj[index] = internals.parseObject(chain, val, options);\n        }\n        else {\n            obj[cleanRoot] = internals.parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseKeys = function (key, val, options) {\n\n    if (!key) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n\n    if (options.allowDots) {\n        key = key.replace(/\\.([^\\.\\[]+)/g, '[$1]');\n    }\n\n    // The regex chunks\n\n    var parent = /^([^\\[\\]]*)/;\n    var child = /(\\[[^\\[\\]]*\\])/g;\n\n    // Get the parent\n\n    var segment = parent.exec(key);\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (segment[1]) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects &&\n            Object.prototype.hasOwnProperty(segment[1])) {\n\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(segment[1]);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n\n        ++i;\n        if (!options.plainObjects &&\n            Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n\n            if (!options.allowPrototypes) {\n                continue;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return internals.parseObject(keys, val, options);\n};\n\n\nmodule.exports = function (str, options) {\n\n    options = options || {};\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : internals.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;\n\n    if (str === '' ||\n        str === null ||\n        typeof str === 'undefined') {\n\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        var newObj = internals.parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj, options);\n    }\n\n    return Utils.compact(obj);\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\n\n/* Exports */\nreturn {\n  export: function () { return {\n      FlowRouter: FlowRouter\n    };},\n  require: require,\n  eagerModulePaths: [\n    \"/node_modules/meteor/kadira:flow-router/client/modules.js\",\n    \"/node_modules/meteor/kadira:flow-router/client/triggers.js\",\n    \"/node_modules/meteor/kadira:flow-router/client/router.js\",\n    \"/node_modules/meteor/kadira:flow-router/client/group.js\",\n    \"/node_modules/meteor/kadira:flow-router/client/route.js\",\n    \"/node_modules/meteor/kadira:flow-router/client/_init.js\",\n    \"/node_modules/meteor/kadira:flow-router/lib/router.js\"\n  ]\n}});\n","servePath":"/packages/kadira_flow-router.js"}]