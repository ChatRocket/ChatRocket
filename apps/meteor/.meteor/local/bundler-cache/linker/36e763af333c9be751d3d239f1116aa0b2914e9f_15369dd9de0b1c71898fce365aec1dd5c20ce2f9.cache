[{"type":"js","data":"Package[\"core-runtime\"].queue(\"meteorhacks:inject-initial\",function () {/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar EmitterPromise = Package.meteor.EmitterPromise;\nvar RoutePolicy = Package.routepolicy.RoutePolicy;\nvar WebApp = Package.webapp.WebApp;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar main = Package.webapp.main;\nvar EJSON = Package.ejson.EJSON;\nvar _ = Package.underscore._;\n\n/* Package-scope variables */\nvar Inject, id;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                               //\n// packages/meteorhacks_inject-initial/lib/inject-server.js                                                      //\n//                                                                                                               //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                 //\nfunction escapeReplaceString(str) {\n\t/*\n\t * When using string.replace(str, newSubStr), the dollar sign (\"$\") is\n\t * considered a special character in newSubStr, and needs to be escaped\n\t * as \"$$\".  We have to do this twice, for escaping the newSubStr in\n\t * this function, and for the resulting string which is passed back.\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace\n\t */\n\treturn str.replace(/\\$/g, '$$$$');\n}\n\nInject = {\n\t// stores in a script type=application/ejson tag, accessed with Injected.obj('id')\n\tobj(id, data, res) {\n\t\tthis._checkForObjOrFunction(data, 'Inject.obj(id, data [,res]) expects `data` to be an Object or Function');\n\n\t\tif (res) {\n\t\t\tthis._resAssign(res, 'objList', id, data);\n\t\t} else {\n\t\t\tthis.objList[id] = data;\n\t\t}\n\t},\n\tobjList: {},\n\n\t// Inserts a META called `id`, whose `content` can be accessed with Injected.meta()\n\tmeta(id, data, res) {\n\t\tthis._checkForTextOrFunction(data, 'Inject.meta(id, data [,res]) expects `data` to be an String or Function');\n\n\t\tif (res) {\n\t\t\tthis._resAssign(res, 'metaList', id, data);\n\t\t} else {\n\t\t\tthis.metaList[id] = data;\n\t\t}\n\t},\n\tmetaList: {},\n\n\trawHead(id, textOrFunc, res) {\n\t\tthis._checkForTextOrFunction(textOrFunc, 'Inject.rawHead(id, content [,res]) expects `content` to be an String or Function');\n\n\t\tif (res) {\n\t\t\tthis._resAssign(res, 'rawHeads', id, textOrFunc);\n\t\t} else {\n\t\t\tthis.rawHeads[id] = textOrFunc;\n\t\t}\n\t},\n\trawHeads: {},\n\n\trawBody(id, textOrFunc, res) {\n\t\tthis._checkForTextOrFunction(textOrFunc, 'Inject.rawBody(id, content [,res]) expects `content` to be an String or Function');\n\n\t\tif (res) {\n\t\t\tthis._resAssign(res, 'rawBodies', id, textOrFunc);\n\t\t} else {\n\t\t\tthis.rawBodies[id] = textOrFunc;\n\t\t}\n\t},\n\trawBodies: {},\n\n\t// The callback receives the entire HTML page and must return a modified version\n\trawModHtml(id, func) {\n\t\tif (!_.isFunction(func)) {\n\t\t\tconst message = `Inject func id \"${id}\" should be a function, not ${typeof func}`;\n\t\t\tthrow new Error(message);\n\t\t}\n\n\t\tthis.rawModHtmlFuncs[id] = func;\n\t},\n\trawModHtmlFuncs: {},\n\n\t_injectObjects(html, res) {\n\t\tconst objs = _.extend({}, Inject.objList, res.Inject && res.Inject.objList);\n\t\tif (_.isEmpty(objs)) {\n\t\t\treturn html;\n\t\t}\n\n\t\tlet obj;\n\t\tlet injectHtml = '';\n\t\tfor (id in objs) {\n\t\t\tobj = _.isFunction(objs[id]) ? objs[id](res) : objs[id];\n\t\t\tinjectHtml += `  <script id='${id.replace(\"'\", '&apos;')}' type='application/ejson'>${EJSON.stringify(obj)}</script>\\n`;\n\t\t}\n\n\t\treturn html.replace('<head>', `<head>\\n${escapeReplaceString(injectHtml)}`);\n\t},\n\n\t_injectMeta(html, res) {\n\t\tconst metas = _.extend({}, Inject.metaList, res.Inject && res.Inject.metaList);\n\t\tif (_.isEmpty(metas)) return html;\n\n\t\tlet injectHtml = '';\n\t\tfor (id in metas) {\n\t\t\tconst meta = this._evalToText(metas[id], res, html);\n\t\t\t(injectHtml += `  <meta id='${id.replace(\"'\", '&apos;')}' content='${meta.replace(\"'\", '&apos;')}'>\\n`), res;\n\t\t}\n\n\t\treturn html.replace('<head>', `<head>\\n${escapeReplaceString(injectHtml)}`);\n\t},\n\n\t_injectHeads(html, res) {\n\t\tconst heads = _.extend({}, Inject.rawHeads, res.Inject && res.Inject.rawHeads);\n\t\tif (_.isEmpty(heads)) return html;\n\n\t\tlet injectHtml = '';\n\t\tfor (id in heads) {\n\t\t\tconst head = this._evalToText(heads[id], res, html);\n\t\t\tinjectHtml += `${head}\\n`;\n\t\t}\n\n\t\treturn html.replace('<head>', `<head>\\n${escapeReplaceString(injectHtml)}`);\n\t},\n\n\t_injectBodies(html, res) {\n\t\tconst bodies = _.extend({}, Inject.rawBodies, res.Inject && res.Inject.rawBodies);\n\t\tif (_.isEmpty(bodies)) return html;\n\n\t\tlet injectHtml = '';\n\t\tfor (id in bodies) {\n\t\t\tconst body = this._evalToText(bodies[id], res, html);\n\t\t\tinjectHtml += `${body}\\n`;\n\t\t}\n\n\t\treturn html.replace('<body>', `<body>\\n${escapeReplaceString(injectHtml)}`);\n\t},\n\n\t// ensure object exists and store there\n\t_resAssign(res, key, id, value) {\n\t\tif (!res.Inject) res.Inject = {};\n\t\tif (!res.Inject[key]) res.Inject[key] = {};\n\t\tres.Inject[key][id] = value;\n\t},\n\n\t_checkForTextOrFunction(arg, message) {\n\t\tif (!(_.isString(arg) || _.isFunction(arg))) {\n\t\t\tthrow new Error(message);\n\t\t}\n\t},\n\n\t_checkForObjOrFunction(arg, message) {\n\t\tif (!(_.isObject(arg) || _.isFunction(arg))) {\n\t\t\tthrow new Error(message);\n\t\t}\n\t},\n\n\t// we don't handle errors here. Let them to handle in a higher level\n\t_evalToText(textOrFunc, res, html) {\n\t\tif (_.isFunction(textOrFunc)) {\n\t\t\treturn textOrFunc(res, html);\n\t\t}\n\t\treturn textOrFunc;\n\t},\n};\n\nInject.rawModHtml('injectHeads', Inject._injectHeads.bind(Inject));\nInject.rawModHtml('injectMeta', Inject._injectMeta.bind(Inject));\nInject.rawModHtml('injectBodies', Inject._injectBodies.bind(Inject));\nInject.rawModHtml('injectObjects', Inject._injectObjects.bind(Inject));\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                               //\n// packages/meteorhacks_inject-initial/lib/inject-core.js                                                        //\n//                                                                                                               //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                 //\n// Hijack core node API and attach data to the response dynamically\n// We are simply using this hack because, there is no way to alter\n// Meteor's html content on the server side\n\nInject._hijackWrite = function (res) {\n\tconst originalWrite = res.write;\n\tres.write = function (chunk, encoding) {\n\t\t// prevent hijacking other http requests\n\t\tif (!res.iInjected && encoding === undefined && /^<!DOCTYPE html>/.test(chunk)) {\n\t\t\tchunk = chunk.toString();\n\n\t\t\tfor (id in Inject.rawModHtmlFuncs) {\n\t\t\t\tchunk = Inject.rawModHtmlFuncs[id](chunk, res);\n\t\t\t\tif (!_.isString(chunk)) {\n\t\t\t\t\tthrow new Error(`Inject func id \"${id}\" must return HTML, not ${typeof chunk}\\n${JSON.stringify(chunk, null, 2)}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres.iInjected = true;\n\t\t}\n\n\t\toriginalWrite.call(res, chunk, encoding);\n\t};\n};\n\nWebApp.connectHandlers.use(function (req, res, next) {\n\t// We only separate this to make testing easier\n\tInject._hijackWrite(res);\n\n\tnext();\n});\n\n// meteor algorithm to check if this is a meteor serving http request or not\nInject.appUrl = function (url) {\n\tif (url === '/favicon.ico' || url === '/robots.txt') return false;\n\n\t// NOTE: app.manifest is not a web standard like favicon.ico and\n\t// robots.txt. It is a file id we have chosen to use for HTML5\n\t// appcache URLs. It is included here to prevent using an appcache\n\t// then removing it from poisoning an app permanently. Eventually,\n\t// once we have server side routing, this won't be needed as\n\t// unknown URLs with return a 404 automatically.\n\tif (url === '/app.manifest') return false;\n\n\t// Avoid serving app HTML for declared routes such as /sockjs/.\n\tif (typeof RoutePolicy !== 'undefined' && RoutePolicy.classify(url)) return false;\n\n\t// we currently return app HTML on all URLs by default\n\treturn true;\n};\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nreturn {\n  export: function () { return {\n      Inject: Inject\n    };}\n}});\n","servePath":"/packages/meteorhacks_inject-initial.js"}]