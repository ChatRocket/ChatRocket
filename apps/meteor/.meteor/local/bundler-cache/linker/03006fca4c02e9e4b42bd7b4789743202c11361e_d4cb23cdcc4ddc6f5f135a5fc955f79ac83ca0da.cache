[{"type":"js","data":"Package[\"core-runtime\"].queue(\"accounts-oauth\",function () {/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar EmitterPromise = Package.meteor.EmitterPromise;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar WebApp = Package.webapp.WebApp;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar main = Package.webapp.main;\nvar Accounts = Package['accounts-base'].Accounts;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar OAuth = Package.oauth.OAuth;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"accounts-oauth\":{\"oauth_common.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/accounts-oauth/oauth_common.js                                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let Meteor;\n    module.link(\"meteor/meteor\", {\n      Meteor(v) {\n        Meteor = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    Accounts.oauth = {};\n    const services = {};\n    const hasOwn = Object.prototype.hasOwnProperty;\n\n    // Helper for registering OAuth based accounts packages.\n    // On the server, adds an index to the user collection.\n    Accounts.oauth.registerService = name => {\n      if (hasOwn.call(services, name)) throw new Error(\"Duplicate service: \".concat(name));\n      services[name] = true;\n      if (Meteor.server) {\n        // Accounts.updateOrCreateUserFromExternalService does a lookup by this id,\n        // so this should be a unique index. You might want to add indexes for other\n        // fields returned by your service (eg services.github.login) but you can do\n        // that in your app.\n        Meteor.users.createIndexAsync(\"services.\".concat(name, \".id\"), {\n          unique: true,\n          sparse: true\n        });\n      }\n    };\n\n    // Removes a previously registered service.\n    // This will disable logging in with this service, and serviceNames() will not\n    // contain it.\n    // It's worth noting that already logged in users will remain logged in unless\n    // you manually expire their sessions.\n    Accounts.oauth.unregisterService = name => {\n      if (!hasOwn.call(services, name)) throw new Error(\"Service not found: \".concat(name));\n      delete services[name];\n    };\n    Accounts.oauth.serviceNames = () => Object.keys(services);\n\n    // loginServiceConfiguration and ConfigError are maintained for backwards compatibility\n    Meteor.startup(() => {\n      var _Meteor$settings, _Meteor$settings$pack;\n      const {\n        ServiceConfiguration\n      } = Package['service-configuration'];\n      Accounts.loginServiceConfiguration = ServiceConfiguration.configurations;\n      Accounts.ConfigError = ServiceConfiguration.ConfigError;\n      const settings = (_Meteor$settings = Meteor.settings) === null || _Meteor$settings === void 0 ? void 0 : (_Meteor$settings$pack = _Meteor$settings.packages) === null || _Meteor$settings$pack === void 0 ? void 0 : _Meteor$settings$pack['accounts-base'];\n      if (settings) {\n        if (settings.oauthSecretKey) {\n          if (!Package['oauth-encryption']) {\n            throw new Error('The oauth-encryption package must be loaded to set oauthSecretKey');\n          }\n          Package['oauth-encryption'].OAuthEncryption.loadKey(settings.oauthSecretKey);\n          delete settings.oauthSecretKey;\n        }\n      }\n    });\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"oauth_server.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/accounts-oauth/oauth_server.js                                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    var _Package$oauthEncryp;\n    let Meteor;\n    module.link(\"meteor/meteor\", {\n      Meteor(v) {\n        Meteor = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    // Listen to calls to `login` with an oauth option set. This is where\n    // users actually get logged in to meteor via oauth.\n    Accounts.registerLoginHandler(async options => {\n      if (!options.oauth) return undefined; // don't handle\n\n      check(options.oauth, {\n        credentialToken: String,\n        // When an error occurs while retrieving the access token, we store\n        // the error in the pending credentials table, with a secret of\n        // null. The client can call the login method with a secret of null\n        // to retrieve the error.\n        credentialSecret: Match.OneOf(null, String)\n      });\n      const result = await OAuth.retrieveCredential(options.oauth.credentialToken, options.oauth.credentialSecret);\n      if (!result) {\n        // OAuth credentialToken is not recognized, which could be either\n        // because the popup was closed by the user before completion, or\n        // some sort of error where the oauth provider didn't talk to our\n        // server correctly and closed the popup somehow.\n        //\n        // We assume it was user canceled and report it as such, using a\n        // numeric code that the client recognizes (XXX this will get\n        // replaced by a symbolic error code at some point\n        // https://trello.com/c/kMkw800Z/53-official-ddp-specification). This\n        // will mask failures where things are misconfigured such that the\n        // server doesn't see the request but does close the window. This\n        // seems unlikely.\n        //\n        // XXX we want `type` to be the service name such as \"facebook\"\n        return {\n          type: \"oauth\",\n          error: new Meteor.Error(Accounts.LoginCancelledError.numericError, \"No matching login attempt found\")\n        };\n      }\n      if (result instanceof Error)\n        // We tried to login, but there was a fatal error. Report it back\n        // to the user.\n        throw result;else {\n        if (!Accounts.oauth.serviceNames().includes(result.serviceName)) {\n          // serviceName was not found in the registered services list.\n          // This could happen because the service never registered itself or\n          // unregisterService was called on it.\n          return {\n            type: \"oauth\",\n            error: new Meteor.Error(Accounts.LoginCancelledError.numericError, \"No registered oauth service found for: \".concat(result.serviceName))\n          };\n        }\n        return Accounts.updateOrCreateUserFromExternalService(result.serviceName, result.serviceData, result.options);\n      }\n    });\n\n    ///\n    /// OAuth Encryption Support\n    ///\n\n    const OAuthEncryption = (_Package$oauthEncryp = Package[\"oauth-encryption\"]) === null || _Package$oauthEncryp === void 0 ? void 0 : _Package$oauthEncryp.OAuthEncryption;\n    const usingOAuthEncryption = () => {\n      return OAuthEncryption === null || OAuthEncryption === void 0 ? void 0 : OAuthEncryption.keyIsLoaded();\n    };\n\n    // Encrypt unencrypted login service secrets when oauth-encryption is\n    // added.\n    //\n    // XXX For the oauthSecretKey to be available here at startup, the\n    // developer must call Accounts.config({oauthSecretKey: ...}) at load\n    // time, instead of in a Meteor.startup block, because the startup\n    // block in the app code will run after this accounts-base startup\n    // block.  Perhaps we need a post-startup callback?\n\n    Meteor.startup(() => {\n      if (!usingOAuthEncryption()) {\n        return;\n      }\n      const {\n        ServiceConfiguration\n      } = Package['service-configuration'];\n      ServiceConfiguration.configurations.find({\n        $and: [{\n          secret: {\n            $exists: true\n          }\n        }, {\n          \"secret.algorithm\": {\n            $exists: false\n          }\n        }]\n      }).forEachAsync(async config => {\n        await ServiceConfiguration.configurations.updateAsync(config._id, {\n          $set: {\n            secret: OAuthEncryption.seal(config.secret)\n          }\n        });\n      });\n    });\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\n\n/* Exports */\nreturn {\n  require: require,\n  eagerModulePaths: [\n    \"/node_modules/meteor/accounts-oauth/oauth_common.js\",\n    \"/node_modules/meteor/accounts-oauth/oauth_server.js\"\n  ]\n}});\n","servePath":"/packages/accounts-oauth.js","sourceMap":{"version":3,"sources":["packages/accounts-oauth/oauth_common.js","packages/accounts-oauth/oauth_server.js"],"names":["Meteor","module","link","v","__reifyWaitForDeps__","Accounts","oauth","services","hasOwn","Object","prototype","hasOwnProperty","registerService","name","call","Error","concat","server","users","createIndexAsync","unique","sparse","unregisterService","serviceNames","keys","startup","_Meteor$settings","_Meteor$settings$pack","ServiceConfiguration","Package","loginServiceConfiguration","configurations","ConfigError","settings","packages","oauthSecretKey","OAuthEncryption","loadKey","__reify_async_result__","_reifyError","self","async","registerLoginHandler","options","undefined","check","credentialToken","String","credentialSecret","Match","OneOf","result","OAuth","retrieveCredential","type","error","LoginCancelledError","numericError","includes","serviceName","updateOrCreateUserFromExternalService","serviceData","_Package$oauthEncryp","usingOAuthEncryption","keyIsLoaded","find","$and","secret","$exists","forEachAsync","config","updateAsync","_id","$set","seal"],"mappings":"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","file":"/packages/accounts-oauth.js","sourcesContent":["import { Meteor } from 'meteor/meteor';\n\nAccounts.oauth = {};\n\nconst services = {};\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// Helper for registering OAuth based accounts packages.\n// On the server, adds an index to the user collection.\nAccounts.oauth.registerService = name => {\n  if (hasOwn.call(services, name))\n    throw new Error(`Duplicate service: ${name}`);\n  services[name] = true;\n\n  if (Meteor.server) {\n    // Accounts.updateOrCreateUserFromExternalService does a lookup by this id,\n    // so this should be a unique index. You might want to add indexes for other\n    // fields returned by your service (eg services.github.login) but you can do\n    // that in your app.\n    Meteor.users.createIndexAsync(`services.${name}.id`, {unique: true, sparse: true});\n  }\n};\n\n// Removes a previously registered service.\n// This will disable logging in with this service, and serviceNames() will not\n// contain it.\n// It's worth noting that already logged in users will remain logged in unless\n// you manually expire their sessions.\nAccounts.oauth.unregisterService = name => {\n  if (!hasOwn.call(services, name))\n    throw new Error(`Service not found: ${name}`);\n  delete services[name];\n};\n\nAccounts.oauth.serviceNames = () => Object.keys(services);\n\n// loginServiceConfiguration and ConfigError are maintained for backwards compatibility\nMeteor.startup(() => {\n  const { ServiceConfiguration } = Package['service-configuration'];\n  Accounts.loginServiceConfiguration = ServiceConfiguration.configurations;\n  Accounts.ConfigError = ServiceConfiguration.ConfigError;\n\n  const settings = Meteor.settings?.packages?.['accounts-base'];\n  if (settings) {\n    if (settings.oauthSecretKey) {\n      if (!Package['oauth-encryption']) {\n        throw new Error(\n          'The oauth-encryption package must be loaded to set oauthSecretKey'\n        );\n      }\n      Package['oauth-encryption'].OAuthEncryption.loadKey(\n        settings.oauthSecretKey\n      );\n      delete settings.oauthSecretKey;\n    }\n  }\n});\n","import { Meteor } from 'meteor/meteor';\n\n// Listen to calls to `login` with an oauth option set. This is where\n// users actually get logged in to meteor via oauth.\nAccounts.registerLoginHandler(async options => {\n  if (!options.oauth)\n    return undefined; // don't handle\n\n  check(options.oauth, {\n    credentialToken: String,\n    // When an error occurs while retrieving the access token, we store\n    // the error in the pending credentials table, with a secret of\n    // null. The client can call the login method with a secret of null\n    // to retrieve the error.\n    credentialSecret: Match.OneOf(null, String)\n  });\n\n  const result = await OAuth.retrieveCredential(options.oauth.credentialToken,\n                                        options.oauth.credentialSecret);\n\n  if (!result) {\n    // OAuth credentialToken is not recognized, which could be either\n    // because the popup was closed by the user before completion, or\n    // some sort of error where the oauth provider didn't talk to our\n    // server correctly and closed the popup somehow.\n    //\n    // We assume it was user canceled and report it as such, using a\n    // numeric code that the client recognizes (XXX this will get\n    // replaced by a symbolic error code at some point\n    // https://trello.com/c/kMkw800Z/53-official-ddp-specification). This\n    // will mask failures where things are misconfigured such that the\n    // server doesn't see the request but does close the window. This\n    // seems unlikely.\n    //\n    // XXX we want `type` to be the service name such as \"facebook\"\n    return { type: \"oauth\",\n             error: new Meteor.Error(\n               Accounts.LoginCancelledError.numericError,\n               \"No matching login attempt found\") };\n  }\n\n  if (result instanceof Error)\n    // We tried to login, but there was a fatal error. Report it back\n    // to the user.\n    throw result;\n  else {\n    if (! Accounts.oauth.serviceNames().includes(result.serviceName)) {\n      // serviceName was not found in the registered services list.\n      // This could happen because the service never registered itself or\n      // unregisterService was called on it.\n      return { type: \"oauth\",\n               error: new Meteor.Error(\n                 Accounts.LoginCancelledError.numericError,\n                 `No registered oauth service found for: ${result.serviceName}`) };\n\n    }\n    return Accounts.updateOrCreateUserFromExternalService(result.serviceName, result.serviceData, result.options);\n  }\n});\n\n///\n/// OAuth Encryption Support\n///\n\nconst OAuthEncryption = Package[\"oauth-encryption\"]?.OAuthEncryption;\n\nconst usingOAuthEncryption = () => {\n  return OAuthEncryption?.keyIsLoaded();\n};\n\n// Encrypt unencrypted login service secrets when oauth-encryption is\n// added.\n//\n// XXX For the oauthSecretKey to be available here at startup, the\n// developer must call Accounts.config({oauthSecretKey: ...}) at load\n// time, instead of in a Meteor.startup block, because the startup\n// block in the app code will run after this accounts-base startup\n// block.  Perhaps we need a post-startup callback?\n\nMeteor.startup(() => {\n  if (! usingOAuthEncryption()) {\n    return;\n  }\n\n  const { ServiceConfiguration } = Package['service-configuration'];\n\n  ServiceConfiguration.configurations.find({\n    $and: [{\n      secret: { $exists: true }\n    }, {\n      \"secret.algorithm\": { $exists: false }\n    }]\n  }).forEachAsync(async (config) => {\n    await ServiceConfiguration.configurations.updateAsync(config._id, {\n      $set: {\n        secret: OAuthEncryption.seal(config.secret)\n      }\n    });\n  });\n});\n"]}}]