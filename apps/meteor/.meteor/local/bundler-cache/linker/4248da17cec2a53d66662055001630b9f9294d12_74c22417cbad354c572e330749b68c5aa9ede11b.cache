[{"type":"js","data":"Package[\"core-runtime\"].queue(\"oauth1\",function () {/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar EmitterPromise = Package.meteor.EmitterPromise;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar Random = Package.random.Random;\nvar ServiceConfiguration = Package['service-configuration'].ServiceConfiguration;\nvar OAuth = Package.oauth.OAuth;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar params, OAuth1Binding, OAuth1Test;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"oauth1\":{\"oauth1_binding.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/oauth1/oauth1_binding.js                                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    module.export({\n      OAuth1Binding: () => OAuth1Binding\n    });\n    let crypto;\n    module.link(\"crypto\", {\n      default(v) {\n        crypto = v;\n      }\n    }, 0);\n    let querystring;\n    module.link(\"querystring\", {\n      default(v) {\n        querystring = v;\n      }\n    }, 1);\n    let urlModule;\n    module.link(\"url\", {\n      default(v) {\n        urlModule = v;\n      }\n    }, 2);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    class OAuth1Binding {\n      constructor(config, urls) {\n        this._config = config;\n        this._urls = urls;\n      }\n      async prepareRequestToken(callbackUrl) {\n        const headers = this._buildHeader({\n          oauth_callback: callbackUrl\n        });\n        const response = await this._call({\n          method: 'POST',\n          url: this._urls.requestToken,\n          headers\n        });\n        const tokens = querystring.parse(response.content);\n        if (!tokens.oauth_callback_confirmed) throw Object.assign(new Error(\"oauth_callback_confirmed false when requesting oauth1 token\"), {\n          response: response\n        });\n        this.requestToken = tokens.oauth_token;\n        this.requestTokenSecret = tokens.oauth_token_secret;\n      }\n      async prepareAccessToken(query, requestTokenSecret) {\n        // support implementations that use request token secrets. This is\n        // read by this._call.\n        //\n        // XXX make it a param to call, not something stashed on self? It's\n        // kinda confusing right now, everything except this is passed as\n        // arguments, but this is stored.\n        if (requestTokenSecret) this.accessTokenSecret = requestTokenSecret;\n        const headers = this._buildHeader({\n          oauth_token: query.oauth_token,\n          oauth_verifier: query.oauth_verifier\n        });\n        const response = await this._call({\n          method: 'POST',\n          url: this._urls.accessToken,\n          headers\n        });\n        const tokens = querystring.parse(response.content);\n        if (!tokens.oauth_token || !tokens.oauth_token_secret) {\n          const error = new Error(\"missing oauth token or secret\");\n          // We provide response only if no token is available, we do not want to leak any tokens\n          if (!tokens.oauth_token && !tokens.oauth_token_secret) {\n            Object.assign(error, {\n              response: response\n            });\n          }\n          throw error;\n        }\n        this.accessToken = tokens.oauth_token;\n        this.accessTokenSecret = tokens.oauth_token_secret;\n      }\n      async callAsync(method, url, params, callback) {\n        const headers = this._buildHeader({\n          oauth_token: this.accessToken\n        });\n        if (!params) {\n          params = {};\n        }\n        return this._call({\n          method,\n          url,\n          headers,\n          params,\n          callback\n        });\n      }\n      async getAsync(url, params, callback) {\n        return this.callAsync('GET', url, params, callback);\n      }\n      async postAsync(url, params, callback) {\n        return this.callAsync('POST', url, params, callback);\n      }\n      get(url, params, callback) {\n        // Require changes when remove Fibers. Exposed to public api.\n        return this.call('GET', url, params, callback);\n      }\n      post(url, params, callback) {\n        // Require changes when remove Fibers. Exposed to public api.\n        return this.call('POST', url, params, callback);\n      }\n      _buildHeader(headers) {\n        return _objectSpread({\n          oauth_consumer_key: this._config.consumerKey,\n          oauth_nonce: Random.secret().replace(/\\W/g, ''),\n          oauth_signature_method: 'HMAC-SHA1',\n          oauth_timestamp: (new Date().valueOf() / 1000).toFixed().toString(),\n          oauth_version: '1.0'\n        }, headers);\n      }\n      _getSignature(method, url, rawHeaders, accessTokenSecret, params) {\n        const headers = this._encodeHeader(_objectSpread(_objectSpread({}, rawHeaders), params));\n        const parameters = Object.keys(headers).map(key => \"\".concat(key, \"=\").concat(headers[key])).sort().join('&');\n        const signatureBase = [method, this._encodeString(url), this._encodeString(parameters)].join('&');\n        const secret = OAuth.openSecret(this._config.secret);\n        let signingKey = \"\".concat(this._encodeString(secret), \"&\");\n        if (accessTokenSecret) signingKey += this._encodeString(accessTokenSecret);\n        return crypto.createHmac('SHA1', signingKey).update(signatureBase).digest('base64');\n      }\n      async _call(_ref) {\n        let {\n          method,\n          url,\n          headers = {},\n          params = {},\n          callback\n        } = _ref;\n        // all URLs to be functions to support parameters/customization\n        if (typeof url === \"function\") {\n          url = url(this);\n        }\n\n        // Extract all query string parameters from the provided URL\n        const parsedUrl = urlModule.parse(url, true);\n        // Merge them in a way that params given to the method call have precedence\n        params = _objectSpread(_objectSpread({}, parsedUrl.query), params);\n\n        // Reconstruct the URL back without any query string parameters\n        // (they are now in params)\n        parsedUrl.query = {};\n        parsedUrl.search = '';\n        url = urlModule.format(parsedUrl);\n\n        // Get the signature\n        headers.oauth_signature = this._getSignature(method, url, headers, this.accessTokenSecret, params);\n\n        // Make a authorization string according to oauth1 spec\n        const authString = this._getAuthHeaderString(headers);\n        // Make signed request\n        return OAuth._fetch(url, method, _objectSpread({\n          headers: _objectSpread({\n            Authorization: authString\n          }, method.toUpperCase() === 'POST' ? {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          } : {})\n        }, method.toUpperCase() === 'POST' ? {\n          body: OAuth._addValuesToQueryParams(params).toString()\n        } : {\n          queryParams: params\n        })).then(res => res.text().then(content => {\n          const responseHeaders = Array.from(res.headers.entries()).reduce((acc, _ref2) => {\n            let [key, val] = _ref2;\n            return _objectSpread(_objectSpread({}, acc), {}, {\n              [key.toLowerCase()]: val\n            });\n          }, {});\n          const data = responseHeaders['content-type'].includes('application/json') ? JSON.parse(content) : undefined;\n          return {\n            content: data ? '' : content,\n            data,\n            headers: _objectSpread(_objectSpread({}, responseHeaders), {}, {\n              nonce: headers.oauth_nonce\n            }),\n            redirected: res.redirected,\n            ok: res.ok,\n            statusCode: res.status\n          };\n        })).then(response => {\n          if (callback) {\n            callback(undefined, response);\n          }\n          return response;\n        }).catch(err => {\n          if (callback) {\n            callback(err);\n          }\n          console.log({\n            err\n          });\n          throw Object.assign(new Error(\"Failed to send OAuth1 request to \".concat(url, \". \").concat(err.message)), {\n            response: err.response\n          });\n        });\n      }\n      _encodeHeader(header) {\n        return Object.keys(header).reduce((memo, key) => {\n          memo[this._encodeString(key)] = this._encodeString(header[key]);\n          return memo;\n        }, {});\n      }\n      _encodeString(str) {\n        return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\n      }\n      _getAuthHeaderString(headers) {\n        return 'OAuth ' + Object.keys(headers).map(key => \"\".concat(this._encodeString(key), \"=\\\"\").concat(this._encodeString(headers[key]), \"\\\"\")).sort().join(', ');\n      }\n    }\n    ;\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"oauth1_server.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/oauth1/oauth1_server.js                                                                                    //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!module.wrapAsync(async function (module1, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module1.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    let url;\n    module1.link(\"url\", {\n      default(v) {\n        url = v;\n      }\n    }, 0);\n    let OAuth1Binding;\n    module1.link(\"./oauth1_binding\", {\n      OAuth1Binding(v) {\n        OAuth1Binding = v;\n      }\n    }, 1);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    OAuth._queryParamsWithAuthTokenUrl = function (authUrl, oauthBinding) {\n      let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      let whitelistedQueryParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      const redirectUrlObj = url.parse(authUrl, true);\n      Object.assign(redirectUrlObj.query, whitelistedQueryParams.reduce((prev, param) => params.query[param] ? _objectSpread(_objectSpread({}, prev), {}, {\n        param: params.query[param]\n      }) : prev, {}), {\n        oauth_token: oauthBinding.requestToken\n      });\n\n      // Clear the `search` so it is rebuilt by Node's `url` from the `query` above.\n      // Using previous versions of the Node `url` module, this was just set to \"\"\n      // However, Node 6 docs seem to indicate that this should be `undefined`.\n      delete redirectUrlObj.search;\n\n      // Reconstruct the URL back with provided query parameters merged with oauth_token\n      return url.format(redirectUrlObj);\n    };\n\n    // connect middleware\n    OAuth._requestHandlers['1'] = async (service, query, res) => {\n      const config = await ServiceConfiguration.configurations.findOneAsync({\n        service: service.serviceName\n      });\n      if (!config) {\n        throw new ServiceConfiguration.ConfigError(service.serviceName);\n      }\n      const {\n        urls\n      } = service;\n      const oauthBinding = new OAuth1Binding(config, urls);\n      let credentialSecret;\n      if (query.requestTokenAndRedirect) {\n        // step 1 - get and store a request token\n        const callbackUrl = OAuth._redirectUri(service.serviceName, config, {\n          state: query.state,\n          cordova: query.cordova === \"true\",\n          android: query.android === \"true\"\n        });\n\n        // Get a request token to start auth process\n        await oauthBinding.prepareRequestToken(callbackUrl);\n\n        // Keep track of request token so we can verify it on the next step\n        await OAuth._storeRequestToken(OAuth._credentialTokenFromQuery(query), oauthBinding.requestToken, oauthBinding.requestTokenSecret);\n\n        // support for scope/name parameters\n        let redirectUrl;\n        const authParams = {\n          query\n        };\n        if (typeof urls.authenticate === \"function\") {\n          redirectUrl = urls.authenticate(oauthBinding, authParams);\n        } else {\n          redirectUrl = OAuth._queryParamsWithAuthTokenUrl(urls.authenticate, oauthBinding, authParams);\n        }\n\n        // redirect to provider login, which will redirect back to \"step 2\" below\n\n        res.writeHead(302, {\n          'Location': redirectUrl\n        });\n        res.end();\n      } else {\n        // step 2, redirected from provider login - store the result\n        // and close the window to allow the login handler to proceed\n\n        // Get the user's request token so we can verify it and clear it\n        const requestTokenInfo = await OAuth._retrieveRequestToken(OAuth._credentialTokenFromQuery(query));\n        if (!requestTokenInfo) {\n          throw new Error(\"Unable to retrieve request token\");\n        }\n\n        // Verify user authorized access and the oauth_token matches\n        // the requestToken from previous step\n        if (query.oauth_token && query.oauth_token === requestTokenInfo.requestToken) {\n          // Prepare the login results before returning.  This way the\n          // subsequent call to the `login` method will be immediate.\n\n          // Get the access token for signing requests\n          await oauthBinding.prepareAccessToken(query, requestTokenInfo.requestTokenSecret);\n\n          // Run service-specific handler.\n          const oauthResult = await service.handleOauthRequest(oauthBinding, {\n            query: query\n          });\n          const credentialToken = OAuth._credentialTokenFromQuery(query);\n          credentialSecret = Random.secret();\n\n          // Store the login result so it can be retrieved in another\n          // browser tab by the result handler\n          await OAuth._storePendingCredential(credentialToken, {\n            serviceName: service.serviceName,\n            serviceData: oauthResult.serviceData,\n            options: oauthResult.options\n          }, credentialSecret);\n        }\n\n        // Either close the window, redirect, or render nothing\n        // if all else fails\n        await OAuth._renderOauthResults(res, query, credentialSecret);\n      }\n    };\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"oauth1_pending_request_tokens.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/oauth1/oauth1_pending_request_tokens.js                                                                    //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    __reifyWaitForDeps__();\n    //\n    // _pendingRequestTokens are request tokens that have been received\n    // but not yet fully authorized (processed).\n    //\n    // During the oauth1 authorization process, the Meteor App opens\n    // a pop-up, requests a request token from the oauth1 service, and\n    // redirects the browser to the oauth1 service for the user\n    // to grant authorization.  The user is then returned to the\n    // Meteor Apps' callback url and the request token is verified.\n    //\n    // When Meteor Apps run on multiple servers, it's possible that\n    // 2 different servers may be used to generate the request token\n    // and to verify it in the callback once the user has authorized.\n    //\n    // For this reason, the _pendingRequestTokens are stored in the database\n    // so they can be shared across Meteor App servers.\n    //\n    // XXX This code is fairly similar to oauth/pending_credentials.js --\n    // maybe we can combine them somehow.\n\n    // Collection containing pending request tokens\n    // Has key, requestToken, requestTokenSecret, and createdAt fields.\n    OAuth._pendingRequestTokens = new Mongo.Collection(\"meteor_oauth_pendingRequestTokens\", {\n      _preventAutopublish: true\n    });\n    await OAuth._pendingRequestTokens.createIndexAsync('key', {\n      unique: true\n    });\n    await OAuth._pendingRequestTokens.createIndexAsync('createdAt');\n\n    // Periodically clear old entries that never got completed\n    const _cleanStaleResults = async () => {\n      // Remove request tokens older than 5 minute\n      const timeCutoff = new Date();\n      timeCutoff.setMinutes(timeCutoff.getMinutes() - 5);\n      await OAuth._pendingRequestTokens.removeAsync({\n        createdAt: {\n          $lt: timeCutoff\n        }\n      });\n    };\n    const _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000);\n\n    // Stores the key and request token in the _pendingRequestTokens collection.\n    // Will throw an exception if `key` is not a string.\n    //\n    // @param key {string}\n    // @param requestToken {string}\n    // @param requestTokenSecret {string}\n    //\n    OAuth._storeRequestToken = async (key, requestToken, requestTokenSecret) => {\n      check(key, String);\n\n      // We do an upsert here instead of an insert in case the user happens\n      // to somehow send the same `state` parameter twice during an OAuth\n      // login; we don't want a duplicate key error.\n      await OAuth._pendingRequestTokens.upsertAsync({\n        key\n      }, {\n        key,\n        requestToken: OAuth.sealSecret(requestToken),\n        requestTokenSecret: OAuth.sealSecret(requestTokenSecret),\n        createdAt: new Date()\n      });\n    };\n\n    // Retrieves and removes a request token from the _pendingRequestTokens collection\n    // Returns an object containing requestToken and requestTokenSecret properties\n    //\n    // @param key {string}\n    //\n    OAuth._retrieveRequestToken = async key => {\n      check(key, String);\n      const pendingRequestToken = await OAuth._pendingRequestTokens.findOneAsync({\n        key: key\n      });\n      if (pendingRequestToken) {\n        await OAuth._pendingRequestTokens.removeAsync({\n          _id: pendingRequestToken._id\n        });\n        return {\n          requestToken: OAuth.openSecret(pendingRequestToken.requestToken),\n          requestTokenSecret: OAuth.openSecret(pendingRequestToken.requestTokenSecret)\n        };\n      } else {\n        return undefined;\n      }\n    };\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: true\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\n\n/* Exports */\nreturn {\n  export: function () { return {\n      OAuth1Binding: OAuth1Binding,\n      OAuth1Test: OAuth1Test\n    };},\n  require: require,\n  eagerModulePaths: [\n    \"/node_modules/meteor/oauth1/oauth1_binding.js\",\n    \"/node_modules/meteor/oauth1/oauth1_server.js\",\n    \"/node_modules/meteor/oauth1/oauth1_pending_request_tokens.js\"\n  ]\n}});\n","servePath":"/packages/oauth1.js","sourceMap":{"version":3,"sources":["packages/oauth1/oauth1_binding.js","packages/oauth1/oauth1_server.js","packages/oauth1/oauth1_pending_request_tokens.js"],"names":["_objectSpread","module","link","default","v","export","OAuth1Binding","crypto","querystring","urlModule","__reifyWaitForDeps__","constructor","config","urls","_config","_urls","prepareRequestToken","callbackUrl","headers","_buildHeader","oauth_callback","response","_call","method","url","requestToken","tokens","parse","content","oauth_callback_confirmed","Object","assign","Error","oauth_token","requestTokenSecret","oauth_token_secret","prepareAccessToken","query","accessTokenSecret","oauth_verifier","accessToken","error","callAsync","params","callback","getAsync","postAsync","get","call","post","oauth_consumer_key","consumerKey","oauth_nonce","Random","secret","replace","oauth_signature_method","oauth_timestamp","Date","valueOf","toFixed","toString","oauth_version","_getSignature","rawHeaders","_encodeHeader","parameters","keys","map","key","concat","sort","join","signatureBase","_encodeString","OAuth","openSecret","signingKey","createHmac","update","digest","_ref","parsedUrl","search","format","oauth_signature","authString","_getAuthHeaderString","_fetch","Authorization","toUpperCase","body","_addValuesToQueryParams","queryParams","then","res","text","responseHeaders","Array","from","entries","reduce","acc","_ref2","val","toLowerCase","data","includes","JSON","undefined","nonce","redirected","ok","statusCode","status","catch","err","console","log","message","header","memo","str","encodeURIComponent","escape","__reify_async_result__","_reifyError","self","async","module1","_queryParamsWithAuthTokenUrl","authUrl","oauthBinding","arguments","length","whitelistedQueryParams","redirectUrlObj","prev","param","_requestHandlers","service","ServiceConfiguration","configurations","findOneAsync","serviceName","ConfigError","credentialSecret","requestTokenAndRedirect","_redirectUri","state","cordova","android","_storeRequestToken","_credentialTokenFromQuery","redirectUrl","authParams","authenticate","writeHead","end","requestTokenInfo","_retrieveRequestToken","oauthResult","handleOauthRequest","credentialToken","_storePendingCredential","serviceData","options","_renderOauthResults","_pendingRequestTokens","Mongo","Collection","_preventAutopublish","createIndexAsync","unique","_cleanStaleResults","timeCutoff","setMinutes","getMinutes","removeAsync","createdAt","$lt","_cleanupHandle","Meteor","setInterval","check","String","upsertAsync","sealSecret","pendingRequestToken","_id"],"mappings":"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","file":"/packages/oauth1.js","sourcesContent":["import crypto from 'crypto';\nimport querystring from 'querystring';\nimport urlModule from 'url';\n\n// An OAuth1 wrapper around http calls which helps get tokens and\n// takes care of HTTP headers\n//\n// @param config {Object}\n//   - consumerKey (String): oauth consumer key\n//   - secret (String): oauth consumer secret\n// @param urls {Object}\n//   - requestToken (String): url\n//   - authorize (String): url\n//   - accessToken (String): url\n//   - authenticate (String): url\nexport class OAuth1Binding {\n  constructor(config, urls) {\n    this._config = config;\n    this._urls = urls;\n  }\n\n  async prepareRequestToken(callbackUrl) {\n    const headers = this._buildHeader({\n      oauth_callback: callbackUrl\n    });\n\n    const response = await this._call({method: 'POST', url: this._urls.requestToken, headers});\n    const tokens = querystring.parse(response.content);\n\n    if (! tokens.oauth_callback_confirmed)\n      throw Object.assign(new Error(\"oauth_callback_confirmed false when requesting oauth1 token\"),\n                               {response: response});\n\n    this.requestToken = tokens.oauth_token;\n    this.requestTokenSecret = tokens.oauth_token_secret;\n  }\n\n  async prepareAccessToken(query, requestTokenSecret) {\n    // support implementations that use request token secrets. This is\n    // read by this._call.\n    //\n    // XXX make it a param to call, not something stashed on self? It's\n    // kinda confusing right now, everything except this is passed as\n    // arguments, but this is stored.\n    if (requestTokenSecret)\n      this.accessTokenSecret = requestTokenSecret;\n\n    const headers = this._buildHeader({\n      oauth_token: query.oauth_token,\n      oauth_verifier: query.oauth_verifier\n    });\n\n    const response = await this._call({ method: 'POST', url: this._urls.accessToken, headers });\n    const tokens = querystring.parse(response.content);\n\n    if (! tokens.oauth_token || ! tokens.oauth_token_secret) {\n      const error = new Error(\"missing oauth token or secret\");\n      // We provide response only if no token is available, we do not want to leak any tokens\n      if (! tokens.oauth_token && ! tokens.oauth_token_secret) {\n        Object.assign(error, {response: response});\n      }\n      throw error;\n    }\n\n    this.accessToken = tokens.oauth_token;\n    this.accessTokenSecret = tokens.oauth_token_secret;\n  }\n\n  async callAsync(method, url, params, callback) {\n    const headers = this._buildHeader({\n      oauth_token: this.accessToken\n    });\n\n    if(! params) {\n      params = {};\n    }\n\n    return this._call({ method, url, headers, params, callback });\n  }\n\n  async getAsync(url, params, callback) {\n    return this.callAsync('GET', url, params, callback);\n  }\n\n  async postAsync(url, params, callback) {\n    return this.callAsync('POST', url, params, callback);\n  }\n\n  get(url, params, callback) {\n    // Require changes when remove Fibers. Exposed to public api.\n    return this.call('GET', url, params, callback);\n  }\n\n  post(url, params, callback) {\n    // Require changes when remove Fibers. Exposed to public api.\n    return this.call('POST', url, params, callback);\n  }\n\n  _buildHeader(headers) {\n    return {\n      oauth_consumer_key: this._config.consumerKey,\n      oauth_nonce: Random.secret().replace(/\\W/g, ''),\n      oauth_signature_method: 'HMAC-SHA1',\n      oauth_timestamp: (new Date().valueOf()/1000).toFixed().toString(),\n      oauth_version: '1.0',\n      ...headers,\n    }\n  }\n\n  _getSignature(method, url, rawHeaders, accessTokenSecret, params) {\n    const headers = this._encodeHeader({ ...rawHeaders, ...params });\n\n    const parameters = Object.keys(headers).map(key => `${key}=${headers[key]}`)\n      .sort().join('&');\n\n    const signatureBase = [\n      method,\n      this._encodeString(url),\n      this._encodeString(parameters)\n    ].join('&');\n\n    const secret = OAuth.openSecret(this._config.secret);\n\n    let signingKey = `${this._encodeString(secret)}&`;\n    if (accessTokenSecret)\n      signingKey += this._encodeString(accessTokenSecret);\n\n    return crypto.createHmac('SHA1', signingKey).update(signatureBase).digest('base64');\n  };\n\n  async _call({method, url, headers = {}, params = {}, callback}) {\n    // all URLs to be functions to support parameters/customization\n    if(typeof url === \"function\") {\n      url = url(this);\n    }\n\n    // Extract all query string parameters from the provided URL\n    const parsedUrl = urlModule.parse(url, true);\n    // Merge them in a way that params given to the method call have precedence\n    params = { ...parsedUrl.query, ...params };\n\n    // Reconstruct the URL back without any query string parameters\n    // (they are now in params)\n    parsedUrl.query = {};\n    parsedUrl.search = '';\n    url = urlModule.format(parsedUrl);\n\n    // Get the signature\n    headers.oauth_signature =\n      this._getSignature(method, url, headers, this.accessTokenSecret, params);\n\n    // Make a authorization string according to oauth1 spec\n    const authString = this._getAuthHeaderString(headers);\n    // Make signed request\n    return OAuth._fetch(url, method, {\n      headers: {\n        Authorization: authString,\n        ...(method.toUpperCase() === 'POST' ? { 'Content-Type': 'application/x-www-form-urlencoded' } : {})\n      },\n      ...(method.toUpperCase() === 'POST' ?\n        { body: OAuth._addValuesToQueryParams(params).toString() }\n        : { queryParams: params })\n    }).then((res) =>\n        res.text().then((content) => {\n          const responseHeaders = Array.from(res.headers.entries()).reduce(\n            (acc, [key, val]) => {\n              return { ...acc, [key.toLowerCase()]: val };\n            },\n            {}\n          );\n          const data = responseHeaders['content-type'].includes('application/json') ?\n            JSON.parse(content) : undefined;\n          return  {\n            content: data ? '' : content,\n            data,\n            headers: { ...responseHeaders, nonce: headers.oauth_nonce },\n            redirected: res.redirected,\n            ok: res.ok,\n            statusCode: res.status,\n          };\n        })\n      )\n      .then((response) => {\n        if (callback) {\n          callback(undefined, response);\n        }\n        return response;\n      })\n      .catch((err) => {\n        if (callback) {\n          callback(err);\n        }\n        console.log({ err });\n        throw Object.assign(\n          new Error(`Failed to send OAuth1 request to ${url}. ${err.message}`),\n          { response: err.response }\n        );\n      });\n  }\n\n  _encodeHeader(header) {\n    return Object.keys(header).reduce((memo, key) => {\n      memo[this._encodeString(key)] = this._encodeString(header[key]);\n      return memo;\n    }, {});\n  };\n\n  _encodeString(str) {\n    return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\n  };\n\n  _getAuthHeaderString(headers) {\n    return 'OAuth ' +  Object.keys(headers).map(key =>\n      `${this._encodeString(key)}=\"${this._encodeString(headers[key])}\"`\n    ).sort().join(', ');\n  };\n\n};\n","import url from 'url';\nimport { OAuth1Binding } from './oauth1_binding';\n\nOAuth._queryParamsWithAuthTokenUrl = (authUrl, oauthBinding, params = {}, whitelistedQueryParams = []) => {\n  const redirectUrlObj = url.parse(authUrl, true);\n\n  Object.assign(\n    redirectUrlObj.query,\n    whitelistedQueryParams.reduce((prev, param) =>\n      params.query[param] ? { ...prev, param: params.query[param] } : prev,\n      {}\n    ),\n    {\n      oauth_token: oauthBinding.requestToken,\n    }\n  );\n\n  // Clear the `search` so it is rebuilt by Node's `url` from the `query` above.\n  // Using previous versions of the Node `url` module, this was just set to \"\"\n  // However, Node 6 docs seem to indicate that this should be `undefined`.\n  delete redirectUrlObj.search;\n\n  // Reconstruct the URL back with provided query parameters merged with oauth_token\n  return url.format(redirectUrlObj);\n};\n\n// connect middleware\nOAuth._requestHandlers['1'] = async (service, query, res) => {\n  const config = await ServiceConfiguration.configurations.findOneAsync({service: service.serviceName});\n  if (! config) {\n    throw new ServiceConfiguration.ConfigError(service.serviceName);\n  }\n\n  const { urls } = service;\n  const oauthBinding = new OAuth1Binding(config, urls);\n\n  let credentialSecret;\n\n  if (query.requestTokenAndRedirect) {\n    // step 1 - get and store a request token\n    const callbackUrl = OAuth._redirectUri(service.serviceName, config, {\n      state: query.state,\n      cordova: (query.cordova === \"true\"),\n      android: (query.android === \"true\")\n    });\n\n    // Get a request token to start auth process\n    await oauthBinding.prepareRequestToken(callbackUrl);\n\n    // Keep track of request token so we can verify it on the next step\n    await OAuth._storeRequestToken(\n      OAuth._credentialTokenFromQuery(query),\n      oauthBinding.requestToken,\n      oauthBinding.requestTokenSecret);\n\n    // support for scope/name parameters\n    let redirectUrl;\n    const authParams = { query };\n\n    if(typeof urls.authenticate === \"function\") {\n      redirectUrl = urls.authenticate(oauthBinding, authParams);\n    } else {\n      redirectUrl = OAuth._queryParamsWithAuthTokenUrl(\n        urls.authenticate,\n        oauthBinding,\n        authParams\n      );\n    }\n\n    // redirect to provider login, which will redirect back to \"step 2\" below\n\n    res.writeHead(302, {'Location': redirectUrl});\n    res.end();\n  } else {\n    // step 2, redirected from provider login - store the result\n    // and close the window to allow the login handler to proceed\n\n    // Get the user's request token so we can verify it and clear it\n    const requestTokenInfo = await OAuth._retrieveRequestToken(\n      OAuth._credentialTokenFromQuery(query));\n\n    if (! requestTokenInfo) {\n      throw new Error(\"Unable to retrieve request token\");\n    }\n\n    // Verify user authorized access and the oauth_token matches\n    // the requestToken from previous step\n    if (query.oauth_token && query.oauth_token === requestTokenInfo.requestToken) {\n\n      // Prepare the login results before returning.  This way the\n      // subsequent call to the `login` method will be immediate.\n\n      // Get the access token for signing requests\n      await oauthBinding.prepareAccessToken(query, requestTokenInfo.requestTokenSecret);\n\n      // Run service-specific handler.\n      const oauthResult = await service.handleOauthRequest(\n        oauthBinding, { query: query });\n\n      const credentialToken = OAuth._credentialTokenFromQuery(query);\n      credentialSecret = Random.secret();\n\n      // Store the login result so it can be retrieved in another\n      // browser tab by the result handler\n      await OAuth._storePendingCredential(credentialToken, {\n        serviceName: service.serviceName,\n        serviceData: oauthResult.serviceData,\n        options: oauthResult.options\n      }, credentialSecret);\n    }\n\n    // Either close the window, redirect, or render nothing\n    // if all else fails\n    await OAuth._renderOauthResults(res, query, credentialSecret);\n  }\n};\n","//\n// _pendingRequestTokens are request tokens that have been received\n// but not yet fully authorized (processed).\n//\n// During the oauth1 authorization process, the Meteor App opens\n// a pop-up, requests a request token from the oauth1 service, and\n// redirects the browser to the oauth1 service for the user\n// to grant authorization.  The user is then returned to the\n// Meteor Apps' callback url and the request token is verified.\n//\n// When Meteor Apps run on multiple servers, it's possible that\n// 2 different servers may be used to generate the request token\n// and to verify it in the callback once the user has authorized.\n//\n// For this reason, the _pendingRequestTokens are stored in the database\n// so they can be shared across Meteor App servers.\n//\n// XXX This code is fairly similar to oauth/pending_credentials.js --\n// maybe we can combine them somehow.\n\n// Collection containing pending request tokens\n// Has key, requestToken, requestTokenSecret, and createdAt fields.\nOAuth._pendingRequestTokens = new Mongo.Collection(\n  \"meteor_oauth_pendingRequestTokens\", {\n    _preventAutopublish: true\n  });\n\nawait OAuth._pendingRequestTokens.createIndexAsync('key', { unique: true });\nawait OAuth._pendingRequestTokens.createIndexAsync('createdAt');\n\n\n\n// Periodically clear old entries that never got completed\nconst _cleanStaleResults = async () => {\n  // Remove request tokens older than 5 minute\n  const timeCutoff = new Date();\n  timeCutoff.setMinutes(timeCutoff.getMinutes() - 5);\n  await OAuth._pendingRequestTokens.removeAsync({ createdAt: { $lt: timeCutoff } });\n};\nconst _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000);\n\n\n// Stores the key and request token in the _pendingRequestTokens collection.\n// Will throw an exception if `key` is not a string.\n//\n// @param key {string}\n// @param requestToken {string}\n// @param requestTokenSecret {string}\n//\nOAuth._storeRequestToken = async (key, requestToken, requestTokenSecret) => {\n  check(key, String);\n\n  // We do an upsert here instead of an insert in case the user happens\n  // to somehow send the same `state` parameter twice during an OAuth\n  // login; we don't want a duplicate key error.\n  await OAuth._pendingRequestTokens.upsertAsync({\n    key,\n  }, {\n    key,\n    requestToken: OAuth.sealSecret(requestToken),\n    requestTokenSecret: OAuth.sealSecret(requestTokenSecret),\n    createdAt: new Date()\n  });\n};\n\n\n// Retrieves and removes a request token from the _pendingRequestTokens collection\n// Returns an object containing requestToken and requestTokenSecret properties\n//\n// @param key {string}\n//\nOAuth._retrieveRequestToken = async key => {\n  check(key, String);\n\n  const pendingRequestToken =  await OAuth._pendingRequestTokens.findOneAsync({ key: key });\n  if (pendingRequestToken) {\n    await OAuth._pendingRequestTokens.removeAsync({ _id: pendingRequestToken._id });\n    return {\n      requestToken: OAuth.openSecret(pendingRequestToken.requestToken),\n      requestTokenSecret: OAuth.openSecret(\n        pendingRequestToken.requestTokenSecret)\n    };\n  } else {\n    return undefined;\n  }\n};\n"]}}]