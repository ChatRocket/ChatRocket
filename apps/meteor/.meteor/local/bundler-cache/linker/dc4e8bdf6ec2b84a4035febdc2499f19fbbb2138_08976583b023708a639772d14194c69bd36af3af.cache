[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\nPackage[\"core-runtime\"].queue(\"rate-limit\",function () {/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Random = Package.random.Random;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package.modules.meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\nvar Symbol = Package['ecmascript-runtime-client'].Symbol;\nvar Map = Package['ecmascript-runtime-client'].Map;\nvar Set = Package['ecmascript-runtime-client'].Set;\n\n/* Package-scope variables */\nvar RateLimiter;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"rate-limit\":{\"rate-limit.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/rate-limit/rate-limit.js                                                                          //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\nvar _slicedToArray;\nmodule.link(\"@babel/runtime/helpers/slicedToArray\", {\n  default: function (v) {\n    _slicedToArray = v;\n  }\n}, 0);\nmodule.export({\n  RateLimiter: function () {\n    return RateLimiter;\n  }\n});\nvar Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\nvar Random;\nmodule.link(\"meteor/random\", {\n  Random: function (v) {\n    Random = v;\n  }\n}, 1);\n// Default time interval (in milliseconds) to reset rate limit counters\nvar DEFAULT_INTERVAL_TIME_IN_MILLISECONDS = 1000;\n// Default number of events allowed per time interval\nvar DEFAULT_REQUESTS_PER_INTERVAL = 10;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n// A rule is defined by an options object that contains two fields,\n// `numRequestsAllowed` which is the number of events allowed per interval, and\n// an `intervalTime` which is the amount of time in milliseconds before the\n// rate limit restarts its internal counters, and by a matchers object. A\n// matchers object is a POJO that contains a set of keys with values that\n// define the entire set of inputs that match for each key. The values can\n// either be null (optional), a primitive or a function that returns a boolean\n// of whether the provided input's value matches for this key.\n//\n// Rules are uniquely assigned an `id` and they store a dictionary of counters,\n// which are records used to keep track of inputs that match the rule. If a\n// counter reaches the `numRequestsAllowed` within a given `intervalTime`, a\n// rate limit is reached and future inputs that map to that counter will\n// result in errors being returned to the client.\nvar Rule = /*#__PURE__*/function () {\n  function Rule(options, matchers) {\n    this.id = Random.id();\n    this.options = options;\n    this._matchers = matchers;\n    this._lastResetTime = new Date().getTime();\n\n    // Dictionary of input keys to counters\n    this.counters = {};\n  }\n  // Determine if this rule applies to the given input by comparing all\n  // rule.matchers. If the match fails, search short circuits instead of\n  // iterating through all matchers.\n  var _proto = Rule.prototype;\n  _proto.match = function () {\n    function match(input) {\n      return Object.entries(this._matchers).every(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          matcher = _ref2[1];\n        if (matcher !== null) {\n          if (!hasOwn.call(input, key)) {\n            return false;\n          } else if (typeof matcher === 'function') {\n            if (!matcher(input[key])) {\n              return false;\n            }\n          } else if (matcher !== input[key]) {\n            return false;\n          }\n        }\n        return true;\n      });\n    }\n    return match;\n  }() // Generates unique key string for provided input by concatenating all the\n  // keys in the matcher with the corresponding values in the input.\n  // Only called if rule matches input.\n  ;\n  _proto._generateKeyString = function () {\n    function _generateKeyString(input) {\n      var _this = this;\n      return Object.entries(this._matchers).filter(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n          key = _ref4[0];\n        return _this._matchers[key] !== null;\n      }).reduce(function (returnString, _ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n          key = _ref6[0],\n          matcher = _ref6[1];\n        if (typeof matcher === 'function') {\n          if (matcher(input[key])) {\n            returnString += key + input[key];\n          }\n        } else {\n          returnString += key + input[key];\n        }\n        return returnString;\n      }, '');\n    }\n    return _generateKeyString;\n  }() // Applies the provided input and returns the key string, time since counters\n  // were last reset and time to next reset.\n  ;\n  _proto.apply = function () {\n    function apply(input) {\n      var key = this._generateKeyString(input);\n      var timeSinceLastReset = new Date().getTime() - this._lastResetTime;\n      var timeToNextReset = this.options.intervalTime - timeSinceLastReset;\n      return {\n        key: key,\n        timeSinceLastReset: timeSinceLastReset,\n        timeToNextReset: timeToNextReset\n      };\n    }\n    return apply;\n  }() // Reset counter dictionary for this specific rule. Called once the\n  // timeSinceLastReset has exceeded the intervalTime. _lastResetTime is\n  // set to be the current time in milliseconds.\n  ;\n  _proto.resetCounter = function () {\n    function resetCounter() {\n      // Delete the old counters dictionary to allow for garbage collection\n      this.counters = {};\n      this._lastResetTime = new Date().getTime();\n    }\n    return resetCounter;\n  }();\n  _proto._executeCallback = function () {\n    function _executeCallback(reply, ruleInput) {\n      try {\n        if (this.options.callback) {\n          this.options.callback(reply, ruleInput);\n        }\n      } catch (e) {\n        // Do not throw error here\n        console.error(e);\n      }\n    }\n    return _executeCallback;\n  }();\n  return Rule;\n}();\nvar RateLimiter = /*#__PURE__*/function () {\n  // Initialize rules to be an empty dictionary.\n  function RateLimiter() {\n    // Dictionary of all rules associated with this RateLimiter, keyed by their\n    // id. Each rule object stores the rule pattern, number of events allowed,\n    // last reset time and the rule reset interval in milliseconds.\n\n    this.rules = {};\n  }\n\n  /**\n  * Checks if this input has exceeded any rate limits.\n  * @param  {object} input dictionary containing key-value pairs of attributes\n  * that match to rules\n  * @return {object} Returns object of following structure\n  * { 'allowed': boolean - is this input allowed\n  *   'timeToReset': integer | Infinity - returns time until counters are reset\n  *                   in milliseconds\n  *   'numInvocationsLeft': integer | Infinity - returns number of calls left\n  *   before limit is reached\n  * }\n  * If multiple rules match, the least number of invocations left is returned.\n  * If the rate limit has been reached, the longest timeToReset is returned.\n  */\n  var _proto2 = RateLimiter.prototype;\n  _proto2.check = function () {\n    function check(input) {\n      var reply = {\n        allowed: true,\n        timeToReset: 0,\n        numInvocationsLeft: Infinity\n      };\n      var matchedRules = this._findAllMatchingRules(input);\n      matchedRules.forEach(function (rule) {\n        var ruleResult = rule.apply(input);\n        var numInvocations = rule.counters[ruleResult.key];\n        if (ruleResult.timeToNextReset < 0) {\n          // Reset all the counters since the rule has reset\n          rule.resetCounter();\n          ruleResult.timeSinceLastReset = new Date().getTime() - rule._lastResetTime;\n          ruleResult.timeToNextReset = rule.options.intervalTime;\n          numInvocations = 0;\n        }\n        if (numInvocations > rule.options.numRequestsAllowed) {\n          // Only update timeToReset if the new time would be longer than the\n          // previously set time. This is to ensure that if this input triggers\n          // multiple rules, we return the longest period of time until they can\n          // successfully make another call\n          if (reply.timeToReset < ruleResult.timeToNextReset) {\n            reply.timeToReset = ruleResult.timeToNextReset;\n          }\n          reply.allowed = false;\n          reply.numInvocationsLeft = 0;\n          reply.ruleId = rule.id;\n          rule._executeCallback(reply, input);\n        } else {\n          // If this is an allowed attempt and we haven't failed on any of the\n          // other rules that match, update the reply field.\n          if (rule.options.numRequestsAllowed - numInvocations < reply.numInvocationsLeft && reply.allowed) {\n            reply.timeToReset = ruleResult.timeToNextReset;\n            reply.numInvocationsLeft = rule.options.numRequestsAllowed - numInvocations;\n          }\n          reply.ruleId = rule.id;\n          rule._executeCallback(reply, input);\n        }\n      });\n      return reply;\n    }\n    return check;\n  }()\n  /**\n  * Adds a rule to dictionary of rules that are checked against on every call.\n  * Only inputs that pass all of the rules will be allowed. Returns unique rule\n  * id that can be passed to `removeRule`.\n  * @param {object} rule    Input dictionary defining certain attributes and\n  * rules associated with them.\n  * Each attribute's value can either be a value, a function or null. All\n  * functions must return a boolean of whether the input is matched by that\n  * attribute's rule or not\n  * @param {integer} numRequestsAllowed Optional. Number of events allowed per\n  * interval. Default = 10.\n  * @param {integer} intervalTime Optional. Number of milliseconds before\n  * rule's counters are reset. Default = 1000.\n  * @param {function} callback Optional. Function to be called after a\n  * rule is executed. Two objects will be passed to this function.\n  * The first one is the result of RateLimiter.prototype.check\n  * The second is the input object of the rule, it has the following structure:\n  * {\n  *   'type': string - either 'method' or 'subscription'\n  *   'name': string - the name of the method or subscription being called\n  *   'userId': string - the user ID attempting the method or subscription\n  *   'connectionId': string - a string representing the user's DDP connection\n  *   'clientAddress': string - the IP address of the user\n  * }\n  * @return {string} Returns unique rule id\n  */\n  ;\n  _proto2.addRule = function () {\n    function addRule(rule, numRequestsAllowed, intervalTime, callback) {\n      var options = {\n        numRequestsAllowed: numRequestsAllowed || DEFAULT_REQUESTS_PER_INTERVAL,\n        intervalTime: intervalTime || DEFAULT_INTERVAL_TIME_IN_MILLISECONDS,\n        callback: callback && Meteor.bindEnvironment(callback)\n      };\n      var newRule = new Rule(options, rule);\n      this.rules[newRule.id] = newRule;\n      return newRule.id;\n    }\n    return addRule;\n  }()\n  /**\n  * Increment counters in every rule that match to this input\n  * @param  {object} input Dictionary object containing attributes that may\n  * match to rules\n  */\n  ;\n  _proto2.increment = function () {\n    function increment(input) {\n      // Only increment rule counters that match this input\n      var matchedRules = this._findAllMatchingRules(input);\n      matchedRules.forEach(function (rule) {\n        var ruleResult = rule.apply(input);\n        if (ruleResult.timeSinceLastReset > rule.options.intervalTime) {\n          // Reset all the counters since the rule has reset\n          rule.resetCounter();\n        }\n\n        // Check whether the key exists, incrementing it if so or otherwise\n        // adding the key and setting its value to 1\n        if (hasOwn.call(rule.counters, ruleResult.key)) {\n          rule.counters[ruleResult.key]++;\n        } else {\n          rule.counters[ruleResult.key] = 1;\n        }\n      });\n    }\n    return increment;\n  }() // Returns an array of all rules that apply to provided input\n  ;\n  _proto2._findAllMatchingRules = function () {\n    function _findAllMatchingRules(input) {\n      return Object.values(this.rules).filter(function (rule) {\n        return rule.match(input);\n      });\n    }\n    return _findAllMatchingRules;\n  }()\n  /**\n   * Provides a mechanism to remove rules from the rate limiter. Returns boolean\n   * about success.\n   * @param  {string} id Rule id returned from #addRule\n   * @return {boolean} Returns true if rule was found and deleted, else false.\n   */\n  ;\n  _proto2.removeRule = function () {\n    function removeRule(id) {\n      if (this.rules[id]) {\n        delete this.rules[id];\n        return true;\n      }\n      return false;\n    }\n    return removeRule;\n  }();\n  return RateLimiter;\n}();\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\n\n/* Exports */\nreturn {\n  export: function () { return {\n      RateLimiter: RateLimiter\n    };},\n  require: require,\n  eagerModulePaths: [\n    \"/node_modules/meteor/rate-limit/rate-limit.js\"\n  ],\n  mainModulePath: \"/node_modules/meteor/rate-limit/rate-limit.js\"\n}});\n","servePath":"/packages/rate-limit.js","sourceMap":{"version":3,"sources":["packages/rate-limit/rate-limit.js"],"names":["_slicedToArray","module","link","default","v","export","RateLimiter","Meteor","Random","DEFAULT_INTERVAL_TIME_IN_MILLISECONDS","DEFAULT_REQUESTS_PER_INTERVAL","hasOwn","Object","prototype","hasOwnProperty","Rule","options","matchers","id","_matchers","_lastResetTime","Date","getTime","counters","_proto","match","input","entries","every","_ref","_ref2","key","matcher","call","_generateKeyString","_this","filter","_ref3","_ref4","reduce","returnString","_ref5","_ref6","apply","timeSinceLastReset","timeToNextReset","intervalTime","resetCounter","_executeCallback","reply","ruleInput","callback","e","console","error","rules","_proto2","check","allowed","timeToReset","numInvocationsLeft","Infinity","matchedRules","_findAllMatchingRules","forEach","rule","ruleResult","numInvocations","numRequestsAllowed","ruleId","addRule","bindEnvironment","newRule","increment","values","removeRule"],"mappings":"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","file":"/packages/rate-limit.js","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { Random } from 'meteor/random';\n\n// Default time interval (in milliseconds) to reset rate limit counters\nconst DEFAULT_INTERVAL_TIME_IN_MILLISECONDS = 1000;\n// Default number of events allowed per time interval\nconst DEFAULT_REQUESTS_PER_INTERVAL = 10;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// A rule is defined by an options object that contains two fields,\n// `numRequestsAllowed` which is the number of events allowed per interval, and\n// an `intervalTime` which is the amount of time in milliseconds before the\n// rate limit restarts its internal counters, and by a matchers object. A\n// matchers object is a POJO that contains a set of keys with values that\n// define the entire set of inputs that match for each key. The values can\n// either be null (optional), a primitive or a function that returns a boolean\n// of whether the provided input's value matches for this key.\n//\n// Rules are uniquely assigned an `id` and they store a dictionary of counters,\n// which are records used to keep track of inputs that match the rule. If a\n// counter reaches the `numRequestsAllowed` within a given `intervalTime`, a\n// rate limit is reached and future inputs that map to that counter will\n// result in errors being returned to the client.\nclass Rule {\n  constructor(options, matchers) {\n    this.id = Random.id();\n\n    this.options = options;\n\n    this._matchers = matchers;\n\n    this._lastResetTime = new Date().getTime();\n\n    // Dictionary of input keys to counters\n    this.counters = {};\n  }\n  // Determine if this rule applies to the given input by comparing all\n  // rule.matchers. If the match fails, search short circuits instead of\n  // iterating through all matchers.\n  match(input) {\n    return Object\n      .entries(this._matchers)\n      .every(([key, matcher]) => {\n        if (matcher !== null) {\n          if (!hasOwn.call(input, key)) {\n            return false;\n          } else if (typeof matcher === 'function') {\n            if (!(matcher(input[key]))) {\n              return false;\n            }\n          } else if (matcher !== input[key]) {\n            return false;\n          }\n        }\n        return true;\n      });\n  }\n\n  // Generates unique key string for provided input by concatenating all the\n  // keys in the matcher with the corresponding values in the input.\n  // Only called if rule matches input.\n  _generateKeyString(input) {\n    return Object.entries(this._matchers)\n      .filter(([key]) => this._matchers[key] !== null)\n      .reduce((returnString, [key, matcher]) => {\n        if (typeof matcher === 'function') {\n          if (matcher(input[key])) {\n            returnString += key + input[key];\n          }\n        } else {\n          returnString += key + input[key];\n        }\n        return returnString;\n      }, '');\n  }\n\n  // Applies the provided input and returns the key string, time since counters\n  // were last reset and time to next reset.\n  apply(input) {\n    const key = this._generateKeyString(input);\n    const timeSinceLastReset = new Date().getTime() - this._lastResetTime;\n    const timeToNextReset = this.options.intervalTime - timeSinceLastReset;\n    return {\n      key,\n      timeSinceLastReset,\n      timeToNextReset,\n    };\n  }\n\n  // Reset counter dictionary for this specific rule. Called once the\n  // timeSinceLastReset has exceeded the intervalTime. _lastResetTime is\n  // set to be the current time in milliseconds.\n  resetCounter() {\n    // Delete the old counters dictionary to allow for garbage collection\n    this.counters = {};\n    this._lastResetTime = new Date().getTime();\n  }\n\n  _executeCallback(reply, ruleInput) {\n    try {\n      if (this.options.callback) {\n        this.options.callback(reply, ruleInput);\n      }\n    } catch (e) {\n      // Do not throw error here\n      console.error(e);\n    }\n  }\n}\n\nclass RateLimiter {\n  // Initialize rules to be an empty dictionary.\n  constructor() {\n    // Dictionary of all rules associated with this RateLimiter, keyed by their\n    // id. Each rule object stores the rule pattern, number of events allowed,\n    // last reset time and the rule reset interval in milliseconds.\n\n    this.rules = {};\n  }\n\n  /**\n  * Checks if this input has exceeded any rate limits.\n  * @param  {object} input dictionary containing key-value pairs of attributes\n  * that match to rules\n  * @return {object} Returns object of following structure\n  * { 'allowed': boolean - is this input allowed\n  *   'timeToReset': integer | Infinity - returns time until counters are reset\n  *                   in milliseconds\n  *   'numInvocationsLeft': integer | Infinity - returns number of calls left\n  *   before limit is reached\n  * }\n  * If multiple rules match, the least number of invocations left is returned.\n  * If the rate limit has been reached, the longest timeToReset is returned.\n  */\n  check(input) {\n    const reply = {\n      allowed: true,\n      timeToReset: 0,\n      numInvocationsLeft: Infinity,\n    };\n\n    const matchedRules = this._findAllMatchingRules(input);\n    matchedRules.forEach((rule) => {\n      const ruleResult = rule.apply(input);\n      let numInvocations = rule.counters[ruleResult.key];\n\n      if (ruleResult.timeToNextReset < 0) {\n        // Reset all the counters since the rule has reset\n        rule.resetCounter();\n        ruleResult.timeSinceLastReset = new Date().getTime() -\n          rule._lastResetTime;\n        ruleResult.timeToNextReset = rule.options.intervalTime;\n        numInvocations = 0;\n      }\n\n      if (numInvocations > rule.options.numRequestsAllowed) {\n        // Only update timeToReset if the new time would be longer than the\n        // previously set time. This is to ensure that if this input triggers\n        // multiple rules, we return the longest period of time until they can\n        // successfully make another call\n        if (reply.timeToReset < ruleResult.timeToNextReset) {\n          reply.timeToReset = ruleResult.timeToNextReset;\n        }\n        reply.allowed = false;\n        reply.numInvocationsLeft = 0;\n        reply.ruleId = rule.id;\n        rule._executeCallback(reply, input);\n      } else {\n        // If this is an allowed attempt and we haven't failed on any of the\n        // other rules that match, update the reply field.\n        if (rule.options.numRequestsAllowed - numInvocations <\n          reply.numInvocationsLeft && reply.allowed) {\n          reply.timeToReset = ruleResult.timeToNextReset;\n          reply.numInvocationsLeft = rule.options.numRequestsAllowed -\n            numInvocations;\n        }\n        reply.ruleId = rule.id;\n        rule._executeCallback(reply, input);\n      }\n    });\n    return reply;\n  }\n\n  /**\n  * Adds a rule to dictionary of rules that are checked against on every call.\n  * Only inputs that pass all of the rules will be allowed. Returns unique rule\n  * id that can be passed to `removeRule`.\n  * @param {object} rule    Input dictionary defining certain attributes and\n  * rules associated with them.\n  * Each attribute's value can either be a value, a function or null. All\n  * functions must return a boolean of whether the input is matched by that\n  * attribute's rule or not\n  * @param {integer} numRequestsAllowed Optional. Number of events allowed per\n  * interval. Default = 10.\n  * @param {integer} intervalTime Optional. Number of milliseconds before\n  * rule's counters are reset. Default = 1000.\n  * @param {function} callback Optional. Function to be called after a\n  * rule is executed. Two objects will be passed to this function.\n  * The first one is the result of RateLimiter.prototype.check\n  * The second is the input object of the rule, it has the following structure:\n  * {\n  *   'type': string - either 'method' or 'subscription'\n  *   'name': string - the name of the method or subscription being called\n  *   'userId': string - the user ID attempting the method or subscription\n  *   'connectionId': string - a string representing the user's DDP connection\n  *   'clientAddress': string - the IP address of the user\n  * }\n  * @return {string} Returns unique rule id\n  */\n  addRule(rule, numRequestsAllowed, intervalTime, callback) {\n    const options = {\n      numRequestsAllowed: numRequestsAllowed || DEFAULT_REQUESTS_PER_INTERVAL,\n      intervalTime: intervalTime || DEFAULT_INTERVAL_TIME_IN_MILLISECONDS,\n      callback: callback && Meteor.bindEnvironment(callback),\n    };\n\n    const newRule = new Rule(options, rule);\n    this.rules[newRule.id] = newRule;\n    return newRule.id;\n  }\n\n  /**\n  * Increment counters in every rule that match to this input\n  * @param  {object} input Dictionary object containing attributes that may\n  * match to rules\n  */\n  increment(input) {\n    // Only increment rule counters that match this input\n    const matchedRules = this._findAllMatchingRules(input);\n    matchedRules.forEach((rule) => {\n      const ruleResult = rule.apply(input);\n\n      if (ruleResult.timeSinceLastReset > rule.options.intervalTime) {\n        // Reset all the counters since the rule has reset\n        rule.resetCounter();\n      }\n\n      // Check whether the key exists, incrementing it if so or otherwise\n      // adding the key and setting its value to 1\n      if (hasOwn.call(rule.counters, ruleResult.key)) {\n        rule.counters[ruleResult.key]++;\n      } else {\n        rule.counters[ruleResult.key] = 1;\n      }\n    });\n  }\n\n  // Returns an array of all rules that apply to provided input\n  _findAllMatchingRules(input) {\n    return Object.values(this.rules).filter(rule => rule.match(input));\n  }\n\n  /**\n   * Provides a mechanism to remove rules from the rate limiter. Returns boolean\n   * about success.\n   * @param  {string} id Rule id returned from #addRule\n   * @return {boolean} Returns true if rule was found and deleted, else false.\n   */\n  removeRule(id) {\n    if (this.rules[id]) {\n      delete this.rules[id];\n      return true;\n    }\n    return false;\n  }\n}\n\nexport { RateLimiter };\n"]}}]