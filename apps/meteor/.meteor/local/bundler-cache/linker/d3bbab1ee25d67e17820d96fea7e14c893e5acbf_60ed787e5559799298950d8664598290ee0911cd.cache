[{"type":"js","data":"Package[\"core-runtime\"].queue(\"service-configuration\",function () {/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar EmitterPromise = Package.meteor.EmitterPromise;\nvar Accounts = Package['accounts-base'].Accounts;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar ServiceConfiguration;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"service-configuration\":{\"service_configuration_common.js\":function module(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// packages/service-configuration/service_configuration_common.js                                         //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\nif (typeof ServiceConfiguration === 'undefined') {\n  ServiceConfiguration = {};\n}\n\n// Table containing documents with configuration options for each\n// login service\nServiceConfiguration.configurations = new Mongo.Collection('meteor_accounts_loginServiceConfiguration', {\n  _preventAutopublish: true,\n  connection: Meteor.isClient ? Accounts.connection : Meteor.connection\n});\n// Leave this collection open in insecure mode. In theory, someone could\n// hijack your oauth connect requests to a different endpoint or appId,\n// but you did ask for 'insecure'. The advantage is that it is much\n// easier to write a configuration wizard that works only in insecure\n// mode.\n\n// Thrown when trying to use a login service which is not configured\nServiceConfiguration.ConfigError = function (serviceName) {\n  if (Meteor.isClient && !Accounts.loginServicesConfigured()) {\n    this.message = 'Login service configuration not yet loaded';\n  } else if (serviceName) {\n    this.message = 'Service ' + serviceName + ' not configured';\n  } else {\n    this.message = 'Service not configured';\n  }\n};\nServiceConfiguration.ConfigError.prototype = new Error();\nServiceConfiguration.ConfigError.prototype.name = 'ServiceConfiguration.ConfigError';\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"service_configuration_server.js\":function module(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                        //\n// packages/service-configuration/service_configuration_server.js                                         //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                          //\n!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let Meteor;\n    module.link(\"meteor/meteor\", {\n      Meteor(v) {\n        Meteor = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    // Only one configuration should ever exist for each service.\n    // A unique index helps avoid various race conditions which could\n    // otherwise lead to an inconsistent database state (when there are multiple\n    // configurations for a single service, which configuration is correct?)\n    try {\n      ServiceConfiguration.configurations.createIndexAsync({\n        service: 1\n      }, {\n        unique: true\n      });\n    } catch (err) {\n      console.error('The service-configuration package persists configuration in the ' + 'meteor_accounts_loginServiceConfiguration collection in MongoDB. As ' + 'each service should have exactly one configuration, Meteor ' + 'automatically creates a MongoDB index with a unique constraint on the ' + ' meteor_accounts_loginServiceConfiguration collection. The ' + 'createIndex command which creates that index is failing.\\n\\n' + 'Meteor versions before 1.0.4 did not create this index. If you recently ' + 'upgraded and are seeing this error message for the first time, please ' + 'check your meteor_accounts_loginServiceConfiguration collection for ' + 'multiple configuration entries for the same service and delete ' + 'configuration entries until there is no more than one configuration ' + 'entry per service.\\n\\n' + 'If the meteor_accounts_loginServiceConfiguration collection looks ' + 'fine, the createIndex command is failing for some other reason.\\n\\n' + 'For more information on this history of this issue, please see ' + 'https://github.com/meteor/meteor/pull/3514.\\n');\n      throw err;\n    }\n    Meteor.startup(() => {\n      var _Meteor$settings, _Meteor$settings$pack;\n      const settings = (_Meteor$settings = Meteor.settings) === null || _Meteor$settings === void 0 ? void 0 : (_Meteor$settings$pack = _Meteor$settings.packages) === null || _Meteor$settings$pack === void 0 ? void 0 : _Meteor$settings$pack['service-configuration'];\n      if (!settings) return;\n      for (const key of Object.keys(settings)) {\n        ServiceConfiguration.configurations.upsertAsync({\n          service: key\n        }, {\n          $set: settings[key]\n        });\n      }\n    });\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\n\n/* Exports */\nreturn {\n  export: function () { return {\n      ServiceConfiguration: ServiceConfiguration\n    };},\n  require: require,\n  eagerModulePaths: [\n    \"/node_modules/meteor/service-configuration/service_configuration_common.js\",\n    \"/node_modules/meteor/service-configuration/service_configuration_server.js\"\n  ]\n}});\n","servePath":"/packages/service-configuration.js","sourceMap":{"version":3,"sources":["packages/service-configuration/service_configuration_common.js","packages/service-configuration/service_configuration_server.js"],"names":["ServiceConfiguration","configurations","Mongo","Collection","_preventAutopublish","connection","Meteor","isClient","Accounts","ConfigError","serviceName","loginServicesConfigured","message","prototype","Error","name","module","link","v","__reifyWaitForDeps__","createIndexAsync","service","unique","err","console","error","startup","_Meteor$settings","_Meteor$settings$pack","settings","packages","key","Object","keys","upsertAsync","$set","__reify_async_result__","_reifyError","self","async"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAI,OAAOA,oBAAoB,KAAK,WAAW,EAAE;EAC/CA,oBAAoB,GAAG,CAAC,CAAC;AAC3B;;AAEA;AACA;AACAA,oBAAoB,CAACC,cAAc,GAAG,IAAIC,KAAK,CAACC,UAAU,CACxD,2CAA2C,EAC3C;EACEC,mBAAmB,EAAE,IAAI;EACzBC,UAAU,EAAEC,MAAM,CAACC,QAAQ,GAAGC,QAAQ,CAACH,UAAU,GAAGC,MAAM,CAACD;AAC7D,CACF,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACAL,oBAAoB,CAACS,WAAW,GAAG,UAASC,WAAW,EAAE;EACvD,IAAIJ,MAAM,CAACC,QAAQ,IAAI,CAACC,QAAQ,CAACG,uBAAuB,CAAC,CAAC,EAAE;IAC1D,IAAI,CAACC,OAAO,GAAG,4CAA4C;EAC7D,CAAC,MAAM,IAAIF,WAAW,EAAE;IACtB,IAAI,CAACE,OAAO,GAAG,UAAU,GAAGF,WAAW,GAAG,iBAAiB;EAC7D,CAAC,MAAM;IACL,IAAI,CAACE,OAAO,GAAG,wBAAwB;EACzC;AACF,CAAC;AACDZ,oBAAoB,CAACS,WAAW,CAACI,SAAS,GAAG,IAAIC,KAAK,CAAC,CAAC;AACxDd,oBAAoB,CAACS,WAAW,CAACI,SAAS,CAACE,IAAI,GAC7C,kCAAkC,C;;;;;;;;;;;;;;IC/BpC,IAAIT,MAAM;IAACU,MAAM,CAACC,IAAI,CAAC,eAAe,EAAC;MAACX,MAAMA,CAACY,CAAC,EAAC;QAACZ,MAAM,GAACY,CAAC;MAAA;IAAC,CAAC,EAAC,CAAC,CAAC;IAAC,IAAIC,oBAAoB,CAAC,CAAC,EAAE,CAAC,MAAMA,oBAAoB,CAAC,CAAC,EAAE,CAAC;IAE5H;IACA;IACA;IACA;IACA,IAAI;MACFnB,oBAAoB,CAACC,cAAc,CAACmB,gBAAgB,CAClD;QAAEC,OAAO,EAAE;MAAE,CAAC,EACd;QAAEC,MAAM,EAAE;MAAK,CACjB,CAAC;IACH,CAAC,CAAC,OAAOC,GAAG,EAAE;MACZC,OAAO,CAACC,KAAK,CACX,kEAAkE,GAChE,sEAAsE,GACtE,6DAA6D,GAC7D,wEAAwE,GACxE,6DAA6D,GAC7D,8DAA8D,GAC9D,0EAA0E,GAC1E,wEAAwE,GACxE,sEAAsE,GACtE,iEAAiE,GACjE,sEAAsE,GACtE,wBAAwB,GACxB,oEAAoE,GACpE,qEAAqE,GACrE,iEAAiE,GACjE,+CACJ,CAAC;MACD,MAAMF,GAAG;IACX;IAEAjB,MAAM,CAACoB,OAAO,CAAC,MAAM;MAAA,IAAAC,gBAAA,EAAAC,qBAAA;MACnB,MAAMC,QAAQ,IAAAF,gBAAA,GAAGrB,MAAM,CAACuB,QAAQ,cAAAF,gBAAA,wBAAAC,qBAAA,GAAfD,gBAAA,CAAiBG,QAAQ,cAAAF,qBAAA,uBAAzBA,qBAAA,CAA4B,uBAAuB,CAAC;MACrE,IAAI,CAACC,QAAQ,EAAE;MACf,KAAK,MAAME,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACJ,QAAQ,CAAC,EAAE;QACvC7B,oBAAoB,CAACC,cAAc,CAACiC,WAAW,CAC7C;UAAEb,OAAO,EAAEU;QAAI,CAAC,EAChB;UACEI,IAAI,EAAEN,QAAQ,CAACE,GAAG;QACpB,CACF,CAAC;MACH;IACF,CAAC,CAAC;IAACK,sBAAA;EAAA,SAAAC,WAAA;IAAA,OAAAD,sBAAA,CAAAC,WAAA;EAAA;EAAAD,sBAAA;AAAA;EAAAE,IAAA;EAAAC,KAAA;AAAA,G","file":"/packages/service-configuration.js","sourcesContent":["if (typeof ServiceConfiguration === 'undefined') {\n  ServiceConfiguration = {};\n}\n\n// Table containing documents with configuration options for each\n// login service\nServiceConfiguration.configurations = new Mongo.Collection(\n  'meteor_accounts_loginServiceConfiguration',\n  {\n    _preventAutopublish: true,\n    connection: Meteor.isClient ? Accounts.connection : Meteor.connection,\n  }\n);\n// Leave this collection open in insecure mode. In theory, someone could\n// hijack your oauth connect requests to a different endpoint or appId,\n// but you did ask for 'insecure'. The advantage is that it is much\n// easier to write a configuration wizard that works only in insecure\n// mode.\n\n// Thrown when trying to use a login service which is not configured\nServiceConfiguration.ConfigError = function(serviceName) {\n  if (Meteor.isClient && !Accounts.loginServicesConfigured()) {\n    this.message = 'Login service configuration not yet loaded';\n  } else if (serviceName) {\n    this.message = 'Service ' + serviceName + ' not configured';\n  } else {\n    this.message = 'Service not configured';\n  }\n};\nServiceConfiguration.ConfigError.prototype = new Error();\nServiceConfiguration.ConfigError.prototype.name =\n  'ServiceConfiguration.ConfigError';\n","import { Meteor } from 'meteor/meteor';\n\n// Only one configuration should ever exist for each service.\n// A unique index helps avoid various race conditions which could\n// otherwise lead to an inconsistent database state (when there are multiple\n// configurations for a single service, which configuration is correct?)\ntry {\n  ServiceConfiguration.configurations.createIndexAsync(\n    { service: 1 },\n    { unique: true }\n  );\n} catch (err) {\n  console.error(\n    'The service-configuration package persists configuration in the ' +\n      'meteor_accounts_loginServiceConfiguration collection in MongoDB. As ' +\n      'each service should have exactly one configuration, Meteor ' +\n      'automatically creates a MongoDB index with a unique constraint on the ' +\n      ' meteor_accounts_loginServiceConfiguration collection. The ' +\n      'createIndex command which creates that index is failing.\\n\\n' +\n      'Meteor versions before 1.0.4 did not create this index. If you recently ' +\n      'upgraded and are seeing this error message for the first time, please ' +\n      'check your meteor_accounts_loginServiceConfiguration collection for ' +\n      'multiple configuration entries for the same service and delete ' +\n      'configuration entries until there is no more than one configuration ' +\n      'entry per service.\\n\\n' +\n      'If the meteor_accounts_loginServiceConfiguration collection looks ' +\n      'fine, the createIndex command is failing for some other reason.\\n\\n' +\n      'For more information on this history of this issue, please see ' +\n      'https://github.com/meteor/meteor/pull/3514.\\n'\n  );\n  throw err;\n}\n\nMeteor.startup(() => {\n  const settings = Meteor.settings?.packages?.['service-configuration'];\n  if (!settings) return;\n  for (const key of Object.keys(settings)) {\n    ServiceConfiguration.configurations.upsertAsync(\n      { service: key },\n      {\n        $set: settings[key],\n      }\n    );\n  }\n});\n"]}}]