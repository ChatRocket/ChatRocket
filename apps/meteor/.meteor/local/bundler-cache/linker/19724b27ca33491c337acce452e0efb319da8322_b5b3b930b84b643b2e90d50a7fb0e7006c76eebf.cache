[{"type":"js","data":"Package[\"core-runtime\"].queue(\"dispatch:run-as-user\",function () {/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar EmitterPromise = Package.meteor.EmitterPromise;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar _ = Package.underscore._;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\n\n/* Package-scope variables */\nvar DDPCommon;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/dispatch_run-as-user/lib/pre.1.0.3.js                                                      //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n// This code will go away in later versions of Meteor, this is just a \"polyfill\"\n// until the next release of Meteor maybe 1.0.3?\n//\nif (typeof DDPCommon === 'undefined') {\n\tDDPCommon = {};\n\n\tDDPCommon.MethodInvocation = function (options) {\n\t\tvar self = this;\n\n\t\t// true if we're running not the actual method, but a stub (that is,\n\t\t// if we're on a client (which may be a browser, or in the future a\n\t\t// server connecting to another server) and presently running a\n\t\t// simulation of a server-side method for latency compensation\n\t\t// purposes). not currently true except in a client such as a browser,\n\t\t// since there's usually no point in running stubs unless you have a\n\t\t// zero-latency connection to the user.\n\n\t\t/**\n\t\t * @summary Access inside a method invocation.  Boolean value, true if this invocation is a stub.\n\t\t * @locus Anywhere\n\t\t * @name  isSimulation\n\t\t * @memberOf MethodInvocation\n\t\t * @instance\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.isSimulation = options.isSimulation;\n\n\t\t// call this function to allow other method invocations (from the\n\t\t// same client) to continue running without waiting for this one to\n\t\t// complete.\n\t\tthis._unblock = options.unblock || function () {};\n\t\tthis._calledUnblock = false;\n\n\t\t// current user id\n\n\t\t/**\n\t\t * @summary The id of the user that made this method call, or `null` if no user was logged in.\n\t\t * @locus Anywhere\n\t\t * @name  userId\n\t\t * @memberOf MethodInvocation\n\t\t * @instance\n\t\t */\n\t\tthis.userId = options.userId;\n\n\t\t// sets current user id in all appropriate server contexts and\n\t\t// reruns subscriptions\n\t\tthis._setUserId = options.setUserId || function () {};\n\n\t\t// On the server, the connection this method call came in on.\n\n\t\t/**\n\t\t * @summary Access inside a method invocation. The [connection](#meteor_onconnection) that this method was received on. `null` if the method is not associated with a connection, eg. a server initiated method call.\n\t\t * @locus Server\n\t\t * @name  connection\n\t\t * @memberOf MethodInvocation\n\t\t * @instance\n\t\t */\n\t\tthis.connection = options.connection;\n\n\t\t// The seed for randomStream value generation\n\t\tthis.randomSeed = options.randomSeed;\n\n\t\t// This is set by RandomStream.get; and holds the random stream state\n\t\tthis.randomStream = null;\n\t};\n\n\t_.extend(DDPCommon.MethodInvocation.prototype, {\n\t\t/**\n\t\t * @summary Call inside a method invocation.  Allow subsequent method from this client to begin running in a new fiber.\n\t\t * @locus Server\n\t\t * @memberOf MethodInvocation\n\t\t * @instance\n\t\t */\n\t\tunblock: function () {\n\t\t\tvar self = this;\n\t\t\tself._calledUnblock = true;\n\t\t\tself._unblock();\n\t\t},\n\n\t\t/**\n\t\t * @summary Set the logged in user.\n\t\t * @locus Server\n\t\t * @memberOf MethodInvocation\n\t\t * @instance\n\t\t * @param {String | null} userId The value that should be returned by `userId` on this connection.\n\t\t */\n\t\tsetUserId: function (userId) {\n\t\t\tvar self = this;\n\t\t\tif (self._calledUnblock) throw new Error(\"Can't call setUserId in a method after calling unblock\");\n\t\t\tself.userId = userId;\n\t\t\t// self._setUserId(userId);\n\t\t},\n\t});\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/dispatch_run-as-user/lib/common.js                                                         //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n// This file adds the actual \"Meteor.runAsUser\" and \"Meteor.isRestricted\" api\n//\n// It's done by using a DDP method invocation, setting a user id and a\n// \"isRestricted\" flag on it.\n//\n// If run inside of an existing DDP invocation a nested version will be created.\n\nvar restrictedMode = new Meteor.EnvironmentVariable();\n\n/**\n * Returns true if inside a runAsUser user scope\n * @return {Boolean} True if in a runAsUser user scope\n */\nMeteor.isRestricted = function () {\n\treturn !!restrictedMode.get();\n};\n\n/**\n * Run code restricted\n * @param  {Function} f Code to run in restricted mode\n * @return {Any}   Result of code running\n */\nMeteor.runRestricted = function (f) {\n\tif (Meteor.isRestricted()) {\n\t\treturn f();\n\t} else {\n\t\treturn restrictedMode.withValue(true, f);\n\t}\n};\n\n/**\n * Run code unrestricted\n * @param  {Function} f Code to run in restricted mode\n * @return {Any}   Result of code running\n */\nMeteor.runUnrestricted = function (f) {\n\tif (Meteor.isRestricted()) {\n\t\treturn restrictedMode.withValue(false, f);\n\t} else {\n\t\tf();\n\t}\n};\n\n/**\n * Run as a user\n * @param  {String} userId The id of user to run as\n * @param  {Function} f      Function to run as user\n * @return {Any} Returns function result\n */\nMeteor.runAsUser = function (userId, f) {\n\tvar currentInvocation = DDP._CurrentInvocation.get();\n\n\t// Create a new method invocation\n\tvar invocation = new DDPCommon.MethodInvocation(\n\t\tcurrentInvocation\n\t\t\t? currentInvocation\n\t\t\t: {\n\t\t\t\t\tconnection: null,\n\t\t\t  },\n\t);\n\n\t// Now run as user on this invocation\n\tinvocation.setUserId(userId);\n\n\treturn DDP._CurrentInvocation.withValue(invocation, function () {\n\t\treturn f.apply(invocation, [userId]);\n\t});\n};\n\n/**\n * Run as restricted user\n * @param  {Function} f Function to run unrestricted\n * @return {Any}   Returns function result\n */\nMeteor.runAsRestrictedUser = function (userId, f) {\n\treturn Meteor.runRestricted(function () {\n\t\treturn Meteor.runAsUser(userId, f);\n\t});\n};\n\nvar adminMode = new Meteor.EnvironmentVariable();\n\n/**\n * Check if code is running isside an invocation / method\n */\nMeteor.isAdmin = function () {\n\treturn !!adminMode.get();\n};\n\n/**\n * Make the function run outside invocation\n */\nMeteor.runAsAdmin = function (f) {\n\tif (Meteor.isAdmin()) {\n\t\treturn f();\n\t} else {\n\t\treturn adminMode.withValue(false, f);\n\t}\n};\n\n/**\n * Make sure code runs outside an invocation on the\n * server\n */\nMeteor.runOutsideInvocation = function (f) {\n\tif (Meteor.isServer && DDP._CurrentInvocation.get()) {\n\t\tDDP._CurrentInvocation.withValue(null, f);\n\t} else {\n\t\tf();\n\t}\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/dispatch_run-as-user/lib/collection.overwrites.js                                          //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n// This file overwrites the default metoer Mongo.Collection modifiers: \"insert\",\n// \"update\", \"remove\"\n//\n// The new methods are checking if Meteor is in \"restricted\" mode to apply\n// allow and deny rules if needed.\n//\n// This will allow us to run the modifiers inside of a \"Meteor.runAsUser\" with\n// security checks.\n_.each(['insert', 'update', 'remove'], function (method) {\n\tvar _super = Mongo.Collection.prototype[method];\n\n\tMongo.Collection.prototype[method] = function (/* arguments */) {\n\t\tvar self = this;\n\t\tvar args = _.toArray(arguments);\n\n\t\t// Check if this method is run in restricted mode and collection is\n\t\t// restricted.\n\t\tif (Meteor.isRestricted() && self._restricted) {\n\t\t\tvar generatedId = null;\n\t\t\tif (method === 'insert' && !_.has(args[0], '_id')) {\n\t\t\t\tgeneratedId = self._makeNewID();\n\t\t\t}\n\n\t\t\t// short circuit if there is no way it will pass.\n\t\t\tif (self._validators[method].allow.length === 0) {\n\t\t\t\tthrow new Meteor.Error(403, 'Access denied. No allow validators set on restricted ' + \"collection for method '\" + method + \"'.\");\n\t\t\t}\n\n\t\t\tvar validatedMethodName = '_validated' + method.charAt(0).toUpperCase() + method.slice(1);\n\t\t\targs.unshift(Meteor.userId());\n\n\t\t\tif (method === 'insert') {\n\t\t\t\targs.push(generatedId);\n\n\t\t\t\tself[validatedMethodName].apply(self, args);\n\t\t\t\t// xxx: for now we return the id since self._validatedInsert doesn't\n\t\t\t\t// yet return the new id\n\t\t\t\treturn generatedId || args[0]._id;\n\t\t\t}\n\n\t\t\treturn self[validatedMethodName].apply(self, args);\n\t\t}\n\n\t\treturn _super.apply(self, args);\n\t};\n});\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nreturn {\n\n}});\n","servePath":"/packages/dispatch_run-as-user.js"}]