{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/lib/callbacks/callbacksBase.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"lib/callbacks/callbacksBase.ts","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/lib/callbacks/callbacksBase.ts","inputSourceMap":{"version":3,"file":"lib/callbacks/callbacksBase.ts","sourceRoot":"","sources":["lib/callbacks/callbacksBase.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Logger } from '@rocket.chat/logger';\nimport { Random } from '@rocket.chat/random';\n\nimport { compareByRanking } from '../utils/comparisons';\n\nenum CallbackPriority {\n\tHIGH = -1000,\n\tMEDIUM = 0,\n\tLOW = 1000,\n}\n\ntype Callback<H> = {\n\t(item: unknown, constant?: unknown): Promise<unknown>;\n\thook: H;\n\tid: string;\n\tpriority: CallbackPriority;\n\tstack: string;\n};\n\ntype CallbackTracker<H> = (callback: Callback<H>) => () => void;\n\ntype HookTracker<H> = (params: { hook: H; length: number }) => () => void;\n\nexport class Callbacks<\n\tTChainedCallbackSignatures extends {\n\t\t[key: string]: (item: any, constant?: any) => any;\n\t},\n\tTEventLikeCallbackSignatures extends {\n\t\t[key: string]: (item: any, constant?: any) => any;\n\t},\n\tTHook extends string = keyof TChainedCallbackSignatures & keyof TEventLikeCallbackSignatures & string,\n> {\n\tprivate logger: Logger | undefined = undefined;\n\n\tprivate trackCallback: CallbackTracker<THook> | undefined = undefined;\n\n\tprivate trackHook: HookTracker<THook> | undefined = undefined;\n\n\tprivate callbacks = new Map<THook, Callback<THook>[]>();\n\n\tprivate sequentialRunners = new Map<THook, (item: unknown, constant?: unknown) => Promise<unknown>>();\n\n\tprivate asyncRunners = new Map<THook, (item: unknown, constant?: unknown) => unknown>();\n\n\treadonly priority = CallbackPriority;\n\n\tsetLogger(logger: Logger): void {\n\t\tthis.logger = logger;\n\t}\n\n\tsetMetricsTrackers({ trackCallback, trackHook }: { trackCallback?: CallbackTracker<THook>; trackHook?: HookTracker<THook> }): void {\n\t\tthis.trackCallback = trackCallback;\n\t\tthis.trackHook = trackHook;\n\t}\n\n\tprivate runOne(callback: Callback<THook>, item: unknown, constant: unknown): Promise<unknown> {\n\t\tconst stopTracking = this.trackCallback?.(callback);\n\n\t\treturn Promise.resolve(callback(item, constant)).finally(stopTracking);\n\t}\n\n\tprivate createSequentialRunner(hook: THook, callbacks: Callback<THook>[]): (item: unknown, constant?: unknown) => Promise<unknown> {\n\t\tconst wrapCallback =\n\t\t\t(callback: Callback<THook>) =>\n\t\t\tasync (item: unknown, constant?: unknown): Promise<unknown> => {\n\t\t\t\tthis.logger?.debug(`Executing callback with id ${callback.id} for hook ${callback.hook}`);\n\n\t\t\t\treturn (await this.runOne(callback, item, constant)) ?? item;\n\t\t\t};\n\n\t\tconst identity = <TItem>(item: TItem): Promise<TItem> => Promise.resolve(item);\n\n\t\tconst pipe =\n\t\t\t(curr: (item: unknown, constant?: unknown) => Promise<unknown>, next: (item: unknown, constant?: unknown) => Promise<unknown>) =>\n\t\t\tasync (item: unknown, constant?: unknown): Promise<unknown> =>\n\t\t\t\tnext(await curr(item, constant), constant);\n\n\t\tconst fn = callbacks.map(wrapCallback).reduce(pipe, identity);\n\n\t\treturn async (item: unknown, constant?: unknown): Promise<unknown> => {\n\t\t\tconst stopTracking = this.trackHook?.({ hook, length: callbacks.length });\n\n\t\t\treturn fn(item, constant).finally(() => stopTracking?.());\n\t\t};\n\t}\n\n\tprivate createAsyncRunner(_: THook, callbacks: Callback<THook>[]) {\n\t\treturn (item: unknown, constant?: unknown): unknown => {\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tthrow new Error('callbacks.runAsync on client server not allowed');\n\t\t\t}\n\n\t\t\tfor (const callback of callbacks) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tvoid this.runOne(callback, item, constant);\n\t\t\t\t}, 0);\n\t\t\t}\n\n\t\t\treturn item;\n\t\t};\n\t}\n\n\tgetCallbacks(hook: THook): Callback<THook>[] {\n\t\treturn this.callbacks.get(hook) ?? [];\n\t}\n\n\tsetCallbacks(hook: THook, callbacks: Callback<THook>[]): void {\n\t\tthis.callbacks.set(hook, callbacks);\n\t\tthis.sequentialRunners.set(hook, this.createSequentialRunner(hook, callbacks));\n\t\tthis.asyncRunners.set(hook, this.createAsyncRunner(hook, callbacks));\n\t}\n\n\t/**\n\t * Add a callback function to a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param callback the callback function\n\t * @param priority the callback run priority (order)\n\t * @param id human friendly name for this callback\n\t */\n\tadd<Hook extends keyof TEventLikeCallbackSignatures>(\n\t\thook: Hook,\n\t\tcallback: TEventLikeCallbackSignatures[Hook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<Hook extends keyof TChainedCallbackSignatures>(\n\t\thook: Hook,\n\t\tcallback: TChainedCallbackSignatures[Hook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<TItem, TConstant, TNextItem = TItem>(\n\t\thook: THook,\n\t\tcallback: (item: TItem, constant?: TConstant) => TNextItem,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd(hook: THook, callback: (item: unknown, constant?: unknown) => unknown, priority = this.priority.MEDIUM, id = Random.id()): void {\n\t\tconst callbacks = this.getCallbacks(hook);\n\n\t\tif (callbacks.some((cb) => cb.id === id)) {\n\t\t\treturn;\n\t\t}\n\n\t\tcallbacks.push(\n\t\t\tObject.assign(callback as Callback<THook>, {\n\t\t\t\thook,\n\t\t\t\tpriority,\n\t\t\t\tid,\n\t\t\t\tstack: new Error().stack,\n\t\t\t}),\n\t\t);\n\t\tcallbacks.sort(compareByRanking((callback: Callback<THook>): number => callback.priority ?? this.priority.MEDIUM));\n\n\t\tthis.setCallbacks(hook, callbacks);\n\t}\n\n\t/**\n\t * Remove a callback from a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param id the callback's id\n\t */\n\tremove(hook: THook, id: string): void {\n\t\tconst hooks = this.getCallbacks(hook).filter((callback) => callback.id !== id);\n\t\tthis.setCallbacks(hook, hooks);\n\t}\n\n\trun<Hook extends keyof TEventLikeCallbackSignatures>(hook: Hook, ...args: Parameters<TEventLikeCallbackSignatures[Hook]>): Promise<void>;\n\n\trun<Hook extends keyof TChainedCallbackSignatures>(\n\t\thook: Hook,\n\t\t...args: Parameters<TChainedCallbackSignatures[Hook]>\n\t): Promise<ReturnType<TChainedCallbackSignatures[Hook]>>;\n\n\trun<TItem, TConstant, TNextItem = TItem>(hook: THook, item: TItem, constant?: TConstant): Promise<TNextItem>;\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns returns the item after it's been through all the callbacks for this hook\n\t */\n\trun(hook: THook, item: unknown, constant?: unknown): Promise<unknown> {\n\t\tconst runner = this.sequentialRunners.get(hook) ?? (async (item: unknown, _constant?: unknown): Promise<unknown> => item);\n\t\treturn runner(item, constant);\n\t}\n\n\trunAsync<Hook extends keyof TEventLikeCallbackSignatures>(hook: Hook, ...args: Parameters<TEventLikeCallbackSignatures[Hook]>): void;\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns the post, comment, modifier, etc. on which to run the callbacks\n\t */\n\trunAsync(hook: THook, item: unknown, constant?: unknown): unknown {\n\t\tconst runner = this.asyncRunners.get(hook) ?? ((item: unknown, _constant?: unknown): unknown => item);\n\t\treturn runner(item, constant);\n\t}\n\n\tstatic create<F extends (item: any, constant?: any) => any | Promise<any>>(\n\t\thook: string,\n\t): Cb<Parameters<F>[0], ReturnType<F>, Parameters<F>[1]>;\n\n\tstatic create<I, R, C = undefined>(hook: string): Cb<I, R, C> {\n\t\tconst callbacks = new Callbacks();\n\n\t\treturn {\n\t\t\tadd: (callback, priority, id) => callbacks.add(hook as any, callback, priority, id),\n\t\t\tremove: (id) => callbacks.remove(hook as any, id),\n\t\t\trun: (item, constant) => callbacks.run(hook as any, item, constant) as any,\n\t\t};\n\t}\n}\n\n/**\n * Callback hooks provide an easy way to add extra steps to common operations.\n * @deprecated\n */\ntype Cb<I, R, C = undefined> = {\n\tadd: (\n\t\tcallback: (item: I, constant: C) => Promise<R | undefined | void> | R | undefined | void,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t) => void;\n\tremove: (id: string) => void;\n\trun: (item: I, constant?: C) => Promise<R>;\n};\n"]},"targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/lib/callbacks/callbacksBase.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/callbacks/callbacksBase.ts","inputSourceMap":{"version":3,"file":"lib/callbacks/callbacksBase.ts","sourceRoot":"","sources":["lib/callbacks/callbacksBase.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Logger } from '@rocket.chat/logger';\nimport { Random } from '@rocket.chat/random';\n\nimport { compareByRanking } from '../utils/comparisons';\n\nenum CallbackPriority {\n\tHIGH = -1000,\n\tMEDIUM = 0,\n\tLOW = 1000,\n}\n\ntype Callback<H> = {\n\t(item: unknown, constant?: unknown): Promise<unknown>;\n\thook: H;\n\tid: string;\n\tpriority: CallbackPriority;\n\tstack: string;\n};\n\ntype CallbackTracker<H> = (callback: Callback<H>) => () => void;\n\ntype HookTracker<H> = (params: { hook: H; length: number }) => () => void;\n\nexport class Callbacks<\n\tTChainedCallbackSignatures extends {\n\t\t[key: string]: (item: any, constant?: any) => any;\n\t},\n\tTEventLikeCallbackSignatures extends {\n\t\t[key: string]: (item: any, constant?: any) => any;\n\t},\n\tTHook extends string = keyof TChainedCallbackSignatures & keyof TEventLikeCallbackSignatures & string,\n> {\n\tprivate logger: Logger | undefined = undefined;\n\n\tprivate trackCallback: CallbackTracker<THook> | undefined = undefined;\n\n\tprivate trackHook: HookTracker<THook> | undefined = undefined;\n\n\tprivate callbacks = new Map<THook, Callback<THook>[]>();\n\n\tprivate sequentialRunners = new Map<THook, (item: unknown, constant?: unknown) => Promise<unknown>>();\n\n\tprivate asyncRunners = new Map<THook, (item: unknown, constant?: unknown) => unknown>();\n\n\treadonly priority = CallbackPriority;\n\n\tsetLogger(logger: Logger): void {\n\t\tthis.logger = logger;\n\t}\n\n\tsetMetricsTrackers({ trackCallback, trackHook }: { trackCallback?: CallbackTracker<THook>; trackHook?: HookTracker<THook> }): void {\n\t\tthis.trackCallback = trackCallback;\n\t\tthis.trackHook = trackHook;\n\t}\n\n\tprivate runOne(callback: Callback<THook>, item: unknown, constant: unknown): Promise<unknown> {\n\t\tconst stopTracking = this.trackCallback?.(callback);\n\n\t\treturn Promise.resolve(callback(item, constant)).finally(stopTracking);\n\t}\n\n\tprivate createSequentialRunner(hook: THook, callbacks: Callback<THook>[]): (item: unknown, constant?: unknown) => Promise<unknown> {\n\t\tconst wrapCallback =\n\t\t\t(callback: Callback<THook>) =>\n\t\t\tasync (item: unknown, constant?: unknown): Promise<unknown> => {\n\t\t\t\tthis.logger?.debug(`Executing callback with id ${callback.id} for hook ${callback.hook}`);\n\n\t\t\t\treturn (await this.runOne(callback, item, constant)) ?? item;\n\t\t\t};\n\n\t\tconst identity = <TItem>(item: TItem): Promise<TItem> => Promise.resolve(item);\n\n\t\tconst pipe =\n\t\t\t(curr: (item: unknown, constant?: unknown) => Promise<unknown>, next: (item: unknown, constant?: unknown) => Promise<unknown>) =>\n\t\t\tasync (item: unknown, constant?: unknown): Promise<unknown> =>\n\t\t\t\tnext(await curr(item, constant), constant);\n\n\t\tconst fn = callbacks.map(wrapCallback).reduce(pipe, identity);\n\n\t\treturn async (item: unknown, constant?: unknown): Promise<unknown> => {\n\t\t\tconst stopTracking = this.trackHook?.({ hook, length: callbacks.length });\n\n\t\t\treturn fn(item, constant).finally(() => stopTracking?.());\n\t\t};\n\t}\n\n\tprivate createAsyncRunner(_: THook, callbacks: Callback<THook>[]) {\n\t\treturn (item: unknown, constant?: unknown): unknown => {\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tthrow new Error('callbacks.runAsync on client server not allowed');\n\t\t\t}\n\n\t\t\tfor (const callback of callbacks) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tvoid this.runOne(callback, item, constant);\n\t\t\t\t}, 0);\n\t\t\t}\n\n\t\t\treturn item;\n\t\t};\n\t}\n\n\tgetCallbacks(hook: THook): Callback<THook>[] {\n\t\treturn this.callbacks.get(hook) ?? [];\n\t}\n\n\tsetCallbacks(hook: THook, callbacks: Callback<THook>[]): void {\n\t\tthis.callbacks.set(hook, callbacks);\n\t\tthis.sequentialRunners.set(hook, this.createSequentialRunner(hook, callbacks));\n\t\tthis.asyncRunners.set(hook, this.createAsyncRunner(hook, callbacks));\n\t}\n\n\t/**\n\t * Add a callback function to a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param callback the callback function\n\t * @param priority the callback run priority (order)\n\t * @param id human friendly name for this callback\n\t */\n\tadd<Hook extends keyof TEventLikeCallbackSignatures>(\n\t\thook: Hook,\n\t\tcallback: TEventLikeCallbackSignatures[Hook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<Hook extends keyof TChainedCallbackSignatures>(\n\t\thook: Hook,\n\t\tcallback: TChainedCallbackSignatures[Hook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<TItem, TConstant, TNextItem = TItem>(\n\t\thook: THook,\n\t\tcallback: (item: TItem, constant?: TConstant) => TNextItem,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd(hook: THook, callback: (item: unknown, constant?: unknown) => unknown, priority = this.priority.MEDIUM, id = Random.id()): void {\n\t\tconst callbacks = this.getCallbacks(hook);\n\n\t\tif (callbacks.some((cb) => cb.id === id)) {\n\t\t\treturn;\n\t\t}\n\n\t\tcallbacks.push(\n\t\t\tObject.assign(callback as Callback<THook>, {\n\t\t\t\thook,\n\t\t\t\tpriority,\n\t\t\t\tid,\n\t\t\t\tstack: new Error().stack,\n\t\t\t}),\n\t\t);\n\t\tcallbacks.sort(compareByRanking((callback: Callback<THook>): number => callback.priority ?? this.priority.MEDIUM));\n\n\t\tthis.setCallbacks(hook, callbacks);\n\t}\n\n\t/**\n\t * Remove a callback from a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param id the callback's id\n\t */\n\tremove(hook: THook, id: string): void {\n\t\tconst hooks = this.getCallbacks(hook).filter((callback) => callback.id !== id);\n\t\tthis.setCallbacks(hook, hooks);\n\t}\n\n\trun<Hook extends keyof TEventLikeCallbackSignatures>(hook: Hook, ...args: Parameters<TEventLikeCallbackSignatures[Hook]>): Promise<void>;\n\n\trun<Hook extends keyof TChainedCallbackSignatures>(\n\t\thook: Hook,\n\t\t...args: Parameters<TChainedCallbackSignatures[Hook]>\n\t): Promise<ReturnType<TChainedCallbackSignatures[Hook]>>;\n\n\trun<TItem, TConstant, TNextItem = TItem>(hook: THook, item: TItem, constant?: TConstant): Promise<TNextItem>;\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns returns the item after it's been through all the callbacks for this hook\n\t */\n\trun(hook: THook, item: unknown, constant?: unknown): Promise<unknown> {\n\t\tconst runner = this.sequentialRunners.get(hook) ?? (async (item: unknown, _constant?: unknown): Promise<unknown> => item);\n\t\treturn runner(item, constant);\n\t}\n\n\trunAsync<Hook extends keyof TEventLikeCallbackSignatures>(hook: Hook, ...args: Parameters<TEventLikeCallbackSignatures[Hook]>): void;\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns the post, comment, modifier, etc. on which to run the callbacks\n\t */\n\trunAsync(hook: THook, item: unknown, constant?: unknown): unknown {\n\t\tconst runner = this.asyncRunners.get(hook) ?? ((item: unknown, _constant?: unknown): unknown => item);\n\t\treturn runner(item, constant);\n\t}\n\n\tstatic create<F extends (item: any, constant?: any) => any | Promise<any>>(\n\t\thook: string,\n\t): Cb<Parameters<F>[0], ReturnType<F>, Parameters<F>[1]>;\n\n\tstatic create<I, R, C = undefined>(hook: string): Cb<I, R, C> {\n\t\tconst callbacks = new Callbacks();\n\n\t\treturn {\n\t\t\tadd: (callback, priority, id) => callbacks.add(hook as any, callback, priority, id),\n\t\t\tremove: (id) => callbacks.remove(hook as any, id),\n\t\t\trun: (item, constant) => callbacks.run(hook as any, item, constant) as any,\n\t\t};\n\t}\n}\n\n/**\n * Callback hooks provide an easy way to add extra steps to common operations.\n * @deprecated\n */\ntype Cb<I, R, C = undefined> = {\n\tadd: (\n\t\tcallback: (item: I, constant: C) => Promise<R | undefined | void> | R | undefined | void,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t) => void;\n\tremove: (id: string) => void;\n\trun: (item: I, constant?: C) => Promise<R>;\n};\n"]}}},"code":"module.export({\n  Callbacks: () => Callbacks\n});\nlet Random;\nmodule.link(\"@rocket.chat/random\", {\n  Random(v) {\n    Random = v;\n  }\n}, 0);\nlet compareByRanking;\nmodule.link(\"../utils/comparisons\", {\n  compareByRanking(v) {\n    compareByRanking = v;\n  }\n}, 1);\nvar CallbackPriority;\n(function (CallbackPriority) {\n  CallbackPriority[CallbackPriority[\"HIGH\"] = -1000] = \"HIGH\";\n  CallbackPriority[CallbackPriority[\"MEDIUM\"] = 0] = \"MEDIUM\";\n  CallbackPriority[CallbackPriority[\"LOW\"] = 1000] = \"LOW\";\n})(CallbackPriority || (CallbackPriority = {}));\nclass Callbacks {\n  constructor() {\n    this.logger = undefined;\n    this.trackCallback = undefined;\n    this.trackHook = undefined;\n    this.callbacks = new Map();\n    this.sequentialRunners = new Map();\n    this.asyncRunners = new Map();\n    this.priority = CallbackPriority;\n  }\n  setLogger(logger) {\n    this.logger = logger;\n  }\n  setMetricsTrackers(_ref) {\n    let {\n      trackCallback,\n      trackHook\n    } = _ref;\n    this.trackCallback = trackCallback;\n    this.trackHook = trackHook;\n  }\n  runOne(callback, item, constant) {\n    var _this$trackCallback;\n    const stopTracking = (_this$trackCallback = this.trackCallback) === null || _this$trackCallback === void 0 ? void 0 : _this$trackCallback.call(this, callback);\n    return Promise.resolve(callback(item, constant)).finally(stopTracking);\n  }\n  createSequentialRunner(hook, callbacks) {\n    const wrapCallback = callback => async (item, constant) => {\n      var _this$logger, _await$this$runOne;\n      (_this$logger = this.logger) === null || _this$logger === void 0 ? void 0 : _this$logger.debug(\"Executing callback with id \".concat(callback.id, \" for hook \").concat(callback.hook));\n      return (_await$this$runOne = await this.runOne(callback, item, constant)) !== null && _await$this$runOne !== void 0 ? _await$this$runOne : item;\n    };\n    const identity = item => Promise.resolve(item);\n    const pipe = (curr, next) => async (item, constant) => next(await curr(item, constant), constant);\n    const fn = callbacks.map(wrapCallback).reduce(pipe, identity);\n    return async (item, constant) => {\n      var _this$trackHook;\n      const stopTracking = (_this$trackHook = this.trackHook) === null || _this$trackHook === void 0 ? void 0 : _this$trackHook.call(this, {\n        hook,\n        length: callbacks.length\n      });\n      return fn(item, constant).finally(() => stopTracking === null || stopTracking === void 0 ? void 0 : stopTracking());\n    };\n  }\n  createAsyncRunner(_, callbacks) {\n    return (item, constant) => {\n      if (typeof window !== 'undefined') {\n        throw new Error('callbacks.runAsync on client server not allowed');\n      }\n      for (const callback of callbacks) {\n        setTimeout(() => {\n          void this.runOne(callback, item, constant);\n        }, 0);\n      }\n      return item;\n    };\n  }\n  getCallbacks(hook) {\n    var _this$callbacks$get;\n    return (_this$callbacks$get = this.callbacks.get(hook)) !== null && _this$callbacks$get !== void 0 ? _this$callbacks$get : [];\n  }\n  setCallbacks(hook, callbacks) {\n    this.callbacks.set(hook, callbacks);\n    this.sequentialRunners.set(hook, this.createSequentialRunner(hook, callbacks));\n    this.asyncRunners.set(hook, this.createAsyncRunner(hook, callbacks));\n  }\n  add(hook, callback) {\n    let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.priority.MEDIUM;\n    let id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Random.id();\n    const callbacks = this.getCallbacks(hook);\n    if (callbacks.some(cb => cb.id === id)) {\n      return;\n    }\n    callbacks.push(Object.assign(callback, {\n      hook,\n      priority,\n      id,\n      stack: new Error().stack\n    }));\n    callbacks.sort(compareByRanking(callback => {\n      var _callback$priority;\n      return (_callback$priority = callback.priority) !== null && _callback$priority !== void 0 ? _callback$priority : this.priority.MEDIUM;\n    }));\n    this.setCallbacks(hook, callbacks);\n  }\n  /**\n   * Remove a callback from a hook\n   *\n   * @param hook the name of the hook\n   * @param id the callback's id\n   */\n  remove(hook, id) {\n    const hooks = this.getCallbacks(hook).filter(callback => callback.id !== id);\n    this.setCallbacks(hook, hooks);\n  }\n  /**\n   * Successively run all of a hook's callbacks on an item\n   *\n   * @param hook the name of the hook\n   * @param item the post, comment, modifier, etc. on which to run the callbacks\n   * @param constant an optional constant that will be passed along to each callback\n   * @returns returns the item after it's been through all the callbacks for this hook\n   */\n  run(hook, item, constant) {\n    var _this$sequentialRunne;\n    const runner = (_this$sequentialRunne = this.sequentialRunners.get(hook)) !== null && _this$sequentialRunne !== void 0 ? _this$sequentialRunne : async (item, _constant) => item;\n    return runner(item, constant);\n  }\n  /**\n   * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n   *\n   * @param hook the name of the hook\n   * @param item the post, comment, modifier, etc. on which to run the callbacks\n   * @param constant an optional constant that will be passed along to each callback\n   * @returns the post, comment, modifier, etc. on which to run the callbacks\n   */\n  runAsync(hook, item, constant) {\n    var _this$asyncRunners$ge;\n    const runner = (_this$asyncRunners$ge = this.asyncRunners.get(hook)) !== null && _this$asyncRunners$ge !== void 0 ? _this$asyncRunners$ge : (item, _constant) => item;\n    return runner(item, constant);\n  }\n  static create(hook) {\n    const callbacks = new Callbacks();\n    return {\n      add: (callback, priority, id) => callbacks.add(hook, callback, priority, id),\n      remove: id => callbacks.remove(hook, id),\n      run: (item, constant) => callbacks.run(hook, item, constant)\n    };\n  }\n}","map":{"version":3,"names":["module","export","Callbacks","Random","link","v","compareByRanking","CallbackPriority","constructor","logger","undefined","trackCallback","trackHook","callbacks","Map","sequentialRunners","asyncRunners","priority","setLogger","setMetricsTrackers","_ref","runOne","callback","item","constant","_this$trackCallback","stopTracking","call","Promise","resolve","finally","createSequentialRunner","hook","wrapCallback","_this$logger","_await$this$runOne","debug","concat","id","identity","pipe","curr","next","fn","map","reduce","_this$trackHook","length","createAsyncRunner","_","window","Error","setTimeout","getCallbacks","_this$callbacks$get","get","setCallbacks","set","add","arguments","MEDIUM","some","cb","push","Object","assign","stack","sort","_callback$priority","remove","hooks","filter","run","_this$sequentialRunne","runner","_constant","runAsync","_this$asyncRunners$ge","create"],"sources":["lib/callbacks/callbacksBase.ts"],"sourcesContent":["import type { Logger } from '@rocket.chat/logger';\nimport { Random } from '@rocket.chat/random';\n\nimport { compareByRanking } from '../utils/comparisons';\n\nenum CallbackPriority {\n\tHIGH = -1000,\n\tMEDIUM = 0,\n\tLOW = 1000,\n}\n\ntype Callback<H> = {\n\t(item: unknown, constant?: unknown): Promise<unknown>;\n\thook: H;\n\tid: string;\n\tpriority: CallbackPriority;\n\tstack: string;\n};\n\ntype CallbackTracker<H> = (callback: Callback<H>) => () => void;\n\ntype HookTracker<H> = (params: { hook: H; length: number }) => () => void;\n\nexport class Callbacks<\n\tTChainedCallbackSignatures extends {\n\t\t[key: string]: (item: any, constant?: any) => any;\n\t},\n\tTEventLikeCallbackSignatures extends {\n\t\t[key: string]: (item: any, constant?: any) => any;\n\t},\n\tTHook extends string = keyof TChainedCallbackSignatures & keyof TEventLikeCallbackSignatures & string,\n> {\n\tprivate logger: Logger | undefined = undefined;\n\n\tprivate trackCallback: CallbackTracker<THook> | undefined = undefined;\n\n\tprivate trackHook: HookTracker<THook> | undefined = undefined;\n\n\tprivate callbacks = new Map<THook, Callback<THook>[]>();\n\n\tprivate sequentialRunners = new Map<THook, (item: unknown, constant?: unknown) => Promise<unknown>>();\n\n\tprivate asyncRunners = new Map<THook, (item: unknown, constant?: unknown) => unknown>();\n\n\treadonly priority = CallbackPriority;\n\n\tsetLogger(logger: Logger): void {\n\t\tthis.logger = logger;\n\t}\n\n\tsetMetricsTrackers({ trackCallback, trackHook }: { trackCallback?: CallbackTracker<THook>; trackHook?: HookTracker<THook> }): void {\n\t\tthis.trackCallback = trackCallback;\n\t\tthis.trackHook = trackHook;\n\t}\n\n\tprivate runOne(callback: Callback<THook>, item: unknown, constant: unknown): Promise<unknown> {\n\t\tconst stopTracking = this.trackCallback?.(callback);\n\n\t\treturn Promise.resolve(callback(item, constant)).finally(stopTracking);\n\t}\n\n\tprivate createSequentialRunner(hook: THook, callbacks: Callback<THook>[]): (item: unknown, constant?: unknown) => Promise<unknown> {\n\t\tconst wrapCallback =\n\t\t\t(callback: Callback<THook>) =>\n\t\t\tasync (item: unknown, constant?: unknown): Promise<unknown> => {\n\t\t\t\tthis.logger?.debug(`Executing callback with id ${callback.id} for hook ${callback.hook}`);\n\n\t\t\t\treturn (await this.runOne(callback, item, constant)) ?? item;\n\t\t\t};\n\n\t\tconst identity = <TItem>(item: TItem): Promise<TItem> => Promise.resolve(item);\n\n\t\tconst pipe =\n\t\t\t(curr: (item: unknown, constant?: unknown) => Promise<unknown>, next: (item: unknown, constant?: unknown) => Promise<unknown>) =>\n\t\t\tasync (item: unknown, constant?: unknown): Promise<unknown> =>\n\t\t\t\tnext(await curr(item, constant), constant);\n\n\t\tconst fn = callbacks.map(wrapCallback).reduce(pipe, identity);\n\n\t\treturn async (item: unknown, constant?: unknown): Promise<unknown> => {\n\t\t\tconst stopTracking = this.trackHook?.({ hook, length: callbacks.length });\n\n\t\t\treturn fn(item, constant).finally(() => stopTracking?.());\n\t\t};\n\t}\n\n\tprivate createAsyncRunner(_: THook, callbacks: Callback<THook>[]) {\n\t\treturn (item: unknown, constant?: unknown): unknown => {\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tthrow new Error('callbacks.runAsync on client server not allowed');\n\t\t\t}\n\n\t\t\tfor (const callback of callbacks) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tvoid this.runOne(callback, item, constant);\n\t\t\t\t}, 0);\n\t\t\t}\n\n\t\t\treturn item;\n\t\t};\n\t}\n\n\tgetCallbacks(hook: THook): Callback<THook>[] {\n\t\treturn this.callbacks.get(hook) ?? [];\n\t}\n\n\tsetCallbacks(hook: THook, callbacks: Callback<THook>[]): void {\n\t\tthis.callbacks.set(hook, callbacks);\n\t\tthis.sequentialRunners.set(hook, this.createSequentialRunner(hook, callbacks));\n\t\tthis.asyncRunners.set(hook, this.createAsyncRunner(hook, callbacks));\n\t}\n\n\t/**\n\t * Add a callback function to a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param callback the callback function\n\t * @param priority the callback run priority (order)\n\t * @param id human friendly name for this callback\n\t */\n\tadd<Hook extends keyof TEventLikeCallbackSignatures>(\n\t\thook: Hook,\n\t\tcallback: TEventLikeCallbackSignatures[Hook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<Hook extends keyof TChainedCallbackSignatures>(\n\t\thook: Hook,\n\t\tcallback: TChainedCallbackSignatures[Hook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<TItem, TConstant, TNextItem = TItem>(\n\t\thook: THook,\n\t\tcallback: (item: TItem, constant?: TConstant) => TNextItem,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd(hook: THook, callback: (item: unknown, constant?: unknown) => unknown, priority = this.priority.MEDIUM, id = Random.id()): void {\n\t\tconst callbacks = this.getCallbacks(hook);\n\n\t\tif (callbacks.some((cb) => cb.id === id)) {\n\t\t\treturn;\n\t\t}\n\n\t\tcallbacks.push(\n\t\t\tObject.assign(callback as Callback<THook>, {\n\t\t\t\thook,\n\t\t\t\tpriority,\n\t\t\t\tid,\n\t\t\t\tstack: new Error().stack,\n\t\t\t}),\n\t\t);\n\t\tcallbacks.sort(compareByRanking((callback: Callback<THook>): number => callback.priority ?? this.priority.MEDIUM));\n\n\t\tthis.setCallbacks(hook, callbacks);\n\t}\n\n\t/**\n\t * Remove a callback from a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param id the callback's id\n\t */\n\tremove(hook: THook, id: string): void {\n\t\tconst hooks = this.getCallbacks(hook).filter((callback) => callback.id !== id);\n\t\tthis.setCallbacks(hook, hooks);\n\t}\n\n\trun<Hook extends keyof TEventLikeCallbackSignatures>(hook: Hook, ...args: Parameters<TEventLikeCallbackSignatures[Hook]>): Promise<void>;\n\n\trun<Hook extends keyof TChainedCallbackSignatures>(\n\t\thook: Hook,\n\t\t...args: Parameters<TChainedCallbackSignatures[Hook]>\n\t): Promise<ReturnType<TChainedCallbackSignatures[Hook]>>;\n\n\trun<TItem, TConstant, TNextItem = TItem>(hook: THook, item: TItem, constant?: TConstant): Promise<TNextItem>;\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns returns the item after it's been through all the callbacks for this hook\n\t */\n\trun(hook: THook, item: unknown, constant?: unknown): Promise<unknown> {\n\t\tconst runner = this.sequentialRunners.get(hook) ?? (async (item: unknown, _constant?: unknown): Promise<unknown> => item);\n\t\treturn runner(item, constant);\n\t}\n\n\trunAsync<Hook extends keyof TEventLikeCallbackSignatures>(hook: Hook, ...args: Parameters<TEventLikeCallbackSignatures[Hook]>): void;\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns the post, comment, modifier, etc. on which to run the callbacks\n\t */\n\trunAsync(hook: THook, item: unknown, constant?: unknown): unknown {\n\t\tconst runner = this.asyncRunners.get(hook) ?? ((item: unknown, _constant?: unknown): unknown => item);\n\t\treturn runner(item, constant);\n\t}\n\n\tstatic create<F extends (item: any, constant?: any) => any | Promise<any>>(\n\t\thook: string,\n\t): Cb<Parameters<F>[0], ReturnType<F>, Parameters<F>[1]>;\n\n\tstatic create<I, R, C = undefined>(hook: string): Cb<I, R, C> {\n\t\tconst callbacks = new Callbacks();\n\n\t\treturn {\n\t\t\tadd: (callback, priority, id) => callbacks.add(hook as any, callback, priority, id),\n\t\t\tremove: (id) => callbacks.remove(hook as any, id),\n\t\t\trun: (item, constant) => callbacks.run(hook as any, item, constant) as any,\n\t\t};\n\t}\n}\n\n/**\n * Callback hooks provide an easy way to add extra steps to common operations.\n * @deprecated\n */\ntype Cb<I, R, C = undefined> = {\n\tadd: (\n\t\tcallback: (item: I, constant: C) => Promise<R | undefined | void> | R | undefined | void,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t) => void;\n\tremove: (id: string) => void;\n\trun: (item: I, constant?: C) => Promise<R>;\n};\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"23129051ea872bdf67a164ab28dee2da9718baac"}
