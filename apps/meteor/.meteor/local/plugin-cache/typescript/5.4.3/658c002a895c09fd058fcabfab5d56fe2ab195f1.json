{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/lib/callbacks/callbacksBase.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"lib/callbacks/callbacksBase.ts","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/lib/callbacks/callbacksBase.ts","inputSourceMap":{"version":3,"file":"lib/callbacks/callbacksBase.ts","sourceRoot":"","sources":["lib/callbacks/callbacksBase.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,MAAM,qBAAqB,CAAC;AAE7C,OAAO,EAAE,gBAAgB,EAAE,MAAM,sBAAsB,CAAC;AAExD,IAAK,gBAIJ;AAJD,WAAK,gBAAgB;IACpB,2DAAY,CAAA;IACZ,2DAAU,CAAA;IACV,wDAAU,CAAA;AACX,CAAC,EAJI,gBAAgB,KAAhB,gBAAgB,QAIpB;AAcD,MAAM,OAAO,SAAS;IASb,MAAM,GAAuB,SAAS,CAAC;IAEvC,aAAa,GAAuC,SAAS,CAAC;IAE9D,SAAS,GAAmC,SAAS,CAAC;IAEtD,SAAS,GAAG,IAAI,GAAG,EAA4B,CAAC;IAEhD,iBAAiB,GAAG,IAAI,GAAG,EAAkE,CAAC;IAE9F,YAAY,GAAG,IAAI,GAAG,EAAyD,CAAC;IAE/E,QAAQ,GAAG,gBAAgB,CAAC;IAErC,SAAS,CAAC,MAAc;QACvB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACtB,CAAC;IAED,kBAAkB,CAAC,EAAE,aAAa,EAAE,SAAS,EAA8E;QAC1H,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC5B,CAAC;IAEO,MAAM,CAAC,QAAyB,EAAE,IAAa,EAAE,QAAiB;QACzE,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC,QAAQ,CAAC,CAAC;QAEpD,OAAO,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;IACxE,CAAC;IAEO,sBAAsB,CAAC,IAAW,EAAE,SAA4B;QACvE,MAAM,YAAY,GACjB,CAAC,QAAyB,EAAE,EAAE,CAC9B,KAAK,EAAE,IAAa,EAAE,QAAkB,EAAoB,EAAE;YAC7D,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,8BAA8B,QAAQ,CAAC,EAAE,aAAa,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC;YAE1F,OAAO,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC,IAAI,IAAI,CAAC;QAC9D,CAAC,CAAC;QAEH,MAAM,QAAQ,GAAG,CAAQ,IAAW,EAAkB,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAE/E,MAAM,IAAI,GACT,CAAC,IAA6D,EAAE,IAA6D,EAAE,EAAE,CACjI,KAAK,EAAE,IAAa,EAAE,QAAkB,EAAoB,EAAE,CAC7D,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;QAE7C,MAAM,EAAE,GAAG,SAAS,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QAE9D,OAAO,KAAK,EAAE,IAAa,EAAE,QAAkB,EAAoB,EAAE;YACpE,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC;YAE1E,OAAO,EAAE,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;QAC3D,CAAC,CAAC;IACH,CAAC;IAEO,iBAAiB,CAAC,CAAQ,EAAE,SAA4B;QAC/D,OAAO,CAAC,IAAa,EAAE,QAAkB,EAAW,EAAE;YACrD,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE,CAAC;gBACnC,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;YACpE,CAAC;YAED,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE,CAAC;gBAClC,UAAU,CAAC,GAAG,EAAE;oBACf,KAAK,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;gBAC5C,CAAC,EAAE,CAAC,CAAC,CAAC;YACP,CAAC;YAED,OAAO,IAAI,CAAC;QACb,CAAC,CAAC;IACH,CAAC;IAED,YAAY,CAAC,IAAW;QACvB,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;IACvC,CAAC;IAED,YAAY,CAAC,IAAW,EAAE,SAA4B;QACrD,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;QACpC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,sBAAsB,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC;QAC/E,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC;IACtE,CAAC;IA+BD,GAAG,CAAC,IAAW,EAAE,QAAwD,EAAE,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,GAAG,MAAM,CAAC,EAAE,EAAE;QAC3H,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;QAE1C,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC;YAC1C,OAAO;QACR,CAAC;QAED,SAAS,CAAC,IAAI,CACb,MAAM,CAAC,MAAM,CAAC,QAA2B,EAAE;YAC1C,IAAI;YACJ,QAAQ;YACR,EAAE;YACF,KAAK,EAAE,IAAI,KAAK,EAAE,CAAC,KAAK;SACxB,CAAC,CACF,CAAC;QACF,SAAS,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,QAAyB,EAAU,EAAE,CAAC,QAAQ,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;QAEnH,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IACpC,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,IAAW,EAAE,EAAU;QAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;QAC/E,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAChC,CAAC;IAWD;;;;;;;OAOG;IACH,GAAG,CAAC,IAAW,EAAE,IAAa,EAAE,QAAkB;QACjD,MAAM,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAa,EAAE,SAAmB,EAAoB,EAAE,CAAC,IAAI,CAAC,CAAC;QAC1H,OAAO,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC/B,CAAC;IAID;;;;;;;OAOG;IACH,QAAQ,CAAC,IAAW,EAAE,IAAa,EAAE,QAAkB;QACtD,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAa,EAAE,SAAmB,EAAW,EAAE,CAAC,IAAI,CAAC,CAAC;QACtG,OAAO,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC/B,CAAC;IAMD,MAAM,CAAC,MAAM,CAAsB,IAAY;QAC9C,MAAM,SAAS,GAAG,IAAI,SAAS,EAAE,CAAC;QAElC,OAAO;YACN,GAAG,EAAE,CAAC,QAAQ,EAAE,QAAQ,EAAE,EAAE,EAAE,EAAE,CAAC,SAAS,CAAC,GAAG,CAAC,IAAW,EAAE,QAAQ,EAAE,QAAQ,EAAE,EAAE,CAAC;YACnF,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,IAAW,EAAE,EAAE,CAAC;YACjD,GAAG,EAAE,CAAC,IAAI,EAAE,QAAQ,EAAE,EAAE,CAAC,SAAS,CAAC,GAAG,CAAC,IAAW,EAAE,IAAI,EAAE,QAAQ,CAAQ;SAC1E,CAAC;IACH,CAAC;CACD","sourcesContent":["import type { Logger } from '@rocket.chat/logger';\nimport { Random } from '@rocket.chat/random';\n\nimport { compareByRanking } from '../utils/comparisons';\n\nenum CallbackPriority {\n\tHIGH = -1000,\n\tMEDIUM = 0,\n\tLOW = 1000,\n}\n\ntype Callback<H> = {\n\t(item: unknown, constant?: unknown): Promise<unknown>;\n\thook: H;\n\tid: string;\n\tpriority: CallbackPriority;\n\tstack: string;\n};\n\ntype CallbackTracker<H> = (callback: Callback<H>) => () => void;\n\ntype HookTracker<H> = (params: { hook: H; length: number }) => () => void;\n\nexport class Callbacks<\n\tTChainedCallbackSignatures extends {\n\t\t[key: string]: (item: any, constant?: any) => any;\n\t},\n\tTEventLikeCallbackSignatures extends {\n\t\t[key: string]: (item: any, constant?: any) => any;\n\t},\n\tTHook extends string = keyof TChainedCallbackSignatures & keyof TEventLikeCallbackSignatures & string,\n> {\n\tprivate logger: Logger | undefined = undefined;\n\n\tprivate trackCallback: CallbackTracker<THook> | undefined = undefined;\n\n\tprivate trackHook: HookTracker<THook> | undefined = undefined;\n\n\tprivate callbacks = new Map<THook, Callback<THook>[]>();\n\n\tprivate sequentialRunners = new Map<THook, (item: unknown, constant?: unknown) => Promise<unknown>>();\n\n\tprivate asyncRunners = new Map<THook, (item: unknown, constant?: unknown) => unknown>();\n\n\treadonly priority = CallbackPriority;\n\n\tsetLogger(logger: Logger): void {\n\t\tthis.logger = logger;\n\t}\n\n\tsetMetricsTrackers({ trackCallback, trackHook }: { trackCallback?: CallbackTracker<THook>; trackHook?: HookTracker<THook> }): void {\n\t\tthis.trackCallback = trackCallback;\n\t\tthis.trackHook = trackHook;\n\t}\n\n\tprivate runOne(callback: Callback<THook>, item: unknown, constant: unknown): Promise<unknown> {\n\t\tconst stopTracking = this.trackCallback?.(callback);\n\n\t\treturn Promise.resolve(callback(item, constant)).finally(stopTracking);\n\t}\n\n\tprivate createSequentialRunner(hook: THook, callbacks: Callback<THook>[]): (item: unknown, constant?: unknown) => Promise<unknown> {\n\t\tconst wrapCallback =\n\t\t\t(callback: Callback<THook>) =>\n\t\t\tasync (item: unknown, constant?: unknown): Promise<unknown> => {\n\t\t\t\tthis.logger?.debug(`Executing callback with id ${callback.id} for hook ${callback.hook}`);\n\n\t\t\t\treturn (await this.runOne(callback, item, constant)) ?? item;\n\t\t\t};\n\n\t\tconst identity = <TItem>(item: TItem): Promise<TItem> => Promise.resolve(item);\n\n\t\tconst pipe =\n\t\t\t(curr: (item: unknown, constant?: unknown) => Promise<unknown>, next: (item: unknown, constant?: unknown) => Promise<unknown>) =>\n\t\t\tasync (item: unknown, constant?: unknown): Promise<unknown> =>\n\t\t\t\tnext(await curr(item, constant), constant);\n\n\t\tconst fn = callbacks.map(wrapCallback).reduce(pipe, identity);\n\n\t\treturn async (item: unknown, constant?: unknown): Promise<unknown> => {\n\t\t\tconst stopTracking = this.trackHook?.({ hook, length: callbacks.length });\n\n\t\t\treturn fn(item, constant).finally(() => stopTracking?.());\n\t\t};\n\t}\n\n\tprivate createAsyncRunner(_: THook, callbacks: Callback<THook>[]) {\n\t\treturn (item: unknown, constant?: unknown): unknown => {\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tthrow new Error('callbacks.runAsync on client server not allowed');\n\t\t\t}\n\n\t\t\tfor (const callback of callbacks) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tvoid this.runOne(callback, item, constant);\n\t\t\t\t}, 0);\n\t\t\t}\n\n\t\t\treturn item;\n\t\t};\n\t}\n\n\tgetCallbacks(hook: THook): Callback<THook>[] {\n\t\treturn this.callbacks.get(hook) ?? [];\n\t}\n\n\tsetCallbacks(hook: THook, callbacks: Callback<THook>[]): void {\n\t\tthis.callbacks.set(hook, callbacks);\n\t\tthis.sequentialRunners.set(hook, this.createSequentialRunner(hook, callbacks));\n\t\tthis.asyncRunners.set(hook, this.createAsyncRunner(hook, callbacks));\n\t}\n\n\t/**\n\t * Add a callback function to a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param callback the callback function\n\t * @param priority the callback run priority (order)\n\t * @param id human friendly name for this callback\n\t */\n\tadd<Hook extends keyof TEventLikeCallbackSignatures>(\n\t\thook: Hook,\n\t\tcallback: TEventLikeCallbackSignatures[Hook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<Hook extends keyof TChainedCallbackSignatures>(\n\t\thook: Hook,\n\t\tcallback: TChainedCallbackSignatures[Hook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<TItem, TConstant, TNextItem = TItem>(\n\t\thook: THook,\n\t\tcallback: (item: TItem, constant?: TConstant) => TNextItem,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd(hook: THook, callback: (item: unknown, constant?: unknown) => unknown, priority = this.priority.MEDIUM, id = Random.id()): void {\n\t\tconst callbacks = this.getCallbacks(hook);\n\n\t\tif (callbacks.some((cb) => cb.id === id)) {\n\t\t\treturn;\n\t\t}\n\n\t\tcallbacks.push(\n\t\t\tObject.assign(callback as Callback<THook>, {\n\t\t\t\thook,\n\t\t\t\tpriority,\n\t\t\t\tid,\n\t\t\t\tstack: new Error().stack,\n\t\t\t}),\n\t\t);\n\t\tcallbacks.sort(compareByRanking((callback: Callback<THook>): number => callback.priority ?? this.priority.MEDIUM));\n\n\t\tthis.setCallbacks(hook, callbacks);\n\t}\n\n\t/**\n\t * Remove a callback from a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param id the callback's id\n\t */\n\tremove(hook: THook, id: string): void {\n\t\tconst hooks = this.getCallbacks(hook).filter((callback) => callback.id !== id);\n\t\tthis.setCallbacks(hook, hooks);\n\t}\n\n\trun<Hook extends keyof TEventLikeCallbackSignatures>(hook: Hook, ...args: Parameters<TEventLikeCallbackSignatures[Hook]>): Promise<void>;\n\n\trun<Hook extends keyof TChainedCallbackSignatures>(\n\t\thook: Hook,\n\t\t...args: Parameters<TChainedCallbackSignatures[Hook]>\n\t): Promise<ReturnType<TChainedCallbackSignatures[Hook]>>;\n\n\trun<TItem, TConstant, TNextItem = TItem>(hook: THook, item: TItem, constant?: TConstant): Promise<TNextItem>;\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns returns the item after it's been through all the callbacks for this hook\n\t */\n\trun(hook: THook, item: unknown, constant?: unknown): Promise<unknown> {\n\t\tconst runner = this.sequentialRunners.get(hook) ?? (async (item: unknown, _constant?: unknown): Promise<unknown> => item);\n\t\treturn runner(item, constant);\n\t}\n\n\trunAsync<Hook extends keyof TEventLikeCallbackSignatures>(hook: Hook, ...args: Parameters<TEventLikeCallbackSignatures[Hook]>): void;\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns the post, comment, modifier, etc. on which to run the callbacks\n\t */\n\trunAsync(hook: THook, item: unknown, constant?: unknown): unknown {\n\t\tconst runner = this.asyncRunners.get(hook) ?? ((item: unknown, _constant?: unknown): unknown => item);\n\t\treturn runner(item, constant);\n\t}\n\n\tstatic create<F extends (item: any, constant?: any) => any | Promise<any>>(\n\t\thook: string,\n\t): Cb<Parameters<F>[0], ReturnType<F>, Parameters<F>[1]>;\n\n\tstatic create<I, R, C = undefined>(hook: string): Cb<I, R, C> {\n\t\tconst callbacks = new Callbacks();\n\n\t\treturn {\n\t\t\tadd: (callback, priority, id) => callbacks.add(hook as any, callback, priority, id),\n\t\t\tremove: (id) => callbacks.remove(hook as any, id),\n\t\t\trun: (item, constant) => callbacks.run(hook as any, item, constant) as any,\n\t\t};\n\t}\n}\n\n/**\n * Callback hooks provide an easy way to add extra steps to common operations.\n * @deprecated\n */\ntype Cb<I, R, C = undefined> = {\n\tadd: (\n\t\tcallback: (item: I, constant: C) => Promise<R | undefined | void> | R | undefined | void,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t) => void;\n\tremove: (id: string) => void;\n\trun: (item: I, constant?: C) => Promise<R>;\n};\n"]},"targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/lib/callbacks/callbacksBase.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/callbacks/callbacksBase.ts","inputSourceMap":{"version":3,"file":"lib/callbacks/callbacksBase.ts","sourceRoot":"","sources":["lib/callbacks/callbacksBase.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Logger } from '@rocket.chat/logger';\nimport { Random } from '@rocket.chat/random';\n\nimport { compareByRanking } from '../utils/comparisons';\n\nenum CallbackPriority {\n\tHIGH = -1000,\n\tMEDIUM = 0,\n\tLOW = 1000,\n}\n\ntype Callback<H> = {\n\t(item: unknown, constant?: unknown): Promise<unknown>;\n\thook: H;\n\tid: string;\n\tpriority: CallbackPriority;\n\tstack: string;\n};\n\ntype CallbackTracker<H> = (callback: Callback<H>) => () => void;\n\ntype HookTracker<H> = (params: { hook: H; length: number }) => () => void;\n\nexport class Callbacks<\n\tTChainedCallbackSignatures extends {\n\t\t[key: string]: (item: any, constant?: any) => any;\n\t},\n\tTEventLikeCallbackSignatures extends {\n\t\t[key: string]: (item: any, constant?: any) => any;\n\t},\n\tTHook extends string = keyof TChainedCallbackSignatures & keyof TEventLikeCallbackSignatures & string,\n> {\n\tprivate logger: Logger | undefined = undefined;\n\n\tprivate trackCallback: CallbackTracker<THook> | undefined = undefined;\n\n\tprivate trackHook: HookTracker<THook> | undefined = undefined;\n\n\tprivate callbacks = new Map<THook, Callback<THook>[]>();\n\n\tprivate sequentialRunners = new Map<THook, (item: unknown, constant?: unknown) => Promise<unknown>>();\n\n\tprivate asyncRunners = new Map<THook, (item: unknown, constant?: unknown) => unknown>();\n\n\treadonly priority = CallbackPriority;\n\n\tsetLogger(logger: Logger): void {\n\t\tthis.logger = logger;\n\t}\n\n\tsetMetricsTrackers({ trackCallback, trackHook }: { trackCallback?: CallbackTracker<THook>; trackHook?: HookTracker<THook> }): void {\n\t\tthis.trackCallback = trackCallback;\n\t\tthis.trackHook = trackHook;\n\t}\n\n\tprivate runOne(callback: Callback<THook>, item: unknown, constant: unknown): Promise<unknown> {\n\t\tconst stopTracking = this.trackCallback?.(callback);\n\n\t\treturn Promise.resolve(callback(item, constant)).finally(stopTracking);\n\t}\n\n\tprivate createSequentialRunner(hook: THook, callbacks: Callback<THook>[]): (item: unknown, constant?: unknown) => Promise<unknown> {\n\t\tconst wrapCallback =\n\t\t\t(callback: Callback<THook>) =>\n\t\t\tasync (item: unknown, constant?: unknown): Promise<unknown> => {\n\t\t\t\tthis.logger?.debug(`Executing callback with id ${callback.id} for hook ${callback.hook}`);\n\n\t\t\t\treturn (await this.runOne(callback, item, constant)) ?? item;\n\t\t\t};\n\n\t\tconst identity = <TItem>(item: TItem): Promise<TItem> => Promise.resolve(item);\n\n\t\tconst pipe =\n\t\t\t(curr: (item: unknown, constant?: unknown) => Promise<unknown>, next: (item: unknown, constant?: unknown) => Promise<unknown>) =>\n\t\t\tasync (item: unknown, constant?: unknown): Promise<unknown> =>\n\t\t\t\tnext(await curr(item, constant), constant);\n\n\t\tconst fn = callbacks.map(wrapCallback).reduce(pipe, identity);\n\n\t\treturn async (item: unknown, constant?: unknown): Promise<unknown> => {\n\t\t\tconst stopTracking = this.trackHook?.({ hook, length: callbacks.length });\n\n\t\t\treturn fn(item, constant).finally(() => stopTracking?.());\n\t\t};\n\t}\n\n\tprivate createAsyncRunner(_: THook, callbacks: Callback<THook>[]) {\n\t\treturn (item: unknown, constant?: unknown): unknown => {\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tthrow new Error('callbacks.runAsync on client server not allowed');\n\t\t\t}\n\n\t\t\tfor (const callback of callbacks) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tvoid this.runOne(callback, item, constant);\n\t\t\t\t}, 0);\n\t\t\t}\n\n\t\t\treturn item;\n\t\t};\n\t}\n\n\tgetCallbacks(hook: THook): Callback<THook>[] {\n\t\treturn this.callbacks.get(hook) ?? [];\n\t}\n\n\tsetCallbacks(hook: THook, callbacks: Callback<THook>[]): void {\n\t\tthis.callbacks.set(hook, callbacks);\n\t\tthis.sequentialRunners.set(hook, this.createSequentialRunner(hook, callbacks));\n\t\tthis.asyncRunners.set(hook, this.createAsyncRunner(hook, callbacks));\n\t}\n\n\t/**\n\t * Add a callback function to a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param callback the callback function\n\t * @param priority the callback run priority (order)\n\t * @param id human friendly name for this callback\n\t */\n\tadd<Hook extends keyof TEventLikeCallbackSignatures>(\n\t\thook: Hook,\n\t\tcallback: TEventLikeCallbackSignatures[Hook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<Hook extends keyof TChainedCallbackSignatures>(\n\t\thook: Hook,\n\t\tcallback: TChainedCallbackSignatures[Hook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<TItem, TConstant, TNextItem = TItem>(\n\t\thook: THook,\n\t\tcallback: (item: TItem, constant?: TConstant) => TNextItem,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd(hook: THook, callback: (item: unknown, constant?: unknown) => unknown, priority = this.priority.MEDIUM, id = Random.id()): void {\n\t\tconst callbacks = this.getCallbacks(hook);\n\n\t\tif (callbacks.some((cb) => cb.id === id)) {\n\t\t\treturn;\n\t\t}\n\n\t\tcallbacks.push(\n\t\t\tObject.assign(callback as Callback<THook>, {\n\t\t\t\thook,\n\t\t\t\tpriority,\n\t\t\t\tid,\n\t\t\t\tstack: new Error().stack,\n\t\t\t}),\n\t\t);\n\t\tcallbacks.sort(compareByRanking((callback: Callback<THook>): number => callback.priority ?? this.priority.MEDIUM));\n\n\t\tthis.setCallbacks(hook, callbacks);\n\t}\n\n\t/**\n\t * Remove a callback from a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param id the callback's id\n\t */\n\tremove(hook: THook, id: string): void {\n\t\tconst hooks = this.getCallbacks(hook).filter((callback) => callback.id !== id);\n\t\tthis.setCallbacks(hook, hooks);\n\t}\n\n\trun<Hook extends keyof TEventLikeCallbackSignatures>(hook: Hook, ...args: Parameters<TEventLikeCallbackSignatures[Hook]>): Promise<void>;\n\n\trun<Hook extends keyof TChainedCallbackSignatures>(\n\t\thook: Hook,\n\t\t...args: Parameters<TChainedCallbackSignatures[Hook]>\n\t): Promise<ReturnType<TChainedCallbackSignatures[Hook]>>;\n\n\trun<TItem, TConstant, TNextItem = TItem>(hook: THook, item: TItem, constant?: TConstant): Promise<TNextItem>;\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns returns the item after it's been through all the callbacks for this hook\n\t */\n\trun(hook: THook, item: unknown, constant?: unknown): Promise<unknown> {\n\t\tconst runner = this.sequentialRunners.get(hook) ?? (async (item: unknown, _constant?: unknown): Promise<unknown> => item);\n\t\treturn runner(item, constant);\n\t}\n\n\trunAsync<Hook extends keyof TEventLikeCallbackSignatures>(hook: Hook, ...args: Parameters<TEventLikeCallbackSignatures[Hook]>): void;\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns the post, comment, modifier, etc. on which to run the callbacks\n\t */\n\trunAsync(hook: THook, item: unknown, constant?: unknown): unknown {\n\t\tconst runner = this.asyncRunners.get(hook) ?? ((item: unknown, _constant?: unknown): unknown => item);\n\t\treturn runner(item, constant);\n\t}\n\n\tstatic create<F extends (item: any, constant?: any) => any | Promise<any>>(\n\t\thook: string,\n\t): Cb<Parameters<F>[0], ReturnType<F>, Parameters<F>[1]>;\n\n\tstatic create<I, R, C = undefined>(hook: string): Cb<I, R, C> {\n\t\tconst callbacks = new Callbacks();\n\n\t\treturn {\n\t\t\tadd: (callback, priority, id) => callbacks.add(hook as any, callback, priority, id),\n\t\t\tremove: (id) => callbacks.remove(hook as any, id),\n\t\t\trun: (item, constant) => callbacks.run(hook as any, item, constant) as any,\n\t\t};\n\t}\n}\n\n/**\n * Callback hooks provide an easy way to add extra steps to common operations.\n * @deprecated\n */\ntype Cb<I, R, C = undefined> = {\n\tadd: (\n\t\tcallback: (item: I, constant: C) => Promise<R | undefined | void> | R | undefined | void,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t) => void;\n\tremove: (id: string) => void;\n\trun: (item: I, constant?: C) => Promise<R>;\n};\n"]}}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    module.export({\n      Callbacks: () => Callbacks\n    });\n    let Random;\n    module.link(\"@rocket.chat/random\", {\n      Random(v) {\n        Random = v;\n      }\n    }, 0);\n    let compareByRanking;\n    module.link(\"../utils/comparisons\", {\n      compareByRanking(v) {\n        compareByRanking = v;\n      }\n    }, 1);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    var CallbackPriority;\n    (function (CallbackPriority) {\n      CallbackPriority[CallbackPriority[\"HIGH\"] = -1000] = \"HIGH\";\n      CallbackPriority[CallbackPriority[\"MEDIUM\"] = 0] = \"MEDIUM\";\n      CallbackPriority[CallbackPriority[\"LOW\"] = 1000] = \"LOW\";\n    })(CallbackPriority || (CallbackPriority = {}));\n    class Callbacks {\n      constructor() {\n        this.logger = undefined;\n        this.trackCallback = undefined;\n        this.trackHook = undefined;\n        this.callbacks = new Map();\n        this.sequentialRunners = new Map();\n        this.asyncRunners = new Map();\n        this.priority = CallbackPriority;\n      }\n      setLogger(logger) {\n        this.logger = logger;\n      }\n      setMetricsTrackers(_ref) {\n        let {\n          trackCallback,\n          trackHook\n        } = _ref;\n        this.trackCallback = trackCallback;\n        this.trackHook = trackHook;\n      }\n      runOne(callback, item, constant) {\n        var _this$trackCallback;\n        const stopTracking = (_this$trackCallback = this.trackCallback) === null || _this$trackCallback === void 0 ? void 0 : _this$trackCallback.call(this, callback);\n        return Promise.resolve(callback(item, constant)).finally(stopTracking);\n      }\n      createSequentialRunner(hook, callbacks) {\n        const wrapCallback = callback => async (item, constant) => {\n          var _this$logger, _await$this$runOne;\n          (_this$logger = this.logger) === null || _this$logger === void 0 ? void 0 : _this$logger.debug(\"Executing callback with id \".concat(callback.id, \" for hook \").concat(callback.hook));\n          return (_await$this$runOne = await this.runOne(callback, item, constant)) !== null && _await$this$runOne !== void 0 ? _await$this$runOne : item;\n        };\n        const identity = item => Promise.resolve(item);\n        const pipe = (curr, next) => async (item, constant) => next(await curr(item, constant), constant);\n        const fn = callbacks.map(wrapCallback).reduce(pipe, identity);\n        return async (item, constant) => {\n          var _this$trackHook;\n          const stopTracking = (_this$trackHook = this.trackHook) === null || _this$trackHook === void 0 ? void 0 : _this$trackHook.call(this, {\n            hook,\n            length: callbacks.length\n          });\n          return fn(item, constant).finally(() => stopTracking === null || stopTracking === void 0 ? void 0 : stopTracking());\n        };\n      }\n      createAsyncRunner(_, callbacks) {\n        return (item, constant) => {\n          if (typeof window !== 'undefined') {\n            throw new Error('callbacks.runAsync on client server not allowed');\n          }\n          for (const callback of callbacks) {\n            setTimeout(() => {\n              void this.runOne(callback, item, constant);\n            }, 0);\n          }\n          return item;\n        };\n      }\n      getCallbacks(hook) {\n        var _this$callbacks$get;\n        return (_this$callbacks$get = this.callbacks.get(hook)) !== null && _this$callbacks$get !== void 0 ? _this$callbacks$get : [];\n      }\n      setCallbacks(hook, callbacks) {\n        this.callbacks.set(hook, callbacks);\n        this.sequentialRunners.set(hook, this.createSequentialRunner(hook, callbacks));\n        this.asyncRunners.set(hook, this.createAsyncRunner(hook, callbacks));\n      }\n      add(hook, callback) {\n        let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.priority.MEDIUM;\n        let id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Random.id();\n        const callbacks = this.getCallbacks(hook);\n        if (callbacks.some(cb => cb.id === id)) {\n          return;\n        }\n        callbacks.push(Object.assign(callback, {\n          hook,\n          priority,\n          id,\n          stack: new Error().stack\n        }));\n        callbacks.sort(compareByRanking(callback => {\n          var _callback$priority;\n          return (_callback$priority = callback.priority) !== null && _callback$priority !== void 0 ? _callback$priority : this.priority.MEDIUM;\n        }));\n        this.setCallbacks(hook, callbacks);\n      }\n      /**\n       * Remove a callback from a hook\n       *\n       * @param hook the name of the hook\n       * @param id the callback's id\n       */\n      remove(hook, id) {\n        const hooks = this.getCallbacks(hook).filter(callback => callback.id !== id);\n        this.setCallbacks(hook, hooks);\n      }\n      /**\n       * Successively run all of a hook's callbacks on an item\n       *\n       * @param hook the name of the hook\n       * @param item the post, comment, modifier, etc. on which to run the callbacks\n       * @param constant an optional constant that will be passed along to each callback\n       * @returns returns the item after it's been through all the callbacks for this hook\n       */\n      run(hook, item, constant) {\n        var _this$sequentialRunne;\n        const runner = (_this$sequentialRunne = this.sequentialRunners.get(hook)) !== null && _this$sequentialRunne !== void 0 ? _this$sequentialRunne : async (item, _constant) => item;\n        return runner(item, constant);\n      }\n      /**\n       * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n       *\n       * @param hook the name of the hook\n       * @param item the post, comment, modifier, etc. on which to run the callbacks\n       * @param constant an optional constant that will be passed along to each callback\n       * @returns the post, comment, modifier, etc. on which to run the callbacks\n       */\n      runAsync(hook, item, constant) {\n        var _this$asyncRunners$ge;\n        const runner = (_this$asyncRunners$ge = this.asyncRunners.get(hook)) !== null && _this$asyncRunners$ge !== void 0 ? _this$asyncRunners$ge : (item, _constant) => item;\n        return runner(item, constant);\n      }\n      static create(hook) {\n        const callbacks = new Callbacks();\n        return {\n          add: (callback, priority, id) => callbacks.add(hook, callback, priority, id),\n          remove: id => callbacks.remove(hook, id),\n          run: (item, constant) => callbacks.run(hook, item, constant)\n        };\n      }\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["module","export","Callbacks","Random","link","v","compareByRanking","__reifyWaitForDeps__","CallbackPriority","constructor","logger","undefined","trackCallback","trackHook","callbacks","Map","sequentialRunners","asyncRunners","priority","setLogger","setMetricsTrackers","_ref","runOne","callback","item","constant","_this$trackCallback","stopTracking","call","Promise","resolve","finally","createSequentialRunner","hook","wrapCallback","_this$logger","_await$this$runOne","debug","concat","id","identity","pipe","curr","next","fn","map","reduce","_this$trackHook","length","createAsyncRunner","_","window","Error","setTimeout","getCallbacks","_this$callbacks$get","get","setCallbacks","set","add","arguments","MEDIUM","some","cb","push","Object","assign","stack","sort","_callback$priority","remove","hooks","filter","run","_this$sequentialRunne","runner","_constant","runAsync","_this$asyncRunners$ge","create","__reify_async_result__","_reifyError","self","async"],"sources":["lib/callbacks/callbacksBase.ts"],"sourcesContent":["import type { Logger } from '@rocket.chat/logger';\nimport { Random } from '@rocket.chat/random';\n\nimport { compareByRanking } from '../utils/comparisons';\n\nenum CallbackPriority {\n\tHIGH = -1000,\n\tMEDIUM = 0,\n\tLOW = 1000,\n}\n\ntype Callback<H> = {\n\t(item: unknown, constant?: unknown): Promise<unknown>;\n\thook: H;\n\tid: string;\n\tpriority: CallbackPriority;\n\tstack: string;\n};\n\ntype CallbackTracker<H> = (callback: Callback<H>) => () => void;\n\ntype HookTracker<H> = (params: { hook: H; length: number }) => () => void;\n\nexport class Callbacks<\n\tTChainedCallbackSignatures extends {\n\t\t[key: string]: (item: any, constant?: any) => any;\n\t},\n\tTEventLikeCallbackSignatures extends {\n\t\t[key: string]: (item: any, constant?: any) => any;\n\t},\n\tTHook extends string = keyof TChainedCallbackSignatures & keyof TEventLikeCallbackSignatures & string,\n> {\n\tprivate logger: Logger | undefined = undefined;\n\n\tprivate trackCallback: CallbackTracker<THook> | undefined = undefined;\n\n\tprivate trackHook: HookTracker<THook> | undefined = undefined;\n\n\tprivate callbacks = new Map<THook, Callback<THook>[]>();\n\n\tprivate sequentialRunners = new Map<THook, (item: unknown, constant?: unknown) => Promise<unknown>>();\n\n\tprivate asyncRunners = new Map<THook, (item: unknown, constant?: unknown) => unknown>();\n\n\treadonly priority = CallbackPriority;\n\n\tsetLogger(logger: Logger): void {\n\t\tthis.logger = logger;\n\t}\n\n\tsetMetricsTrackers({ trackCallback, trackHook }: { trackCallback?: CallbackTracker<THook>; trackHook?: HookTracker<THook> }): void {\n\t\tthis.trackCallback = trackCallback;\n\t\tthis.trackHook = trackHook;\n\t}\n\n\tprivate runOne(callback: Callback<THook>, item: unknown, constant: unknown): Promise<unknown> {\n\t\tconst stopTracking = this.trackCallback?.(callback);\n\n\t\treturn Promise.resolve(callback(item, constant)).finally(stopTracking);\n\t}\n\n\tprivate createSequentialRunner(hook: THook, callbacks: Callback<THook>[]): (item: unknown, constant?: unknown) => Promise<unknown> {\n\t\tconst wrapCallback =\n\t\t\t(callback: Callback<THook>) =>\n\t\t\tasync (item: unknown, constant?: unknown): Promise<unknown> => {\n\t\t\t\tthis.logger?.debug(`Executing callback with id ${callback.id} for hook ${callback.hook}`);\n\n\t\t\t\treturn (await this.runOne(callback, item, constant)) ?? item;\n\t\t\t};\n\n\t\tconst identity = <TItem>(item: TItem): Promise<TItem> => Promise.resolve(item);\n\n\t\tconst pipe =\n\t\t\t(curr: (item: unknown, constant?: unknown) => Promise<unknown>, next: (item: unknown, constant?: unknown) => Promise<unknown>) =>\n\t\t\tasync (item: unknown, constant?: unknown): Promise<unknown> =>\n\t\t\t\tnext(await curr(item, constant), constant);\n\n\t\tconst fn = callbacks.map(wrapCallback).reduce(pipe, identity);\n\n\t\treturn async (item: unknown, constant?: unknown): Promise<unknown> => {\n\t\t\tconst stopTracking = this.trackHook?.({ hook, length: callbacks.length });\n\n\t\t\treturn fn(item, constant).finally(() => stopTracking?.());\n\t\t};\n\t}\n\n\tprivate createAsyncRunner(_: THook, callbacks: Callback<THook>[]) {\n\t\treturn (item: unknown, constant?: unknown): unknown => {\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tthrow new Error('callbacks.runAsync on client server not allowed');\n\t\t\t}\n\n\t\t\tfor (const callback of callbacks) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tvoid this.runOne(callback, item, constant);\n\t\t\t\t}, 0);\n\t\t\t}\n\n\t\t\treturn item;\n\t\t};\n\t}\n\n\tgetCallbacks(hook: THook): Callback<THook>[] {\n\t\treturn this.callbacks.get(hook) ?? [];\n\t}\n\n\tsetCallbacks(hook: THook, callbacks: Callback<THook>[]): void {\n\t\tthis.callbacks.set(hook, callbacks);\n\t\tthis.sequentialRunners.set(hook, this.createSequentialRunner(hook, callbacks));\n\t\tthis.asyncRunners.set(hook, this.createAsyncRunner(hook, callbacks));\n\t}\n\n\t/**\n\t * Add a callback function to a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param callback the callback function\n\t * @param priority the callback run priority (order)\n\t * @param id human friendly name for this callback\n\t */\n\tadd<Hook extends keyof TEventLikeCallbackSignatures>(\n\t\thook: Hook,\n\t\tcallback: TEventLikeCallbackSignatures[Hook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<Hook extends keyof TChainedCallbackSignatures>(\n\t\thook: Hook,\n\t\tcallback: TChainedCallbackSignatures[Hook],\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd<TItem, TConstant, TNextItem = TItem>(\n\t\thook: THook,\n\t\tcallback: (item: TItem, constant?: TConstant) => TNextItem,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t): void;\n\n\tadd(hook: THook, callback: (item: unknown, constant?: unknown) => unknown, priority = this.priority.MEDIUM, id = Random.id()): void {\n\t\tconst callbacks = this.getCallbacks(hook);\n\n\t\tif (callbacks.some((cb) => cb.id === id)) {\n\t\t\treturn;\n\t\t}\n\n\t\tcallbacks.push(\n\t\t\tObject.assign(callback as Callback<THook>, {\n\t\t\t\thook,\n\t\t\t\tpriority,\n\t\t\t\tid,\n\t\t\t\tstack: new Error().stack,\n\t\t\t}),\n\t\t);\n\t\tcallbacks.sort(compareByRanking((callback: Callback<THook>): number => callback.priority ?? this.priority.MEDIUM));\n\n\t\tthis.setCallbacks(hook, callbacks);\n\t}\n\n\t/**\n\t * Remove a callback from a hook\n\t *\n\t * @param hook the name of the hook\n\t * @param id the callback's id\n\t */\n\tremove(hook: THook, id: string): void {\n\t\tconst hooks = this.getCallbacks(hook).filter((callback) => callback.id !== id);\n\t\tthis.setCallbacks(hook, hooks);\n\t}\n\n\trun<Hook extends keyof TEventLikeCallbackSignatures>(hook: Hook, ...args: Parameters<TEventLikeCallbackSignatures[Hook]>): Promise<void>;\n\n\trun<Hook extends keyof TChainedCallbackSignatures>(\n\t\thook: Hook,\n\t\t...args: Parameters<TChainedCallbackSignatures[Hook]>\n\t): Promise<ReturnType<TChainedCallbackSignatures[Hook]>>;\n\n\trun<TItem, TConstant, TNextItem = TItem>(hook: THook, item: TItem, constant?: TConstant): Promise<TNextItem>;\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns returns the item after it's been through all the callbacks for this hook\n\t */\n\trun(hook: THook, item: unknown, constant?: unknown): Promise<unknown> {\n\t\tconst runner = this.sequentialRunners.get(hook) ?? (async (item: unknown, _constant?: unknown): Promise<unknown> => item);\n\t\treturn runner(item, constant);\n\t}\n\n\trunAsync<Hook extends keyof TEventLikeCallbackSignatures>(hook: Hook, ...args: Parameters<TEventLikeCallbackSignatures[Hook]>): void;\n\n\t/**\n\t * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n\t *\n\t * @param hook the name of the hook\n\t * @param item the post, comment, modifier, etc. on which to run the callbacks\n\t * @param constant an optional constant that will be passed along to each callback\n\t * @returns the post, comment, modifier, etc. on which to run the callbacks\n\t */\n\trunAsync(hook: THook, item: unknown, constant?: unknown): unknown {\n\t\tconst runner = this.asyncRunners.get(hook) ?? ((item: unknown, _constant?: unknown): unknown => item);\n\t\treturn runner(item, constant);\n\t}\n\n\tstatic create<F extends (item: any, constant?: any) => any | Promise<any>>(\n\t\thook: string,\n\t): Cb<Parameters<F>[0], ReturnType<F>, Parameters<F>[1]>;\n\n\tstatic create<I, R, C = undefined>(hook: string): Cb<I, R, C> {\n\t\tconst callbacks = new Callbacks();\n\n\t\treturn {\n\t\t\tadd: (callback, priority, id) => callbacks.add(hook as any, callback, priority, id),\n\t\t\tremove: (id) => callbacks.remove(hook as any, id),\n\t\t\trun: (item, constant) => callbacks.run(hook as any, item, constant) as any,\n\t\t};\n\t}\n}\n\n/**\n * Callback hooks provide an easy way to add extra steps to common operations.\n * @deprecated\n */\ntype Cb<I, R, C = undefined> = {\n\tadd: (\n\t\tcallback: (item: I, constant: C) => Promise<R | undefined | void> | R | undefined | void,\n\t\tpriority?: CallbackPriority,\n\t\tid?: string,\n\t) => void;\n\tremove: (id: string) => void;\n\trun: (item: I, constant?: C) => Promise<R>;\n};\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"658c002a895c09fd058fcabfab5d56fe2ab195f1"}
