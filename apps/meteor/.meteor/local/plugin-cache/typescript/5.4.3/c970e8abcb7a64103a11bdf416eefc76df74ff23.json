{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/server/services/omnichannel-voip/service.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"server/services/omnichannel-voip/service.ts","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/server/services/omnichannel-voip/service.ts","inputSourceMap":{"version":3,"file":"server/services/omnichannel-voip/service.ts","sourceRoot":"","sources":["server/services/omnichannel-voip/service.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IOmnichannelVoipService, FindVoipRoomsParams } from '@rocket.chat/core-services';\nimport { api, ServiceClassInternal, VoipAsterisk } from '@rocket.chat/core-services';\nimport type {\n\tIVoipExtensionBase,\n\tIVoipExtensionWithAgentInfo,\n\tIAgentExtensionMap,\n\tIRoomCreationResponse,\n\tIUser,\n\tILivechatAgent,\n\tILivechatVisitor,\n\tIVoipRoom,\n\tIVoipRoomClosingInfo,\n} from '@rocket.chat/core-typings';\nimport { isILivechatVisitor, OmnichannelSourceType, isVoipRoom, VoipClientEvents, UserStatus } from '@rocket.chat/core-typings';\nimport { Logger } from '@rocket.chat/logger';\nimport { Users, VoipRoom, PbxEvents } from '@rocket.chat/models';\nimport type { PaginatedResult } from '@rocket.chat/rest-typings';\nimport type { FindOptions } from 'mongodb';\nimport _ from 'underscore';\n\nimport type { IOmniRoomClosingMessage } from './internalTypes';\nimport { sendMessage } from '../../../app/lib/server/functions/sendMessage';\n\nexport class OmnichannelVoipService extends ServiceClassInternal implements IOmnichannelVoipService {\n\tprotected name = 'omnichannel-voip';\n\n\tprivate logger: Logger;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.logger = new Logger('OmnichannelVoipService');\n\n\t\t// handle agent disconnections\n\t\tthis.onEvent('watch.pbxevents', async ({ data }) => {\n\t\t\tconst extension = data.agentExtension;\n\t\t\tif (!extension) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswitch (data.event) {\n\t\t\t\tcase 'ContactStatus': {\n\t\t\t\t\treturn this.processAgentDisconnect(extension);\n\t\t\t\t}\n\t\t\t\tcase 'Hangup': {\n\t\t\t\t\treturn this.processCallerHangup(extension);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async processCallerHangup(extension: string): Promise<void> {\n\t\tthis.logger.info(`Processing hangup event for call with agent on extension ${extension}`);\n\t\tconst agent = await Users.findOneByExtension(extension);\n\t\tif (!agent) {\n\t\t\tthis.logger.error(`No agent found with extension ${extension}. Event won't proceed`);\n\t\t\treturn;\n\t\t}\n\t\tconst currentRoom = await VoipRoom.findOneByAgentId(agent._id);\n\t\tif (!currentRoom) {\n\t\t\tthis.logger.error(`No active call found for agent ${agent._id}`);\n\t\t\treturn;\n\t\t}\n\t\tthis.logger.debug(`Notifying agent ${agent._id} of hangup on room ${currentRoom._id}`);\n\t\tvoid api.broadcast('call.callerhangup', agent._id, { roomId: currentRoom._id });\n\t}\n\n\tprivate async processAgentDisconnect(extension: string): Promise<void> {\n\t\tthis.logger.info(`Processing disconnection event for agent with extension ${extension}`);\n\t\tconst agent = await Users.findOneByExtension(extension);\n\t\tif (!agent) {\n\t\t\tthis.logger.error(`No agent found with extension ${extension}. Event won't proceed`);\n\t\t\t// this should not even be possible, but just in case\n\t\t\treturn;\n\t\t}\n\n\t\tconst openRooms = await VoipRoom.findOpenByAgentId(agent._id).toArray();\n\t\tthis.logger.info(`Closing ${openRooms.length} for agent with extension ${extension}`);\n\t\t// In the best scenario, an agent would only have one active voip room\n\t\t// this is to handle the \"just in case\" scenario of a server and agent failure multiple times\n\t\t// and multiple rooms are left opened for one single agent. Best case this will iterate once\n\t\tfor await (const room of openRooms) {\n\t\t\tawait this.handleEvent(VoipClientEvents['VOIP-CALL-ENDED'], room, agent, 'Agent disconnected abruptly');\n\t\t\tawait this.closeRoom(agent, room, agent, 'voip-call-ended-unexpectedly', { comment: 'Agent disconnected abruptly' });\n\t\t}\n\t}\n\n\tprivate async createVoipRoom(\n\t\trid: string,\n\t\tname: string,\n\t\tagent: { agentId: string; username: string },\n\t\tguest: ILivechatVisitor,\n\t\tdirection: IVoipRoom['direction'],\n\t): Promise<string> {\n\t\tconst status = UserStatus.ONLINE;\n\t\tconst { _id, department: departmentId } = guest;\n\t\tconst newRoomAt = new Date();\n\n\t\t/**\n\t\t * This is a peculiar case for outbound. In case of outbound,\n\t\t * the room is created as soon as the remote use accepts a call.\n\t\t * We generate the DialEnd (dialstatus = 'ANSWERED') only when\n\t\t * the call is picked up. But the agent receiving 200 OK and the ContinuousMonitor\n\t\t * receiving DialEnd happens in any order. So just depending here on\n\t\t * DialEnd would result in creating a room which does not have a correct reference of the call.\n\t\t *\n\t\t * This may result in missed system messages or posting messages to wrong room.\n\t\t * So ContinuousMonitor adds a DialState (dialstatus = 'RINGING') event.\n\t\t * When this event gets added, findone call below will find the latest of\n\t\t * the 'QueueCallerJoin', 'DialEnd', 'DialState' event and create a correct association of the room.\n\t\t */\n\n\t\t// Use latest queue caller join event\n\t\tconst numericPhone = guest?.phone?.[0]?.phoneNumber.replace(/\\D/g, '');\n\t\tconst callStartPbxEvent = await PbxEvents.findOne(\n\t\t\t{\n\t\t\t\t$or: [\n\t\t\t\t\t{\n\t\t\t\t\t\tphone: numericPhone, // Incoming calls will have phone number (connectedlinenum) without any symbol\n\t\t\t\t\t},\n\t\t\t\t\t{ phone: `*${numericPhone}` }, // Outgoing calls will have phone number (connectedlinenum) with * prefix\n\t\t\t\t\t{ phone: `+${numericPhone}` }, // Just in case\n\t\t\t\t],\n\t\t\t\tevent: {\n\t\t\t\t\t$in: ['QueueCallerJoin', 'DialEnd', 'DialState'],\n\t\t\t\t},\n\t\t\t},\n\t\t\t{ sort: { ts: -1 } },\n\t\t);\n\n\t\tif (!callStartPbxEvent) {\n\t\t\tthis.logger.warn(`Call for visitor ${guest._id} is not associated with a pbx event`);\n\t\t}\n\n\t\tconst { queue = 'default', callUniqueId } = callStartPbxEvent || {};\n\n\t\tconst room: IVoipRoom = {\n\t\t\t_id: rid,\n\t\t\tmsgs: 0,\n\t\t\tusersCount: 1,\n\t\t\tlm: newRoomAt,\n\t\t\tname: `${name}-${callUniqueId}`,\n\t\t\tfname: name,\n\t\t\tt: 'v',\n\t\t\tts: newRoomAt,\n\t\t\tdepartmentId,\n\t\t\tv: {\n\t\t\t\t_id,\n\t\t\t\ttoken: guest.token,\n\t\t\t\tstatus,\n\t\t\t\tusername: guest.username,\n\t\t\t\t...(guest?.phone?.[0] && { phone: guest.phone[0].phoneNumber }),\n\t\t\t},\n\t\t\tservedBy: {\n\t\t\t\t_id: agent.agentId,\n\t\t\t\tts: newRoomAt,\n\t\t\t\tusername: agent.username,\n\t\t\t},\n\t\t\topen: true,\n\t\t\twaitingResponse: true,\n\t\t\t// this should be overriden by extraRoomInfo when provided\n\t\t\t// in case it's not provided, we'll use this \"default\" type\n\t\t\tsource: {\n\t\t\t\ttype: OmnichannelSourceType.API,\n\t\t\t},\n\t\t\tqueuedAt: newRoomAt,\n\t\t\t// We assume room is created when call is started (there could be small delay)\n\t\t\tcallStarted: newRoomAt,\n\t\t\tqueue,\n\t\t\tcallUniqueId,\n\n\t\t\tuids: [],\n\t\t\tautoTranslateLanguage: '',\n\t\t\tlivechatData: '',\n\t\t\tu: {\n\t\t\t\t_id: agent.agentId,\n\t\t\t\tusername: agent.username,\n\t\t\t},\n\t\t\tdirection,\n\t\t\t_updatedAt: newRoomAt,\n\t\t};\n\n\t\treturn (await VoipRoom.insertOne(room)).insertedId;\n\t}\n\n\tprivate async getAllocatedExtesionAllocationData(projection: Partial<{ [P in keyof IUser]: number }>): Promise<IUser[]> {\n\t\tconst roles: string[] = ['livechat-agent', 'livechat-manager', 'admin'];\n\t\tconst options = {\n\t\t\tsort: {\n\t\t\t\tusername: 1,\n\t\t\t},\n\t\t\tprojection,\n\t\t};\n\n\t\tconst query = {\n\t\t\textension: { $exists: true },\n\t\t};\n\t\treturn Users.findUsersInRolesWithQuery(roles, query, options).toArray();\n\t}\n\n\tasync getFreeExtensions(): Promise<string[]> {\n\t\tconst allExtensions = await VoipAsterisk.getExtensionList();\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\textension: 1,\n\t\t});\n\t\tconst filtered = _.difference(\n\t\t\t_.pluck(allExtensions.result as IVoipExtensionBase[], 'extension'),\n\t\t\t_.pluck(allocatedExtensions, 'extension'),\n\t\t) as string[];\n\t\treturn filtered;\n\t}\n\n\tasync getExtensionAllocationDetails(): Promise<IAgentExtensionMap[]> {\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\tusername: 1,\n\t\t\troles: 1,\n\t\t\textension: 1,\n\t\t});\n\t\treturn allocatedExtensions.map((user: any) => ({\n\t\t\t_id: user._id,\n\t\t\tagentName: user.username,\n\t\t\textension: user.extension,\n\t\t}));\n\t}\n\n\t/* Voip calls */\n\tasync getNewRoom(\n\t\tguest: ILivechatVisitor,\n\t\tagent: { agentId: string; username: string },\n\t\trid: string,\n\t\tdirection: IVoipRoom['direction'],\n\t\toptions: FindOptions<IVoipRoom> = {},\n\t): Promise<IRoomCreationResponse> {\n\t\tlet room = await VoipRoom.findOneById(rid, options);\n\t\tlet newRoom = false;\n\t\tif (room && !room.open) {\n\t\t\troom = null;\n\t\t}\n\t\tif (room == null) {\n\t\t\tconst name = guest.name || guest.username;\n\t\t\tconst roomId = await this.createVoipRoom(rid, name, agent, guest, direction);\n\t\t\troom = await VoipRoom.findOneVoipRoomById(roomId);\n\t\t\tnewRoom = true;\n\t\t}\n\t\tif (!room) {\n\t\t\tthrow new Error('cannot-access-room');\n\t\t}\n\t\treturn {\n\t\t\troom,\n\t\t\tnewRoom,\n\t\t};\n\t}\n\n\tasync findRoom(token: string, rid: string): Promise<IVoipRoom | null> {\n\t\tconst projection = {\n\t\t\tt: 1,\n\t\t\tdepartmentId: 1,\n\t\t\tservedBy: 1,\n\t\t\topen: 1,\n\t\t\tv: 1,\n\t\t\tts: 1,\n\t\t\tcallUniqueId: 1,\n\t\t};\n\t\tif (!rid) {\n\t\t\treturn VoipRoom.findOneByVisitorToken(token, { projection });\n\t\t}\n\t\treturn VoipRoom.findOneByIdAndVisitorToken(rid, token, { projection });\n\t}\n\n\tasync closeRoom(\n\t\tcloserParam: ILivechatVisitor | ILivechatAgent,\n\t\troom: IVoipRoom,\n\t\tuser: IUser,\n\t\tsysMessageId: 'voip-call-wrapup' | 'voip-call-ended-unexpectedly' = 'voip-call-wrapup',\n\t\toptions?: { comment?: string; tags?: string[] },\n\t): Promise<boolean> {\n\t\tif (!room || room.t !== 'v' || !room.open) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet { closeInfo, closeSystemMsgData } = await this.getBaseRoomClosingData(closerParam, room, sysMessageId, options);\n\t\tconst finalClosingData = await this.getRoomClosingData(closeInfo, closeSystemMsgData, room, sysMessageId, options);\n\t\tcloseInfo = finalClosingData.closeInfo;\n\t\tcloseSystemMsgData = finalClosingData.closeSystemMsgData;\n\n\t\tawait sendMessage(user, closeSystemMsgData, room);\n\n\t\t// There's a race condition between receiving the call and receiving the event\n\t\t// Sometimes it happens before the connection on client, sometimes it happens after\n\t\t// For now, this data will be appended as a metric on room closing\n\t\tawait this.setCallWaitingQueueTimers(room);\n\n\t\tawait VoipRoom.closeByRoomId(room._id, closeInfo);\n\n\t\treturn true;\n\t}\n\n\tasync getRoomClosingData(\n\t\tcloseInfo: IVoipRoomClosingInfo,\n\t\tcloseSystemMsgData: IOmniRoomClosingMessage,\n\t\t_room: IVoipRoom,\n\t\t_sysMessageId: 'voip-call-wrapup' | 'voip-call-ended-unexpectedly',\n\t\t_options?: { comment?: string; tags?: string[] },\n\t): Promise<{ closeInfo: IVoipRoomClosingInfo; closeSystemMsgData: IOmniRoomClosingMessage }> {\n\t\treturn { closeInfo, closeSystemMsgData };\n\t}\n\n\tasync getBaseRoomClosingData(\n\t\tcloserParam: ILivechatVisitor | ILivechatAgent,\n\t\troom: IVoipRoom,\n\t\tsysMessageId: 'voip-call-wrapup' | 'voip-call-ended-unexpectedly',\n\t\t_options?: { comment?: string; tags?: string[] },\n\t): Promise<{ closeInfo: IVoipRoomClosingInfo; closeSystemMsgData: IOmniRoomClosingMessage }> {\n\t\tconst now = new Date();\n\t\tconst closer = isILivechatVisitor(closerParam) ? 'visitor' : 'user';\n\n\t\tconst closeData: IVoipRoomClosingInfo = {\n\t\t\tclosedAt: now,\n\t\t\tcallDuration: now.getTime() - room.ts.getTime(),\n\t\t\tcloser,\n\t\t\tclosedBy: {\n\t\t\t\t_id: closerParam._id,\n\t\t\t\tusername: closerParam.username,\n\t\t\t},\n\t\t};\n\n\t\tconst message: IOmniRoomClosingMessage = {\n\t\t\tt: sysMessageId,\n\t\t\tgroupable: false,\n\t\t};\n\n\t\treturn {\n\t\t\tcloseInfo: closeData,\n\t\t\tcloseSystemMsgData: message,\n\t\t};\n\t}\n\n\tprivate getQueuesForExt(\n\t\text: string,\n\t\tqueueInfo: {\n\t\t\tname: string;\n\t\t\tmembers: string[];\n\t\t}[],\n\t): string[] {\n\t\treturn queueInfo.reduce((acc: string[], queue: { name: string; members: string[] }) => {\n\t\t\tif (queue.members.includes(ext)) {\n\t\t\t\tacc.push(queue.name);\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\t}\n\n\tasync getExtensionListWithAgentData(): Promise<IVoipExtensionWithAgentInfo[]> {\n\t\tconst { result: extensions } = await VoipAsterisk.getExtensionList();\n\t\tconst summary = await (await VoipAsterisk.cachedQueueDetails())();\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\textension: 1,\n\t\t\t_id: 1,\n\t\t\tusername: 1,\n\t\t\tname: 1,\n\t\t});\n\n\t\treturn (extensions as unknown as IVoipExtensionBase[]).map((ext) => {\n\t\t\tconst user = allocatedExtensions.find((ex) => ex.extension === ext.extension);\n\t\t\treturn {\n\t\t\t\tuserId: user?._id,\n\t\t\t\tusername: user?.username,\n\t\t\t\tname: user?.name,\n\t\t\t\tqueues: this.getQueuesForExt(ext.extension, summary),\n\t\t\t\t...ext,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync findVoipRooms({\n\t\tagents,\n\t\topen,\n\t\tcreatedAt,\n\t\tclosedAt,\n\t\tvisitorId,\n\t\ttags,\n\t\tqueue,\n\t\tdirection,\n\t\troomName,\n\t\toptions: { offset = 0, count, fields, sort } = {},\n\t}: FindVoipRoomsParams): Promise<PaginatedResult<{ rooms: IVoipRoom[] }>> {\n\t\tconst { cursor, totalCount } = VoipRoom.findRoomsWithCriteria({\n\t\t\tagents,\n\t\t\topen,\n\t\t\tcreatedAt,\n\t\t\tclosedAt,\n\t\t\ttags,\n\t\t\tqueue,\n\t\t\tvisitorId,\n\t\t\tdirection,\n\t\t\troomName,\n\t\t\toptions: {\n\t\t\t\tsort: sort || { ts: -1 },\n\t\t\t\toffset,\n\t\t\t\tcount,\n\t\t\t\tfields,\n\t\t\t},\n\t\t});\n\n\t\tconst [rooms, total] = await Promise.all([cursor.toArray(), totalCount]);\n\n\t\treturn {\n\t\t\trooms,\n\t\t\tcount: rooms.length,\n\t\t\ttotal,\n\t\t\toffset,\n\t\t};\n\t}\n\n\tprivate async setCallWaitingQueueTimers(room: IVoipRoom): Promise<void> {\n\t\t// Fetch agent connected event for started call\n\t\tif (!room.callUniqueId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst agentCalledEvent = await PbxEvents.findOneByEvent(room.callUniqueId, 'AgentConnect');\n\t\t// Update room with the agentconnect event information (hold time => time call was in queue)\n\t\tawait VoipRoom.updateOne(\n\t\t\t{ _id: room._id },\n\t\t\t{\n\t\t\t\t$set: {\n\t\t\t\t\t// holdtime is stored in seconds, so convert to millis\n\t\t\t\t\tcallWaitingTime: Number(agentCalledEvent?.holdTime) * 1000,\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\t}\n\n\tasync handleEvent(event: VoipClientEvents, room: IVoipRoom, user: IUser, comment?: string): Promise<void> {\n\t\tconst message = {\n\t\t\tt: event,\n\t\t\tmsg: comment,\n\t\t\tgroupable: false as const,\n\t\t\tvoipData: {\n\t\t\t\tcallDuration: Number(room.callDuration) || 0,\n\t\t\t\tcallStarted: room.callStarted?.toISOString() || new Date().toISOString(),\n\t\t\t},\n\t\t};\n\n\t\tif (\n\t\t\tisVoipRoom(room) &&\n\t\t\troom.open &&\n\t\t\troom.callUniqueId &&\n\t\t\t// Check if call exists by looking if we have pbx events of it\n\t\t\t(await PbxEvents.findOneByUniqueId(room.callUniqueId))\n\t\t) {\n\t\t\tawait sendMessage(user, message, room);\n\t\t} else {\n\t\t\tthis.logger.warn({ msg: 'Invalid room type or event type', type: room.t, event });\n\t\t}\n\t}\n\n\tasync getAvailableAgents(\n\t\tincludeExtension?: string,\n\t\ttext?: string,\n\t\tcount?: number,\n\t\toffset?: number,\n\t\tsort?: Record<string, unknown>,\n\t): Promise<{ agents: ILivechatAgent[]; total: number }> {\n\t\tconst { cursor, totalCount } = Users.getAvailableAgentsIncludingExt(includeExtension, text, { count, skip: offset, sort });\n\n\t\tconst [agents, total] = await Promise.all([cursor.toArray(), totalCount]);\n\n\t\treturn {\n\t\t\tagents,\n\t\t\ttotal,\n\t\t};\n\t}\n}\n"]},"targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/server/services/omnichannel-voip/service.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/services/omnichannel-voip/service.ts","inputSourceMap":{"version":3,"file":"server/services/omnichannel-voip/service.ts","sourceRoot":"","sources":["server/services/omnichannel-voip/service.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IOmnichannelVoipService, FindVoipRoomsParams } from '@rocket.chat/core-services';\nimport { api, ServiceClassInternal, VoipAsterisk } from '@rocket.chat/core-services';\nimport type {\n\tIVoipExtensionBase,\n\tIVoipExtensionWithAgentInfo,\n\tIAgentExtensionMap,\n\tIRoomCreationResponse,\n\tIUser,\n\tILivechatAgent,\n\tILivechatVisitor,\n\tIVoipRoom,\n\tIVoipRoomClosingInfo,\n} from '@rocket.chat/core-typings';\nimport { isILivechatVisitor, OmnichannelSourceType, isVoipRoom, VoipClientEvents, UserStatus } from '@rocket.chat/core-typings';\nimport { Logger } from '@rocket.chat/logger';\nimport { Users, VoipRoom, PbxEvents } from '@rocket.chat/models';\nimport type { PaginatedResult } from '@rocket.chat/rest-typings';\nimport type { FindOptions } from 'mongodb';\nimport _ from 'underscore';\n\nimport type { IOmniRoomClosingMessage } from './internalTypes';\nimport { sendMessage } from '../../../app/lib/server/functions/sendMessage';\n\nexport class OmnichannelVoipService extends ServiceClassInternal implements IOmnichannelVoipService {\n\tprotected name = 'omnichannel-voip';\n\n\tprivate logger: Logger;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.logger = new Logger('OmnichannelVoipService');\n\n\t\t// handle agent disconnections\n\t\tthis.onEvent('watch.pbxevents', async ({ data }) => {\n\t\t\tconst extension = data.agentExtension;\n\t\t\tif (!extension) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswitch (data.event) {\n\t\t\t\tcase 'ContactStatus': {\n\t\t\t\t\treturn this.processAgentDisconnect(extension);\n\t\t\t\t}\n\t\t\t\tcase 'Hangup': {\n\t\t\t\t\treturn this.processCallerHangup(extension);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async processCallerHangup(extension: string): Promise<void> {\n\t\tthis.logger.info(`Processing hangup event for call with agent on extension ${extension}`);\n\t\tconst agent = await Users.findOneByExtension(extension);\n\t\tif (!agent) {\n\t\t\tthis.logger.error(`No agent found with extension ${extension}. Event won't proceed`);\n\t\t\treturn;\n\t\t}\n\t\tconst currentRoom = await VoipRoom.findOneByAgentId(agent._id);\n\t\tif (!currentRoom) {\n\t\t\tthis.logger.error(`No active call found for agent ${agent._id}`);\n\t\t\treturn;\n\t\t}\n\t\tthis.logger.debug(`Notifying agent ${agent._id} of hangup on room ${currentRoom._id}`);\n\t\tvoid api.broadcast('call.callerhangup', agent._id, { roomId: currentRoom._id });\n\t}\n\n\tprivate async processAgentDisconnect(extension: string): Promise<void> {\n\t\tthis.logger.info(`Processing disconnection event for agent with extension ${extension}`);\n\t\tconst agent = await Users.findOneByExtension(extension);\n\t\tif (!agent) {\n\t\t\tthis.logger.error(`No agent found with extension ${extension}. Event won't proceed`);\n\t\t\t// this should not even be possible, but just in case\n\t\t\treturn;\n\t\t}\n\n\t\tconst openRooms = await VoipRoom.findOpenByAgentId(agent._id).toArray();\n\t\tthis.logger.info(`Closing ${openRooms.length} for agent with extension ${extension}`);\n\t\t// In the best scenario, an agent would only have one active voip room\n\t\t// this is to handle the \"just in case\" scenario of a server and agent failure multiple times\n\t\t// and multiple rooms are left opened for one single agent. Best case this will iterate once\n\t\tfor await (const room of openRooms) {\n\t\t\tawait this.handleEvent(VoipClientEvents['VOIP-CALL-ENDED'], room, agent, 'Agent disconnected abruptly');\n\t\t\tawait this.closeRoom(agent, room, agent, 'voip-call-ended-unexpectedly', { comment: 'Agent disconnected abruptly' });\n\t\t}\n\t}\n\n\tprivate async createVoipRoom(\n\t\trid: string,\n\t\tname: string,\n\t\tagent: { agentId: string; username: string },\n\t\tguest: ILivechatVisitor,\n\t\tdirection: IVoipRoom['direction'],\n\t): Promise<string> {\n\t\tconst status = UserStatus.ONLINE;\n\t\tconst { _id, department: departmentId } = guest;\n\t\tconst newRoomAt = new Date();\n\n\t\t/**\n\t\t * This is a peculiar case for outbound. In case of outbound,\n\t\t * the room is created as soon as the remote use accepts a call.\n\t\t * We generate the DialEnd (dialstatus = 'ANSWERED') only when\n\t\t * the call is picked up. But the agent receiving 200 OK and the ContinuousMonitor\n\t\t * receiving DialEnd happens in any order. So just depending here on\n\t\t * DialEnd would result in creating a room which does not have a correct reference of the call.\n\t\t *\n\t\t * This may result in missed system messages or posting messages to wrong room.\n\t\t * So ContinuousMonitor adds a DialState (dialstatus = 'RINGING') event.\n\t\t * When this event gets added, findone call below will find the latest of\n\t\t * the 'QueueCallerJoin', 'DialEnd', 'DialState' event and create a correct association of the room.\n\t\t */\n\n\t\t// Use latest queue caller join event\n\t\tconst numericPhone = guest?.phone?.[0]?.phoneNumber.replace(/\\D/g, '');\n\t\tconst callStartPbxEvent = await PbxEvents.findOne(\n\t\t\t{\n\t\t\t\t$or: [\n\t\t\t\t\t{\n\t\t\t\t\t\tphone: numericPhone, // Incoming calls will have phone number (connectedlinenum) without any symbol\n\t\t\t\t\t},\n\t\t\t\t\t{ phone: `*${numericPhone}` }, // Outgoing calls will have phone number (connectedlinenum) with * prefix\n\t\t\t\t\t{ phone: `+${numericPhone}` }, // Just in case\n\t\t\t\t],\n\t\t\t\tevent: {\n\t\t\t\t\t$in: ['QueueCallerJoin', 'DialEnd', 'DialState'],\n\t\t\t\t},\n\t\t\t},\n\t\t\t{ sort: { ts: -1 } },\n\t\t);\n\n\t\tif (!callStartPbxEvent) {\n\t\t\tthis.logger.warn(`Call for visitor ${guest._id} is not associated with a pbx event`);\n\t\t}\n\n\t\tconst { queue = 'default', callUniqueId } = callStartPbxEvent || {};\n\n\t\tconst room: IVoipRoom = {\n\t\t\t_id: rid,\n\t\t\tmsgs: 0,\n\t\t\tusersCount: 1,\n\t\t\tlm: newRoomAt,\n\t\t\tname: `${name}-${callUniqueId}`,\n\t\t\tfname: name,\n\t\t\tt: 'v',\n\t\t\tts: newRoomAt,\n\t\t\tdepartmentId,\n\t\t\tv: {\n\t\t\t\t_id,\n\t\t\t\ttoken: guest.token,\n\t\t\t\tstatus,\n\t\t\t\tusername: guest.username,\n\t\t\t\t...(guest?.phone?.[0] && { phone: guest.phone[0].phoneNumber }),\n\t\t\t},\n\t\t\tservedBy: {\n\t\t\t\t_id: agent.agentId,\n\t\t\t\tts: newRoomAt,\n\t\t\t\tusername: agent.username,\n\t\t\t},\n\t\t\topen: true,\n\t\t\twaitingResponse: true,\n\t\t\t// this should be overriden by extraRoomInfo when provided\n\t\t\t// in case it's not provided, we'll use this \"default\" type\n\t\t\tsource: {\n\t\t\t\ttype: OmnichannelSourceType.API,\n\t\t\t},\n\t\t\tqueuedAt: newRoomAt,\n\t\t\t// We assume room is created when call is started (there could be small delay)\n\t\t\tcallStarted: newRoomAt,\n\t\t\tqueue,\n\t\t\tcallUniqueId,\n\n\t\t\tuids: [],\n\t\t\tautoTranslateLanguage: '',\n\t\t\tlivechatData: '',\n\t\t\tu: {\n\t\t\t\t_id: agent.agentId,\n\t\t\t\tusername: agent.username,\n\t\t\t},\n\t\t\tdirection,\n\t\t\t_updatedAt: newRoomAt,\n\t\t};\n\n\t\treturn (await VoipRoom.insertOne(room)).insertedId;\n\t}\n\n\tprivate async getAllocatedExtesionAllocationData(projection: Partial<{ [P in keyof IUser]: number }>): Promise<IUser[]> {\n\t\tconst roles: string[] = ['livechat-agent', 'livechat-manager', 'admin'];\n\t\tconst options = {\n\t\t\tsort: {\n\t\t\t\tusername: 1,\n\t\t\t},\n\t\t\tprojection,\n\t\t};\n\n\t\tconst query = {\n\t\t\textension: { $exists: true },\n\t\t};\n\t\treturn Users.findUsersInRolesWithQuery(roles, query, options).toArray();\n\t}\n\n\tasync getFreeExtensions(): Promise<string[]> {\n\t\tconst allExtensions = await VoipAsterisk.getExtensionList();\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\textension: 1,\n\t\t});\n\t\tconst filtered = _.difference(\n\t\t\t_.pluck(allExtensions.result as IVoipExtensionBase[], 'extension'),\n\t\t\t_.pluck(allocatedExtensions, 'extension'),\n\t\t) as string[];\n\t\treturn filtered;\n\t}\n\n\tasync getExtensionAllocationDetails(): Promise<IAgentExtensionMap[]> {\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\tusername: 1,\n\t\t\troles: 1,\n\t\t\textension: 1,\n\t\t});\n\t\treturn allocatedExtensions.map((user: any) => ({\n\t\t\t_id: user._id,\n\t\t\tagentName: user.username,\n\t\t\textension: user.extension,\n\t\t}));\n\t}\n\n\t/* Voip calls */\n\tasync getNewRoom(\n\t\tguest: ILivechatVisitor,\n\t\tagent: { agentId: string; username: string },\n\t\trid: string,\n\t\tdirection: IVoipRoom['direction'],\n\t\toptions: FindOptions<IVoipRoom> = {},\n\t): Promise<IRoomCreationResponse> {\n\t\tlet room = await VoipRoom.findOneById(rid, options);\n\t\tlet newRoom = false;\n\t\tif (room && !room.open) {\n\t\t\troom = null;\n\t\t}\n\t\tif (room == null) {\n\t\t\tconst name = guest.name || guest.username;\n\t\t\tconst roomId = await this.createVoipRoom(rid, name, agent, guest, direction);\n\t\t\troom = await VoipRoom.findOneVoipRoomById(roomId);\n\t\t\tnewRoom = true;\n\t\t}\n\t\tif (!room) {\n\t\t\tthrow new Error('cannot-access-room');\n\t\t}\n\t\treturn {\n\t\t\troom,\n\t\t\tnewRoom,\n\t\t};\n\t}\n\n\tasync findRoom(token: string, rid: string): Promise<IVoipRoom | null> {\n\t\tconst projection = {\n\t\t\tt: 1,\n\t\t\tdepartmentId: 1,\n\t\t\tservedBy: 1,\n\t\t\topen: 1,\n\t\t\tv: 1,\n\t\t\tts: 1,\n\t\t\tcallUniqueId: 1,\n\t\t};\n\t\tif (!rid) {\n\t\t\treturn VoipRoom.findOneByVisitorToken(token, { projection });\n\t\t}\n\t\treturn VoipRoom.findOneByIdAndVisitorToken(rid, token, { projection });\n\t}\n\n\tasync closeRoom(\n\t\tcloserParam: ILivechatVisitor | ILivechatAgent,\n\t\troom: IVoipRoom,\n\t\tuser: IUser,\n\t\tsysMessageId: 'voip-call-wrapup' | 'voip-call-ended-unexpectedly' = 'voip-call-wrapup',\n\t\toptions?: { comment?: string; tags?: string[] },\n\t): Promise<boolean> {\n\t\tif (!room || room.t !== 'v' || !room.open) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet { closeInfo, closeSystemMsgData } = await this.getBaseRoomClosingData(closerParam, room, sysMessageId, options);\n\t\tconst finalClosingData = await this.getRoomClosingData(closeInfo, closeSystemMsgData, room, sysMessageId, options);\n\t\tcloseInfo = finalClosingData.closeInfo;\n\t\tcloseSystemMsgData = finalClosingData.closeSystemMsgData;\n\n\t\tawait sendMessage(user, closeSystemMsgData, room);\n\n\t\t// There's a race condition between receiving the call and receiving the event\n\t\t// Sometimes it happens before the connection on client, sometimes it happens after\n\t\t// For now, this data will be appended as a metric on room closing\n\t\tawait this.setCallWaitingQueueTimers(room);\n\n\t\tawait VoipRoom.closeByRoomId(room._id, closeInfo);\n\n\t\treturn true;\n\t}\n\n\tasync getRoomClosingData(\n\t\tcloseInfo: IVoipRoomClosingInfo,\n\t\tcloseSystemMsgData: IOmniRoomClosingMessage,\n\t\t_room: IVoipRoom,\n\t\t_sysMessageId: 'voip-call-wrapup' | 'voip-call-ended-unexpectedly',\n\t\t_options?: { comment?: string; tags?: string[] },\n\t): Promise<{ closeInfo: IVoipRoomClosingInfo; closeSystemMsgData: IOmniRoomClosingMessage }> {\n\t\treturn { closeInfo, closeSystemMsgData };\n\t}\n\n\tasync getBaseRoomClosingData(\n\t\tcloserParam: ILivechatVisitor | ILivechatAgent,\n\t\troom: IVoipRoom,\n\t\tsysMessageId: 'voip-call-wrapup' | 'voip-call-ended-unexpectedly',\n\t\t_options?: { comment?: string; tags?: string[] },\n\t): Promise<{ closeInfo: IVoipRoomClosingInfo; closeSystemMsgData: IOmniRoomClosingMessage }> {\n\t\tconst now = new Date();\n\t\tconst closer = isILivechatVisitor(closerParam) ? 'visitor' : 'user';\n\n\t\tconst closeData: IVoipRoomClosingInfo = {\n\t\t\tclosedAt: now,\n\t\t\tcallDuration: now.getTime() - room.ts.getTime(),\n\t\t\tcloser,\n\t\t\tclosedBy: {\n\t\t\t\t_id: closerParam._id,\n\t\t\t\tusername: closerParam.username,\n\t\t\t},\n\t\t};\n\n\t\tconst message: IOmniRoomClosingMessage = {\n\t\t\tt: sysMessageId,\n\t\t\tgroupable: false,\n\t\t};\n\n\t\treturn {\n\t\t\tcloseInfo: closeData,\n\t\t\tcloseSystemMsgData: message,\n\t\t};\n\t}\n\n\tprivate getQueuesForExt(\n\t\text: string,\n\t\tqueueInfo: {\n\t\t\tname: string;\n\t\t\tmembers: string[];\n\t\t}[],\n\t): string[] {\n\t\treturn queueInfo.reduce((acc: string[], queue: { name: string; members: string[] }) => {\n\t\t\tif (queue.members.includes(ext)) {\n\t\t\t\tacc.push(queue.name);\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\t}\n\n\tasync getExtensionListWithAgentData(): Promise<IVoipExtensionWithAgentInfo[]> {\n\t\tconst { result: extensions } = await VoipAsterisk.getExtensionList();\n\t\tconst summary = await (await VoipAsterisk.cachedQueueDetails())();\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\textension: 1,\n\t\t\t_id: 1,\n\t\t\tusername: 1,\n\t\t\tname: 1,\n\t\t});\n\n\t\treturn (extensions as unknown as IVoipExtensionBase[]).map((ext) => {\n\t\t\tconst user = allocatedExtensions.find((ex) => ex.extension === ext.extension);\n\t\t\treturn {\n\t\t\t\tuserId: user?._id,\n\t\t\t\tusername: user?.username,\n\t\t\t\tname: user?.name,\n\t\t\t\tqueues: this.getQueuesForExt(ext.extension, summary),\n\t\t\t\t...ext,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync findVoipRooms({\n\t\tagents,\n\t\topen,\n\t\tcreatedAt,\n\t\tclosedAt,\n\t\tvisitorId,\n\t\ttags,\n\t\tqueue,\n\t\tdirection,\n\t\troomName,\n\t\toptions: { offset = 0, count, fields, sort } = {},\n\t}: FindVoipRoomsParams): Promise<PaginatedResult<{ rooms: IVoipRoom[] }>> {\n\t\tconst { cursor, totalCount } = VoipRoom.findRoomsWithCriteria({\n\t\t\tagents,\n\t\t\topen,\n\t\t\tcreatedAt,\n\t\t\tclosedAt,\n\t\t\ttags,\n\t\t\tqueue,\n\t\t\tvisitorId,\n\t\t\tdirection,\n\t\t\troomName,\n\t\t\toptions: {\n\t\t\t\tsort: sort || { ts: -1 },\n\t\t\t\toffset,\n\t\t\t\tcount,\n\t\t\t\tfields,\n\t\t\t},\n\t\t});\n\n\t\tconst [rooms, total] = await Promise.all([cursor.toArray(), totalCount]);\n\n\t\treturn {\n\t\t\trooms,\n\t\t\tcount: rooms.length,\n\t\t\ttotal,\n\t\t\toffset,\n\t\t};\n\t}\n\n\tprivate async setCallWaitingQueueTimers(room: IVoipRoom): Promise<void> {\n\t\t// Fetch agent connected event for started call\n\t\tif (!room.callUniqueId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst agentCalledEvent = await PbxEvents.findOneByEvent(room.callUniqueId, 'AgentConnect');\n\t\t// Update room with the agentconnect event information (hold time => time call was in queue)\n\t\tawait VoipRoom.updateOne(\n\t\t\t{ _id: room._id },\n\t\t\t{\n\t\t\t\t$set: {\n\t\t\t\t\t// holdtime is stored in seconds, so convert to millis\n\t\t\t\t\tcallWaitingTime: Number(agentCalledEvent?.holdTime) * 1000,\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\t}\n\n\tasync handleEvent(event: VoipClientEvents, room: IVoipRoom, user: IUser, comment?: string): Promise<void> {\n\t\tconst message = {\n\t\t\tt: event,\n\t\t\tmsg: comment,\n\t\t\tgroupable: false as const,\n\t\t\tvoipData: {\n\t\t\t\tcallDuration: Number(room.callDuration) || 0,\n\t\t\t\tcallStarted: room.callStarted?.toISOString() || new Date().toISOString(),\n\t\t\t},\n\t\t};\n\n\t\tif (\n\t\t\tisVoipRoom(room) &&\n\t\t\troom.open &&\n\t\t\troom.callUniqueId &&\n\t\t\t// Check if call exists by looking if we have pbx events of it\n\t\t\t(await PbxEvents.findOneByUniqueId(room.callUniqueId))\n\t\t) {\n\t\t\tawait sendMessage(user, message, room);\n\t\t} else {\n\t\t\tthis.logger.warn({ msg: 'Invalid room type or event type', type: room.t, event });\n\t\t}\n\t}\n\n\tasync getAvailableAgents(\n\t\tincludeExtension?: string,\n\t\ttext?: string,\n\t\tcount?: number,\n\t\toffset?: number,\n\t\tsort?: Record<string, unknown>,\n\t): Promise<{ agents: ILivechatAgent[]; total: number }> {\n\t\tconst { cursor, totalCount } = Users.getAvailableAgentsIncludingExt(includeExtension, text, { count, skip: offset, sort });\n\n\t\tconst [agents, total] = await Promise.all([cursor.toArray(), totalCount]);\n\n\t\treturn {\n\t\t\tagents,\n\t\t\ttotal,\n\t\t};\n\t}\n}\n"]}}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    let _asyncIterator;\n    module.link(\"@babel/runtime/helpers/asyncIterator\", {\n      default(v) {\n        _asyncIterator = v;\n      }\n    }, 1);\n    module.export({\n      OmnichannelVoipService: () => OmnichannelVoipService\n    });\n    let api, ServiceClassInternal, VoipAsterisk;\n    module.link(\"@rocket.chat/core-services\", {\n      api(v) {\n        api = v;\n      },\n      ServiceClassInternal(v) {\n        ServiceClassInternal = v;\n      },\n      VoipAsterisk(v) {\n        VoipAsterisk = v;\n      }\n    }, 0);\n    let isILivechatVisitor, OmnichannelSourceType, isVoipRoom, VoipClientEvents, UserStatus;\n    module.link(\"@rocket.chat/core-typings\", {\n      isILivechatVisitor(v) {\n        isILivechatVisitor = v;\n      },\n      OmnichannelSourceType(v) {\n        OmnichannelSourceType = v;\n      },\n      isVoipRoom(v) {\n        isVoipRoom = v;\n      },\n      VoipClientEvents(v) {\n        VoipClientEvents = v;\n      },\n      UserStatus(v) {\n        UserStatus = v;\n      }\n    }, 1);\n    let Logger;\n    module.link(\"@rocket.chat/logger\", {\n      Logger(v) {\n        Logger = v;\n      }\n    }, 2);\n    let Users, VoipRoom, PbxEvents;\n    module.link(\"@rocket.chat/models\", {\n      Users(v) {\n        Users = v;\n      },\n      VoipRoom(v) {\n        VoipRoom = v;\n      },\n      PbxEvents(v) {\n        PbxEvents = v;\n      }\n    }, 3);\n    let _;\n    module.link(\"underscore\", {\n      default(v) {\n        _ = v;\n      }\n    }, 4);\n    let sendMessage;\n    module.link(\"../../../app/lib/server/functions/sendMessage\", {\n      sendMessage(v) {\n        sendMessage = v;\n      }\n    }, 5);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    class OmnichannelVoipService extends ServiceClassInternal {\n      constructor() {\n        super();\n        this.name = 'omnichannel-voip';\n        this.logger = void 0;\n        this.logger = new Logger('OmnichannelVoipService');\n        // handle agent disconnections\n        this.onEvent('watch.pbxevents', async _ref => {\n          let {\n            data\n          } = _ref;\n          const extension = data.agentExtension;\n          if (!extension) {\n            return;\n          }\n          switch (data.event) {\n            case 'ContactStatus':\n              {\n                return this.processAgentDisconnect(extension);\n              }\n            case 'Hangup':\n              {\n                return this.processCallerHangup(extension);\n              }\n          }\n        });\n      }\n      async processCallerHangup(extension) {\n        this.logger.info(\"Processing hangup event for call with agent on extension \".concat(extension));\n        const agent = await Users.findOneByExtension(extension);\n        if (!agent) {\n          this.logger.error(\"No agent found with extension \".concat(extension, \". Event won't proceed\"));\n          return;\n        }\n        const currentRoom = await VoipRoom.findOneByAgentId(agent._id);\n        if (!currentRoom) {\n          this.logger.error(\"No active call found for agent \".concat(agent._id));\n          return;\n        }\n        this.logger.debug(\"Notifying agent \".concat(agent._id, \" of hangup on room \").concat(currentRoom._id));\n        void api.broadcast('call.callerhangup', agent._id, {\n          roomId: currentRoom._id\n        });\n      }\n      async processAgentDisconnect(extension) {\n        this.logger.info(\"Processing disconnection event for agent with extension \".concat(extension));\n        const agent = await Users.findOneByExtension(extension);\n        if (!agent) {\n          this.logger.error(\"No agent found with extension \".concat(extension, \". Event won't proceed\"));\n          // this should not even be possible, but just in case\n          return;\n        }\n        const openRooms = await VoipRoom.findOpenByAgentId(agent._id).toArray();\n        this.logger.info(\"Closing \".concat(openRooms.length, \" for agent with extension \").concat(extension));\n        // In the best scenario, an agent would only have one active voip room\n        // this is to handle the \"just in case\" scenario of a server and agent failure multiple times\n        // and multiple rooms are left opened for one single agent. Best case this will iterate once\n        var _iteratorAbruptCompletion = false;\n        var _didIteratorError = false;\n        var _iteratorError;\n        try {\n          for (var _iterator = _asyncIterator(openRooms), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n            const room = _step.value;\n            {\n              await this.handleEvent(VoipClientEvents['VOIP-CALL-ENDED'], room, agent, 'Agent disconnected abruptly');\n              await this.closeRoom(agent, room, agent, 'voip-call-ended-unexpectedly', {\n                comment: 'Agent disconnected abruptly'\n              });\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion && _iterator.return != null) {\n              await _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n      async createVoipRoom(rid, name, agent, guest, direction) {\n        var _guest$phone, _guest$phone$, _guest$phone2;\n        const status = UserStatus.ONLINE;\n        const {\n          _id,\n          department: departmentId\n        } = guest;\n        const newRoomAt = new Date();\n        /**\n         * This is a peculiar case for outbound. In case of outbound,\n         * the room is created as soon as the remote use accepts a call.\n         * We generate the DialEnd (dialstatus = 'ANSWERED') only when\n         * the call is picked up. But the agent receiving 200 OK and the ContinuousMonitor\n         * receiving DialEnd happens in any order. So just depending here on\n         * DialEnd would result in creating a room which does not have a correct reference of the call.\n         *\n         * This may result in missed system messages or posting messages to wrong room.\n         * So ContinuousMonitor adds a DialState (dialstatus = 'RINGING') event.\n         * When this event gets added, findone call below will find the latest of\n         * the 'QueueCallerJoin', 'DialEnd', 'DialState' event and create a correct association of the room.\n         */\n        // Use latest queue caller join event\n        const numericPhone = guest === null || guest === void 0 ? void 0 : (_guest$phone = guest.phone) === null || _guest$phone === void 0 ? void 0 : (_guest$phone$ = _guest$phone[0]) === null || _guest$phone$ === void 0 ? void 0 : _guest$phone$.phoneNumber.replace(/\\D/g, '');\n        const callStartPbxEvent = await PbxEvents.findOne({\n          $or: [{\n            phone: numericPhone // Incoming calls will have phone number (connectedlinenum) without any symbol\n          }, {\n            phone: \"*\".concat(numericPhone)\n          },\n          // Outgoing calls will have phone number (connectedlinenum) with * prefix\n          {\n            phone: \"+\".concat(numericPhone)\n          } // Just in case\n          ],\n          event: {\n            $in: ['QueueCallerJoin', 'DialEnd', 'DialState']\n          }\n        }, {\n          sort: {\n            ts: -1\n          }\n        });\n        if (!callStartPbxEvent) {\n          this.logger.warn(\"Call for visitor \".concat(guest._id, \" is not associated with a pbx event\"));\n        }\n        const {\n          queue = 'default',\n          callUniqueId\n        } = callStartPbxEvent || {};\n        const room = {\n          _id: rid,\n          msgs: 0,\n          usersCount: 1,\n          lm: newRoomAt,\n          name: \"\".concat(name, \"-\").concat(callUniqueId),\n          fname: name,\n          t: 'v',\n          ts: newRoomAt,\n          departmentId,\n          v: _objectSpread({\n            _id,\n            token: guest.token,\n            status,\n            username: guest.username\n          }, (guest === null || guest === void 0 ? void 0 : (_guest$phone2 = guest.phone) === null || _guest$phone2 === void 0 ? void 0 : _guest$phone2[0]) && {\n            phone: guest.phone[0].phoneNumber\n          }),\n          servedBy: {\n            _id: agent.agentId,\n            ts: newRoomAt,\n            username: agent.username\n          },\n          open: true,\n          waitingResponse: true,\n          // this should be overriden by extraRoomInfo when provided\n          // in case it's not provided, we'll use this \"default\" type\n          source: {\n            type: OmnichannelSourceType.API\n          },\n          queuedAt: newRoomAt,\n          // We assume room is created when call is started (there could be small delay)\n          callStarted: newRoomAt,\n          queue,\n          callUniqueId,\n          uids: [],\n          autoTranslateLanguage: '',\n          livechatData: '',\n          u: {\n            _id: agent.agentId,\n            username: agent.username\n          },\n          direction,\n          _updatedAt: newRoomAt\n        };\n        return (await VoipRoom.insertOne(room)).insertedId;\n      }\n      async getAllocatedExtesionAllocationData(projection) {\n        const roles = ['livechat-agent', 'livechat-manager', 'admin'];\n        const options = {\n          sort: {\n            username: 1\n          },\n          projection\n        };\n        const query = {\n          extension: {\n            $exists: true\n          }\n        };\n        return Users.findUsersInRolesWithQuery(roles, query, options).toArray();\n      }\n      async getFreeExtensions() {\n        const allExtensions = await VoipAsterisk.getExtensionList();\n        const allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n          extension: 1\n        });\n        const filtered = _.difference(_.pluck(allExtensions.result, 'extension'), _.pluck(allocatedExtensions, 'extension'));\n        return filtered;\n      }\n      async getExtensionAllocationDetails() {\n        const allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n          username: 1,\n          roles: 1,\n          extension: 1\n        });\n        return allocatedExtensions.map(user => ({\n          _id: user._id,\n          agentName: user.username,\n          extension: user.extension\n        }));\n      }\n      /* Voip calls */\n      async getNewRoom(guest, agent, rid, direction) {\n        let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n        let room = await VoipRoom.findOneById(rid, options);\n        let newRoom = false;\n        if (room && !room.open) {\n          room = null;\n        }\n        if (room == null) {\n          const name = guest.name || guest.username;\n          const roomId = await this.createVoipRoom(rid, name, agent, guest, direction);\n          room = await VoipRoom.findOneVoipRoomById(roomId);\n          newRoom = true;\n        }\n        if (!room) {\n          throw new Error('cannot-access-room');\n        }\n        return {\n          room,\n          newRoom\n        };\n      }\n      async findRoom(token, rid) {\n        const projection = {\n          t: 1,\n          departmentId: 1,\n          servedBy: 1,\n          open: 1,\n          v: 1,\n          ts: 1,\n          callUniqueId: 1\n        };\n        if (!rid) {\n          return VoipRoom.findOneByVisitorToken(token, {\n            projection\n          });\n        }\n        return VoipRoom.findOneByIdAndVisitorToken(rid, token, {\n          projection\n        });\n      }\n      async closeRoom(closerParam, room, user) {\n        let sysMessageId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'voip-call-wrapup';\n        let options = arguments.length > 4 ? arguments[4] : undefined;\n        if (!room || room.t !== 'v' || !room.open) {\n          return false;\n        }\n        let {\n          closeInfo,\n          closeSystemMsgData\n        } = await this.getBaseRoomClosingData(closerParam, room, sysMessageId, options);\n        const finalClosingData = await this.getRoomClosingData(closeInfo, closeSystemMsgData, room, sysMessageId, options);\n        closeInfo = finalClosingData.closeInfo;\n        closeSystemMsgData = finalClosingData.closeSystemMsgData;\n        await sendMessage(user, closeSystemMsgData, room);\n        // There's a race condition between receiving the call and receiving the event\n        // Sometimes it happens before the connection on client, sometimes it happens after\n        // For now, this data will be appended as a metric on room closing\n        await this.setCallWaitingQueueTimers(room);\n        await VoipRoom.closeByRoomId(room._id, closeInfo);\n        return true;\n      }\n      async getRoomClosingData(closeInfo, closeSystemMsgData, _room, _sysMessageId, _options) {\n        return {\n          closeInfo,\n          closeSystemMsgData\n        };\n      }\n      async getBaseRoomClosingData(closerParam, room, sysMessageId, _options) {\n        const now = new Date();\n        const closer = isILivechatVisitor(closerParam) ? 'visitor' : 'user';\n        const closeData = {\n          closedAt: now,\n          callDuration: now.getTime() - room.ts.getTime(),\n          closer,\n          closedBy: {\n            _id: closerParam._id,\n            username: closerParam.username\n          }\n        };\n        const message = {\n          t: sysMessageId,\n          groupable: false\n        };\n        return {\n          closeInfo: closeData,\n          closeSystemMsgData: message\n        };\n      }\n      getQueuesForExt(ext, queueInfo) {\n        return queueInfo.reduce((acc, queue) => {\n          if (queue.members.includes(ext)) {\n            acc.push(queue.name);\n          }\n          return acc;\n        }, []);\n      }\n      async getExtensionListWithAgentData() {\n        const {\n          result: extensions\n        } = await VoipAsterisk.getExtensionList();\n        const summary = await (await VoipAsterisk.cachedQueueDetails())();\n        const allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n          extension: 1,\n          _id: 1,\n          username: 1,\n          name: 1\n        });\n        return extensions.map(ext => {\n          const user = allocatedExtensions.find(ex => ex.extension === ext.extension);\n          return _objectSpread({\n            userId: user === null || user === void 0 ? void 0 : user._id,\n            username: user === null || user === void 0 ? void 0 : user.username,\n            name: user === null || user === void 0 ? void 0 : user.name,\n            queues: this.getQueuesForExt(ext.extension, summary)\n          }, ext);\n        });\n      }\n      async findVoipRooms(_ref2) {\n        let {\n          agents,\n          open,\n          createdAt,\n          closedAt,\n          visitorId,\n          tags,\n          queue,\n          direction,\n          roomName,\n          options: {\n            offset = 0,\n            count,\n            fields,\n            sort\n          } = {}\n        } = _ref2;\n        const {\n          cursor,\n          totalCount\n        } = VoipRoom.findRoomsWithCriteria({\n          agents,\n          open,\n          createdAt,\n          closedAt,\n          tags,\n          queue,\n          visitorId,\n          direction,\n          roomName,\n          options: {\n            sort: sort || {\n              ts: -1\n            },\n            offset,\n            count,\n            fields\n          }\n        });\n        const [rooms, total] = await Promise.all([cursor.toArray(), totalCount]);\n        return {\n          rooms,\n          count: rooms.length,\n          total,\n          offset\n        };\n      }\n      async setCallWaitingQueueTimers(room) {\n        // Fetch agent connected event for started call\n        if (!room.callUniqueId) {\n          return;\n        }\n        const agentCalledEvent = await PbxEvents.findOneByEvent(room.callUniqueId, 'AgentConnect');\n        // Update room with the agentconnect event information (hold time => time call was in queue)\n        await VoipRoom.updateOne({\n          _id: room._id\n        }, {\n          $set: {\n            // holdtime is stored in seconds, so convert to millis\n            callWaitingTime: Number(agentCalledEvent === null || agentCalledEvent === void 0 ? void 0 : agentCalledEvent.holdTime) * 1000\n          }\n        });\n      }\n      async handleEvent(event, room, user, comment) {\n        var _room$callStarted;\n        const message = {\n          t: event,\n          msg: comment,\n          groupable: false,\n          voipData: {\n            callDuration: Number(room.callDuration) || 0,\n            callStarted: ((_room$callStarted = room.callStarted) === null || _room$callStarted === void 0 ? void 0 : _room$callStarted.toISOString()) || new Date().toISOString()\n          }\n        };\n        if (isVoipRoom(room) && room.open && room.callUniqueId && (\n        // Check if call exists by looking if we have pbx events of it\n        await PbxEvents.findOneByUniqueId(room.callUniqueId))) {\n          await sendMessage(user, message, room);\n        } else {\n          this.logger.warn({\n            msg: 'Invalid room type or event type',\n            type: room.t,\n            event\n          });\n        }\n      }\n      async getAvailableAgents(includeExtension, text, count, offset, sort) {\n        const {\n          cursor,\n          totalCount\n        } = Users.getAvailableAgentsIncludingExt(includeExtension, text, {\n          count,\n          skip: offset,\n          sort\n        });\n        const [agents, total] = await Promise.all([cursor.toArray(), totalCount]);\n        return {\n          agents,\n          total\n        };\n      }\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_objectSpread","module","link","default","v","_asyncIterator","export","OmnichannelVoipService","api","ServiceClassInternal","VoipAsterisk","isILivechatVisitor","OmnichannelSourceType","isVoipRoom","VoipClientEvents","UserStatus","Logger","Users","VoipRoom","PbxEvents","_","sendMessage","__reifyWaitForDeps__","constructor","name","logger","onEvent","_ref","data","extension","agentExtension","event","processAgentDisconnect","processCallerHangup","info","concat","agent","findOneByExtension","error","currentRoom","findOneByAgentId","_id","debug","broadcast","roomId","openRooms","findOpenByAgentId","toArray","length","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","room","value","handleEvent","closeRoom","comment","err","return","createVoipRoom","rid","guest","direction","_guest$phone","_guest$phone$","_guest$phone2","status","ONLINE","department","departmentId","newRoomAt","Date","numericPhone","phone","phoneNumber","replace","callStartPbxEvent","findOne","$or","$in","sort","ts","warn","queue","callUniqueId","msgs","usersCount","lm","fname","t","token","username","servedBy","agentId","open","waitingResponse","source","type","API","queuedAt","callStarted","uids","autoTranslateLanguage","livechatData","u","_updatedAt","insertOne","insertedId","getAllocatedExtesionAllocationData","projection","roles","options","query","$exists","findUsersInRolesWithQuery","getFreeExtensions","allExtensions","getExtensionList","allocatedExtensions","filtered","difference","pluck","result","getExtensionAllocationDetails","map","user","agentName","getNewRoom","arguments","undefined","findOneById","newRoom","findOneVoipRoomById","Error","findRoom","findOneByVisitorToken","findOneByIdAndVisitorToken","closerParam","sysMessageId","closeInfo","closeSystemMsgData","getBaseRoomClosingData","finalClosingData","getRoomClosingData","setCallWaitingQueueTimers","closeByRoomId","_room","_sysMessageId","_options","now","closer","closeData","closedAt","callDuration","getTime","closedBy","message","groupable","getQueuesForExt","ext","queueInfo","reduce","acc","members","includes","push","getExtensionListWithAgentData","extensions","summary","cachedQueueDetails","find","ex","userId","queues","findVoipRooms","_ref2","agents","createdAt","visitorId","tags","roomName","offset","count","fields","cursor","totalCount","findRoomsWithCriteria","rooms","total","Promise","all","agentCalledEvent","findOneByEvent","updateOne","$set","callWaitingTime","Number","holdTime","_room$callStarted","msg","voipData","toISOString","findOneByUniqueId","getAvailableAgents","includeExtension","text","getAvailableAgentsIncludingExt","skip","__reify_async_result__","_reifyError","self","async"],"sources":["server/services/omnichannel-voip/service.ts"],"sourcesContent":["import type { IOmnichannelVoipService, FindVoipRoomsParams } from '@rocket.chat/core-services';\nimport { api, ServiceClassInternal, VoipAsterisk } from '@rocket.chat/core-services';\nimport type {\n\tIVoipExtensionBase,\n\tIVoipExtensionWithAgentInfo,\n\tIAgentExtensionMap,\n\tIRoomCreationResponse,\n\tIUser,\n\tILivechatAgent,\n\tILivechatVisitor,\n\tIVoipRoom,\n\tIVoipRoomClosingInfo,\n} from '@rocket.chat/core-typings';\nimport { isILivechatVisitor, OmnichannelSourceType, isVoipRoom, VoipClientEvents, UserStatus } from '@rocket.chat/core-typings';\nimport { Logger } from '@rocket.chat/logger';\nimport { Users, VoipRoom, PbxEvents } from '@rocket.chat/models';\nimport type { PaginatedResult } from '@rocket.chat/rest-typings';\nimport type { FindOptions } from 'mongodb';\nimport _ from 'underscore';\n\nimport type { IOmniRoomClosingMessage } from './internalTypes';\nimport { sendMessage } from '../../../app/lib/server/functions/sendMessage';\n\nexport class OmnichannelVoipService extends ServiceClassInternal implements IOmnichannelVoipService {\n\tprotected name = 'omnichannel-voip';\n\n\tprivate logger: Logger;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.logger = new Logger('OmnichannelVoipService');\n\n\t\t// handle agent disconnections\n\t\tthis.onEvent('watch.pbxevents', async ({ data }) => {\n\t\t\tconst extension = data.agentExtension;\n\t\t\tif (!extension) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswitch (data.event) {\n\t\t\t\tcase 'ContactStatus': {\n\t\t\t\t\treturn this.processAgentDisconnect(extension);\n\t\t\t\t}\n\t\t\t\tcase 'Hangup': {\n\t\t\t\t\treturn this.processCallerHangup(extension);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async processCallerHangup(extension: string): Promise<void> {\n\t\tthis.logger.info(`Processing hangup event for call with agent on extension ${extension}`);\n\t\tconst agent = await Users.findOneByExtension(extension);\n\t\tif (!agent) {\n\t\t\tthis.logger.error(`No agent found with extension ${extension}. Event won't proceed`);\n\t\t\treturn;\n\t\t}\n\t\tconst currentRoom = await VoipRoom.findOneByAgentId(agent._id);\n\t\tif (!currentRoom) {\n\t\t\tthis.logger.error(`No active call found for agent ${agent._id}`);\n\t\t\treturn;\n\t\t}\n\t\tthis.logger.debug(`Notifying agent ${agent._id} of hangup on room ${currentRoom._id}`);\n\t\tvoid api.broadcast('call.callerhangup', agent._id, { roomId: currentRoom._id });\n\t}\n\n\tprivate async processAgentDisconnect(extension: string): Promise<void> {\n\t\tthis.logger.info(`Processing disconnection event for agent with extension ${extension}`);\n\t\tconst agent = await Users.findOneByExtension(extension);\n\t\tif (!agent) {\n\t\t\tthis.logger.error(`No agent found with extension ${extension}. Event won't proceed`);\n\t\t\t// this should not even be possible, but just in case\n\t\t\treturn;\n\t\t}\n\n\t\tconst openRooms = await VoipRoom.findOpenByAgentId(agent._id).toArray();\n\t\tthis.logger.info(`Closing ${openRooms.length} for agent with extension ${extension}`);\n\t\t// In the best scenario, an agent would only have one active voip room\n\t\t// this is to handle the \"just in case\" scenario of a server and agent failure multiple times\n\t\t// and multiple rooms are left opened for one single agent. Best case this will iterate once\n\t\tfor await (const room of openRooms) {\n\t\t\tawait this.handleEvent(VoipClientEvents['VOIP-CALL-ENDED'], room, agent, 'Agent disconnected abruptly');\n\t\t\tawait this.closeRoom(agent, room, agent, 'voip-call-ended-unexpectedly', { comment: 'Agent disconnected abruptly' });\n\t\t}\n\t}\n\n\tprivate async createVoipRoom(\n\t\trid: string,\n\t\tname: string,\n\t\tagent: { agentId: string; username: string },\n\t\tguest: ILivechatVisitor,\n\t\tdirection: IVoipRoom['direction'],\n\t): Promise<string> {\n\t\tconst status = UserStatus.ONLINE;\n\t\tconst { _id, department: departmentId } = guest;\n\t\tconst newRoomAt = new Date();\n\n\t\t/**\n\t\t * This is a peculiar case for outbound. In case of outbound,\n\t\t * the room is created as soon as the remote use accepts a call.\n\t\t * We generate the DialEnd (dialstatus = 'ANSWERED') only when\n\t\t * the call is picked up. But the agent receiving 200 OK and the ContinuousMonitor\n\t\t * receiving DialEnd happens in any order. So just depending here on\n\t\t * DialEnd would result in creating a room which does not have a correct reference of the call.\n\t\t *\n\t\t * This may result in missed system messages or posting messages to wrong room.\n\t\t * So ContinuousMonitor adds a DialState (dialstatus = 'RINGING') event.\n\t\t * When this event gets added, findone call below will find the latest of\n\t\t * the 'QueueCallerJoin', 'DialEnd', 'DialState' event and create a correct association of the room.\n\t\t */\n\n\t\t// Use latest queue caller join event\n\t\tconst numericPhone = guest?.phone?.[0]?.phoneNumber.replace(/\\D/g, '');\n\t\tconst callStartPbxEvent = await PbxEvents.findOne(\n\t\t\t{\n\t\t\t\t$or: [\n\t\t\t\t\t{\n\t\t\t\t\t\tphone: numericPhone, // Incoming calls will have phone number (connectedlinenum) without any symbol\n\t\t\t\t\t},\n\t\t\t\t\t{ phone: `*${numericPhone}` }, // Outgoing calls will have phone number (connectedlinenum) with * prefix\n\t\t\t\t\t{ phone: `+${numericPhone}` }, // Just in case\n\t\t\t\t],\n\t\t\t\tevent: {\n\t\t\t\t\t$in: ['QueueCallerJoin', 'DialEnd', 'DialState'],\n\t\t\t\t},\n\t\t\t},\n\t\t\t{ sort: { ts: -1 } },\n\t\t);\n\n\t\tif (!callStartPbxEvent) {\n\t\t\tthis.logger.warn(`Call for visitor ${guest._id} is not associated with a pbx event`);\n\t\t}\n\n\t\tconst { queue = 'default', callUniqueId } = callStartPbxEvent || {};\n\n\t\tconst room: IVoipRoom = {\n\t\t\t_id: rid,\n\t\t\tmsgs: 0,\n\t\t\tusersCount: 1,\n\t\t\tlm: newRoomAt,\n\t\t\tname: `${name}-${callUniqueId}`,\n\t\t\tfname: name,\n\t\t\tt: 'v',\n\t\t\tts: newRoomAt,\n\t\t\tdepartmentId,\n\t\t\tv: {\n\t\t\t\t_id,\n\t\t\t\ttoken: guest.token,\n\t\t\t\tstatus,\n\t\t\t\tusername: guest.username,\n\t\t\t\t...(guest?.phone?.[0] && { phone: guest.phone[0].phoneNumber }),\n\t\t\t},\n\t\t\tservedBy: {\n\t\t\t\t_id: agent.agentId,\n\t\t\t\tts: newRoomAt,\n\t\t\t\tusername: agent.username,\n\t\t\t},\n\t\t\topen: true,\n\t\t\twaitingResponse: true,\n\t\t\t// this should be overriden by extraRoomInfo when provided\n\t\t\t// in case it's not provided, we'll use this \"default\" type\n\t\t\tsource: {\n\t\t\t\ttype: OmnichannelSourceType.API,\n\t\t\t},\n\t\t\tqueuedAt: newRoomAt,\n\t\t\t// We assume room is created when call is started (there could be small delay)\n\t\t\tcallStarted: newRoomAt,\n\t\t\tqueue,\n\t\t\tcallUniqueId,\n\n\t\t\tuids: [],\n\t\t\tautoTranslateLanguage: '',\n\t\t\tlivechatData: '',\n\t\t\tu: {\n\t\t\t\t_id: agent.agentId,\n\t\t\t\tusername: agent.username,\n\t\t\t},\n\t\t\tdirection,\n\t\t\t_updatedAt: newRoomAt,\n\t\t};\n\n\t\treturn (await VoipRoom.insertOne(room)).insertedId;\n\t}\n\n\tprivate async getAllocatedExtesionAllocationData(projection: Partial<{ [P in keyof IUser]: number }>): Promise<IUser[]> {\n\t\tconst roles: string[] = ['livechat-agent', 'livechat-manager', 'admin'];\n\t\tconst options = {\n\t\t\tsort: {\n\t\t\t\tusername: 1,\n\t\t\t},\n\t\t\tprojection,\n\t\t};\n\n\t\tconst query = {\n\t\t\textension: { $exists: true },\n\t\t};\n\t\treturn Users.findUsersInRolesWithQuery(roles, query, options).toArray();\n\t}\n\n\tasync getFreeExtensions(): Promise<string[]> {\n\t\tconst allExtensions = await VoipAsterisk.getExtensionList();\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\textension: 1,\n\t\t});\n\t\tconst filtered = _.difference(\n\t\t\t_.pluck(allExtensions.result as IVoipExtensionBase[], 'extension'),\n\t\t\t_.pluck(allocatedExtensions, 'extension'),\n\t\t) as string[];\n\t\treturn filtered;\n\t}\n\n\tasync getExtensionAllocationDetails(): Promise<IAgentExtensionMap[]> {\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\tusername: 1,\n\t\t\troles: 1,\n\t\t\textension: 1,\n\t\t});\n\t\treturn allocatedExtensions.map((user: any) => ({\n\t\t\t_id: user._id,\n\t\t\tagentName: user.username,\n\t\t\textension: user.extension,\n\t\t}));\n\t}\n\n\t/* Voip calls */\n\tasync getNewRoom(\n\t\tguest: ILivechatVisitor,\n\t\tagent: { agentId: string; username: string },\n\t\trid: string,\n\t\tdirection: IVoipRoom['direction'],\n\t\toptions: FindOptions<IVoipRoom> = {},\n\t): Promise<IRoomCreationResponse> {\n\t\tlet room = await VoipRoom.findOneById(rid, options);\n\t\tlet newRoom = false;\n\t\tif (room && !room.open) {\n\t\t\troom = null;\n\t\t}\n\t\tif (room == null) {\n\t\t\tconst name = guest.name || guest.username;\n\t\t\tconst roomId = await this.createVoipRoom(rid, name, agent, guest, direction);\n\t\t\troom = await VoipRoom.findOneVoipRoomById(roomId);\n\t\t\tnewRoom = true;\n\t\t}\n\t\tif (!room) {\n\t\t\tthrow new Error('cannot-access-room');\n\t\t}\n\t\treturn {\n\t\t\troom,\n\t\t\tnewRoom,\n\t\t};\n\t}\n\n\tasync findRoom(token: string, rid: string): Promise<IVoipRoom | null> {\n\t\tconst projection = {\n\t\t\tt: 1,\n\t\t\tdepartmentId: 1,\n\t\t\tservedBy: 1,\n\t\t\topen: 1,\n\t\t\tv: 1,\n\t\t\tts: 1,\n\t\t\tcallUniqueId: 1,\n\t\t};\n\t\tif (!rid) {\n\t\t\treturn VoipRoom.findOneByVisitorToken(token, { projection });\n\t\t}\n\t\treturn VoipRoom.findOneByIdAndVisitorToken(rid, token, { projection });\n\t}\n\n\tasync closeRoom(\n\t\tcloserParam: ILivechatVisitor | ILivechatAgent,\n\t\troom: IVoipRoom,\n\t\tuser: IUser,\n\t\tsysMessageId: 'voip-call-wrapup' | 'voip-call-ended-unexpectedly' = 'voip-call-wrapup',\n\t\toptions?: { comment?: string; tags?: string[] },\n\t): Promise<boolean> {\n\t\tif (!room || room.t !== 'v' || !room.open) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet { closeInfo, closeSystemMsgData } = await this.getBaseRoomClosingData(closerParam, room, sysMessageId, options);\n\t\tconst finalClosingData = await this.getRoomClosingData(closeInfo, closeSystemMsgData, room, sysMessageId, options);\n\t\tcloseInfo = finalClosingData.closeInfo;\n\t\tcloseSystemMsgData = finalClosingData.closeSystemMsgData;\n\n\t\tawait sendMessage(user, closeSystemMsgData, room);\n\n\t\t// There's a race condition between receiving the call and receiving the event\n\t\t// Sometimes it happens before the connection on client, sometimes it happens after\n\t\t// For now, this data will be appended as a metric on room closing\n\t\tawait this.setCallWaitingQueueTimers(room);\n\n\t\tawait VoipRoom.closeByRoomId(room._id, closeInfo);\n\n\t\treturn true;\n\t}\n\n\tasync getRoomClosingData(\n\t\tcloseInfo: IVoipRoomClosingInfo,\n\t\tcloseSystemMsgData: IOmniRoomClosingMessage,\n\t\t_room: IVoipRoom,\n\t\t_sysMessageId: 'voip-call-wrapup' | 'voip-call-ended-unexpectedly',\n\t\t_options?: { comment?: string; tags?: string[] },\n\t): Promise<{ closeInfo: IVoipRoomClosingInfo; closeSystemMsgData: IOmniRoomClosingMessage }> {\n\t\treturn { closeInfo, closeSystemMsgData };\n\t}\n\n\tasync getBaseRoomClosingData(\n\t\tcloserParam: ILivechatVisitor | ILivechatAgent,\n\t\troom: IVoipRoom,\n\t\tsysMessageId: 'voip-call-wrapup' | 'voip-call-ended-unexpectedly',\n\t\t_options?: { comment?: string; tags?: string[] },\n\t): Promise<{ closeInfo: IVoipRoomClosingInfo; closeSystemMsgData: IOmniRoomClosingMessage }> {\n\t\tconst now = new Date();\n\t\tconst closer = isILivechatVisitor(closerParam) ? 'visitor' : 'user';\n\n\t\tconst closeData: IVoipRoomClosingInfo = {\n\t\t\tclosedAt: now,\n\t\t\tcallDuration: now.getTime() - room.ts.getTime(),\n\t\t\tcloser,\n\t\t\tclosedBy: {\n\t\t\t\t_id: closerParam._id,\n\t\t\t\tusername: closerParam.username,\n\t\t\t},\n\t\t};\n\n\t\tconst message: IOmniRoomClosingMessage = {\n\t\t\tt: sysMessageId,\n\t\t\tgroupable: false,\n\t\t};\n\n\t\treturn {\n\t\t\tcloseInfo: closeData,\n\t\t\tcloseSystemMsgData: message,\n\t\t};\n\t}\n\n\tprivate getQueuesForExt(\n\t\text: string,\n\t\tqueueInfo: {\n\t\t\tname: string;\n\t\t\tmembers: string[];\n\t\t}[],\n\t): string[] {\n\t\treturn queueInfo.reduce((acc: string[], queue: { name: string; members: string[] }) => {\n\t\t\tif (queue.members.includes(ext)) {\n\t\t\t\tacc.push(queue.name);\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\t}\n\n\tasync getExtensionListWithAgentData(): Promise<IVoipExtensionWithAgentInfo[]> {\n\t\tconst { result: extensions } = await VoipAsterisk.getExtensionList();\n\t\tconst summary = await (await VoipAsterisk.cachedQueueDetails())();\n\t\tconst allocatedExtensions = await this.getAllocatedExtesionAllocationData({\n\t\t\textension: 1,\n\t\t\t_id: 1,\n\t\t\tusername: 1,\n\t\t\tname: 1,\n\t\t});\n\n\t\treturn (extensions as unknown as IVoipExtensionBase[]).map((ext) => {\n\t\t\tconst user = allocatedExtensions.find((ex) => ex.extension === ext.extension);\n\t\t\treturn {\n\t\t\t\tuserId: user?._id,\n\t\t\t\tusername: user?.username,\n\t\t\t\tname: user?.name,\n\t\t\t\tqueues: this.getQueuesForExt(ext.extension, summary),\n\t\t\t\t...ext,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync findVoipRooms({\n\t\tagents,\n\t\topen,\n\t\tcreatedAt,\n\t\tclosedAt,\n\t\tvisitorId,\n\t\ttags,\n\t\tqueue,\n\t\tdirection,\n\t\troomName,\n\t\toptions: { offset = 0, count, fields, sort } = {},\n\t}: FindVoipRoomsParams): Promise<PaginatedResult<{ rooms: IVoipRoom[] }>> {\n\t\tconst { cursor, totalCount } = VoipRoom.findRoomsWithCriteria({\n\t\t\tagents,\n\t\t\topen,\n\t\t\tcreatedAt,\n\t\t\tclosedAt,\n\t\t\ttags,\n\t\t\tqueue,\n\t\t\tvisitorId,\n\t\t\tdirection,\n\t\t\troomName,\n\t\t\toptions: {\n\t\t\t\tsort: sort || { ts: -1 },\n\t\t\t\toffset,\n\t\t\t\tcount,\n\t\t\t\tfields,\n\t\t\t},\n\t\t});\n\n\t\tconst [rooms, total] = await Promise.all([cursor.toArray(), totalCount]);\n\n\t\treturn {\n\t\t\trooms,\n\t\t\tcount: rooms.length,\n\t\t\ttotal,\n\t\t\toffset,\n\t\t};\n\t}\n\n\tprivate async setCallWaitingQueueTimers(room: IVoipRoom): Promise<void> {\n\t\t// Fetch agent connected event for started call\n\t\tif (!room.callUniqueId) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst agentCalledEvent = await PbxEvents.findOneByEvent(room.callUniqueId, 'AgentConnect');\n\t\t// Update room with the agentconnect event information (hold time => time call was in queue)\n\t\tawait VoipRoom.updateOne(\n\t\t\t{ _id: room._id },\n\t\t\t{\n\t\t\t\t$set: {\n\t\t\t\t\t// holdtime is stored in seconds, so convert to millis\n\t\t\t\t\tcallWaitingTime: Number(agentCalledEvent?.holdTime) * 1000,\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\t}\n\n\tasync handleEvent(event: VoipClientEvents, room: IVoipRoom, user: IUser, comment?: string): Promise<void> {\n\t\tconst message = {\n\t\t\tt: event,\n\t\t\tmsg: comment,\n\t\t\tgroupable: false as const,\n\t\t\tvoipData: {\n\t\t\t\tcallDuration: Number(room.callDuration) || 0,\n\t\t\t\tcallStarted: room.callStarted?.toISOString() || new Date().toISOString(),\n\t\t\t},\n\t\t};\n\n\t\tif (\n\t\t\tisVoipRoom(room) &&\n\t\t\troom.open &&\n\t\t\troom.callUniqueId &&\n\t\t\t// Check if call exists by looking if we have pbx events of it\n\t\t\t(await PbxEvents.findOneByUniqueId(room.callUniqueId))\n\t\t) {\n\t\t\tawait sendMessage(user, message, room);\n\t\t} else {\n\t\t\tthis.logger.warn({ msg: 'Invalid room type or event type', type: room.t, event });\n\t\t}\n\t}\n\n\tasync getAvailableAgents(\n\t\tincludeExtension?: string,\n\t\ttext?: string,\n\t\tcount?: number,\n\t\toffset?: number,\n\t\tsort?: Record<string, unknown>,\n\t): Promise<{ agents: ILivechatAgent[]; total: number }> {\n\t\tconst { cursor, totalCount } = Users.getAvailableAgentsIncludingExt(includeExtension, text, { count, skip: offset, sort });\n\n\t\tconst [agents, total] = await Promise.all([cursor.toArray(), totalCount]);\n\n\t\treturn {\n\t\t\tagents,\n\t\t\ttotal,\n\t\t};\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"c970e8abcb7a64103a11bdf416eefc76df74ff23"}
