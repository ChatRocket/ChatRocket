{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/server/lib/ldap/Manager.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"server/lib/ldap/Manager.ts","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/server/lib/ldap/Manager.ts","inputSourceMap":{"version":3,"file":"server/lib/ldap/Manager.ts","sourceRoot":"","sources":["server/lib/ldap/Manager.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ILDAPEntry, LDAPLoginResult, ILDAPUniqueIdentifierField, IUser, LoginUsername, IImportUser } from '@rocket.chat/core-typings';\nimport { Users as UsersRaw } from '@rocket.chat/models';\nimport { SHA256 } from '@rocket.chat/sha256';\nimport ldapEscape from 'ldap-escape';\nimport limax from 'limax';\n// #ToDo: #TODO: Remove Meteor dependencies\nimport { Accounts } from 'meteor/accounts-base';\nimport { Meteor } from 'meteor/meteor';\nimport _ from 'underscore';\n\nimport type { UserConverterOptions } from '../../../app/importer/server/classes/converters/UserConverter';\nimport { setUserAvatar } from '../../../app/lib/server/functions/setUserAvatar';\nimport { settings } from '../../../app/settings/server';\nimport { callbacks } from '../../../lib/callbacks';\nimport { omit } from '../../../lib/utils/omit';\nimport { LDAPConnection } from './Connection';\nimport { logger, authLogger, connLogger } from './Logger';\nimport { LDAPUserConverter } from './UserConverter';\nimport { getLDAPConditionalSetting } from './getLDAPConditionalSetting';\n\nexport class LDAPManager {\n\tpublic static async login(username: string, password: string): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'Init LDAP login', username });\n\n\t\tif (settings.get('LDAP_Enable') !== true) {\n\t\t\treturn this.fallbackToDefaultLogin(username, password);\n\t\t}\n\n\t\tlet ldapUser: ILDAPEntry | undefined;\n\n\t\tconst ldap = new LDAPConnection();\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tawait ldap.connect();\n\t\t\t\tldapUser = await this.findUser(ldap, username, password);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(error);\n\t\t\t}\n\n\t\t\tif (ldapUser === undefined) {\n\t\t\t\treturn this.fallbackToDefaultLogin(username, password);\n\t\t\t}\n\n\t\t\tconst slugifiedUsername = this.slugifyUsername(ldapUser, username);\n\t\t\tconst user = await this.findExistingUser(ldapUser, slugifiedUsername);\n\n\t\t\t// Bind connection to the admin user so that RC has full access to groups in the next steps\n\t\t\tawait ldap.bindAuthenticationUser();\n\t\t\tif (user) {\n\t\t\t\treturn await this.loginExistingUser(ldap, user, ldapUser, password);\n\t\t\t}\n\n\t\t\treturn await this.loginNewUserFromLDAP(slugifiedUsername, ldap, ldapUser, password);\n\t\t} finally {\n\t\t\tldap.disconnect();\n\t\t}\n\t}\n\n\tpublic static async loginAuthenticatedUser(username: string): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'Init LDAP login', username });\n\n\t\tif (settings.get('LDAP_Enable') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet ldapUser: ILDAPEntry | undefined;\n\n\t\tconst ldap = new LDAPConnection();\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tawait ldap.connect();\n\t\t\t\tldapUser = await this.findAuthenticatedUser(ldap, username);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(error);\n\t\t\t}\n\n\t\t\tif (ldapUser === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst slugifiedUsername = this.slugifyUsername(ldapUser, username);\n\t\t\tconst user = await this.findExistingUser(ldapUser, slugifiedUsername);\n\n\t\t\tif (user) {\n\t\t\t\treturn await this.loginExistingUser(ldap, user, ldapUser);\n\t\t\t}\n\n\t\t\treturn await this.loginNewUserFromLDAP(slugifiedUsername, ldap, ldapUser);\n\t\t} finally {\n\t\t\tldap.disconnect();\n\t\t}\n\t}\n\n\tpublic static async testConnection(): Promise<void> {\n\t\ttry {\n\t\t\tconst ldap = new LDAPConnection();\n\t\t\tawait ldap.testConnection();\n\t\t} catch (error) {\n\t\t\tconnLogger.error(error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tpublic static async testSearch(username: string): Promise<void> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\t\tconst ldap = new LDAPConnection();\n\n\t\ttry {\n\t\t\tawait ldap.connect();\n\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tpublic static async syncUserAvatar(user: IUser, ldapUser: ILDAPEntry): Promise<void> {\n\t\tif (!user?._id || settings.get('LDAP_Sync_User_Avatar') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst avatar = this.getAvatarFromUser(ldapUser);\n\t\tif (!avatar) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst hash = SHA256(avatar.toString());\n\t\tif (user.avatarETag === hash) {\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug({ msg: 'Syncing user avatar', username: user.username });\n\n\t\tawait setUserAvatar(user, avatar, 'image/jpeg', 'rest', hash);\n\t}\n\n\t// This method will only find existing users that are already linked to LDAP\n\tprotected static async findExistingLDAPUser(ldapUser: ILDAPEntry): Promise<IUser | undefined> {\n\t\tconst uniqueIdentifierField = this.getLdapUserUniqueID(ldapUser);\n\n\t\tif (uniqueIdentifierField) {\n\t\t\tlogger.debug({ msg: 'Querying user', uniqueId: uniqueIdentifierField.value });\n\t\t\treturn UsersRaw.findOneByLDAPId(uniqueIdentifierField.value, uniqueIdentifierField.attribute);\n\t\t}\n\t}\n\n\tprotected static getConverterOptions(): UserConverterOptions {\n\t\treturn {\n\t\t\tflagEmailsAsVerified: settings.get<boolean>('Accounts_Verify_Email_For_External_Accounts') ?? false,\n\t\t\tskipExistingUsers: false,\n\t\t\tskipUserCallbacks: false,\n\t\t};\n\t}\n\n\tprotected static mapUserData(ldapUser: ILDAPEntry, usedUsername?: string | undefined): IImportUser {\n\t\tconst uniqueId = this.getLdapUserUniqueID(ldapUser);\n\t\tif (!uniqueId) {\n\t\t\tthrow new Error('Failed to generate unique identifier for ldap entry');\n\t\t}\n\n\t\tconst { attribute: idAttribute, value: id } = uniqueId;\n\t\tconst username = this.slugifyUsername(ldapUser, usedUsername || id || '') || undefined;\n\t\tconst emails = this.getLdapEmails(ldapUser, username).map((email) => email.trim());\n\t\tconst name = this.getLdapName(ldapUser) || undefined;\n\t\tconst voipExtension = this.getLdapExtension(ldapUser);\n\n\t\tconst userData: IImportUser = {\n\t\t\ttype: 'user',\n\t\t\temails,\n\t\t\timportIds: [ldapUser.dn],\n\t\t\tusername,\n\t\t\tname,\n\t\t\tvoipExtension,\n\t\t\tservices: {\n\t\t\t\tldap: {\n\t\t\t\t\tidAttribute,\n\t\t\t\t\tid,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tthis.onMapUserData(ldapUser, userData);\n\t\treturn userData;\n\t}\n\n\tprivate static onMapUserData(ldapUser: ILDAPEntry, userData: IImportUser): void {\n\t\tvoid callbacks.run('mapLDAPUserData', userData, ldapUser);\n\t}\n\n\tprivate static async findUser(ldap: LDAPConnection, username: string, password: string): Promise<ILDAPEntry | undefined> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\n\t\ttry {\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\n\t\t\tconst [ldapUser] = users;\n\t\t\tif (!(await ldap.isUserAcceptedByGroupFilter(escapedUsername, ldapUser.dn))) {\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\n\t\t\tif (!(await ldap.authenticate(ldapUser.dn, password))) {\n\t\t\t\tlogger.debug(`Wrong password for ${escapedUsername}`);\n\t\t\t\tthrow new Error('Invalid user or wrong password');\n\t\t\t}\n\n\t\t\tif (settings.get<boolean>('LDAP_Find_User_After_Login')) {\n\t\t\t\t// Do a search as the user and check if they have any result\n\t\t\t\tauthLogger.debug('User authenticated successfully, performing additional search.');\n\t\t\t\tif ((await ldap.searchAndCount(ldapUser.dn, {})) === 0) {\n\t\t\t\t\tauthLogger.debug(`Bind successful but user ${ldapUser.dn} was not found via search`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ldapUser;\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\tprivate static async findAuthenticatedUser(ldap: LDAPConnection, username: string): Promise<ILDAPEntry | undefined> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\n\t\ttry {\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst [ldapUser] = users;\n\n\t\t\tif (settings.get<boolean>('LDAP_Find_User_After_Login')) {\n\t\t\t\t// Do a search as the user and check if they have any result\n\t\t\t\tauthLogger.debug('User authenticated successfully, performing additional search.');\n\t\t\t\tif ((await ldap.searchAndCount(ldapUser.dn, {})) === 0) {\n\t\t\t\t\tauthLogger.debug(`Bind successful but user ${ldapUser.dn} was not found via search`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(await ldap.isUserAcceptedByGroupFilter(escapedUsername, ldapUser.dn))) {\n\t\t\t\tthrow new Error('User not in a valid group');\n\t\t\t}\n\n\t\t\treturn ldapUser;\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\tprivate static async loginNewUserFromLDAP(\n\t\tslugifiedUsername: string,\n\t\tldap: LDAPConnection,\n\t\tldapUser: ILDAPEntry,\n\t\tldapPass?: string,\n\t): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'User does not exist, creating', username: slugifiedUsername });\n\n\t\tlet username: string | undefined;\n\n\t\tif (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n\t\t\tusername = slugifiedUsername;\n\t\t}\n\n\t\t// Create new user\n\t\treturn this.addLdapUser(ldapUser, username, ldapPass, ldap);\n\t}\n\n\tprivate static async addLdapUser(\n\t\tldapUser: ILDAPEntry,\n\t\tusername: string | undefined,\n\t\tpassword: string | undefined,\n\t\tldap: LDAPConnection,\n\t): Promise<LDAPLoginResult> {\n\t\tconst user = await this.syncUserForLogin(ldapUser, undefined, username);\n\n\t\tif (!user) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.onLogin(ldapUser, user, password, ldap, true);\n\n\t\treturn {\n\t\t\tuserId: user._id,\n\t\t};\n\t}\n\n\tprivate static async onLogin(\n\t\tldapUser: ILDAPEntry,\n\t\tuser: IUser,\n\t\tpassword: string | undefined,\n\t\tldap: LDAPConnection,\n\t\tisNewUser: boolean,\n\t): Promise<void> {\n\t\tlogger.debug('running onLDAPLogin');\n\t\tif (settings.get<boolean>('LDAP_Login_Fallback') && typeof password === 'string' && password.trim() !== '') {\n\t\t\tawait Accounts.setPasswordAsync(user._id, password, { logout: false });\n\t\t}\n\n\t\tawait this.syncUserAvatar(user, ldapUser);\n\t\tawait callbacks.run('onLDAPLogin', { user, ldapUser, isNewUser }, ldap);\n\t}\n\n\tprivate static async loginExistingUser(\n\t\tldap: LDAPConnection,\n\t\tuser: IUser,\n\t\tldapUser: ILDAPEntry,\n\t\tpassword?: string,\n\t): Promise<LDAPLoginResult> {\n\t\tif (user.ldap !== true && settings.get('LDAP_Merge_Existing_Users') !== true) {\n\t\t\tlogger.debug('User exists without \"ldap: true\"');\n\t\t\tthrow new Meteor.Error(\n\t\t\t\t'LDAP-login-error',\n\t\t\t\t`LDAP Authentication succeeded, but there's already an existing user with provided username [${user.username}] in Mongo.`,\n\t\t\t);\n\t\t}\n\n\t\t// If we're merging an ldap user with a local user, then we need to sync the data even if 'update data on login' is off.\n\t\tconst forceUserSync = !user.ldap;\n\n\t\tconst syncData = forceUserSync || (settings.get<boolean>('LDAP_Update_Data_On_Login') ?? true);\n\t\tlogger.debug({ msg: 'Logging user in', syncData });\n\t\tconst updatedUser = (syncData && (await this.syncUserForLogin(ldapUser, user))) || user;\n\n\t\tawait this.onLogin(ldapUser, updatedUser, password, ldap, false);\n\t\treturn {\n\t\t\tuserId: user._id,\n\t\t};\n\t}\n\n\tprivate static async syncUserForLogin(\n\t\tldapUser: ILDAPEntry,\n\t\texistingUser?: IUser,\n\t\tusedUsername?: string | undefined,\n\t): Promise<IUser | undefined> {\n\t\tlogger.debug({\n\t\t\tmsg: 'Syncing user data',\n\t\t\tldapUser: omit(ldapUser, '_raw'),\n\t\t\tuser: { ...(existingUser && { email: existingUser.emails, _id: existingUser._id }) },\n\t\t});\n\n\t\tconst userData = this.mapUserData(ldapUser, usedUsername);\n\n\t\t// make sure to persist existing user data when passing to sync/convert\n\t\t// TODO this is only needed because ImporterDataConverter assigns a default role and type if nothing is set. we might need to figure out a better way and stop doing that there\n\t\tif (existingUser) {\n\t\t\tif (!userData.roles && existingUser.roles) {\n\t\t\t\tuserData.roles = existingUser.roles;\n\t\t\t}\n\t\t\tif (!userData.type && existingUser.type) {\n\t\t\t\tuserData.type = existingUser.type as IImportUser['type'];\n\t\t\t}\n\t\t}\n\n\t\tconst options = this.getConverterOptions();\n\t\tawait LDAPUserConverter.convertSingleUser(userData, options);\n\n\t\treturn existingUser || this.findExistingLDAPUser(ldapUser);\n\t}\n\n\tprivate static getLdapUserUniqueID(ldapUser: ILDAPEntry): ILDAPUniqueIdentifierField | undefined {\n\t\tlet uniqueIdentifierField: string | string[] | undefined = settings.get<string>('LDAP_Unique_Identifier_Field');\n\n\t\tif (uniqueIdentifierField) {\n\t\t\tuniqueIdentifierField = uniqueIdentifierField.replace(/\\s/g, '').split(',');\n\t\t} else {\n\t\t\tuniqueIdentifierField = [];\n\t\t}\n\n\t\tlet userSearchField: string | string[] | undefined = getLDAPConditionalSetting<string>('LDAP_User_Search_Field');\n\n\t\tif (userSearchField) {\n\t\t\tuserSearchField = userSearchField.replace(/\\s/g, '').split(',');\n\t\t} else {\n\t\t\tuserSearchField = [];\n\t\t}\n\n\t\tuniqueIdentifierField = uniqueIdentifierField.concat(userSearchField);\n\t\tif (!uniqueIdentifierField.length) {\n\t\t\tuniqueIdentifierField.push('dn');\n\t\t}\n\n\t\tconst key = uniqueIdentifierField.find((field) => !_.isEmpty(ldapUser._raw[field]));\n\t\tif (key) {\n\t\t\treturn {\n\t\t\t\tattribute: key,\n\t\t\t\tvalue: ldapUser._raw[key].toString('hex'),\n\t\t\t};\n\t\t}\n\n\t\tconnLogger.warn('Failed to generate unique identifier for ldap entry');\n\t\tconnLogger.debug(ldapUser);\n\t}\n\n\tprivate static ldapKeyExists(ldapUser: ILDAPEntry, key: string): boolean {\n\t\treturn !_.isEmpty(ldapUser[key.trim()]);\n\t}\n\n\tprivate static getLdapString(ldapUser: ILDAPEntry, key: string): string {\n\t\treturn ldapUser[key.trim()];\n\t}\n\n\tprivate static getLdapDynamicValue(ldapUser: ILDAPEntry, attributeSetting: string | undefined): string | undefined {\n\t\tif (!attributeSetting) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the attribute setting is a template, then convert the variables in it\n\t\tif (attributeSetting.includes('#{')) {\n\t\t\treturn attributeSetting.replace(/#{(.+?)}/g, (_match, field) => {\n\t\t\t\tconst key = field.trim();\n\n\t\t\t\tif (this.ldapKeyExists(ldapUser, key)) {\n\t\t\t\t\treturn this.getLdapString(ldapUser, key);\n\t\t\t\t}\n\n\t\t\t\treturn '';\n\t\t\t});\n\t\t}\n\n\t\t// If it's not a template, then treat the setting as a CSV list of possible attribute names and return the first valid one.\n\t\tconst attributeList: string[] = attributeSetting.replace(/\\s/g, '').split(',');\n\t\tconst key = attributeList.find((field) => this.ldapKeyExists(ldapUser, field));\n\t\tif (key) {\n\t\t\treturn this.getLdapString(ldapUser, key);\n\t\t}\n\t}\n\n\tprivate static getLdapName(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst nameAttributes = getLDAPConditionalSetting<string | undefined>('LDAP_Name_Field');\n\t\treturn this.getLdapDynamicValue(ldapUser, nameAttributes);\n\t}\n\n\tprivate static getLdapExtension(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst extensionAttribute = settings.get<string>('LDAP_Extension_Field');\n\t\tif (!extensionAttribute) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.getLdapString(ldapUser, extensionAttribute);\n\t}\n\n\tprivate static getLdapEmails(ldapUser: ILDAPEntry, username?: string): string[] {\n\t\tconst emailAttributes = getLDAPConditionalSetting<string>('LDAP_Email_Field');\n\t\tif (emailAttributes) {\n\t\t\tconst attributeList: string[] = emailAttributes.replace(/\\s/g, '').split(',');\n\t\t\tconst key = attributeList.find((field) => this.ldapKeyExists(ldapUser, field));\n\n\t\t\tconst emails: string[] = [].concat(key ? ldapUser[key.trim()] : []);\n\t\t\tconst filteredEmails = emails.filter((email) => email.includes('@'));\n\n\t\t\tif (filteredEmails.length) {\n\t\t\t\treturn filteredEmails;\n\t\t\t}\n\t\t}\n\n\t\tif (settings.get('LDAP_Default_Domain') !== '' && username) {\n\t\t\treturn [`${username}@${settings.get('LDAP_Default_Domain')}`];\n\t\t}\n\n\t\tif (ldapUser.mail?.includes('@')) {\n\t\t\treturn [ldapUser.mail];\n\t\t}\n\n\t\tlogger.debug(ldapUser);\n\t\tthrow new Error('Failed to get email address from LDAP user');\n\t}\n\n\tprivate static slugify(text: string): string {\n\t\tif (settings.get('UTF8_Names_Slugify') !== true) {\n\t\t\treturn text;\n\t\t}\n\n\t\ttext = limax(text, { replacement: '.' });\n\t\treturn text.replace(/[^0-9a-z-_.]/g, '');\n\t}\n\n\tprivate static slugifyUsername(ldapUser: ILDAPEntry, requestUsername: string): string {\n\t\tif (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n\t\t\tconst username = this.getLdapUsername(ldapUser);\n\t\t\tif (username) {\n\t\t\t\treturn this.slugify(username);\n\t\t\t}\n\t\t}\n\n\t\treturn this.slugify(requestUsername);\n\t}\n\n\tprotected static getLdapUsername(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst usernameField = getLDAPConditionalSetting('LDAP_Username_Field') as string;\n\t\treturn this.getLdapDynamicValue(ldapUser, usernameField);\n\t}\n\n\t// This method will find existing users by LDAP id or by username.\n\tprivate static async findExistingUser(ldapUser: ILDAPEntry, slugifiedUsername: string): Promise<IUser | undefined> {\n\t\tconst user = await this.findExistingLDAPUser(ldapUser);\n\t\tif (user) {\n\t\t\treturn user;\n\t\t}\n\n\t\t// If we don't have that ldap user linked yet, check if there's any non-ldap user with the same username\n\t\treturn UsersRaw.findOneWithoutLDAPByUsernameIgnoringCase(slugifiedUsername);\n\t}\n\n\tprivate static fallbackToDefaultLogin(username: LoginUsername, password: string): LDAPLoginResult {\n\t\tif (typeof username === 'string') {\n\t\t\tif (username.indexOf('@') === -1) {\n\t\t\t\tusername = { username };\n\t\t\t} else {\n\t\t\t\tusername = { email: username };\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug({ msg: 'Fallback to default account system', username });\n\n\t\tconst loginRequest = {\n\t\t\tuser: username,\n\t\t\tpassword: {\n\t\t\t\tdigest: SHA256(password),\n\t\t\t\talgorithm: 'sha-256',\n\t\t\t},\n\t\t};\n\n\t\treturn Accounts._runLoginHandlers(this, loginRequest);\n\t}\n\n\tprivate static getAvatarFromUser(ldapUser: ILDAPEntry): any | undefined {\n\t\tconst avatarField = String(settings.get('LDAP_Avatar_Field') || '').trim();\n\t\tif (avatarField && ldapUser._raw[avatarField]) {\n\t\t\treturn ldapUser._raw[avatarField];\n\t\t}\n\n\t\tif (ldapUser._raw.thumbnailPhoto) {\n\t\t\treturn ldapUser._raw.thumbnailPhoto;\n\t\t}\n\n\t\tif (ldapUser._raw.jpegPhoto) {\n\t\t\treturn ldapUser._raw.jpegPhoto;\n\t\t}\n\t}\n}\n"]},"targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/server/lib/ldap/Manager.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/lib/ldap/Manager.ts","inputSourceMap":{"version":3,"file":"server/lib/ldap/Manager.ts","sourceRoot":"","sources":["server/lib/ldap/Manager.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ILDAPEntry, LDAPLoginResult, ILDAPUniqueIdentifierField, IUser, LoginUsername, IImportUser } from '@rocket.chat/core-typings';\nimport { Users as UsersRaw } from '@rocket.chat/models';\nimport { SHA256 } from '@rocket.chat/sha256';\nimport ldapEscape from 'ldap-escape';\nimport limax from 'limax';\n// #ToDo: #TODO: Remove Meteor dependencies\nimport { Accounts } from 'meteor/accounts-base';\nimport { Meteor } from 'meteor/meteor';\nimport _ from 'underscore';\n\nimport type { UserConverterOptions } from '../../../app/importer/server/classes/converters/UserConverter';\nimport { setUserAvatar } from '../../../app/lib/server/functions/setUserAvatar';\nimport { settings } from '../../../app/settings/server';\nimport { callbacks } from '../../../lib/callbacks';\nimport { omit } from '../../../lib/utils/omit';\nimport { LDAPConnection } from './Connection';\nimport { logger, authLogger, connLogger } from './Logger';\nimport { LDAPUserConverter } from './UserConverter';\nimport { getLDAPConditionalSetting } from './getLDAPConditionalSetting';\n\nexport class LDAPManager {\n\tpublic static async login(username: string, password: string): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'Init LDAP login', username });\n\n\t\tif (settings.get('LDAP_Enable') !== true) {\n\t\t\treturn this.fallbackToDefaultLogin(username, password);\n\t\t}\n\n\t\tlet ldapUser: ILDAPEntry | undefined;\n\n\t\tconst ldap = new LDAPConnection();\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tawait ldap.connect();\n\t\t\t\tldapUser = await this.findUser(ldap, username, password);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(error);\n\t\t\t}\n\n\t\t\tif (ldapUser === undefined) {\n\t\t\t\treturn this.fallbackToDefaultLogin(username, password);\n\t\t\t}\n\n\t\t\tconst slugifiedUsername = this.slugifyUsername(ldapUser, username);\n\t\t\tconst user = await this.findExistingUser(ldapUser, slugifiedUsername);\n\n\t\t\t// Bind connection to the admin user so that RC has full access to groups in the next steps\n\t\t\tawait ldap.bindAuthenticationUser();\n\t\t\tif (user) {\n\t\t\t\treturn await this.loginExistingUser(ldap, user, ldapUser, password);\n\t\t\t}\n\n\t\t\treturn await this.loginNewUserFromLDAP(slugifiedUsername, ldap, ldapUser, password);\n\t\t} finally {\n\t\t\tldap.disconnect();\n\t\t}\n\t}\n\n\tpublic static async loginAuthenticatedUser(username: string): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'Init LDAP login', username });\n\n\t\tif (settings.get('LDAP_Enable') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet ldapUser: ILDAPEntry | undefined;\n\n\t\tconst ldap = new LDAPConnection();\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tawait ldap.connect();\n\t\t\t\tldapUser = await this.findAuthenticatedUser(ldap, username);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(error);\n\t\t\t}\n\n\t\t\tif (ldapUser === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst slugifiedUsername = this.slugifyUsername(ldapUser, username);\n\t\t\tconst user = await this.findExistingUser(ldapUser, slugifiedUsername);\n\n\t\t\tif (user) {\n\t\t\t\treturn await this.loginExistingUser(ldap, user, ldapUser);\n\t\t\t}\n\n\t\t\treturn await this.loginNewUserFromLDAP(slugifiedUsername, ldap, ldapUser);\n\t\t} finally {\n\t\t\tldap.disconnect();\n\t\t}\n\t}\n\n\tpublic static async testConnection(): Promise<void> {\n\t\ttry {\n\t\t\tconst ldap = new LDAPConnection();\n\t\t\tawait ldap.testConnection();\n\t\t} catch (error) {\n\t\t\tconnLogger.error(error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tpublic static async testSearch(username: string): Promise<void> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\t\tconst ldap = new LDAPConnection();\n\n\t\ttry {\n\t\t\tawait ldap.connect();\n\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tpublic static async syncUserAvatar(user: IUser, ldapUser: ILDAPEntry): Promise<void> {\n\t\tif (!user?._id || settings.get('LDAP_Sync_User_Avatar') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst avatar = this.getAvatarFromUser(ldapUser);\n\t\tif (!avatar) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst hash = SHA256(avatar.toString());\n\t\tif (user.avatarETag === hash) {\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug({ msg: 'Syncing user avatar', username: user.username });\n\n\t\tawait setUserAvatar(user, avatar, 'image/jpeg', 'rest', hash);\n\t}\n\n\t// This method will only find existing users that are already linked to LDAP\n\tprotected static async findExistingLDAPUser(ldapUser: ILDAPEntry): Promise<IUser | undefined> {\n\t\tconst uniqueIdentifierField = this.getLdapUserUniqueID(ldapUser);\n\n\t\tif (uniqueIdentifierField) {\n\t\t\tlogger.debug({ msg: 'Querying user', uniqueId: uniqueIdentifierField.value });\n\t\t\treturn UsersRaw.findOneByLDAPId(uniqueIdentifierField.value, uniqueIdentifierField.attribute);\n\t\t}\n\t}\n\n\tprotected static getConverterOptions(): UserConverterOptions {\n\t\treturn {\n\t\t\tflagEmailsAsVerified: settings.get<boolean>('Accounts_Verify_Email_For_External_Accounts') ?? false,\n\t\t\tskipExistingUsers: false,\n\t\t\tskipUserCallbacks: false,\n\t\t};\n\t}\n\n\tprotected static mapUserData(ldapUser: ILDAPEntry, usedUsername?: string | undefined): IImportUser {\n\t\tconst uniqueId = this.getLdapUserUniqueID(ldapUser);\n\t\tif (!uniqueId) {\n\t\t\tthrow new Error('Failed to generate unique identifier for ldap entry');\n\t\t}\n\n\t\tconst { attribute: idAttribute, value: id } = uniqueId;\n\t\tconst username = this.slugifyUsername(ldapUser, usedUsername || id || '') || undefined;\n\t\tconst emails = this.getLdapEmails(ldapUser, username).map((email) => email.trim());\n\t\tconst name = this.getLdapName(ldapUser) || undefined;\n\t\tconst voipExtension = this.getLdapExtension(ldapUser);\n\n\t\tconst userData: IImportUser = {\n\t\t\ttype: 'user',\n\t\t\temails,\n\t\t\timportIds: [ldapUser.dn],\n\t\t\tusername,\n\t\t\tname,\n\t\t\tvoipExtension,\n\t\t\tservices: {\n\t\t\t\tldap: {\n\t\t\t\t\tidAttribute,\n\t\t\t\t\tid,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tthis.onMapUserData(ldapUser, userData);\n\t\treturn userData;\n\t}\n\n\tprivate static onMapUserData(ldapUser: ILDAPEntry, userData: IImportUser): void {\n\t\tvoid callbacks.run('mapLDAPUserData', userData, ldapUser);\n\t}\n\n\tprivate static async findUser(ldap: LDAPConnection, username: string, password: string): Promise<ILDAPEntry | undefined> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\n\t\ttry {\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\n\t\t\tconst [ldapUser] = users;\n\t\t\tif (!(await ldap.isUserAcceptedByGroupFilter(escapedUsername, ldapUser.dn))) {\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\n\t\t\tif (!(await ldap.authenticate(ldapUser.dn, password))) {\n\t\t\t\tlogger.debug(`Wrong password for ${escapedUsername}`);\n\t\t\t\tthrow new Error('Invalid user or wrong password');\n\t\t\t}\n\n\t\t\tif (settings.get<boolean>('LDAP_Find_User_After_Login')) {\n\t\t\t\t// Do a search as the user and check if they have any result\n\t\t\t\tauthLogger.debug('User authenticated successfully, performing additional search.');\n\t\t\t\tif ((await ldap.searchAndCount(ldapUser.dn, {})) === 0) {\n\t\t\t\t\tauthLogger.debug(`Bind successful but user ${ldapUser.dn} was not found via search`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ldapUser;\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\tprivate static async findAuthenticatedUser(ldap: LDAPConnection, username: string): Promise<ILDAPEntry | undefined> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\n\t\ttry {\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst [ldapUser] = users;\n\n\t\t\tif (settings.get<boolean>('LDAP_Find_User_After_Login')) {\n\t\t\t\t// Do a search as the user and check if they have any result\n\t\t\t\tauthLogger.debug('User authenticated successfully, performing additional search.');\n\t\t\t\tif ((await ldap.searchAndCount(ldapUser.dn, {})) === 0) {\n\t\t\t\t\tauthLogger.debug(`Bind successful but user ${ldapUser.dn} was not found via search`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(await ldap.isUserAcceptedByGroupFilter(escapedUsername, ldapUser.dn))) {\n\t\t\t\tthrow new Error('User not in a valid group');\n\t\t\t}\n\n\t\t\treturn ldapUser;\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\tprivate static async loginNewUserFromLDAP(\n\t\tslugifiedUsername: string,\n\t\tldap: LDAPConnection,\n\t\tldapUser: ILDAPEntry,\n\t\tldapPass?: string,\n\t): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'User does not exist, creating', username: slugifiedUsername });\n\n\t\tlet username: string | undefined;\n\n\t\tif (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n\t\t\tusername = slugifiedUsername;\n\t\t}\n\n\t\t// Create new user\n\t\treturn this.addLdapUser(ldapUser, username, ldapPass, ldap);\n\t}\n\n\tprivate static async addLdapUser(\n\t\tldapUser: ILDAPEntry,\n\t\tusername: string | undefined,\n\t\tpassword: string | undefined,\n\t\tldap: LDAPConnection,\n\t): Promise<LDAPLoginResult> {\n\t\tconst user = await this.syncUserForLogin(ldapUser, undefined, username);\n\n\t\tif (!user) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.onLogin(ldapUser, user, password, ldap, true);\n\n\t\treturn {\n\t\t\tuserId: user._id,\n\t\t};\n\t}\n\n\tprivate static async onLogin(\n\t\tldapUser: ILDAPEntry,\n\t\tuser: IUser,\n\t\tpassword: string | undefined,\n\t\tldap: LDAPConnection,\n\t\tisNewUser: boolean,\n\t): Promise<void> {\n\t\tlogger.debug('running onLDAPLogin');\n\t\tif (settings.get<boolean>('LDAP_Login_Fallback') && typeof password === 'string' && password.trim() !== '') {\n\t\t\tawait Accounts.setPasswordAsync(user._id, password, { logout: false });\n\t\t}\n\n\t\tawait this.syncUserAvatar(user, ldapUser);\n\t\tawait callbacks.run('onLDAPLogin', { user, ldapUser, isNewUser }, ldap);\n\t}\n\n\tprivate static async loginExistingUser(\n\t\tldap: LDAPConnection,\n\t\tuser: IUser,\n\t\tldapUser: ILDAPEntry,\n\t\tpassword?: string,\n\t): Promise<LDAPLoginResult> {\n\t\tif (user.ldap !== true && settings.get('LDAP_Merge_Existing_Users') !== true) {\n\t\t\tlogger.debug('User exists without \"ldap: true\"');\n\t\t\tthrow new Meteor.Error(\n\t\t\t\t'LDAP-login-error',\n\t\t\t\t`LDAP Authentication succeeded, but there's already an existing user with provided username [${user.username}] in Mongo.`,\n\t\t\t);\n\t\t}\n\n\t\t// If we're merging an ldap user with a local user, then we need to sync the data even if 'update data on login' is off.\n\t\tconst forceUserSync = !user.ldap;\n\n\t\tconst syncData = forceUserSync || (settings.get<boolean>('LDAP_Update_Data_On_Login') ?? true);\n\t\tlogger.debug({ msg: 'Logging user in', syncData });\n\t\tconst updatedUser = (syncData && (await this.syncUserForLogin(ldapUser, user))) || user;\n\n\t\tawait this.onLogin(ldapUser, updatedUser, password, ldap, false);\n\t\treturn {\n\t\t\tuserId: user._id,\n\t\t};\n\t}\n\n\tprivate static async syncUserForLogin(\n\t\tldapUser: ILDAPEntry,\n\t\texistingUser?: IUser,\n\t\tusedUsername?: string | undefined,\n\t): Promise<IUser | undefined> {\n\t\tlogger.debug({\n\t\t\tmsg: 'Syncing user data',\n\t\t\tldapUser: omit(ldapUser, '_raw'),\n\t\t\tuser: { ...(existingUser && { email: existingUser.emails, _id: existingUser._id }) },\n\t\t});\n\n\t\tconst userData = this.mapUserData(ldapUser, usedUsername);\n\n\t\t// make sure to persist existing user data when passing to sync/convert\n\t\t// TODO this is only needed because ImporterDataConverter assigns a default role and type if nothing is set. we might need to figure out a better way and stop doing that there\n\t\tif (existingUser) {\n\t\t\tif (!userData.roles && existingUser.roles) {\n\t\t\t\tuserData.roles = existingUser.roles;\n\t\t\t}\n\t\t\tif (!userData.type && existingUser.type) {\n\t\t\t\tuserData.type = existingUser.type as IImportUser['type'];\n\t\t\t}\n\t\t}\n\n\t\tconst options = this.getConverterOptions();\n\t\tawait LDAPUserConverter.convertSingleUser(userData, options);\n\n\t\treturn existingUser || this.findExistingLDAPUser(ldapUser);\n\t}\n\n\tprivate static getLdapUserUniqueID(ldapUser: ILDAPEntry): ILDAPUniqueIdentifierField | undefined {\n\t\tlet uniqueIdentifierField: string | string[] | undefined = settings.get<string>('LDAP_Unique_Identifier_Field');\n\n\t\tif (uniqueIdentifierField) {\n\t\t\tuniqueIdentifierField = uniqueIdentifierField.replace(/\\s/g, '').split(',');\n\t\t} else {\n\t\t\tuniqueIdentifierField = [];\n\t\t}\n\n\t\tlet userSearchField: string | string[] | undefined = getLDAPConditionalSetting<string>('LDAP_User_Search_Field');\n\n\t\tif (userSearchField) {\n\t\t\tuserSearchField = userSearchField.replace(/\\s/g, '').split(',');\n\t\t} else {\n\t\t\tuserSearchField = [];\n\t\t}\n\n\t\tuniqueIdentifierField = uniqueIdentifierField.concat(userSearchField);\n\t\tif (!uniqueIdentifierField.length) {\n\t\t\tuniqueIdentifierField.push('dn');\n\t\t}\n\n\t\tconst key = uniqueIdentifierField.find((field) => !_.isEmpty(ldapUser._raw[field]));\n\t\tif (key) {\n\t\t\treturn {\n\t\t\t\tattribute: key,\n\t\t\t\tvalue: ldapUser._raw[key].toString('hex'),\n\t\t\t};\n\t\t}\n\n\t\tconnLogger.warn('Failed to generate unique identifier for ldap entry');\n\t\tconnLogger.debug(ldapUser);\n\t}\n\n\tprivate static ldapKeyExists(ldapUser: ILDAPEntry, key: string): boolean {\n\t\treturn !_.isEmpty(ldapUser[key.trim()]);\n\t}\n\n\tprivate static getLdapString(ldapUser: ILDAPEntry, key: string): string {\n\t\treturn ldapUser[key.trim()];\n\t}\n\n\tprivate static getLdapDynamicValue(ldapUser: ILDAPEntry, attributeSetting: string | undefined): string | undefined {\n\t\tif (!attributeSetting) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the attribute setting is a template, then convert the variables in it\n\t\tif (attributeSetting.includes('#{')) {\n\t\t\treturn attributeSetting.replace(/#{(.+?)}/g, (_match, field) => {\n\t\t\t\tconst key = field.trim();\n\n\t\t\t\tif (this.ldapKeyExists(ldapUser, key)) {\n\t\t\t\t\treturn this.getLdapString(ldapUser, key);\n\t\t\t\t}\n\n\t\t\t\treturn '';\n\t\t\t});\n\t\t}\n\n\t\t// If it's not a template, then treat the setting as a CSV list of possible attribute names and return the first valid one.\n\t\tconst attributeList: string[] = attributeSetting.replace(/\\s/g, '').split(',');\n\t\tconst key = attributeList.find((field) => this.ldapKeyExists(ldapUser, field));\n\t\tif (key) {\n\t\t\treturn this.getLdapString(ldapUser, key);\n\t\t}\n\t}\n\n\tprivate static getLdapName(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst nameAttributes = getLDAPConditionalSetting<string | undefined>('LDAP_Name_Field');\n\t\treturn this.getLdapDynamicValue(ldapUser, nameAttributes);\n\t}\n\n\tprivate static getLdapExtension(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst extensionAttribute = settings.get<string>('LDAP_Extension_Field');\n\t\tif (!extensionAttribute) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.getLdapString(ldapUser, extensionAttribute);\n\t}\n\n\tprivate static getLdapEmails(ldapUser: ILDAPEntry, username?: string): string[] {\n\t\tconst emailAttributes = getLDAPConditionalSetting<string>('LDAP_Email_Field');\n\t\tif (emailAttributes) {\n\t\t\tconst attributeList: string[] = emailAttributes.replace(/\\s/g, '').split(',');\n\t\t\tconst key = attributeList.find((field) => this.ldapKeyExists(ldapUser, field));\n\n\t\t\tconst emails: string[] = [].concat(key ? ldapUser[key.trim()] : []);\n\t\t\tconst filteredEmails = emails.filter((email) => email.includes('@'));\n\n\t\t\tif (filteredEmails.length) {\n\t\t\t\treturn filteredEmails;\n\t\t\t}\n\t\t}\n\n\t\tif (settings.get('LDAP_Default_Domain') !== '' && username) {\n\t\t\treturn [`${username}@${settings.get('LDAP_Default_Domain')}`];\n\t\t}\n\n\t\tif (ldapUser.mail?.includes('@')) {\n\t\t\treturn [ldapUser.mail];\n\t\t}\n\n\t\tlogger.debug(ldapUser);\n\t\tthrow new Error('Failed to get email address from LDAP user');\n\t}\n\n\tprivate static slugify(text: string): string {\n\t\tif (settings.get('UTF8_Names_Slugify') !== true) {\n\t\t\treturn text;\n\t\t}\n\n\t\ttext = limax(text, { replacement: '.' });\n\t\treturn text.replace(/[^0-9a-z-_.]/g, '');\n\t}\n\n\tprivate static slugifyUsername(ldapUser: ILDAPEntry, requestUsername: string): string {\n\t\tif (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n\t\t\tconst username = this.getLdapUsername(ldapUser);\n\t\t\tif (username) {\n\t\t\t\treturn this.slugify(username);\n\t\t\t}\n\t\t}\n\n\t\treturn this.slugify(requestUsername);\n\t}\n\n\tprotected static getLdapUsername(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst usernameField = getLDAPConditionalSetting('LDAP_Username_Field') as string;\n\t\treturn this.getLdapDynamicValue(ldapUser, usernameField);\n\t}\n\n\t// This method will find existing users by LDAP id or by username.\n\tprivate static async findExistingUser(ldapUser: ILDAPEntry, slugifiedUsername: string): Promise<IUser | undefined> {\n\t\tconst user = await this.findExistingLDAPUser(ldapUser);\n\t\tif (user) {\n\t\t\treturn user;\n\t\t}\n\n\t\t// If we don't have that ldap user linked yet, check if there's any non-ldap user with the same username\n\t\treturn UsersRaw.findOneWithoutLDAPByUsernameIgnoringCase(slugifiedUsername);\n\t}\n\n\tprivate static fallbackToDefaultLogin(username: LoginUsername, password: string): LDAPLoginResult {\n\t\tif (typeof username === 'string') {\n\t\t\tif (username.indexOf('@') === -1) {\n\t\t\t\tusername = { username };\n\t\t\t} else {\n\t\t\t\tusername = { email: username };\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug({ msg: 'Fallback to default account system', username });\n\n\t\tconst loginRequest = {\n\t\t\tuser: username,\n\t\t\tpassword: {\n\t\t\t\tdigest: SHA256(password),\n\t\t\t\talgorithm: 'sha-256',\n\t\t\t},\n\t\t};\n\n\t\treturn Accounts._runLoginHandlers(this, loginRequest);\n\t}\n\n\tprivate static getAvatarFromUser(ldapUser: ILDAPEntry): any | undefined {\n\t\tconst avatarField = String(settings.get('LDAP_Avatar_Field') || '').trim();\n\t\tif (avatarField && ldapUser._raw[avatarField]) {\n\t\t\treturn ldapUser._raw[avatarField];\n\t\t}\n\n\t\tif (ldapUser._raw.thumbnailPhoto) {\n\t\t\treturn ldapUser._raw.thumbnailPhoto;\n\t\t}\n\n\t\tif (ldapUser._raw.jpegPhoto) {\n\t\t\treturn ldapUser._raw.jpegPhoto;\n\t\t}\n\t}\n}\n"]}}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    let _taggedTemplateLiteral;\n    module.link(\"@babel/runtime/helpers/taggedTemplateLiteral\", {\n      default(v) {\n        _taggedTemplateLiteral = v;\n      }\n    }, 1);\n    var _templateObject, _templateObject2, _templateObject3;\n    module.export({\n      LDAPManager: () => LDAPManager\n    });\n    let UsersRaw;\n    module.link(\"@rocket.chat/models\", {\n      Users(v) {\n        UsersRaw = v;\n      }\n    }, 0);\n    let SHA256;\n    module.link(\"@rocket.chat/sha256\", {\n      SHA256(v) {\n        SHA256 = v;\n      }\n    }, 1);\n    let ldapEscape;\n    module.link(\"ldap-escape\", {\n      default(v) {\n        ldapEscape = v;\n      }\n    }, 2);\n    let limax;\n    module.link(\"limax\", {\n      default(v) {\n        limax = v;\n      }\n    }, 3);\n    let Accounts;\n    module.link(\"meteor/accounts-base\", {\n      Accounts(v) {\n        Accounts = v;\n      }\n    }, 4);\n    let Meteor;\n    module.link(\"meteor/meteor\", {\n      Meteor(v) {\n        Meteor = v;\n      }\n    }, 5);\n    let _;\n    module.link(\"underscore\", {\n      default(v) {\n        _ = v;\n      }\n    }, 6);\n    let setUserAvatar;\n    module.link(\"../../../app/lib/server/functions/setUserAvatar\", {\n      setUserAvatar(v) {\n        setUserAvatar = v;\n      }\n    }, 7);\n    let settings;\n    module.link(\"../../../app/settings/server\", {\n      settings(v) {\n        settings = v;\n      }\n    }, 8);\n    let callbacks;\n    module.link(\"../../../lib/callbacks\", {\n      callbacks(v) {\n        callbacks = v;\n      }\n    }, 9);\n    let omit;\n    module.link(\"../../../lib/utils/omit\", {\n      omit(v) {\n        omit = v;\n      }\n    }, 10);\n    let LDAPConnection;\n    module.link(\"./Connection\", {\n      LDAPConnection(v) {\n        LDAPConnection = v;\n      }\n    }, 11);\n    let logger, authLogger, connLogger;\n    module.link(\"./Logger\", {\n      logger(v) {\n        logger = v;\n      },\n      authLogger(v) {\n        authLogger = v;\n      },\n      connLogger(v) {\n        connLogger = v;\n      }\n    }, 12);\n    let LDAPUserConverter;\n    module.link(\"./UserConverter\", {\n      LDAPUserConverter(v) {\n        LDAPUserConverter = v;\n      }\n    }, 13);\n    let getLDAPConditionalSetting;\n    module.link(\"./getLDAPConditionalSetting\", {\n      getLDAPConditionalSetting(v) {\n        getLDAPConditionalSetting = v;\n      }\n    }, 14);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    class LDAPManager {\n      static async login(username, password) {\n        logger.debug({\n          msg: 'Init LDAP login',\n          username\n        });\n        if (settings.get('LDAP_Enable') !== true) {\n          return this.fallbackToDefaultLogin(username, password);\n        }\n        let ldapUser;\n        const ldap = new LDAPConnection();\n        try {\n          try {\n            await ldap.connect();\n            ldapUser = await this.findUser(ldap, username, password);\n          } catch (error) {\n            logger.error(error);\n          }\n          if (ldapUser === undefined) {\n            return this.fallbackToDefaultLogin(username, password);\n          }\n          const slugifiedUsername = this.slugifyUsername(ldapUser, username);\n          const user = await this.findExistingUser(ldapUser, slugifiedUsername);\n          // Bind connection to the admin user so that RC has full access to groups in the next steps\n          await ldap.bindAuthenticationUser();\n          if (user) {\n            return await this.loginExistingUser(ldap, user, ldapUser, password);\n          }\n          return await this.loginNewUserFromLDAP(slugifiedUsername, ldap, ldapUser, password);\n        } finally {\n          ldap.disconnect();\n        }\n      }\n      static async loginAuthenticatedUser(username) {\n        logger.debug({\n          msg: 'Init LDAP login',\n          username\n        });\n        if (settings.get('LDAP_Enable') !== true) {\n          return;\n        }\n        let ldapUser;\n        const ldap = new LDAPConnection();\n        try {\n          try {\n            await ldap.connect();\n            ldapUser = await this.findAuthenticatedUser(ldap, username);\n          } catch (error) {\n            logger.error(error);\n          }\n          if (ldapUser === undefined) {\n            return;\n          }\n          const slugifiedUsername = this.slugifyUsername(ldapUser, username);\n          const user = await this.findExistingUser(ldapUser, slugifiedUsername);\n          if (user) {\n            return await this.loginExistingUser(ldap, user, ldapUser);\n          }\n          return await this.loginNewUserFromLDAP(slugifiedUsername, ldap, ldapUser);\n        } finally {\n          ldap.disconnect();\n        }\n      }\n      static async testConnection() {\n        try {\n          const ldap = new LDAPConnection();\n          await ldap.testConnection();\n        } catch (error) {\n          connLogger.error(error);\n          throw error;\n        }\n      }\n      static async testSearch(username) {\n        const escapedUsername = ldapEscape.filter(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \"\"])), username);\n        const ldap = new LDAPConnection();\n        try {\n          await ldap.connect();\n          const users = await ldap.searchByUsername(escapedUsername);\n          if (users.length !== 1) {\n            logger.debug(\"Search returned \".concat(users.length, \" records for \").concat(escapedUsername));\n            throw new Error('User not found');\n          }\n        } catch (error) {\n          logger.error(error);\n          throw error;\n        }\n      }\n      static async syncUserAvatar(user, ldapUser) {\n        if (!(user !== null && user !== void 0 && user._id) || settings.get('LDAP_Sync_User_Avatar') !== true) {\n          return;\n        }\n        const avatar = this.getAvatarFromUser(ldapUser);\n        if (!avatar) {\n          return;\n        }\n        const hash = SHA256(avatar.toString());\n        if (user.avatarETag === hash) {\n          return;\n        }\n        logger.debug({\n          msg: 'Syncing user avatar',\n          username: user.username\n        });\n        await setUserAvatar(user, avatar, 'image/jpeg', 'rest', hash);\n      }\n      // This method will only find existing users that are already linked to LDAP\n      static async findExistingLDAPUser(ldapUser) {\n        const uniqueIdentifierField = this.getLdapUserUniqueID(ldapUser);\n        if (uniqueIdentifierField) {\n          logger.debug({\n            msg: 'Querying user',\n            uniqueId: uniqueIdentifierField.value\n          });\n          return UsersRaw.findOneByLDAPId(uniqueIdentifierField.value, uniqueIdentifierField.attribute);\n        }\n      }\n      static getConverterOptions() {\n        var _settings$get;\n        return {\n          flagEmailsAsVerified: (_settings$get = settings.get('Accounts_Verify_Email_For_External_Accounts')) !== null && _settings$get !== void 0 ? _settings$get : false,\n          skipExistingUsers: false,\n          skipUserCallbacks: false\n        };\n      }\n      static mapUserData(ldapUser, usedUsername) {\n        const uniqueId = this.getLdapUserUniqueID(ldapUser);\n        if (!uniqueId) {\n          throw new Error('Failed to generate unique identifier for ldap entry');\n        }\n        const {\n          attribute: idAttribute,\n          value: id\n        } = uniqueId;\n        const username = this.slugifyUsername(ldapUser, usedUsername || id || '') || undefined;\n        const emails = this.getLdapEmails(ldapUser, username).map(email => email.trim());\n        const name = this.getLdapName(ldapUser) || undefined;\n        const voipExtension = this.getLdapExtension(ldapUser);\n        const userData = {\n          type: 'user',\n          emails,\n          importIds: [ldapUser.dn],\n          username,\n          name,\n          voipExtension,\n          services: {\n            ldap: {\n              idAttribute,\n              id\n            }\n          }\n        };\n        this.onMapUserData(ldapUser, userData);\n        return userData;\n      }\n      static onMapUserData(ldapUser, userData) {\n        void callbacks.run('mapLDAPUserData', userData, ldapUser);\n      }\n      static async findUser(ldap, username, password) {\n        const escapedUsername = ldapEscape.filter(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"\"])), username);\n        try {\n          const users = await ldap.searchByUsername(escapedUsername);\n          if (users.length !== 1) {\n            logger.debug(\"Search returned \".concat(users.length, \" records for \").concat(escapedUsername));\n            throw new Error('User not found');\n          }\n          const [ldapUser] = users;\n          if (!(await ldap.isUserAcceptedByGroupFilter(escapedUsername, ldapUser.dn))) {\n            throw new Error('User not found');\n          }\n          if (!(await ldap.authenticate(ldapUser.dn, password))) {\n            logger.debug(\"Wrong password for \".concat(escapedUsername));\n            throw new Error('Invalid user or wrong password');\n          }\n          if (settings.get('LDAP_Find_User_After_Login')) {\n            // Do a search as the user and check if they have any result\n            authLogger.debug('User authenticated successfully, performing additional search.');\n            if ((await ldap.searchAndCount(ldapUser.dn, {})) === 0) {\n              authLogger.debug(\"Bind successful but user \".concat(ldapUser.dn, \" was not found via search\"));\n            }\n          }\n          return ldapUser;\n        } catch (error) {\n          logger.error(error);\n        }\n      }\n      static async findAuthenticatedUser(ldap, username) {\n        const escapedUsername = ldapEscape.filter(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"\"])), username);\n        try {\n          const users = await ldap.searchByUsername(escapedUsername);\n          if (users.length !== 1) {\n            logger.debug(\"Search returned \".concat(users.length, \" records for \").concat(escapedUsername));\n            return;\n          }\n          const [ldapUser] = users;\n          if (settings.get('LDAP_Find_User_After_Login')) {\n            // Do a search as the user and check if they have any result\n            authLogger.debug('User authenticated successfully, performing additional search.');\n            if ((await ldap.searchAndCount(ldapUser.dn, {})) === 0) {\n              authLogger.debug(\"Bind successful but user \".concat(ldapUser.dn, \" was not found via search\"));\n            }\n          }\n          if (!(await ldap.isUserAcceptedByGroupFilter(escapedUsername, ldapUser.dn))) {\n            throw new Error('User not in a valid group');\n          }\n          return ldapUser;\n        } catch (error) {\n          logger.error(error);\n        }\n      }\n      static async loginNewUserFromLDAP(slugifiedUsername, ldap, ldapUser, ldapPass) {\n        logger.debug({\n          msg: 'User does not exist, creating',\n          username: slugifiedUsername\n        });\n        let username;\n        if (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n          username = slugifiedUsername;\n        }\n        // Create new user\n        return this.addLdapUser(ldapUser, username, ldapPass, ldap);\n      }\n      static async addLdapUser(ldapUser, username, password, ldap) {\n        const user = await this.syncUserForLogin(ldapUser, undefined, username);\n        if (!user) {\n          return;\n        }\n        await this.onLogin(ldapUser, user, password, ldap, true);\n        return {\n          userId: user._id\n        };\n      }\n      static async onLogin(ldapUser, user, password, ldap, isNewUser) {\n        logger.debug('running onLDAPLogin');\n        if (settings.get('LDAP_Login_Fallback') && typeof password === 'string' && password.trim() !== '') {\n          await Accounts.setPasswordAsync(user._id, password, {\n            logout: false\n          });\n        }\n        await this.syncUserAvatar(user, ldapUser);\n        await callbacks.run('onLDAPLogin', {\n          user,\n          ldapUser,\n          isNewUser\n        }, ldap);\n      }\n      static async loginExistingUser(ldap, user, ldapUser, password) {\n        var _settings$get2;\n        if (user.ldap !== true && settings.get('LDAP_Merge_Existing_Users') !== true) {\n          logger.debug('User exists without \"ldap: true\"');\n          throw new Meteor.Error('LDAP-login-error', \"LDAP Authentication succeeded, but there's already an existing user with provided username [\".concat(user.username, \"] in Mongo.\"));\n        }\n        // If we're merging an ldap user with a local user, then we need to sync the data even if 'update data on login' is off.\n        const forceUserSync = !user.ldap;\n        const syncData = forceUserSync || ((_settings$get2 = settings.get('LDAP_Update_Data_On_Login')) !== null && _settings$get2 !== void 0 ? _settings$get2 : true);\n        logger.debug({\n          msg: 'Logging user in',\n          syncData\n        });\n        const updatedUser = syncData && (await this.syncUserForLogin(ldapUser, user)) || user;\n        await this.onLogin(ldapUser, updatedUser, password, ldap, false);\n        return {\n          userId: user._id\n        };\n      }\n      static async syncUserForLogin(ldapUser, existingUser, usedUsername) {\n        logger.debug({\n          msg: 'Syncing user data',\n          ldapUser: omit(ldapUser, '_raw'),\n          user: _objectSpread({}, existingUser && {\n            email: existingUser.emails,\n            _id: existingUser._id\n          })\n        });\n        const userData = this.mapUserData(ldapUser, usedUsername);\n        // make sure to persist existing user data when passing to sync/convert\n        // TODO this is only needed because ImporterDataConverter assigns a default role and type if nothing is set. we might need to figure out a better way and stop doing that there\n        if (existingUser) {\n          if (!userData.roles && existingUser.roles) {\n            userData.roles = existingUser.roles;\n          }\n          if (!userData.type && existingUser.type) {\n            userData.type = existingUser.type;\n          }\n        }\n        const options = this.getConverterOptions();\n        await LDAPUserConverter.convertSingleUser(userData, options);\n        return existingUser || this.findExistingLDAPUser(ldapUser);\n      }\n      static getLdapUserUniqueID(ldapUser) {\n        let uniqueIdentifierField = settings.get('LDAP_Unique_Identifier_Field');\n        if (uniqueIdentifierField) {\n          uniqueIdentifierField = uniqueIdentifierField.replace(/\\s/g, '').split(',');\n        } else {\n          uniqueIdentifierField = [];\n        }\n        let userSearchField = getLDAPConditionalSetting('LDAP_User_Search_Field');\n        if (userSearchField) {\n          userSearchField = userSearchField.replace(/\\s/g, '').split(',');\n        } else {\n          userSearchField = [];\n        }\n        uniqueIdentifierField = uniqueIdentifierField.concat(userSearchField);\n        if (!uniqueIdentifierField.length) {\n          uniqueIdentifierField.push('dn');\n        }\n        const key = uniqueIdentifierField.find(field => !_.isEmpty(ldapUser._raw[field]));\n        if (key) {\n          return {\n            attribute: key,\n            value: ldapUser._raw[key].toString('hex')\n          };\n        }\n        connLogger.warn('Failed to generate unique identifier for ldap entry');\n        connLogger.debug(ldapUser);\n      }\n      static ldapKeyExists(ldapUser, key) {\n        return !_.isEmpty(ldapUser[key.trim()]);\n      }\n      static getLdapString(ldapUser, key) {\n        return ldapUser[key.trim()];\n      }\n      static getLdapDynamicValue(ldapUser, attributeSetting) {\n        if (!attributeSetting) {\n          return;\n        }\n        // If the attribute setting is a template, then convert the variables in it\n        if (attributeSetting.includes('#{')) {\n          return attributeSetting.replace(/#{(.+?)}/g, (_match, field) => {\n            const key = field.trim();\n            if (this.ldapKeyExists(ldapUser, key)) {\n              return this.getLdapString(ldapUser, key);\n            }\n            return '';\n          });\n        }\n        // If it's not a template, then treat the setting as a CSV list of possible attribute names and return the first valid one.\n        const attributeList = attributeSetting.replace(/\\s/g, '').split(',');\n        const key = attributeList.find(field => this.ldapKeyExists(ldapUser, field));\n        if (key) {\n          return this.getLdapString(ldapUser, key);\n        }\n      }\n      static getLdapName(ldapUser) {\n        const nameAttributes = getLDAPConditionalSetting('LDAP_Name_Field');\n        return this.getLdapDynamicValue(ldapUser, nameAttributes);\n      }\n      static getLdapExtension(ldapUser) {\n        const extensionAttribute = settings.get('LDAP_Extension_Field');\n        if (!extensionAttribute) {\n          return;\n        }\n        return this.getLdapString(ldapUser, extensionAttribute);\n      }\n      static getLdapEmails(ldapUser, username) {\n        var _ldapUser$mail;\n        const emailAttributes = getLDAPConditionalSetting('LDAP_Email_Field');\n        if (emailAttributes) {\n          const attributeList = emailAttributes.replace(/\\s/g, '').split(',');\n          const key = attributeList.find(field => this.ldapKeyExists(ldapUser, field));\n          const emails = [].concat(key ? ldapUser[key.trim()] : []);\n          const filteredEmails = emails.filter(email => email.includes('@'));\n          if (filteredEmails.length) {\n            return filteredEmails;\n          }\n        }\n        if (settings.get('LDAP_Default_Domain') !== '' && username) {\n          return [\"\".concat(username, \"@\").concat(settings.get('LDAP_Default_Domain'))];\n        }\n        if ((_ldapUser$mail = ldapUser.mail) !== null && _ldapUser$mail !== void 0 && _ldapUser$mail.includes('@')) {\n          return [ldapUser.mail];\n        }\n        logger.debug(ldapUser);\n        throw new Error('Failed to get email address from LDAP user');\n      }\n      static slugify(text) {\n        if (settings.get('UTF8_Names_Slugify') !== true) {\n          return text;\n        }\n        text = limax(text, {\n          replacement: '.'\n        });\n        return text.replace(/[^0-9a-z-_.]/g, '');\n      }\n      static slugifyUsername(ldapUser, requestUsername) {\n        if (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n          const username = this.getLdapUsername(ldapUser);\n          if (username) {\n            return this.slugify(username);\n          }\n        }\n        return this.slugify(requestUsername);\n      }\n      static getLdapUsername(ldapUser) {\n        const usernameField = getLDAPConditionalSetting('LDAP_Username_Field');\n        return this.getLdapDynamicValue(ldapUser, usernameField);\n      }\n      // This method will find existing users by LDAP id or by username.\n      static async findExistingUser(ldapUser, slugifiedUsername) {\n        const user = await this.findExistingLDAPUser(ldapUser);\n        if (user) {\n          return user;\n        }\n        // If we don't have that ldap user linked yet, check if there's any non-ldap user with the same username\n        return UsersRaw.findOneWithoutLDAPByUsernameIgnoringCase(slugifiedUsername);\n      }\n      static fallbackToDefaultLogin(username, password) {\n        if (typeof username === 'string') {\n          if (username.indexOf('@') === -1) {\n            username = {\n              username\n            };\n          } else {\n            username = {\n              email: username\n            };\n          }\n        }\n        logger.debug({\n          msg: 'Fallback to default account system',\n          username\n        });\n        const loginRequest = {\n          user: username,\n          password: {\n            digest: SHA256(password),\n            algorithm: 'sha-256'\n          }\n        };\n        return Accounts._runLoginHandlers(this, loginRequest);\n      }\n      static getAvatarFromUser(ldapUser) {\n        const avatarField = String(settings.get('LDAP_Avatar_Field') || '').trim();\n        if (avatarField && ldapUser._raw[avatarField]) {\n          return ldapUser._raw[avatarField];\n        }\n        if (ldapUser._raw.thumbnailPhoto) {\n          return ldapUser._raw.thumbnailPhoto;\n        }\n        if (ldapUser._raw.jpegPhoto) {\n          return ldapUser._raw.jpegPhoto;\n        }\n      }\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_objectSpread","module","link","default","v","_taggedTemplateLiteral","_templateObject","_templateObject2","_templateObject3","export","LDAPManager","UsersRaw","Users","SHA256","ldapEscape","limax","Accounts","Meteor","_","setUserAvatar","settings","callbacks","omit","LDAPConnection","logger","authLogger","connLogger","LDAPUserConverter","getLDAPConditionalSetting","__reifyWaitForDeps__","login","username","password","debug","msg","get","fallbackToDefaultLogin","ldapUser","ldap","connect","findUser","error","undefined","slugifiedUsername","slugifyUsername","user","findExistingUser","bindAuthenticationUser","loginExistingUser","loginNewUserFromLDAP","disconnect","loginAuthenticatedUser","findAuthenticatedUser","testConnection","testSearch","escapedUsername","filter","users","searchByUsername","length","concat","Error","syncUserAvatar","_id","avatar","getAvatarFromUser","hash","toString","avatarETag","findExistingLDAPUser","uniqueIdentifierField","getLdapUserUniqueID","uniqueId","value","findOneByLDAPId","attribute","getConverterOptions","_settings$get","flagEmailsAsVerified","skipExistingUsers","skipUserCallbacks","mapUserData","usedUsername","idAttribute","id","emails","getLdapEmails","map","email","trim","name","getLdapName","voipExtension","getLdapExtension","userData","type","importIds","dn","services","onMapUserData","run","isUserAcceptedByGroupFilter","authenticate","searchAndCount","ldapPass","addLdapUser","syncUserForLogin","onLogin","userId","isNewUser","setPasswordAsync","logout","_settings$get2","forceUserSync","syncData","updatedUser","existingUser","roles","options","convertSingleUser","replace","split","userSearchField","push","key","find","field","isEmpty","_raw","warn","ldapKeyExists","getLdapString","getLdapDynamicValue","attributeSetting","includes","_match","attributeList","nameAttributes","extensionAttribute","_ldapUser$mail","emailAttributes","filteredEmails","mail","slugify","text","replacement","requestUsername","getLdapUsername","usernameField","findOneWithoutLDAPByUsernameIgnoringCase","indexOf","loginRequest","digest","algorithm","_runLoginHandlers","avatarField","String","thumbnailPhoto","jpegPhoto","__reify_async_result__","_reifyError","self","async"],"sources":["server/lib/ldap/Manager.ts"],"sourcesContent":["import type { ILDAPEntry, LDAPLoginResult, ILDAPUniqueIdentifierField, IUser, LoginUsername, IImportUser } from '@rocket.chat/core-typings';\nimport { Users as UsersRaw } from '@rocket.chat/models';\nimport { SHA256 } from '@rocket.chat/sha256';\nimport ldapEscape from 'ldap-escape';\nimport limax from 'limax';\n// #ToDo: #TODO: Remove Meteor dependencies\nimport { Accounts } from 'meteor/accounts-base';\nimport { Meteor } from 'meteor/meteor';\nimport _ from 'underscore';\n\nimport type { UserConverterOptions } from '../../../app/importer/server/classes/converters/UserConverter';\nimport { setUserAvatar } from '../../../app/lib/server/functions/setUserAvatar';\nimport { settings } from '../../../app/settings/server';\nimport { callbacks } from '../../../lib/callbacks';\nimport { omit } from '../../../lib/utils/omit';\nimport { LDAPConnection } from './Connection';\nimport { logger, authLogger, connLogger } from './Logger';\nimport { LDAPUserConverter } from './UserConverter';\nimport { getLDAPConditionalSetting } from './getLDAPConditionalSetting';\n\nexport class LDAPManager {\n\tpublic static async login(username: string, password: string): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'Init LDAP login', username });\n\n\t\tif (settings.get('LDAP_Enable') !== true) {\n\t\t\treturn this.fallbackToDefaultLogin(username, password);\n\t\t}\n\n\t\tlet ldapUser: ILDAPEntry | undefined;\n\n\t\tconst ldap = new LDAPConnection();\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tawait ldap.connect();\n\t\t\t\tldapUser = await this.findUser(ldap, username, password);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(error);\n\t\t\t}\n\n\t\t\tif (ldapUser === undefined) {\n\t\t\t\treturn this.fallbackToDefaultLogin(username, password);\n\t\t\t}\n\n\t\t\tconst slugifiedUsername = this.slugifyUsername(ldapUser, username);\n\t\t\tconst user = await this.findExistingUser(ldapUser, slugifiedUsername);\n\n\t\t\t// Bind connection to the admin user so that RC has full access to groups in the next steps\n\t\t\tawait ldap.bindAuthenticationUser();\n\t\t\tif (user) {\n\t\t\t\treturn await this.loginExistingUser(ldap, user, ldapUser, password);\n\t\t\t}\n\n\t\t\treturn await this.loginNewUserFromLDAP(slugifiedUsername, ldap, ldapUser, password);\n\t\t} finally {\n\t\t\tldap.disconnect();\n\t\t}\n\t}\n\n\tpublic static async loginAuthenticatedUser(username: string): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'Init LDAP login', username });\n\n\t\tif (settings.get('LDAP_Enable') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet ldapUser: ILDAPEntry | undefined;\n\n\t\tconst ldap = new LDAPConnection();\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tawait ldap.connect();\n\t\t\t\tldapUser = await this.findAuthenticatedUser(ldap, username);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(error);\n\t\t\t}\n\n\t\t\tif (ldapUser === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst slugifiedUsername = this.slugifyUsername(ldapUser, username);\n\t\t\tconst user = await this.findExistingUser(ldapUser, slugifiedUsername);\n\n\t\t\tif (user) {\n\t\t\t\treturn await this.loginExistingUser(ldap, user, ldapUser);\n\t\t\t}\n\n\t\t\treturn await this.loginNewUserFromLDAP(slugifiedUsername, ldap, ldapUser);\n\t\t} finally {\n\t\t\tldap.disconnect();\n\t\t}\n\t}\n\n\tpublic static async testConnection(): Promise<void> {\n\t\ttry {\n\t\t\tconst ldap = new LDAPConnection();\n\t\t\tawait ldap.testConnection();\n\t\t} catch (error) {\n\t\t\tconnLogger.error(error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tpublic static async testSearch(username: string): Promise<void> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\t\tconst ldap = new LDAPConnection();\n\n\t\ttry {\n\t\t\tawait ldap.connect();\n\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tpublic static async syncUserAvatar(user: IUser, ldapUser: ILDAPEntry): Promise<void> {\n\t\tif (!user?._id || settings.get('LDAP_Sync_User_Avatar') !== true) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst avatar = this.getAvatarFromUser(ldapUser);\n\t\tif (!avatar) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst hash = SHA256(avatar.toString());\n\t\tif (user.avatarETag === hash) {\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug({ msg: 'Syncing user avatar', username: user.username });\n\n\t\tawait setUserAvatar(user, avatar, 'image/jpeg', 'rest', hash);\n\t}\n\n\t// This method will only find existing users that are already linked to LDAP\n\tprotected static async findExistingLDAPUser(ldapUser: ILDAPEntry): Promise<IUser | undefined> {\n\t\tconst uniqueIdentifierField = this.getLdapUserUniqueID(ldapUser);\n\n\t\tif (uniqueIdentifierField) {\n\t\t\tlogger.debug({ msg: 'Querying user', uniqueId: uniqueIdentifierField.value });\n\t\t\treturn UsersRaw.findOneByLDAPId(uniqueIdentifierField.value, uniqueIdentifierField.attribute);\n\t\t}\n\t}\n\n\tprotected static getConverterOptions(): UserConverterOptions {\n\t\treturn {\n\t\t\tflagEmailsAsVerified: settings.get<boolean>('Accounts_Verify_Email_For_External_Accounts') ?? false,\n\t\t\tskipExistingUsers: false,\n\t\t\tskipUserCallbacks: false,\n\t\t};\n\t}\n\n\tprotected static mapUserData(ldapUser: ILDAPEntry, usedUsername?: string | undefined): IImportUser {\n\t\tconst uniqueId = this.getLdapUserUniqueID(ldapUser);\n\t\tif (!uniqueId) {\n\t\t\tthrow new Error('Failed to generate unique identifier for ldap entry');\n\t\t}\n\n\t\tconst { attribute: idAttribute, value: id } = uniqueId;\n\t\tconst username = this.slugifyUsername(ldapUser, usedUsername || id || '') || undefined;\n\t\tconst emails = this.getLdapEmails(ldapUser, username).map((email) => email.trim());\n\t\tconst name = this.getLdapName(ldapUser) || undefined;\n\t\tconst voipExtension = this.getLdapExtension(ldapUser);\n\n\t\tconst userData: IImportUser = {\n\t\t\ttype: 'user',\n\t\t\temails,\n\t\t\timportIds: [ldapUser.dn],\n\t\t\tusername,\n\t\t\tname,\n\t\t\tvoipExtension,\n\t\t\tservices: {\n\t\t\t\tldap: {\n\t\t\t\t\tidAttribute,\n\t\t\t\t\tid,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tthis.onMapUserData(ldapUser, userData);\n\t\treturn userData;\n\t}\n\n\tprivate static onMapUserData(ldapUser: ILDAPEntry, userData: IImportUser): void {\n\t\tvoid callbacks.run('mapLDAPUserData', userData, ldapUser);\n\t}\n\n\tprivate static async findUser(ldap: LDAPConnection, username: string, password: string): Promise<ILDAPEntry | undefined> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\n\t\ttry {\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\n\t\t\tconst [ldapUser] = users;\n\t\t\tif (!(await ldap.isUserAcceptedByGroupFilter(escapedUsername, ldapUser.dn))) {\n\t\t\t\tthrow new Error('User not found');\n\t\t\t}\n\n\t\t\tif (!(await ldap.authenticate(ldapUser.dn, password))) {\n\t\t\t\tlogger.debug(`Wrong password for ${escapedUsername}`);\n\t\t\t\tthrow new Error('Invalid user or wrong password');\n\t\t\t}\n\n\t\t\tif (settings.get<boolean>('LDAP_Find_User_After_Login')) {\n\t\t\t\t// Do a search as the user and check if they have any result\n\t\t\t\tauthLogger.debug('User authenticated successfully, performing additional search.');\n\t\t\t\tif ((await ldap.searchAndCount(ldapUser.dn, {})) === 0) {\n\t\t\t\t\tauthLogger.debug(`Bind successful but user ${ldapUser.dn} was not found via search`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ldapUser;\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\tprivate static async findAuthenticatedUser(ldap: LDAPConnection, username: string): Promise<ILDAPEntry | undefined> {\n\t\tconst escapedUsername = ldapEscape.filter`${username}`;\n\n\t\ttry {\n\t\t\tconst users = await ldap.searchByUsername(escapedUsername);\n\n\t\t\tif (users.length !== 1) {\n\t\t\t\tlogger.debug(`Search returned ${users.length} records for ${escapedUsername}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst [ldapUser] = users;\n\n\t\t\tif (settings.get<boolean>('LDAP_Find_User_After_Login')) {\n\t\t\t\t// Do a search as the user and check if they have any result\n\t\t\t\tauthLogger.debug('User authenticated successfully, performing additional search.');\n\t\t\t\tif ((await ldap.searchAndCount(ldapUser.dn, {})) === 0) {\n\t\t\t\t\tauthLogger.debug(`Bind successful but user ${ldapUser.dn} was not found via search`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(await ldap.isUserAcceptedByGroupFilter(escapedUsername, ldapUser.dn))) {\n\t\t\t\tthrow new Error('User not in a valid group');\n\t\t\t}\n\n\t\t\treturn ldapUser;\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\tprivate static async loginNewUserFromLDAP(\n\t\tslugifiedUsername: string,\n\t\tldap: LDAPConnection,\n\t\tldapUser: ILDAPEntry,\n\t\tldapPass?: string,\n\t): Promise<LDAPLoginResult> {\n\t\tlogger.debug({ msg: 'User does not exist, creating', username: slugifiedUsername });\n\n\t\tlet username: string | undefined;\n\n\t\tif (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n\t\t\tusername = slugifiedUsername;\n\t\t}\n\n\t\t// Create new user\n\t\treturn this.addLdapUser(ldapUser, username, ldapPass, ldap);\n\t}\n\n\tprivate static async addLdapUser(\n\t\tldapUser: ILDAPEntry,\n\t\tusername: string | undefined,\n\t\tpassword: string | undefined,\n\t\tldap: LDAPConnection,\n\t): Promise<LDAPLoginResult> {\n\t\tconst user = await this.syncUserForLogin(ldapUser, undefined, username);\n\n\t\tif (!user) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.onLogin(ldapUser, user, password, ldap, true);\n\n\t\treturn {\n\t\t\tuserId: user._id,\n\t\t};\n\t}\n\n\tprivate static async onLogin(\n\t\tldapUser: ILDAPEntry,\n\t\tuser: IUser,\n\t\tpassword: string | undefined,\n\t\tldap: LDAPConnection,\n\t\tisNewUser: boolean,\n\t): Promise<void> {\n\t\tlogger.debug('running onLDAPLogin');\n\t\tif (settings.get<boolean>('LDAP_Login_Fallback') && typeof password === 'string' && password.trim() !== '') {\n\t\t\tawait Accounts.setPasswordAsync(user._id, password, { logout: false });\n\t\t}\n\n\t\tawait this.syncUserAvatar(user, ldapUser);\n\t\tawait callbacks.run('onLDAPLogin', { user, ldapUser, isNewUser }, ldap);\n\t}\n\n\tprivate static async loginExistingUser(\n\t\tldap: LDAPConnection,\n\t\tuser: IUser,\n\t\tldapUser: ILDAPEntry,\n\t\tpassword?: string,\n\t): Promise<LDAPLoginResult> {\n\t\tif (user.ldap !== true && settings.get('LDAP_Merge_Existing_Users') !== true) {\n\t\t\tlogger.debug('User exists without \"ldap: true\"');\n\t\t\tthrow new Meteor.Error(\n\t\t\t\t'LDAP-login-error',\n\t\t\t\t`LDAP Authentication succeeded, but there's already an existing user with provided username [${user.username}] in Mongo.`,\n\t\t\t);\n\t\t}\n\n\t\t// If we're merging an ldap user with a local user, then we need to sync the data even if 'update data on login' is off.\n\t\tconst forceUserSync = !user.ldap;\n\n\t\tconst syncData = forceUserSync || (settings.get<boolean>('LDAP_Update_Data_On_Login') ?? true);\n\t\tlogger.debug({ msg: 'Logging user in', syncData });\n\t\tconst updatedUser = (syncData && (await this.syncUserForLogin(ldapUser, user))) || user;\n\n\t\tawait this.onLogin(ldapUser, updatedUser, password, ldap, false);\n\t\treturn {\n\t\t\tuserId: user._id,\n\t\t};\n\t}\n\n\tprivate static async syncUserForLogin(\n\t\tldapUser: ILDAPEntry,\n\t\texistingUser?: IUser,\n\t\tusedUsername?: string | undefined,\n\t): Promise<IUser | undefined> {\n\t\tlogger.debug({\n\t\t\tmsg: 'Syncing user data',\n\t\t\tldapUser: omit(ldapUser, '_raw'),\n\t\t\tuser: { ...(existingUser && { email: existingUser.emails, _id: existingUser._id }) },\n\t\t});\n\n\t\tconst userData = this.mapUserData(ldapUser, usedUsername);\n\n\t\t// make sure to persist existing user data when passing to sync/convert\n\t\t// TODO this is only needed because ImporterDataConverter assigns a default role and type if nothing is set. we might need to figure out a better way and stop doing that there\n\t\tif (existingUser) {\n\t\t\tif (!userData.roles && existingUser.roles) {\n\t\t\t\tuserData.roles = existingUser.roles;\n\t\t\t}\n\t\t\tif (!userData.type && existingUser.type) {\n\t\t\t\tuserData.type = existingUser.type as IImportUser['type'];\n\t\t\t}\n\t\t}\n\n\t\tconst options = this.getConverterOptions();\n\t\tawait LDAPUserConverter.convertSingleUser(userData, options);\n\n\t\treturn existingUser || this.findExistingLDAPUser(ldapUser);\n\t}\n\n\tprivate static getLdapUserUniqueID(ldapUser: ILDAPEntry): ILDAPUniqueIdentifierField | undefined {\n\t\tlet uniqueIdentifierField: string | string[] | undefined = settings.get<string>('LDAP_Unique_Identifier_Field');\n\n\t\tif (uniqueIdentifierField) {\n\t\t\tuniqueIdentifierField = uniqueIdentifierField.replace(/\\s/g, '').split(',');\n\t\t} else {\n\t\t\tuniqueIdentifierField = [];\n\t\t}\n\n\t\tlet userSearchField: string | string[] | undefined = getLDAPConditionalSetting<string>('LDAP_User_Search_Field');\n\n\t\tif (userSearchField) {\n\t\t\tuserSearchField = userSearchField.replace(/\\s/g, '').split(',');\n\t\t} else {\n\t\t\tuserSearchField = [];\n\t\t}\n\n\t\tuniqueIdentifierField = uniqueIdentifierField.concat(userSearchField);\n\t\tif (!uniqueIdentifierField.length) {\n\t\t\tuniqueIdentifierField.push('dn');\n\t\t}\n\n\t\tconst key = uniqueIdentifierField.find((field) => !_.isEmpty(ldapUser._raw[field]));\n\t\tif (key) {\n\t\t\treturn {\n\t\t\t\tattribute: key,\n\t\t\t\tvalue: ldapUser._raw[key].toString('hex'),\n\t\t\t};\n\t\t}\n\n\t\tconnLogger.warn('Failed to generate unique identifier for ldap entry');\n\t\tconnLogger.debug(ldapUser);\n\t}\n\n\tprivate static ldapKeyExists(ldapUser: ILDAPEntry, key: string): boolean {\n\t\treturn !_.isEmpty(ldapUser[key.trim()]);\n\t}\n\n\tprivate static getLdapString(ldapUser: ILDAPEntry, key: string): string {\n\t\treturn ldapUser[key.trim()];\n\t}\n\n\tprivate static getLdapDynamicValue(ldapUser: ILDAPEntry, attributeSetting: string | undefined): string | undefined {\n\t\tif (!attributeSetting) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If the attribute setting is a template, then convert the variables in it\n\t\tif (attributeSetting.includes('#{')) {\n\t\t\treturn attributeSetting.replace(/#{(.+?)}/g, (_match, field) => {\n\t\t\t\tconst key = field.trim();\n\n\t\t\t\tif (this.ldapKeyExists(ldapUser, key)) {\n\t\t\t\t\treturn this.getLdapString(ldapUser, key);\n\t\t\t\t}\n\n\t\t\t\treturn '';\n\t\t\t});\n\t\t}\n\n\t\t// If it's not a template, then treat the setting as a CSV list of possible attribute names and return the first valid one.\n\t\tconst attributeList: string[] = attributeSetting.replace(/\\s/g, '').split(',');\n\t\tconst key = attributeList.find((field) => this.ldapKeyExists(ldapUser, field));\n\t\tif (key) {\n\t\t\treturn this.getLdapString(ldapUser, key);\n\t\t}\n\t}\n\n\tprivate static getLdapName(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst nameAttributes = getLDAPConditionalSetting<string | undefined>('LDAP_Name_Field');\n\t\treturn this.getLdapDynamicValue(ldapUser, nameAttributes);\n\t}\n\n\tprivate static getLdapExtension(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst extensionAttribute = settings.get<string>('LDAP_Extension_Field');\n\t\tif (!extensionAttribute) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.getLdapString(ldapUser, extensionAttribute);\n\t}\n\n\tprivate static getLdapEmails(ldapUser: ILDAPEntry, username?: string): string[] {\n\t\tconst emailAttributes = getLDAPConditionalSetting<string>('LDAP_Email_Field');\n\t\tif (emailAttributes) {\n\t\t\tconst attributeList: string[] = emailAttributes.replace(/\\s/g, '').split(',');\n\t\t\tconst key = attributeList.find((field) => this.ldapKeyExists(ldapUser, field));\n\n\t\t\tconst emails: string[] = [].concat(key ? ldapUser[key.trim()] : []);\n\t\t\tconst filteredEmails = emails.filter((email) => email.includes('@'));\n\n\t\t\tif (filteredEmails.length) {\n\t\t\t\treturn filteredEmails;\n\t\t\t}\n\t\t}\n\n\t\tif (settings.get('LDAP_Default_Domain') !== '' && username) {\n\t\t\treturn [`${username}@${settings.get('LDAP_Default_Domain')}`];\n\t\t}\n\n\t\tif (ldapUser.mail?.includes('@')) {\n\t\t\treturn [ldapUser.mail];\n\t\t}\n\n\t\tlogger.debug(ldapUser);\n\t\tthrow new Error('Failed to get email address from LDAP user');\n\t}\n\n\tprivate static slugify(text: string): string {\n\t\tif (settings.get('UTF8_Names_Slugify') !== true) {\n\t\t\treturn text;\n\t\t}\n\n\t\ttext = limax(text, { replacement: '.' });\n\t\treturn text.replace(/[^0-9a-z-_.]/g, '');\n\t}\n\n\tprivate static slugifyUsername(ldapUser: ILDAPEntry, requestUsername: string): string {\n\t\tif (getLDAPConditionalSetting('LDAP_Username_Field') !== '') {\n\t\t\tconst username = this.getLdapUsername(ldapUser);\n\t\t\tif (username) {\n\t\t\t\treturn this.slugify(username);\n\t\t\t}\n\t\t}\n\n\t\treturn this.slugify(requestUsername);\n\t}\n\n\tprotected static getLdapUsername(ldapUser: ILDAPEntry): string | undefined {\n\t\tconst usernameField = getLDAPConditionalSetting('LDAP_Username_Field') as string;\n\t\treturn this.getLdapDynamicValue(ldapUser, usernameField);\n\t}\n\n\t// This method will find existing users by LDAP id or by username.\n\tprivate static async findExistingUser(ldapUser: ILDAPEntry, slugifiedUsername: string): Promise<IUser | undefined> {\n\t\tconst user = await this.findExistingLDAPUser(ldapUser);\n\t\tif (user) {\n\t\t\treturn user;\n\t\t}\n\n\t\t// If we don't have that ldap user linked yet, check if there's any non-ldap user with the same username\n\t\treturn UsersRaw.findOneWithoutLDAPByUsernameIgnoringCase(slugifiedUsername);\n\t}\n\n\tprivate static fallbackToDefaultLogin(username: LoginUsername, password: string): LDAPLoginResult {\n\t\tif (typeof username === 'string') {\n\t\t\tif (username.indexOf('@') === -1) {\n\t\t\t\tusername = { username };\n\t\t\t} else {\n\t\t\t\tusername = { email: username };\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug({ msg: 'Fallback to default account system', username });\n\n\t\tconst loginRequest = {\n\t\t\tuser: username,\n\t\t\tpassword: {\n\t\t\t\tdigest: SHA256(password),\n\t\t\t\talgorithm: 'sha-256',\n\t\t\t},\n\t\t};\n\n\t\treturn Accounts._runLoginHandlers(this, loginRequest);\n\t}\n\n\tprivate static getAvatarFromUser(ldapUser: ILDAPEntry): any | undefined {\n\t\tconst avatarField = String(settings.get('LDAP_Avatar_Field') || '').trim();\n\t\tif (avatarField && ldapUser._raw[avatarField]) {\n\t\t\treturn ldapUser._raw[avatarField];\n\t\t}\n\n\t\tif (ldapUser._raw.thumbnailPhoto) {\n\t\t\treturn ldapUser._raw.thumbnailPhoto;\n\t\t}\n\n\t\tif (ldapUser._raw.jpegPhoto) {\n\t\t\treturn ldapUser._raw.jpegPhoto;\n\t\t}\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"b87a76602d2fc1441265065f345a2f9f609f9c89"}
