{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/server/services/voip-asterisk/connector/asterisk/ami/AMIConnection.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"server/services/voip-asterisk/connector/asterisk/ami/AMIConnection.ts","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/server/services/voip-asterisk/connector/asterisk/ami/AMIConnection.ts","inputSourceMap":{"version":3,"file":"server/services/voip-asterisk/connector/asterisk/ami/AMIConnection.ts","sourceRoot":"","sources":["server/services/voip-asterisk/connector/asterisk/ami/AMIConnection.ts"],"names":[],"mappings":"AAAA;;;;;;;;;GASG;AACH,OAAO,EAAE,MAAM,EAAE,MAAM,qBAAqB,CAAC;AAC7C,OAAO,OAAO,MAAM,kBAAkB,CAAC;AAMvC,SAAS,eAAe,CAAC,MAAc;IACtC,MAAM,CAAC,GAAG,GAAG,SAAS,GAAG,CAAC,GAAG,KAAY;QACxC,cAAc;IACf,CAAC,CAAC;IACF,MAAM,CAAC,KAAK,GAAG,SAAS,KAAK,CAAC,GAAG,KAAY;QAC5C,cAAc;IACf,CAAC,CAAC;IACF,MAAM,CAAC,IAAI,GAAG,SAAS,IAAI,CAAC,GAAG,KAAY;QAC1C,cAAc;IACf,CAAC,CAAC;IACF,MAAM,CAAC,KAAK,GAAG,SAAS,KAAK,CAAC,GAAG,KAAY;QAC5C,cAAc;IACf,CAAC,CAAC;IAEF,OAAO,MAAM,CAAC;AACf,CAAC;AAID,MAAM,OAAO,aAAa;IACzB,UAAU,CAA6B;IAEvC,eAAe,CAAkB;IAEjC,sBAAsB,CAAS;IAE/B,cAAc,CAAS;IAEvB,QAAQ,CAAS;IAEjB,QAAQ,CAAS;IAEjB,aAAa,CAAmB;IAExB,MAAM,CAAS;IAEvB,8FAA8F;IAC9F,2FAA2F;IAC3F,qFAAqF;IAC7E,SAAS,GAAG,KAAK,CAAC;IAE1B,yBAAyB,GAAG,CAAC,CAAC;IAE9B,0BAA0B,GAAG,CAAC,CAAC;IAE/B,wEAAwE;IACxE,wBAAwB,GAAG,IAAI,CAAC;IAEhC,iBAAiB,GAAG,KAAK,CAAC;IAE1B,6BAA6B;IAC7B,8CAA8C;IAC9C,iBAAiB,GAAG,KAAK,CAAC;IAE1B;QACC,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,eAAe,CAAC,CAAC;QAC3C,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;QAChE,IAAI,CAAC,aAAa,GAAG,IAAI,GAAG,EAA6B,CAAC;QAC1D,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;IAClC,CAAC;IAED,OAAO;QACN,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;YACtB,OAAO;QACR,CAAC;QACD,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,CAAC;QAC7B,IAAI,CAAC,UAAU,CAAC,kBAAkB,EAAE,CAAC;QACrC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;IACxB,CAAC;IAED,SAAS;QACR,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;YACjB,GAAG,EAAE,cAAc;YACnB,wBAAwB,EAAE,IAAI,CAAC,wBAAwB;YACvD,0BAA0B,EAAE,IAAI,CAAC,0BAA0B;SAC3D,CAAC,CAAC;QACH,IAAI,IAAI,CAAC,0BAA0B,KAAK,IAAI,CAAC,yBAAyB,EAAE,CAAC;YACxE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,0CAA0C,EAAE,CAAC,CAAC;YACtE,8EAA8E;YAC9E,gCAAgC;YAChC,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC;YAC/B,OAAO;QACR,CAAC;QACD,MAAM,WAAW,GAAG,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC,0BAA0B,CAAC;QACpH,UAAU,CAAC,KAAK,IAAI,EAAE;YACrB,IAAI,CAAC;gBACJ,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAChC,CAAC;YAAC,OAAO,GAAY,EAAE,CAAC;gBACvB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,mDAAmD,EAAE,GAAG,EAAE,CAAC,CAAC;YACtF,CAAC;QACF,CAAC,EAAE,WAAW,CAAC,CAAC;QAChB,IAAI,CAAC,0BAA0B,IAAI,CAAC,CAAC;IACtC,CAAC;IAED,cAAc,CAAC,MAAW,EAAE,GAAY;QACvC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,oCAAoC,EAAE,GAAG,EAAE,CAAC,CAAC;QACtE,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC;QAC/B,IAAI,IAAI,CAAC,0BAA0B,KAAK,IAAI,CAAC,yBAAyB,EAAE,CAAC;YACxE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,qFAAqF,EAAE,CAAC,CAAC;YAClH,MAAM,CAAC,GAAG,CAAC,CAAC;QACb,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,SAAS,EAAE,CAAC;QAClB,CAAC;IACF,CAAC;IAED,gBAAgB,CAAC,QAAa,EAAE,OAAY;QAC3C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,wCAAwC,EAAE,CAAC,CAAC;QACrE,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC;IAC1E,CAAC;IAED,cAAc,CAAC,OAAY,EAAE,MAAW,EAAE,KAAc;QACvD,IAAI,KAAK,EAAE,CAAC;YACX,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,sFAAsF,EAAE,CAAC,CAAC;YACnH,4CAA4C;YAC5C,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,MAAM,CAAC,KAAK,CAAC,CAAC;QACf,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;YACvC,IAAI,CAAC,0BAA0B,GAAG,CAAC,CAAC;YACpC;;;;;;;;;;;;;;;eAeG;YACH,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBAC7B,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,cAAc,EAAE,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC1E,CAAC;YACD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,qDAAqD,EAAE,CAAC,CAAC;YAClF,OAAO,EAAE,CAAC;QACX,CAAC;IACF,CAAC;IAED,cAAc,CAAC,QAAiB;QAC/B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,mBAAmB,EAAE,QAAQ,EAAE,CAAC,CAAC;QAC1D,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC7B,IAAI,CAAC,SAAS,EAAE,CAAC;QAClB,CAAC;IACF,CAAC;IAED,gBAAgB;QACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,qBAAqB,EAAE,CAAC,CAAC;QAClD,IAAI,CAAC,OAAO,EAAE,CAAC;IAChB,CAAC;IAED,KAAK,CAAC,iBAAiB;QACtB,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;QACjC,IAAI,CAAC,UAAU,GAAG,IAAI,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,sBAAsB,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAE1G,MAAM,aAAa,GAAG,IAAI,OAAO,CAAO,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAE;YAC7D,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC;YACnF,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC;YAErE,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC5D,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAEhE,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,sBAAsB,CAAC,CAAC;QAC3E,CAAC,CAAC,CAAC;QACH,OAAO,aAAa,CAAC;IACtB,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;OAuBG;IACH,KAAK,CAAC,OAAO,CACZ,sBAA8B,EAC9B,cAAsB,EACtB,QAAgB,EAChB,QAAgB,EAChB,iBAAiB,GAAG,KAAK;QAEzB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,WAAW,EAAE,CAAC,CAAC;QACtC,IAAI,CAAC,sBAAsB,GAAG,sBAAsB,CAAC;QACrD,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACrC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAChC,CAAC;IAED,WAAW;QACV,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YACrB,OAAO,IAAI,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC;QACtC,CAAC;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAED,yDAAyD;IACzD,cAAc,CAAC,MAAc,EAAE,oBAAyB;QACvD,IAAI,IAAI,CAAC,eAAe,KAAK,eAAe,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC,EAAE,CAAC;YACrG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,gFAAgF,EAAE,CAAC,CAAC;YAC5G,MAAM,KAAK,CAAC,+DAA+D,CAAC,CAAC;QAC9E,CAAC;QACD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,kBAAkB,EAAE,CAAC,CAAC;QAC9C,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,oBAAoB,CAAC,CAAC;IACtD,CAAC;IAED,oBAAoB,CAAC,KAAU;QAC9B,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,EAAE,CAAC;YACxD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,4BAA4B,KAAK,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;YACrE,OAAO;QACR,CAAC;QACD,MAAM,QAAQ,GAAsB,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;QACtF,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,0CAA0C,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QACxF,2FAA2F;QAC3F,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAChC,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;gBACzB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,uDAAuD,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;YACrG,CAAC;iBAAM,CAAC;gBACP,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;oBACjB,GAAG,EAAE,wDAAwD,KAAK,CAAC,QAAQ,EAAE;oBAC7E,KAAK,EAAE,KAAK,CAAC,KAAK;iBAClB,CAAC,CAAC;YACJ,CAAC;QACF,CAAC;IACF,CAAC;IAED,EAAE,CAAC,KAAa,EAAE,eAAgC;QACjD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,MAAM,EAAE,CAAC,CAAC;QAClC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC;YACpC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,yCAAyC,KAAK,EAAE,EAAE,CAAC,CAAC;YAC7E,MAAM,KAAK,GAAsB,EAAE,CAAC;YACpC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QACtC,CAAC;QACD,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;IACtD,CAAC;IAED,GAAG,CAAC,KAAa,EAAE,OAAgB;QAClC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,OAAO,EAAE,CAAC,CAAC;QACnC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC;YACpC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,oCAAoC,KAAK,EAAE,EAAE,CAAC,CAAC;YACvE,OAAO;QACR,CAAC;QACD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,qBAAqB,KAAK,EAAE,EAAE,CAAC,CAAC;QACzD,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAC/C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,gCAAgC,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAC9E,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAChC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC;gBAC/C,SAAS;YACV,CAAC;YACD,MAAM,WAAW,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAQ,EAAE,EAAE,CAAC,GAAG,KAAK,OAAO,CAAC,CAAC;YACnE,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC;gBACzB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,wBAAwB,KAAK,+BAA+B,EAAE,CAAC,CAAC;gBACzF,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAClC,CAAC;iBAAM,CAAC;gBACP,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;gBAC3C,MAAM;YACP,CAAC;QACF,CAAC;IACF,CAAC;IAED,eAAe;QACd,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,mBAAmB,EAAE,CAAC,CAAC;QAC/C,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;QAC9B,IAAI,CAAC,OAAO,EAAE,CAAC;IAChB,CAAC;CACD","sourcesContent":["/**\n * Class representing AMI connection.\n * @remarks\n * This class is based on https://github.com/pipobscure/NodeJS-AsteriskManager\n * which is internally based on https://github.com/mscdex/node-asterisk\n *\n * Asterisk AMI interface is a socket based interface. The AMI configuration\n * happens in /etc/asterisk/manager.conf file.\n *\n */\nimport { Logger } from '@rocket.chat/logger';\nimport Manager from 'asterisk-manager';\n\nimport type { Command } from '../Command';\nimport type { IConnection } from '../IConnection';\nimport type { CallbackContext } from './CallbackContext';\n\nfunction makeLoggerDummy(logger: Logger): Logger {\n\tlogger.log = function log(..._args: any[]): void {\n\t\t// do nothing.\n\t};\n\tlogger.debug = function debug(..._args: any[]): void {\n\t\t// do nothing.\n\t};\n\tlogger.info = function info(..._args: any[]): void {\n\t\t// do nothing.\n\t};\n\tlogger.error = function error(..._args: any[]): void {\n\t\t// do nothing.\n\t};\n\n\treturn logger;\n}\n\ntype ConnectionState = 'UNKNOWN' | 'AUTHENTICATED' | 'ERROR';\n\nexport class AMIConnection implements IConnection {\n\tconnection: typeof Manager | undefined;\n\n\tconnectionState: ConnectionState;\n\n\tconnectionIpOrHostname: string;\n\n\tconnectionPort: string;\n\n\tuserName: string;\n\n\tpassword: string;\n\n\teventHandlers: Map<string, any>;\n\n\tprivate logger: Logger;\n\n\t// This class prints a ton of logs that are useful for debugging specific communication things\n\t// However, for most usecases, logs here won't be needed. Hardcoding while we add a setting\n\t// \"Print extended voip connection logs\" which will control classes' logging behavior\n\tprivate printLogs = false;\n\n\ttotalReconnectionAttempts = 5;\n\n\tcurrentReconnectionAttempt = 0;\n\n\t// Starting with 5 seconds of backoff time. increases with the attempts.\n\tinitialBackoffDurationMS = 5000;\n\n\tnearEndDisconnect = false;\n\n\t// if it is a test connection\n\t// Reconnectivity logic should not be applied.\n\tconnectivityCheck = false;\n\n\tconstructor() {\n\t\tconst logger = new Logger('AMIConnection');\n\t\tthis.logger = this.printLogs ? logger : makeLoggerDummy(logger);\n\t\tthis.eventHandlers = new Map<string, CallbackContext[]>();\n\t\tthis.connectionState = 'UNKNOWN';\n\t}\n\n\tcleanup(): void {\n\t\tif (!this.connection) {\n\t\t\treturn;\n\t\t}\n\t\tthis.connection.disconnect();\n\t\tthis.connection.removeAllListeners();\n\t\tthis.connection = null;\n\t}\n\n\treconnect(): void {\n\t\tthis.logger.debug({\n\t\t\tmsg: 'reconnect ()',\n\t\t\tinitialBackoffDurationMS: this.initialBackoffDurationMS,\n\t\t\tcurrentReconnectionAttempt: this.currentReconnectionAttempt,\n\t\t});\n\t\tif (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n\t\t\tthis.logger.info({ msg: 'reconnect () Not attempting to reconnect' });\n\t\t\t// We have exhausted the reconnection attempts or we have authentication error\n\t\t\t// We dont want to retry anymore\n\t\t\tthis.connectionState = 'ERROR';\n\t\t\treturn;\n\t\t}\n\t\tconst backoffTime = this.initialBackoffDurationMS + this.initialBackoffDurationMS * this.currentReconnectionAttempt;\n\t\tsetTimeout(async () => {\n\t\t\ttry {\n\t\t\t\tawait this.attemptConnection();\n\t\t\t} catch (err: unknown) {\n\t\t\t\tthis.logger.error({ msg: 'reconnect () attemptConnection() has thrown error', err });\n\t\t\t}\n\t\t}, backoffTime);\n\t\tthis.currentReconnectionAttempt += 1;\n\t}\n\n\tonManagerError(reject: any, err: unknown): void {\n\t\tthis.logger.error({ msg: 'onManagerError () Connection Error', err });\n\t\tthis.cleanup();\n\t\tthis.connectionState = 'ERROR';\n\t\tif (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n\t\t\tthis.logger.error({ msg: 'onManagerError () reconnection attempts exhausted. Please check connection settings' });\n\t\t\treject(err);\n\t\t} else {\n\t\t\tthis.reconnect();\n\t\t}\n\t}\n\n\tonManagerConnect(_resolve: any, _reject: any): void {\n\t\tthis.logger.debug({ msg: 'onManagerConnect () Connection Success' });\n\t\tthis.connection.login(this.onManagerLogin.bind(this, _resolve, _reject));\n\t}\n\n\tonManagerLogin(resolve: any, reject: any, error: unknown): void {\n\t\tif (error) {\n\t\t\tthis.logger.error({ msg: 'onManagerLogin () Authentication Error. Not going to reattempt. Fix the credentaials' });\n\t\t\t// Do not reattempt if we have login failure\n\t\t\tthis.cleanup();\n\t\t\treject(error);\n\t\t} else {\n\t\t\tthis.connectionState = 'AUTHENTICATED';\n\t\t\tthis.currentReconnectionAttempt = 0;\n\t\t\t/**\n\t\t\t * Note : There is no way to release a handler or cleanup the handlers.\n\t\t\t * Handlers are released only when the connection is closed.\n\t\t\t * Closing the connection and establishing it again for every command is an overhead.\n\t\t\t * To avoid that, we have taken a clean, though a bit complex approach.\n\t\t\t * We will register for all the manager event.\n\t\t\t *\n\t\t\t * Each command will register to AMIConnection to receive the events which it is\n\t\t\t * interested in. Once the processing is complete, it will unregister.\n\t\t\t *\n\t\t\t * Handled in this way will avoid disconnection of the connection to cleanup the\n\t\t\t * handlers.\n\t\t\t *\n\t\t\t * Furthermore, we do not want to initiate this when we are checking\n\t\t\t * the connectivity.\n\t\t\t */\n\t\t\tif (!this.connectivityCheck) {\n\t\t\t\tthis.connection.on('managerevent', this.eventHandlerCallback.bind(this));\n\t\t\t}\n\t\t\tthis.logger.debug({ msg: 'onManagerLogin () Authentication Success, Connected' });\n\t\t\tresolve();\n\t\t}\n\t}\n\n\tonManagerClose(hadError: unknown): void {\n\t\tthis.logger.error({ msg: 'onManagerClose ()', hadError });\n\t\tthis.cleanup();\n\t\tif (!this.nearEndDisconnect) {\n\t\t\tthis.reconnect();\n\t\t}\n\t}\n\n\tonManagerTimeout(): void {\n\t\tthis.logger.debug({ msg: 'onManagerTimeout ()' });\n\t\tthis.cleanup();\n\t}\n\n\tasync attemptConnection(): Promise<void> {\n\t\tthis.connectionState = 'UNKNOWN';\n\t\tthis.connection = new Manager(undefined, this.connectionIpOrHostname, this.userName, this.password, true);\n\n\t\tconst returnPromise = new Promise<void>((_resolve, _reject) => {\n\t\t\tthis.connection.on('connect', this.onManagerConnect.bind(this, _resolve, _reject));\n\t\t\tthis.connection.on('error', this.onManagerError.bind(this, _reject));\n\n\t\t\tthis.connection.on('close', this.onManagerClose.bind(this));\n\t\t\tthis.connection.on('timeout', this.onManagerTimeout.bind(this));\n\n\t\t\tthis.connection.connect(this.connectionPort, this.connectionIpOrHostname);\n\t\t});\n\t\treturn returnPromise;\n\t}\n\n\t/**\n\t * connect: Connects to asterisk\n\t * description: This function initiates a connection to asterisk management interface\n\t * for receiving the various events. These events could be a result of action command sent over\n\t * the socket or an events that asterisk sents over this connection. In the later case, what asterisk\n\t * sends over the socket depends on the way permissions are given to the user in asterisk's\n\t * manager.conf file.\n\t * This code uses a lib https://github.com/pipobscure/NodeJS-AsteriskManager\n\t * The working of this library actually connects in the object creation. i.e\n\t * new Manager(port, connectionIpOrHostname, userName, password, true);\n\t * So it was noticed that if we call isConnected immediately after creating the object,\n\t * it returns false. Eventualy when the connection  and authentication succeeds\n\t * it will be set back to true.\n\t * To avoid this connection we have to explicitly create the Manager with undefined port value.\n\t * When done so, We will have to explicitly call connect and login functions.\n\t * These functions can give a callback where we can resolve the promises\n\t * This way it ensures that the rocket.chat service has a valid connection or an error when this function\n\t * call is over.\n\t *\n\t * @param connectionIpOrHostname\n\t * @param connectionPort\n\t * @param userName\n\t * @param password\n\t */\n\tasync connect(\n\t\tconnectionIpOrHostname: string,\n\t\tconnectionPort: string,\n\t\tuserName: string,\n\t\tpassword: string,\n\t\tconnectivityCheck = false,\n\t): Promise<void> {\n\t\tthis.logger.log({ msg: 'connect()' });\n\t\tthis.connectionIpOrHostname = connectionIpOrHostname;\n\t\tthis.connectionPort = connectionPort;\n\t\tthis.userName = userName;\n\t\tthis.password = password;\n\t\tthis.connectivityCheck = connectivityCheck;\n\t\tawait this.attemptConnection();\n\t}\n\n\tisConnected(): boolean {\n\t\tif (this.connection) {\n\t\t\treturn this.connection.isConnected();\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Executes an action on asterisk and returns the result.\n\texecuteCommand(action: object, actionResultCallback: any): void {\n\t\tif (this.connectionState !== 'AUTHENTICATED' || (this.connection && !this.connection.isConnected())) {\n\t\t\tthis.logger.warn({ msg: 'executeCommand() Cant execute command at this moment. Connection is not active' });\n\t\t\tthrow Error('Cant execute command at this moment. Connection is not active');\n\t\t}\n\t\tthis.logger.info({ msg: 'executeCommand()' });\n\t\tthis.connection.action(action, actionResultCallback);\n\t}\n\n\teventHandlerCallback(event: any): void {\n\t\tif (!this.eventHandlers.has(event.event.toLowerCase())) {\n\t\t\tthis.logger.info({ msg: `No event handler set for ${event.event}` });\n\t\t\treturn;\n\t\t}\n\t\tconst handlers: CallbackContext[] = this.eventHandlers.get(event.event.toLowerCase());\n\t\tthis.logger.debug({ msg: `eventHandlerCallback() Handler count = ${handlers.length}` });\n\t\t/* Go thru all the available handlers  and call each one of them if the actionid matches */\n\t\tfor (const handler of handlers) {\n\t\t\tif (handler.call(event)) {\n\t\t\t\tthis.logger.debug({ msg: `eventHandlerCallback() called callback for action = ${event.actionid}` });\n\t\t\t} else {\n\t\t\t\tthis.logger.debug({\n\t\t\t\t\tmsg: `eventHandlerCallback() No command found for action = ${event.actionid}`,\n\t\t\t\t\tevent: event.event,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\ton(event: string, callbackContext: CallbackContext): void {\n\t\tthis.logger.info({ msg: 'on()' });\n\t\tif (!this.eventHandlers.has(event)) {\n\t\t\tthis.logger.debug({ msg: `on() no existing handlers for event = ${event}` });\n\t\t\tconst array: CallbackContext[] = [];\n\t\t\tthis.eventHandlers.set(event, array);\n\t\t}\n\t\tthis.eventHandlers.get(event)?.push(callbackContext);\n\t}\n\n\toff(event: string, command: Command): void {\n\t\tthis.logger.info({ msg: 'off()' });\n\t\tif (!this.eventHandlers.has(event)) {\n\t\t\tthis.logger.warn({ msg: `off() No event handler found for ${event}` });\n\t\t\treturn;\n\t\t}\n\t\tthis.logger.debug({ msg: `off() Event found ${event}` });\n\t\tconst handlers = this.eventHandlers.get(event);\n\t\tthis.logger.debug({ msg: `off() Handler array length = ${handlers.length}` });\n\t\tfor (const handler of handlers) {\n\t\t\tif (!handler.isValidContext(command.actionid)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst newHandlers = handlers.filter((obj: any) => obj !== handler);\n\t\t\tif (!newHandlers.length) {\n\t\t\t\tthis.logger.debug({ msg: `off() No handler for ${event} deleting event from the map.` });\n\t\t\t\tthis.eventHandlers.delete(event);\n\t\t\t} else {\n\t\t\t\tthis.eventHandlers.set(event, newHandlers);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcloseConnection(): void {\n\t\tthis.logger.info({ msg: 'closeConnection()' });\n\t\tthis.nearEndDisconnect = true;\n\t\tthis.cleanup();\n\t}\n}\n"]},"targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/server/services/voip-asterisk/connector/asterisk/ami/AMIConnection.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/services/voip-asterisk/connector/asterisk/ami/AMIConnection.ts","inputSourceMap":{"version":3,"file":"server/services/voip-asterisk/connector/asterisk/ami/AMIConnection.ts","sourceRoot":"","sources":["server/services/voip-asterisk/connector/asterisk/ami/AMIConnection.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Class representing AMI connection.\n * @remarks\n * This class is based on https://github.com/pipobscure/NodeJS-AsteriskManager\n * which is internally based on https://github.com/mscdex/node-asterisk\n *\n * Asterisk AMI interface is a socket based interface. The AMI configuration\n * happens in /etc/asterisk/manager.conf file.\n *\n */\nimport { Logger } from '@rocket.chat/logger';\nimport Manager from 'asterisk-manager';\n\nimport type { Command } from '../Command';\nimport type { IConnection } from '../IConnection';\nimport type { CallbackContext } from './CallbackContext';\n\nfunction makeLoggerDummy(logger: Logger): Logger {\n\tlogger.log = function log(..._args: any[]): void {\n\t\t// do nothing.\n\t};\n\tlogger.debug = function debug(..._args: any[]): void {\n\t\t// do nothing.\n\t};\n\tlogger.info = function info(..._args: any[]): void {\n\t\t// do nothing.\n\t};\n\tlogger.error = function error(..._args: any[]): void {\n\t\t// do nothing.\n\t};\n\n\treturn logger;\n}\n\ntype ConnectionState = 'UNKNOWN' | 'AUTHENTICATED' | 'ERROR';\n\nexport class AMIConnection implements IConnection {\n\tconnection: typeof Manager | undefined;\n\n\tconnectionState: ConnectionState;\n\n\tconnectionIpOrHostname: string;\n\n\tconnectionPort: string;\n\n\tuserName: string;\n\n\tpassword: string;\n\n\teventHandlers: Map<string, any>;\n\n\tprivate logger: Logger;\n\n\t// This class prints a ton of logs that are useful for debugging specific communication things\n\t// However, for most usecases, logs here won't be needed. Hardcoding while we add a setting\n\t// \"Print extended voip connection logs\" which will control classes' logging behavior\n\tprivate printLogs = false;\n\n\ttotalReconnectionAttempts = 5;\n\n\tcurrentReconnectionAttempt = 0;\n\n\t// Starting with 5 seconds of backoff time. increases with the attempts.\n\tinitialBackoffDurationMS = 5000;\n\n\tnearEndDisconnect = false;\n\n\t// if it is a test connection\n\t// Reconnectivity logic should not be applied.\n\tconnectivityCheck = false;\n\n\tconstructor() {\n\t\tconst logger = new Logger('AMIConnection');\n\t\tthis.logger = this.printLogs ? logger : makeLoggerDummy(logger);\n\t\tthis.eventHandlers = new Map<string, CallbackContext[]>();\n\t\tthis.connectionState = 'UNKNOWN';\n\t}\n\n\tcleanup(): void {\n\t\tif (!this.connection) {\n\t\t\treturn;\n\t\t}\n\t\tthis.connection.disconnect();\n\t\tthis.connection.removeAllListeners();\n\t\tthis.connection = null;\n\t}\n\n\treconnect(): void {\n\t\tthis.logger.debug({\n\t\t\tmsg: 'reconnect ()',\n\t\t\tinitialBackoffDurationMS: this.initialBackoffDurationMS,\n\t\t\tcurrentReconnectionAttempt: this.currentReconnectionAttempt,\n\t\t});\n\t\tif (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n\t\t\tthis.logger.info({ msg: 'reconnect () Not attempting to reconnect' });\n\t\t\t// We have exhausted the reconnection attempts or we have authentication error\n\t\t\t// We dont want to retry anymore\n\t\t\tthis.connectionState = 'ERROR';\n\t\t\treturn;\n\t\t}\n\t\tconst backoffTime = this.initialBackoffDurationMS + this.initialBackoffDurationMS * this.currentReconnectionAttempt;\n\t\tsetTimeout(async () => {\n\t\t\ttry {\n\t\t\t\tawait this.attemptConnection();\n\t\t\t} catch (err: unknown) {\n\t\t\t\tthis.logger.error({ msg: 'reconnect () attemptConnection() has thrown error', err });\n\t\t\t}\n\t\t}, backoffTime);\n\t\tthis.currentReconnectionAttempt += 1;\n\t}\n\n\tonManagerError(reject: any, err: unknown): void {\n\t\tthis.logger.error({ msg: 'onManagerError () Connection Error', err });\n\t\tthis.cleanup();\n\t\tthis.connectionState = 'ERROR';\n\t\tif (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n\t\t\tthis.logger.error({ msg: 'onManagerError () reconnection attempts exhausted. Please check connection settings' });\n\t\t\treject(err);\n\t\t} else {\n\t\t\tthis.reconnect();\n\t\t}\n\t}\n\n\tonManagerConnect(_resolve: any, _reject: any): void {\n\t\tthis.logger.debug({ msg: 'onManagerConnect () Connection Success' });\n\t\tthis.connection.login(this.onManagerLogin.bind(this, _resolve, _reject));\n\t}\n\n\tonManagerLogin(resolve: any, reject: any, error: unknown): void {\n\t\tif (error) {\n\t\t\tthis.logger.error({ msg: 'onManagerLogin () Authentication Error. Not going to reattempt. Fix the credentaials' });\n\t\t\t// Do not reattempt if we have login failure\n\t\t\tthis.cleanup();\n\t\t\treject(error);\n\t\t} else {\n\t\t\tthis.connectionState = 'AUTHENTICATED';\n\t\t\tthis.currentReconnectionAttempt = 0;\n\t\t\t/**\n\t\t\t * Note : There is no way to release a handler or cleanup the handlers.\n\t\t\t * Handlers are released only when the connection is closed.\n\t\t\t * Closing the connection and establishing it again for every command is an overhead.\n\t\t\t * To avoid that, we have taken a clean, though a bit complex approach.\n\t\t\t * We will register for all the manager event.\n\t\t\t *\n\t\t\t * Each command will register to AMIConnection to receive the events which it is\n\t\t\t * interested in. Once the processing is complete, it will unregister.\n\t\t\t *\n\t\t\t * Handled in this way will avoid disconnection of the connection to cleanup the\n\t\t\t * handlers.\n\t\t\t *\n\t\t\t * Furthermore, we do not want to initiate this when we are checking\n\t\t\t * the connectivity.\n\t\t\t */\n\t\t\tif (!this.connectivityCheck) {\n\t\t\t\tthis.connection.on('managerevent', this.eventHandlerCallback.bind(this));\n\t\t\t}\n\t\t\tthis.logger.debug({ msg: 'onManagerLogin () Authentication Success, Connected' });\n\t\t\tresolve();\n\t\t}\n\t}\n\n\tonManagerClose(hadError: unknown): void {\n\t\tthis.logger.error({ msg: 'onManagerClose ()', hadError });\n\t\tthis.cleanup();\n\t\tif (!this.nearEndDisconnect) {\n\t\t\tthis.reconnect();\n\t\t}\n\t}\n\n\tonManagerTimeout(): void {\n\t\tthis.logger.debug({ msg: 'onManagerTimeout ()' });\n\t\tthis.cleanup();\n\t}\n\n\tasync attemptConnection(): Promise<void> {\n\t\tthis.connectionState = 'UNKNOWN';\n\t\tthis.connection = new Manager(undefined, this.connectionIpOrHostname, this.userName, this.password, true);\n\n\t\tconst returnPromise = new Promise<void>((_resolve, _reject) => {\n\t\t\tthis.connection.on('connect', this.onManagerConnect.bind(this, _resolve, _reject));\n\t\t\tthis.connection.on('error', this.onManagerError.bind(this, _reject));\n\n\t\t\tthis.connection.on('close', this.onManagerClose.bind(this));\n\t\t\tthis.connection.on('timeout', this.onManagerTimeout.bind(this));\n\n\t\t\tthis.connection.connect(this.connectionPort, this.connectionIpOrHostname);\n\t\t});\n\t\treturn returnPromise;\n\t}\n\n\t/**\n\t * connect: Connects to asterisk\n\t * description: This function initiates a connection to asterisk management interface\n\t * for receiving the various events. These events could be a result of action command sent over\n\t * the socket or an events that asterisk sents over this connection. In the later case, what asterisk\n\t * sends over the socket depends on the way permissions are given to the user in asterisk's\n\t * manager.conf file.\n\t * This code uses a lib https://github.com/pipobscure/NodeJS-AsteriskManager\n\t * The working of this library actually connects in the object creation. i.e\n\t * new Manager(port, connectionIpOrHostname, userName, password, true);\n\t * So it was noticed that if we call isConnected immediately after creating the object,\n\t * it returns false. Eventualy when the connection  and authentication succeeds\n\t * it will be set back to true.\n\t * To avoid this connection we have to explicitly create the Manager with undefined port value.\n\t * When done so, We will have to explicitly call connect and login functions.\n\t * These functions can give a callback where we can resolve the promises\n\t * This way it ensures that the rocket.chat service has a valid connection or an error when this function\n\t * call is over.\n\t *\n\t * @param connectionIpOrHostname\n\t * @param connectionPort\n\t * @param userName\n\t * @param password\n\t */\n\tasync connect(\n\t\tconnectionIpOrHostname: string,\n\t\tconnectionPort: string,\n\t\tuserName: string,\n\t\tpassword: string,\n\t\tconnectivityCheck = false,\n\t): Promise<void> {\n\t\tthis.logger.log({ msg: 'connect()' });\n\t\tthis.connectionIpOrHostname = connectionIpOrHostname;\n\t\tthis.connectionPort = connectionPort;\n\t\tthis.userName = userName;\n\t\tthis.password = password;\n\t\tthis.connectivityCheck = connectivityCheck;\n\t\tawait this.attemptConnection();\n\t}\n\n\tisConnected(): boolean {\n\t\tif (this.connection) {\n\t\t\treturn this.connection.isConnected();\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Executes an action on asterisk and returns the result.\n\texecuteCommand(action: object, actionResultCallback: any): void {\n\t\tif (this.connectionState !== 'AUTHENTICATED' || (this.connection && !this.connection.isConnected())) {\n\t\t\tthis.logger.warn({ msg: 'executeCommand() Cant execute command at this moment. Connection is not active' });\n\t\t\tthrow Error('Cant execute command at this moment. Connection is not active');\n\t\t}\n\t\tthis.logger.info({ msg: 'executeCommand()' });\n\t\tthis.connection.action(action, actionResultCallback);\n\t}\n\n\teventHandlerCallback(event: any): void {\n\t\tif (!this.eventHandlers.has(event.event.toLowerCase())) {\n\t\t\tthis.logger.info({ msg: `No event handler set for ${event.event}` });\n\t\t\treturn;\n\t\t}\n\t\tconst handlers: CallbackContext[] = this.eventHandlers.get(event.event.toLowerCase());\n\t\tthis.logger.debug({ msg: `eventHandlerCallback() Handler count = ${handlers.length}` });\n\t\t/* Go thru all the available handlers  and call each one of them if the actionid matches */\n\t\tfor (const handler of handlers) {\n\t\t\tif (handler.call(event)) {\n\t\t\t\tthis.logger.debug({ msg: `eventHandlerCallback() called callback for action = ${event.actionid}` });\n\t\t\t} else {\n\t\t\t\tthis.logger.debug({\n\t\t\t\t\tmsg: `eventHandlerCallback() No command found for action = ${event.actionid}`,\n\t\t\t\t\tevent: event.event,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\ton(event: string, callbackContext: CallbackContext): void {\n\t\tthis.logger.info({ msg: 'on()' });\n\t\tif (!this.eventHandlers.has(event)) {\n\t\t\tthis.logger.debug({ msg: `on() no existing handlers for event = ${event}` });\n\t\t\tconst array: CallbackContext[] = [];\n\t\t\tthis.eventHandlers.set(event, array);\n\t\t}\n\t\tthis.eventHandlers.get(event)?.push(callbackContext);\n\t}\n\n\toff(event: string, command: Command): void {\n\t\tthis.logger.info({ msg: 'off()' });\n\t\tif (!this.eventHandlers.has(event)) {\n\t\t\tthis.logger.warn({ msg: `off() No event handler found for ${event}` });\n\t\t\treturn;\n\t\t}\n\t\tthis.logger.debug({ msg: `off() Event found ${event}` });\n\t\tconst handlers = this.eventHandlers.get(event);\n\t\tthis.logger.debug({ msg: `off() Handler array length = ${handlers.length}` });\n\t\tfor (const handler of handlers) {\n\t\t\tif (!handler.isValidContext(command.actionid)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst newHandlers = handlers.filter((obj: any) => obj !== handler);\n\t\t\tif (!newHandlers.length) {\n\t\t\t\tthis.logger.debug({ msg: `off() No handler for ${event} deleting event from the map.` });\n\t\t\t\tthis.eventHandlers.delete(event);\n\t\t\t} else {\n\t\t\t\tthis.eventHandlers.set(event, newHandlers);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcloseConnection(): void {\n\t\tthis.logger.info({ msg: 'closeConnection()' });\n\t\tthis.nearEndDisconnect = true;\n\t\tthis.cleanup();\n\t}\n}\n"]}}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    module.export({\n      AMIConnection: () => AMIConnection\n    });\n    let Logger;\n    module.link(\"@rocket.chat/logger\", {\n      Logger(v) {\n        Logger = v;\n      }\n    }, 0);\n    let Manager;\n    module.link(\"asterisk-manager\", {\n      default(v) {\n        Manager = v;\n      }\n    }, 1);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    function makeLoggerDummy(logger) {\n      logger.log = function log() {\n        // do nothing.\n      };\n      logger.debug = function debug() {\n        // do nothing.\n      };\n      logger.info = function info() {\n        // do nothing.\n      };\n      logger.error = function error() {\n        // do nothing.\n      };\n      return logger;\n    }\n    class AMIConnection {\n      constructor() {\n        this.connection = void 0;\n        this.connectionState = void 0;\n        this.connectionIpOrHostname = void 0;\n        this.connectionPort = void 0;\n        this.userName = void 0;\n        this.password = void 0;\n        this.eventHandlers = void 0;\n        this.logger = void 0;\n        // This class prints a ton of logs that are useful for debugging specific communication things\n        // However, for most usecases, logs here won't be needed. Hardcoding while we add a setting\n        // \"Print extended voip connection logs\" which will control classes' logging behavior\n        this.printLogs = false;\n        this.totalReconnectionAttempts = 5;\n        this.currentReconnectionAttempt = 0;\n        // Starting with 5 seconds of backoff time. increases with the attempts.\n        this.initialBackoffDurationMS = 5000;\n        this.nearEndDisconnect = false;\n        // if it is a test connection\n        // Reconnectivity logic should not be applied.\n        this.connectivityCheck = false;\n        const logger = new Logger('AMIConnection');\n        this.logger = this.printLogs ? logger : makeLoggerDummy(logger);\n        this.eventHandlers = new Map();\n        this.connectionState = 'UNKNOWN';\n      }\n      cleanup() {\n        if (!this.connection) {\n          return;\n        }\n        this.connection.disconnect();\n        this.connection.removeAllListeners();\n        this.connection = null;\n      }\n      reconnect() {\n        this.logger.debug({\n          msg: 'reconnect ()',\n          initialBackoffDurationMS: this.initialBackoffDurationMS,\n          currentReconnectionAttempt: this.currentReconnectionAttempt\n        });\n        if (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n          this.logger.info({\n            msg: 'reconnect () Not attempting to reconnect'\n          });\n          // We have exhausted the reconnection attempts or we have authentication error\n          // We dont want to retry anymore\n          this.connectionState = 'ERROR';\n          return;\n        }\n        const backoffTime = this.initialBackoffDurationMS + this.initialBackoffDurationMS * this.currentReconnectionAttempt;\n        setTimeout(async () => {\n          try {\n            await this.attemptConnection();\n          } catch (err) {\n            this.logger.error({\n              msg: 'reconnect () attemptConnection() has thrown error',\n              err\n            });\n          }\n        }, backoffTime);\n        this.currentReconnectionAttempt += 1;\n      }\n      onManagerError(reject, err) {\n        this.logger.error({\n          msg: 'onManagerError () Connection Error',\n          err\n        });\n        this.cleanup();\n        this.connectionState = 'ERROR';\n        if (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n          this.logger.error({\n            msg: 'onManagerError () reconnection attempts exhausted. Please check connection settings'\n          });\n          reject(err);\n        } else {\n          this.reconnect();\n        }\n      }\n      onManagerConnect(_resolve, _reject) {\n        this.logger.debug({\n          msg: 'onManagerConnect () Connection Success'\n        });\n        this.connection.login(this.onManagerLogin.bind(this, _resolve, _reject));\n      }\n      onManagerLogin(resolve, reject, error) {\n        if (error) {\n          this.logger.error({\n            msg: 'onManagerLogin () Authentication Error. Not going to reattempt. Fix the credentaials'\n          });\n          // Do not reattempt if we have login failure\n          this.cleanup();\n          reject(error);\n        } else {\n          this.connectionState = 'AUTHENTICATED';\n          this.currentReconnectionAttempt = 0;\n          /**\n           * Note : There is no way to release a handler or cleanup the handlers.\n           * Handlers are released only when the connection is closed.\n           * Closing the connection and establishing it again for every command is an overhead.\n           * To avoid that, we have taken a clean, though a bit complex approach.\n           * We will register for all the manager event.\n           *\n           * Each command will register to AMIConnection to receive the events which it is\n           * interested in. Once the processing is complete, it will unregister.\n           *\n           * Handled in this way will avoid disconnection of the connection to cleanup the\n           * handlers.\n           *\n           * Furthermore, we do not want to initiate this when we are checking\n           * the connectivity.\n           */\n          if (!this.connectivityCheck) {\n            this.connection.on('managerevent', this.eventHandlerCallback.bind(this));\n          }\n          this.logger.debug({\n            msg: 'onManagerLogin () Authentication Success, Connected'\n          });\n          resolve();\n        }\n      }\n      onManagerClose(hadError) {\n        this.logger.error({\n          msg: 'onManagerClose ()',\n          hadError\n        });\n        this.cleanup();\n        if (!this.nearEndDisconnect) {\n          this.reconnect();\n        }\n      }\n      onManagerTimeout() {\n        this.logger.debug({\n          msg: 'onManagerTimeout ()'\n        });\n        this.cleanup();\n      }\n      async attemptConnection() {\n        this.connectionState = 'UNKNOWN';\n        this.connection = new Manager(undefined, this.connectionIpOrHostname, this.userName, this.password, true);\n        const returnPromise = new Promise((_resolve, _reject) => {\n          this.connection.on('connect', this.onManagerConnect.bind(this, _resolve, _reject));\n          this.connection.on('error', this.onManagerError.bind(this, _reject));\n          this.connection.on('close', this.onManagerClose.bind(this));\n          this.connection.on('timeout', this.onManagerTimeout.bind(this));\n          this.connection.connect(this.connectionPort, this.connectionIpOrHostname);\n        });\n        return returnPromise;\n      }\n      /**\n       * connect: Connects to asterisk\n       * description: This function initiates a connection to asterisk management interface\n       * for receiving the various events. These events could be a result of action command sent over\n       * the socket or an events that asterisk sents over this connection. In the later case, what asterisk\n       * sends over the socket depends on the way permissions are given to the user in asterisk's\n       * manager.conf file.\n       * This code uses a lib https://github.com/pipobscure/NodeJS-AsteriskManager\n       * The working of this library actually connects in the object creation. i.e\n       * new Manager(port, connectionIpOrHostname, userName, password, true);\n       * So it was noticed that if we call isConnected immediately after creating the object,\n       * it returns false. Eventualy when the connection  and authentication succeeds\n       * it will be set back to true.\n       * To avoid this connection we have to explicitly create the Manager with undefined port value.\n       * When done so, We will have to explicitly call connect and login functions.\n       * These functions can give a callback where we can resolve the promises\n       * This way it ensures that the rocket.chat service has a valid connection or an error when this function\n       * call is over.\n       *\n       * @param connectionIpOrHostname\n       * @param connectionPort\n       * @param userName\n       * @param password\n       */\n      async connect(connectionIpOrHostname, connectionPort, userName, password) {\n        let connectivityCheck = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n        this.logger.log({\n          msg: 'connect()'\n        });\n        this.connectionIpOrHostname = connectionIpOrHostname;\n        this.connectionPort = connectionPort;\n        this.userName = userName;\n        this.password = password;\n        this.connectivityCheck = connectivityCheck;\n        await this.attemptConnection();\n      }\n      isConnected() {\n        if (this.connection) {\n          return this.connection.isConnected();\n        }\n        return false;\n      }\n      // Executes an action on asterisk and returns the result.\n      executeCommand(action, actionResultCallback) {\n        if (this.connectionState !== 'AUTHENTICATED' || this.connection && !this.connection.isConnected()) {\n          this.logger.warn({\n            msg: 'executeCommand() Cant execute command at this moment. Connection is not active'\n          });\n          throw Error('Cant execute command at this moment. Connection is not active');\n        }\n        this.logger.info({\n          msg: 'executeCommand()'\n        });\n        this.connection.action(action, actionResultCallback);\n      }\n      eventHandlerCallback(event) {\n        if (!this.eventHandlers.has(event.event.toLowerCase())) {\n          this.logger.info({\n            msg: \"No event handler set for \".concat(event.event)\n          });\n          return;\n        }\n        const handlers = this.eventHandlers.get(event.event.toLowerCase());\n        this.logger.debug({\n          msg: \"eventHandlerCallback() Handler count = \".concat(handlers.length)\n        });\n        /* Go thru all the available handlers  and call each one of them if the actionid matches */\n        for (const handler of handlers) {\n          if (handler.call(event)) {\n            this.logger.debug({\n              msg: \"eventHandlerCallback() called callback for action = \".concat(event.actionid)\n            });\n          } else {\n            this.logger.debug({\n              msg: \"eventHandlerCallback() No command found for action = \".concat(event.actionid),\n              event: event.event\n            });\n          }\n        }\n      }\n      on(event, callbackContext) {\n        var _this$eventHandlers$g;\n        this.logger.info({\n          msg: 'on()'\n        });\n        if (!this.eventHandlers.has(event)) {\n          this.logger.debug({\n            msg: \"on() no existing handlers for event = \".concat(event)\n          });\n          const array = [];\n          this.eventHandlers.set(event, array);\n        }\n        (_this$eventHandlers$g = this.eventHandlers.get(event)) === null || _this$eventHandlers$g === void 0 ? void 0 : _this$eventHandlers$g.push(callbackContext);\n      }\n      off(event, command) {\n        this.logger.info({\n          msg: 'off()'\n        });\n        if (!this.eventHandlers.has(event)) {\n          this.logger.warn({\n            msg: \"off() No event handler found for \".concat(event)\n          });\n          return;\n        }\n        this.logger.debug({\n          msg: \"off() Event found \".concat(event)\n        });\n        const handlers = this.eventHandlers.get(event);\n        this.logger.debug({\n          msg: \"off() Handler array length = \".concat(handlers.length)\n        });\n        for (const handler of handlers) {\n          if (!handler.isValidContext(command.actionid)) {\n            continue;\n          }\n          const newHandlers = handlers.filter(obj => obj !== handler);\n          if (!newHandlers.length) {\n            this.logger.debug({\n              msg: \"off() No handler for \".concat(event, \" deleting event from the map.\")\n            });\n            this.eventHandlers.delete(event);\n          } else {\n            this.eventHandlers.set(event, newHandlers);\n            break;\n          }\n        }\n      }\n      closeConnection() {\n        this.logger.info({\n          msg: 'closeConnection()'\n        });\n        this.nearEndDisconnect = true;\n        this.cleanup();\n      }\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["module","export","AMIConnection","Logger","link","v","Manager","default","__reifyWaitForDeps__","makeLoggerDummy","logger","log","debug","info","error","constructor","connection","connectionState","connectionIpOrHostname","connectionPort","userName","password","eventHandlers","printLogs","totalReconnectionAttempts","currentReconnectionAttempt","initialBackoffDurationMS","nearEndDisconnect","connectivityCheck","Map","cleanup","disconnect","removeAllListeners","reconnect","msg","backoffTime","setTimeout","attemptConnection","err","onManagerError","reject","onManagerConnect","_resolve","_reject","login","onManagerLogin","bind","resolve","on","eventHandlerCallback","onManagerClose","hadError","onManagerTimeout","undefined","returnPromise","Promise","connect","arguments","length","isConnected","executeCommand","action","actionResultCallback","warn","Error","event","has","toLowerCase","concat","handlers","get","handler","call","actionid","callbackContext","_this$eventHandlers$g","array","set","push","off","command","isValidContext","newHandlers","filter","obj","delete","closeConnection","__reify_async_result__","_reifyError","self","async"],"sources":["server/services/voip-asterisk/connector/asterisk/ami/AMIConnection.ts"],"sourcesContent":["/**\n * Class representing AMI connection.\n * @remarks\n * This class is based on https://github.com/pipobscure/NodeJS-AsteriskManager\n * which is internally based on https://github.com/mscdex/node-asterisk\n *\n * Asterisk AMI interface is a socket based interface. The AMI configuration\n * happens in /etc/asterisk/manager.conf file.\n *\n */\nimport { Logger } from '@rocket.chat/logger';\nimport Manager from 'asterisk-manager';\n\nimport type { Command } from '../Command';\nimport type { IConnection } from '../IConnection';\nimport type { CallbackContext } from './CallbackContext';\n\nfunction makeLoggerDummy(logger: Logger): Logger {\n\tlogger.log = function log(..._args: any[]): void {\n\t\t// do nothing.\n\t};\n\tlogger.debug = function debug(..._args: any[]): void {\n\t\t// do nothing.\n\t};\n\tlogger.info = function info(..._args: any[]): void {\n\t\t// do nothing.\n\t};\n\tlogger.error = function error(..._args: any[]): void {\n\t\t// do nothing.\n\t};\n\n\treturn logger;\n}\n\ntype ConnectionState = 'UNKNOWN' | 'AUTHENTICATED' | 'ERROR';\n\nexport class AMIConnection implements IConnection {\n\tconnection: typeof Manager | undefined;\n\n\tconnectionState: ConnectionState;\n\n\tconnectionIpOrHostname: string;\n\n\tconnectionPort: string;\n\n\tuserName: string;\n\n\tpassword: string;\n\n\teventHandlers: Map<string, any>;\n\n\tprivate logger: Logger;\n\n\t// This class prints a ton of logs that are useful for debugging specific communication things\n\t// However, for most usecases, logs here won't be needed. Hardcoding while we add a setting\n\t// \"Print extended voip connection logs\" which will control classes' logging behavior\n\tprivate printLogs = false;\n\n\ttotalReconnectionAttempts = 5;\n\n\tcurrentReconnectionAttempt = 0;\n\n\t// Starting with 5 seconds of backoff time. increases with the attempts.\n\tinitialBackoffDurationMS = 5000;\n\n\tnearEndDisconnect = false;\n\n\t// if it is a test connection\n\t// Reconnectivity logic should not be applied.\n\tconnectivityCheck = false;\n\n\tconstructor() {\n\t\tconst logger = new Logger('AMIConnection');\n\t\tthis.logger = this.printLogs ? logger : makeLoggerDummy(logger);\n\t\tthis.eventHandlers = new Map<string, CallbackContext[]>();\n\t\tthis.connectionState = 'UNKNOWN';\n\t}\n\n\tcleanup(): void {\n\t\tif (!this.connection) {\n\t\t\treturn;\n\t\t}\n\t\tthis.connection.disconnect();\n\t\tthis.connection.removeAllListeners();\n\t\tthis.connection = null;\n\t}\n\n\treconnect(): void {\n\t\tthis.logger.debug({\n\t\t\tmsg: 'reconnect ()',\n\t\t\tinitialBackoffDurationMS: this.initialBackoffDurationMS,\n\t\t\tcurrentReconnectionAttempt: this.currentReconnectionAttempt,\n\t\t});\n\t\tif (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n\t\t\tthis.logger.info({ msg: 'reconnect () Not attempting to reconnect' });\n\t\t\t// We have exhausted the reconnection attempts or we have authentication error\n\t\t\t// We dont want to retry anymore\n\t\t\tthis.connectionState = 'ERROR';\n\t\t\treturn;\n\t\t}\n\t\tconst backoffTime = this.initialBackoffDurationMS + this.initialBackoffDurationMS * this.currentReconnectionAttempt;\n\t\tsetTimeout(async () => {\n\t\t\ttry {\n\t\t\t\tawait this.attemptConnection();\n\t\t\t} catch (err: unknown) {\n\t\t\t\tthis.logger.error({ msg: 'reconnect () attemptConnection() has thrown error', err });\n\t\t\t}\n\t\t}, backoffTime);\n\t\tthis.currentReconnectionAttempt += 1;\n\t}\n\n\tonManagerError(reject: any, err: unknown): void {\n\t\tthis.logger.error({ msg: 'onManagerError () Connection Error', err });\n\t\tthis.cleanup();\n\t\tthis.connectionState = 'ERROR';\n\t\tif (this.currentReconnectionAttempt === this.totalReconnectionAttempts) {\n\t\t\tthis.logger.error({ msg: 'onManagerError () reconnection attempts exhausted. Please check connection settings' });\n\t\t\treject(err);\n\t\t} else {\n\t\t\tthis.reconnect();\n\t\t}\n\t}\n\n\tonManagerConnect(_resolve: any, _reject: any): void {\n\t\tthis.logger.debug({ msg: 'onManagerConnect () Connection Success' });\n\t\tthis.connection.login(this.onManagerLogin.bind(this, _resolve, _reject));\n\t}\n\n\tonManagerLogin(resolve: any, reject: any, error: unknown): void {\n\t\tif (error) {\n\t\t\tthis.logger.error({ msg: 'onManagerLogin () Authentication Error. Not going to reattempt. Fix the credentaials' });\n\t\t\t// Do not reattempt if we have login failure\n\t\t\tthis.cleanup();\n\t\t\treject(error);\n\t\t} else {\n\t\t\tthis.connectionState = 'AUTHENTICATED';\n\t\t\tthis.currentReconnectionAttempt = 0;\n\t\t\t/**\n\t\t\t * Note : There is no way to release a handler or cleanup the handlers.\n\t\t\t * Handlers are released only when the connection is closed.\n\t\t\t * Closing the connection and establishing it again for every command is an overhead.\n\t\t\t * To avoid that, we have taken a clean, though a bit complex approach.\n\t\t\t * We will register for all the manager event.\n\t\t\t *\n\t\t\t * Each command will register to AMIConnection to receive the events which it is\n\t\t\t * interested in. Once the processing is complete, it will unregister.\n\t\t\t *\n\t\t\t * Handled in this way will avoid disconnection of the connection to cleanup the\n\t\t\t * handlers.\n\t\t\t *\n\t\t\t * Furthermore, we do not want to initiate this when we are checking\n\t\t\t * the connectivity.\n\t\t\t */\n\t\t\tif (!this.connectivityCheck) {\n\t\t\t\tthis.connection.on('managerevent', this.eventHandlerCallback.bind(this));\n\t\t\t}\n\t\t\tthis.logger.debug({ msg: 'onManagerLogin () Authentication Success, Connected' });\n\t\t\tresolve();\n\t\t}\n\t}\n\n\tonManagerClose(hadError: unknown): void {\n\t\tthis.logger.error({ msg: 'onManagerClose ()', hadError });\n\t\tthis.cleanup();\n\t\tif (!this.nearEndDisconnect) {\n\t\t\tthis.reconnect();\n\t\t}\n\t}\n\n\tonManagerTimeout(): void {\n\t\tthis.logger.debug({ msg: 'onManagerTimeout ()' });\n\t\tthis.cleanup();\n\t}\n\n\tasync attemptConnection(): Promise<void> {\n\t\tthis.connectionState = 'UNKNOWN';\n\t\tthis.connection = new Manager(undefined, this.connectionIpOrHostname, this.userName, this.password, true);\n\n\t\tconst returnPromise = new Promise<void>((_resolve, _reject) => {\n\t\t\tthis.connection.on('connect', this.onManagerConnect.bind(this, _resolve, _reject));\n\t\t\tthis.connection.on('error', this.onManagerError.bind(this, _reject));\n\n\t\t\tthis.connection.on('close', this.onManagerClose.bind(this));\n\t\t\tthis.connection.on('timeout', this.onManagerTimeout.bind(this));\n\n\t\t\tthis.connection.connect(this.connectionPort, this.connectionIpOrHostname);\n\t\t});\n\t\treturn returnPromise;\n\t}\n\n\t/**\n\t * connect: Connects to asterisk\n\t * description: This function initiates a connection to asterisk management interface\n\t * for receiving the various events. These events could be a result of action command sent over\n\t * the socket or an events that asterisk sents over this connection. In the later case, what asterisk\n\t * sends over the socket depends on the way permissions are given to the user in asterisk's\n\t * manager.conf file.\n\t * This code uses a lib https://github.com/pipobscure/NodeJS-AsteriskManager\n\t * The working of this library actually connects in the object creation. i.e\n\t * new Manager(port, connectionIpOrHostname, userName, password, true);\n\t * So it was noticed that if we call isConnected immediately after creating the object,\n\t * it returns false. Eventualy when the connection  and authentication succeeds\n\t * it will be set back to true.\n\t * To avoid this connection we have to explicitly create the Manager with undefined port value.\n\t * When done so, We will have to explicitly call connect and login functions.\n\t * These functions can give a callback where we can resolve the promises\n\t * This way it ensures that the rocket.chat service has a valid connection or an error when this function\n\t * call is over.\n\t *\n\t * @param connectionIpOrHostname\n\t * @param connectionPort\n\t * @param userName\n\t * @param password\n\t */\n\tasync connect(\n\t\tconnectionIpOrHostname: string,\n\t\tconnectionPort: string,\n\t\tuserName: string,\n\t\tpassword: string,\n\t\tconnectivityCheck = false,\n\t): Promise<void> {\n\t\tthis.logger.log({ msg: 'connect()' });\n\t\tthis.connectionIpOrHostname = connectionIpOrHostname;\n\t\tthis.connectionPort = connectionPort;\n\t\tthis.userName = userName;\n\t\tthis.password = password;\n\t\tthis.connectivityCheck = connectivityCheck;\n\t\tawait this.attemptConnection();\n\t}\n\n\tisConnected(): boolean {\n\t\tif (this.connection) {\n\t\t\treturn this.connection.isConnected();\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Executes an action on asterisk and returns the result.\n\texecuteCommand(action: object, actionResultCallback: any): void {\n\t\tif (this.connectionState !== 'AUTHENTICATED' || (this.connection && !this.connection.isConnected())) {\n\t\t\tthis.logger.warn({ msg: 'executeCommand() Cant execute command at this moment. Connection is not active' });\n\t\t\tthrow Error('Cant execute command at this moment. Connection is not active');\n\t\t}\n\t\tthis.logger.info({ msg: 'executeCommand()' });\n\t\tthis.connection.action(action, actionResultCallback);\n\t}\n\n\teventHandlerCallback(event: any): void {\n\t\tif (!this.eventHandlers.has(event.event.toLowerCase())) {\n\t\t\tthis.logger.info({ msg: `No event handler set for ${event.event}` });\n\t\t\treturn;\n\t\t}\n\t\tconst handlers: CallbackContext[] = this.eventHandlers.get(event.event.toLowerCase());\n\t\tthis.logger.debug({ msg: `eventHandlerCallback() Handler count = ${handlers.length}` });\n\t\t/* Go thru all the available handlers  and call each one of them if the actionid matches */\n\t\tfor (const handler of handlers) {\n\t\t\tif (handler.call(event)) {\n\t\t\t\tthis.logger.debug({ msg: `eventHandlerCallback() called callback for action = ${event.actionid}` });\n\t\t\t} else {\n\t\t\t\tthis.logger.debug({\n\t\t\t\t\tmsg: `eventHandlerCallback() No command found for action = ${event.actionid}`,\n\t\t\t\t\tevent: event.event,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\ton(event: string, callbackContext: CallbackContext): void {\n\t\tthis.logger.info({ msg: 'on()' });\n\t\tif (!this.eventHandlers.has(event)) {\n\t\t\tthis.logger.debug({ msg: `on() no existing handlers for event = ${event}` });\n\t\t\tconst array: CallbackContext[] = [];\n\t\t\tthis.eventHandlers.set(event, array);\n\t\t}\n\t\tthis.eventHandlers.get(event)?.push(callbackContext);\n\t}\n\n\toff(event: string, command: Command): void {\n\t\tthis.logger.info({ msg: 'off()' });\n\t\tif (!this.eventHandlers.has(event)) {\n\t\t\tthis.logger.warn({ msg: `off() No event handler found for ${event}` });\n\t\t\treturn;\n\t\t}\n\t\tthis.logger.debug({ msg: `off() Event found ${event}` });\n\t\tconst handlers = this.eventHandlers.get(event);\n\t\tthis.logger.debug({ msg: `off() Handler array length = ${handlers.length}` });\n\t\tfor (const handler of handlers) {\n\t\t\tif (!handler.isValidContext(command.actionid)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst newHandlers = handlers.filter((obj: any) => obj !== handler);\n\t\t\tif (!newHandlers.length) {\n\t\t\t\tthis.logger.debug({ msg: `off() No handler for ${event} deleting event from the map.` });\n\t\t\t\tthis.eventHandlers.delete(event);\n\t\t\t} else {\n\t\t\t\tthis.eventHandlers.set(event, newHandlers);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcloseConnection(): void {\n\t\tthis.logger.info({ msg: 'closeConnection()' });\n\t\tthis.nearEndDisconnect = true;\n\t\tthis.cleanup();\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"ff4f01da0d597adaa2e9227e4d58d9c4661b0feb"}
