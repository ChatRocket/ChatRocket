{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/server/models/raw/FederationEvents.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"server/models/raw/FederationEvents.ts","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/server/models/raw/FederationEvents.ts","inputSourceMap":{"version":3,"file":"server/models/raw/FederationEvents.ts","sourceRoot":"","sources":["server/models/raw/FederationEvents.ts"],"names":[],"mappings":"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","sourcesContent":["import { eventTypes } from '@rocket.chat/core-typings';\nimport type { IFederationEvent } from '@rocket.chat/core-typings';\nimport { SHA256 } from '@rocket.chat/sha256';\nimport type { IndexDescription, Db } from 'mongodb';\n\nimport { BaseRaw } from './BaseRaw';\n\nexport class FederationEventsModel extends BaseRaw<IFederationEvent> {\n\tconstructor(db: Db, nameOrModel: string) {\n\t\tsuper(db, nameOrModel);\n\t}\n\n\tprotected modelIndexes(): IndexDescription[] {\n\t\treturn [{ key: { hasChildren: 1 }, sparse: true }, { key: { timestamp: 1 } }];\n\t}\n\n\tgetEventHash(\n\t\tcontextQuery: { roomId: string },\n\t\tevent: { type: string; timestamp: Date; data: Record<string, unknown>; parentIds: string[]; origin: string },\n\t): string {\n\t\treturn SHA256(\n\t\t\t`${event.origin}${JSON.stringify(contextQuery)}${event.parentIds.join(',')}${event.type}${event.timestamp}${JSON.stringify(\n\t\t\t\tevent.data,\n\t\t\t)}`,\n\t\t);\n\t}\n\n\tasync createEvent(\n\t\torigin: string,\n\t\tcontextQuery: { roomId: string },\n\t\ttype: string,\n\t\tdata: any,\n\t): Promise<Omit<IFederationEvent, '_updatedAt'>> {\n\t\tlet previousEventsIds: string[] = [];\n\n\t\t// If it is not a GENESIS event, we need to get the previous events\n\t\tif (type !== eventTypes.GENESIS) {\n\t\t\tconst previousEvents = await this.find({ context: contextQuery, hasChildren: false }).toArray();\n\n\t\t\t// if (!previousEvents.length) {\n\t\t\t// \tthrow new Error('Could not create event, the context does not exist');\n\t\t\t// }\n\n\t\t\tpreviousEventsIds = previousEvents.map((e) => e._id);\n\t\t}\n\n\t\tconst event = {\n\t\t\torigin,\n\t\t\tcontext: contextQuery,\n\t\t\tparentIds: previousEventsIds || [],\n\t\t\ttype,\n\t\t\ttimestamp: new Date(),\n\t\t\tdata,\n\t\t\thasChildren: false,\n\t\t\t_id: '',\n\t\t};\n\n\t\tevent._id = this.getEventHash(contextQuery, event);\n\n\t\t// this.insert(event);\n\n\t\t// Clear the \"hasChildren\" of those events\n\t\tawait this.updateMany({ _id: { $in: previousEventsIds } }, { $unset: { hasChildren: '' } });\n\n\t\treturn event;\n\t}\n\n\tasync createGenesisEvent(origin: string, contextQuery: { roomId: string }, data: any): Promise<Omit<IFederationEvent, '_updatedAt'>> {\n\t\t// Check if genesis event already exists, if so, do not create\n\t\tconst genesisEvent = await this.findOne({ context: contextQuery, type: eventTypes.GENESIS });\n\n\t\tif (genesisEvent) {\n\t\t\tthrow new Error(`A GENESIS event for this context query already exists: ${JSON.stringify(contextQuery, null, 2)}`);\n\t\t}\n\n\t\treturn this.createEvent(origin, contextQuery, eventTypes.GENESIS, data);\n\t}\n\n\tasync addEvent(\n\t\tcontextQuery: { roomId: string },\n\t\tevent: IFederationEvent,\n\t): Promise<{ success: boolean; reason: string; missingParentIds: string[]; latestEventIds: string[] } | { success: boolean }> {\n\t\t// Check if the event does not exit\n\t\tconst existingEvent = await this.findOne({ _id: event._id });\n\n\t\t// If it does not, we insert it, checking for the parents\n\t\tif (!existingEvent) {\n\t\t\t// Check if we have the parents\n\t\t\tconst parents = await this.find({ context: contextQuery, _id: { $in: event.parentIds } }, { projection: { _id: 1 } }).toArray();\n\t\t\tconst parentIds = parents.map(({ _id }) => _id);\n\n\t\t\t// This means that we do not have the parents of the event we are adding\n\t\t\tif (parentIds.length !== event.parentIds.length) {\n\t\t\t\tconst { origin } = event;\n\n\t\t\t\t// Get the latest events for that context and origin\n\t\t\t\tconst latestEvents = await this.find({ context: contextQuery, origin }, { projection: { _id: 1 } }).toArray();\n\t\t\t\tconst latestEventIds = latestEvents.map(({ _id }) => _id);\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\treason: 'missingParents',\n\t\t\t\t\t// @ts-expect-error - Is this properly typed? parentIds seems to be an string[] (and its used as a filter on an $in query)\n\t\t\t\t\t// but here it seems its an object of { _id: string }[] so I'm not sure if this is correct\n\t\t\t\t\tmissingParentIds: event.parentIds.filter(({ _id }) => parentIds.indexOf(_id) === -1),\n\t\t\t\t\tlatestEventIds,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Clear the \"hasChildren\" of the parent events\n\t\t\tawait this.updateMany({ _id: { $in: parentIds } }, { $unset: { hasChildren: '' } });\n\n\t\t\tawait this.insertOne(event);\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t};\n\t}\n\n\tasync getEventById(contextQuery: { roomId: string }, eventId: string): Promise<{ success: boolean; event: IFederationEvent | null }> {\n\t\tconst event = await this.findOne({ context: contextQuery, _id: eventId });\n\n\t\treturn {\n\t\t\tsuccess: !!event,\n\t\t\tevent,\n\t\t};\n\t}\n\n\tasync getLatestEvents(contextQuery: { roomId: string }, fromTimestamp: string): Promise<IFederationEvent[]> {\n\t\treturn this.find({ context: contextQuery, timestamp: { $gt: new Date(fromTimestamp) } }).toArray();\n\t}\n\n\tasync removeContextEvents(contextQuery: { roomId: string }) {\n\t\treturn this.deleteMany({ context: contextQuery });\n\t}\n}\n"]},"targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/server/models/raw/FederationEvents.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/models/raw/FederationEvents.ts","inputSourceMap":{"version":3,"file":"server/models/raw/FederationEvents.ts","sourceRoot":"","sources":["server/models/raw/FederationEvents.ts"],"names":[],"mappings":"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","sourcesContent":["import { eventTypes } from '@rocket.chat/core-typings';\nimport type { IFederationEvent } from '@rocket.chat/core-typings';\nimport { SHA256 } from '@rocket.chat/sha256';\nimport type { IndexDescription, Db } from 'mongodb';\n\nimport { BaseRaw } from './BaseRaw';\n\nexport class FederationEventsModel extends BaseRaw<IFederationEvent> {\n\tconstructor(db: Db, nameOrModel: string) {\n\t\tsuper(db, nameOrModel);\n\t}\n\n\tprotected modelIndexes(): IndexDescription[] {\n\t\treturn [{ key: { hasChildren: 1 }, sparse: true }, { key: { timestamp: 1 } }];\n\t}\n\n\tgetEventHash(\n\t\tcontextQuery: { roomId: string },\n\t\tevent: { type: string; timestamp: Date; data: Record<string, unknown>; parentIds: string[]; origin: string },\n\t): string {\n\t\treturn SHA256(\n\t\t\t`${event.origin}${JSON.stringify(contextQuery)}${event.parentIds.join(',')}${event.type}${event.timestamp}${JSON.stringify(\n\t\t\t\tevent.data,\n\t\t\t)}`,\n\t\t);\n\t}\n\n\tasync createEvent(\n\t\torigin: string,\n\t\tcontextQuery: { roomId: string },\n\t\ttype: string,\n\t\tdata: any,\n\t): Promise<Omit<IFederationEvent, '_updatedAt'>> {\n\t\tlet previousEventsIds: string[] = [];\n\n\t\t// If it is not a GENESIS event, we need to get the previous events\n\t\tif (type !== eventTypes.GENESIS) {\n\t\t\tconst previousEvents = await this.find({ context: contextQuery, hasChildren: false }).toArray();\n\n\t\t\t// if (!previousEvents.length) {\n\t\t\t// \tthrow new Error('Could not create event, the context does not exist');\n\t\t\t// }\n\n\t\t\tpreviousEventsIds = previousEvents.map((e) => e._id);\n\t\t}\n\n\t\tconst event = {\n\t\t\torigin,\n\t\t\tcontext: contextQuery,\n\t\t\tparentIds: previousEventsIds || [],\n\t\t\ttype,\n\t\t\ttimestamp: new Date(),\n\t\t\tdata,\n\t\t\thasChildren: false,\n\t\t\t_id: '',\n\t\t};\n\n\t\tevent._id = this.getEventHash(contextQuery, event);\n\n\t\t// this.insert(event);\n\n\t\t// Clear the \"hasChildren\" of those events\n\t\tawait this.updateMany({ _id: { $in: previousEventsIds } }, { $unset: { hasChildren: '' } });\n\n\t\treturn event;\n\t}\n\n\tasync createGenesisEvent(origin: string, contextQuery: { roomId: string }, data: any): Promise<Omit<IFederationEvent, '_updatedAt'>> {\n\t\t// Check if genesis event already exists, if so, do not create\n\t\tconst genesisEvent = await this.findOne({ context: contextQuery, type: eventTypes.GENESIS });\n\n\t\tif (genesisEvent) {\n\t\t\tthrow new Error(`A GENESIS event for this context query already exists: ${JSON.stringify(contextQuery, null, 2)}`);\n\t\t}\n\n\t\treturn this.createEvent(origin, contextQuery, eventTypes.GENESIS, data);\n\t}\n\n\tasync addEvent(\n\t\tcontextQuery: { roomId: string },\n\t\tevent: IFederationEvent,\n\t): Promise<{ success: boolean; reason: string; missingParentIds: string[]; latestEventIds: string[] } | { success: boolean }> {\n\t\t// Check if the event does not exit\n\t\tconst existingEvent = await this.findOne({ _id: event._id });\n\n\t\t// If it does not, we insert it, checking for the parents\n\t\tif (!existingEvent) {\n\t\t\t// Check if we have the parents\n\t\t\tconst parents = await this.find({ context: contextQuery, _id: { $in: event.parentIds } }, { projection: { _id: 1 } }).toArray();\n\t\t\tconst parentIds = parents.map(({ _id }) => _id);\n\n\t\t\t// This means that we do not have the parents of the event we are adding\n\t\t\tif (parentIds.length !== event.parentIds.length) {\n\t\t\t\tconst { origin } = event;\n\n\t\t\t\t// Get the latest events for that context and origin\n\t\t\t\tconst latestEvents = await this.find({ context: contextQuery, origin }, { projection: { _id: 1 } }).toArray();\n\t\t\t\tconst latestEventIds = latestEvents.map(({ _id }) => _id);\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\treason: 'missingParents',\n\t\t\t\t\t// @ts-expect-error - Is this properly typed? parentIds seems to be an string[] (and its used as a filter on an $in query)\n\t\t\t\t\t// but here it seems its an object of { _id: string }[] so I'm not sure if this is correct\n\t\t\t\t\tmissingParentIds: event.parentIds.filter(({ _id }) => parentIds.indexOf(_id) === -1),\n\t\t\t\t\tlatestEventIds,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Clear the \"hasChildren\" of the parent events\n\t\t\tawait this.updateMany({ _id: { $in: parentIds } }, { $unset: { hasChildren: '' } });\n\n\t\t\tawait this.insertOne(event);\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t};\n\t}\n\n\tasync getEventById(contextQuery: { roomId: string }, eventId: string): Promise<{ success: boolean; event: IFederationEvent | null }> {\n\t\tconst event = await this.findOne({ context: contextQuery, _id: eventId });\n\n\t\treturn {\n\t\t\tsuccess: !!event,\n\t\t\tevent,\n\t\t};\n\t}\n\n\tasync getLatestEvents(contextQuery: { roomId: string }, fromTimestamp: string): Promise<IFederationEvent[]> {\n\t\treturn this.find({ context: contextQuery, timestamp: { $gt: new Date(fromTimestamp) } }).toArray();\n\t}\n\n\tasync removeContextEvents(contextQuery: { roomId: string }) {\n\t\treturn this.deleteMany({ context: contextQuery });\n\t}\n}\n"]}}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    module.export({\n      FederationEventsModel: () => FederationEventsModel\n    });\n    let eventTypes;\n    module.link(\"@rocket.chat/core-typings\", {\n      eventTypes(v) {\n        eventTypes = v;\n      }\n    }, 0);\n    let SHA256;\n    module.link(\"@rocket.chat/sha256\", {\n      SHA256(v) {\n        SHA256 = v;\n      }\n    }, 1);\n    let BaseRaw;\n    module.link(\"./BaseRaw\", {\n      BaseRaw(v) {\n        BaseRaw = v;\n      }\n    }, 2);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    class FederationEventsModel extends BaseRaw {\n      constructor(db, nameOrModel) {\n        super(db, nameOrModel);\n      }\n      modelIndexes() {\n        return [{\n          key: {\n            hasChildren: 1\n          },\n          sparse: true\n        }, {\n          key: {\n            timestamp: 1\n          }\n        }];\n      }\n      getEventHash(contextQuery, event) {\n        return SHA256(\"\".concat(event.origin).concat(JSON.stringify(contextQuery)).concat(event.parentIds.join(',')).concat(event.type).concat(event.timestamp).concat(JSON.stringify(event.data)));\n      }\n      async createEvent(origin, contextQuery, type, data) {\n        let previousEventsIds = [];\n        // If it is not a GENESIS event, we need to get the previous events\n        if (type !== eventTypes.GENESIS) {\n          const previousEvents = await this.find({\n            context: contextQuery,\n            hasChildren: false\n          }).toArray();\n          // if (!previousEvents.length) {\n          // \tthrow new Error('Could not create event, the context does not exist');\n          // }\n          previousEventsIds = previousEvents.map(e => e._id);\n        }\n        const event = {\n          origin,\n          context: contextQuery,\n          parentIds: previousEventsIds || [],\n          type,\n          timestamp: new Date(),\n          data,\n          hasChildren: false,\n          _id: ''\n        };\n        event._id = this.getEventHash(contextQuery, event);\n        // this.insert(event);\n        // Clear the \"hasChildren\" of those events\n        await this.updateMany({\n          _id: {\n            $in: previousEventsIds\n          }\n        }, {\n          $unset: {\n            hasChildren: ''\n          }\n        });\n        return event;\n      }\n      async createGenesisEvent(origin, contextQuery, data) {\n        // Check if genesis event already exists, if so, do not create\n        const genesisEvent = await this.findOne({\n          context: contextQuery,\n          type: eventTypes.GENESIS\n        });\n        if (genesisEvent) {\n          throw new Error(\"A GENESIS event for this context query already exists: \".concat(JSON.stringify(contextQuery, null, 2)));\n        }\n        return this.createEvent(origin, contextQuery, eventTypes.GENESIS, data);\n      }\n      async addEvent(contextQuery, event) {\n        // Check if the event does not exit\n        const existingEvent = await this.findOne({\n          _id: event._id\n        });\n        // If it does not, we insert it, checking for the parents\n        if (!existingEvent) {\n          // Check if we have the parents\n          const parents = await this.find({\n            context: contextQuery,\n            _id: {\n              $in: event.parentIds\n            }\n          }, {\n            projection: {\n              _id: 1\n            }\n          }).toArray();\n          const parentIds = parents.map(_ref => {\n            let {\n              _id\n            } = _ref;\n            return _id;\n          });\n          // This means that we do not have the parents of the event we are adding\n          if (parentIds.length !== event.parentIds.length) {\n            const {\n              origin\n            } = event;\n            // Get the latest events for that context and origin\n            const latestEvents = await this.find({\n              context: contextQuery,\n              origin\n            }, {\n              projection: {\n                _id: 1\n              }\n            }).toArray();\n            const latestEventIds = latestEvents.map(_ref2 => {\n              let {\n                _id\n              } = _ref2;\n              return _id;\n            });\n            return {\n              success: false,\n              reason: 'missingParents',\n              // @ts-expect-error - Is this properly typed? parentIds seems to be an string[] (and its used as a filter on an $in query)\n              // but here it seems its an object of { _id: string }[] so I'm not sure if this is correct\n              missingParentIds: event.parentIds.filter(_ref3 => {\n                let {\n                  _id\n                } = _ref3;\n                return parentIds.indexOf(_id) === -1;\n              }),\n              latestEventIds\n            };\n          }\n          // Clear the \"hasChildren\" of the parent events\n          await this.updateMany({\n            _id: {\n              $in: parentIds\n            }\n          }, {\n            $unset: {\n              hasChildren: ''\n            }\n          });\n          await this.insertOne(event);\n        }\n        return {\n          success: true\n        };\n      }\n      async getEventById(contextQuery, eventId) {\n        const event = await this.findOne({\n          context: contextQuery,\n          _id: eventId\n        });\n        return {\n          success: !!event,\n          event\n        };\n      }\n      async getLatestEvents(contextQuery, fromTimestamp) {\n        return this.find({\n          context: contextQuery,\n          timestamp: {\n            $gt: new Date(fromTimestamp)\n          }\n        }).toArray();\n      }\n      async removeContextEvents(contextQuery) {\n        return this.deleteMany({\n          context: contextQuery\n        });\n      }\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["module","export","FederationEventsModel","eventTypes","link","v","SHA256","BaseRaw","__reifyWaitForDeps__","constructor","db","nameOrModel","modelIndexes","key","hasChildren","sparse","timestamp","getEventHash","contextQuery","event","concat","origin","JSON","stringify","parentIds","join","type","data","createEvent","previousEventsIds","GENESIS","previousEvents","find","context","toArray","map","e","_id","Date","updateMany","$in","$unset","createGenesisEvent","genesisEvent","findOne","Error","addEvent","existingEvent","parents","projection","_ref","length","latestEvents","latestEventIds","_ref2","success","reason","missingParentIds","filter","_ref3","indexOf","insertOne","getEventById","eventId","getLatestEvents","fromTimestamp","$gt","removeContextEvents","deleteMany","__reify_async_result__","_reifyError","self","async"],"sources":["server/models/raw/FederationEvents.ts"],"sourcesContent":["import { eventTypes } from '@rocket.chat/core-typings';\nimport type { IFederationEvent } from '@rocket.chat/core-typings';\nimport { SHA256 } from '@rocket.chat/sha256';\nimport type { IndexDescription, Db } from 'mongodb';\n\nimport { BaseRaw } from './BaseRaw';\n\nexport class FederationEventsModel extends BaseRaw<IFederationEvent> {\n\tconstructor(db: Db, nameOrModel: string) {\n\t\tsuper(db, nameOrModel);\n\t}\n\n\tprotected modelIndexes(): IndexDescription[] {\n\t\treturn [{ key: { hasChildren: 1 }, sparse: true }, { key: { timestamp: 1 } }];\n\t}\n\n\tgetEventHash(\n\t\tcontextQuery: { roomId: string },\n\t\tevent: { type: string; timestamp: Date; data: Record<string, unknown>; parentIds: string[]; origin: string },\n\t): string {\n\t\treturn SHA256(\n\t\t\t`${event.origin}${JSON.stringify(contextQuery)}${event.parentIds.join(',')}${event.type}${event.timestamp}${JSON.stringify(\n\t\t\t\tevent.data,\n\t\t\t)}`,\n\t\t);\n\t}\n\n\tasync createEvent(\n\t\torigin: string,\n\t\tcontextQuery: { roomId: string },\n\t\ttype: string,\n\t\tdata: any,\n\t): Promise<Omit<IFederationEvent, '_updatedAt'>> {\n\t\tlet previousEventsIds: string[] = [];\n\n\t\t// If it is not a GENESIS event, we need to get the previous events\n\t\tif (type !== eventTypes.GENESIS) {\n\t\t\tconst previousEvents = await this.find({ context: contextQuery, hasChildren: false }).toArray();\n\n\t\t\t// if (!previousEvents.length) {\n\t\t\t// \tthrow new Error('Could not create event, the context does not exist');\n\t\t\t// }\n\n\t\t\tpreviousEventsIds = previousEvents.map((e) => e._id);\n\t\t}\n\n\t\tconst event = {\n\t\t\torigin,\n\t\t\tcontext: contextQuery,\n\t\t\tparentIds: previousEventsIds || [],\n\t\t\ttype,\n\t\t\ttimestamp: new Date(),\n\t\t\tdata,\n\t\t\thasChildren: false,\n\t\t\t_id: '',\n\t\t};\n\n\t\tevent._id = this.getEventHash(contextQuery, event);\n\n\t\t// this.insert(event);\n\n\t\t// Clear the \"hasChildren\" of those events\n\t\tawait this.updateMany({ _id: { $in: previousEventsIds } }, { $unset: { hasChildren: '' } });\n\n\t\treturn event;\n\t}\n\n\tasync createGenesisEvent(origin: string, contextQuery: { roomId: string }, data: any): Promise<Omit<IFederationEvent, '_updatedAt'>> {\n\t\t// Check if genesis event already exists, if so, do not create\n\t\tconst genesisEvent = await this.findOne({ context: contextQuery, type: eventTypes.GENESIS });\n\n\t\tif (genesisEvent) {\n\t\t\tthrow new Error(`A GENESIS event for this context query already exists: ${JSON.stringify(contextQuery, null, 2)}`);\n\t\t}\n\n\t\treturn this.createEvent(origin, contextQuery, eventTypes.GENESIS, data);\n\t}\n\n\tasync addEvent(\n\t\tcontextQuery: { roomId: string },\n\t\tevent: IFederationEvent,\n\t): Promise<{ success: boolean; reason: string; missingParentIds: string[]; latestEventIds: string[] } | { success: boolean }> {\n\t\t// Check if the event does not exit\n\t\tconst existingEvent = await this.findOne({ _id: event._id });\n\n\t\t// If it does not, we insert it, checking for the parents\n\t\tif (!existingEvent) {\n\t\t\t// Check if we have the parents\n\t\t\tconst parents = await this.find({ context: contextQuery, _id: { $in: event.parentIds } }, { projection: { _id: 1 } }).toArray();\n\t\t\tconst parentIds = parents.map(({ _id }) => _id);\n\n\t\t\t// This means that we do not have the parents of the event we are adding\n\t\t\tif (parentIds.length !== event.parentIds.length) {\n\t\t\t\tconst { origin } = event;\n\n\t\t\t\t// Get the latest events for that context and origin\n\t\t\t\tconst latestEvents = await this.find({ context: contextQuery, origin }, { projection: { _id: 1 } }).toArray();\n\t\t\t\tconst latestEventIds = latestEvents.map(({ _id }) => _id);\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\treason: 'missingParents',\n\t\t\t\t\t// @ts-expect-error - Is this properly typed? parentIds seems to be an string[] (and its used as a filter on an $in query)\n\t\t\t\t\t// but here it seems its an object of { _id: string }[] so I'm not sure if this is correct\n\t\t\t\t\tmissingParentIds: event.parentIds.filter(({ _id }) => parentIds.indexOf(_id) === -1),\n\t\t\t\t\tlatestEventIds,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Clear the \"hasChildren\" of the parent events\n\t\t\tawait this.updateMany({ _id: { $in: parentIds } }, { $unset: { hasChildren: '' } });\n\n\t\t\tawait this.insertOne(event);\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t};\n\t}\n\n\tasync getEventById(contextQuery: { roomId: string }, eventId: string): Promise<{ success: boolean; event: IFederationEvent | null }> {\n\t\tconst event = await this.findOne({ context: contextQuery, _id: eventId });\n\n\t\treturn {\n\t\t\tsuccess: !!event,\n\t\t\tevent,\n\t\t};\n\t}\n\n\tasync getLatestEvents(contextQuery: { roomId: string }, fromTimestamp: string): Promise<IFederationEvent[]> {\n\t\treturn this.find({ context: contextQuery, timestamp: { $gt: new Date(fromTimestamp) } }).toArray();\n\t}\n\n\tasync removeContextEvents(contextQuery: { roomId: string }) {\n\t\treturn this.deleteMany({ context: contextQuery });\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"f11da6a3d67884ccdc6e57adc3bfd570b6c689bf"}
