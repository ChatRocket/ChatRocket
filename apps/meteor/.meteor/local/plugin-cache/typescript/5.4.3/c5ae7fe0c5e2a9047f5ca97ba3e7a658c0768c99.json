{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/lib/server/functions/getRoomsWithSingleOwner.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"app/lib/server/functions/getRoomsWithSingleOwner.ts","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/lib/server/functions/getRoomsWithSingleOwner.ts","inputSourceMap":{"version":3,"file":"app/lib/server/functions/getRoomsWithSingleOwner.ts","sourceRoot":"","sources":["app/lib/server/functions/getRoomsWithSingleOwner.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IUser } from '@rocket.chat/core-typings';\nimport { Subscriptions, Users } from '@rocket.chat/models';\n\nimport { subscriptionHasRole } from '../../../authorization/server';\n\nexport type SubscribedRoomsForUserWithDetails = {\n\trid: string;\n\tt: string;\n\tshouldBeRemoved: boolean;\n\tshouldChangeOwner: boolean;\n\tuserIsLastOwner: boolean;\n\tnewOwner: IUser['_id'] | null;\n};\n\nexport function shouldRemoveOrChangeOwner(subscribedRooms: SubscribedRoomsForUserWithDetails[]): boolean {\n\treturn subscribedRooms.some(({ shouldBeRemoved, shouldChangeOwner }) => shouldBeRemoved || shouldChangeOwner);\n}\n\nexport async function getSubscribedRoomsForUserWithDetails(\n\tuserId: string,\n\tassignNewOwner = true,\n\troomIds: string[] = [],\n): Promise<SubscribedRoomsForUserWithDetails[]> {\n\tconst subscribedRooms: SubscribedRoomsForUserWithDetails[] = [];\n\n\tconst cursor =\n\t\troomIds.length > 0 ? Subscriptions.findByUserIdAndRoomIds(userId, roomIds) : Subscriptions.findByUserIdExceptType(userId, 'd');\n\n\t// Iterate through all the rooms the user is subscribed to, to check if he is the last owner of any of them.\n\tfor await (const subscription of cursor) {\n\t\tconst roomData: SubscribedRoomsForUserWithDetails = {\n\t\t\trid: subscription.rid,\n\t\t\tt: subscription.t,\n\t\t\tshouldBeRemoved: false,\n\t\t\tshouldChangeOwner: false,\n\t\t\tuserIsLastOwner: false,\n\t\t\tnewOwner: null,\n\t\t};\n\n\t\tif (subscriptionHasRole(subscription, 'owner')) {\n\t\t\t// Fetch the number of owners\n\t\t\tconst numOwners = await Subscriptions.countByRoomIdAndRoles(subscription.rid, ['owner']);\n\t\t\t// If it's only one, then this user is the only owner.\n\t\t\troomData.userIsLastOwner = numOwners === 1;\n\t\t\tif (numOwners === 1 && assignNewOwner) {\n\t\t\t\t// Let's check how many subscribers the room has.\n\t\t\t\tconst options = { projection: { 'u._id': 1 }, sort: { ts: 1 as const } };\n\t\t\t\tconst subscribersCursor = Subscriptions.findByRoomId(subscription.rid, options);\n\n\t\t\t\tfor await (const {\n\t\t\t\t\tu: { _id: uid },\n\t\t\t\t} of subscribersCursor) {\n\t\t\t\t\t// If we already changed the owner or this subscription is for the user we are removing, then don't try to give it ownership\n\t\t\t\t\tif (roomData.shouldChangeOwner || uid === userId) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst newOwner = await Users.findOneActiveById(uid, { projection: { _id: 1 } });\n\t\t\t\t\tif (!newOwner) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\troomData.newOwner = uid;\n\t\t\t\t\troomData.shouldChangeOwner = true;\n\t\t\t\t}\n\n\t\t\t\t// If there's no subscriber available to be the new owner and it's not a public room, we can remove it.\n\t\t\t\tif (!roomData.shouldChangeOwner && roomData.t !== 'c') {\n\t\t\t\t\troomData.shouldBeRemoved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (roomData.t !== 'c') {\n\t\t\t// If the user is not an owner, remove the room if the user is the only subscriber\n\t\t\troomData.shouldBeRemoved = (await Subscriptions.countByRoomId(roomData.rid)) === 1;\n\t\t}\n\n\t\tsubscribedRooms.push(roomData);\n\t}\n\n\treturn subscribedRooms;\n}\n"]},"targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/lib/server/functions/getRoomsWithSingleOwner.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/lib/server/functions/getRoomsWithSingleOwner.ts","inputSourceMap":{"version":3,"file":"app/lib/server/functions/getRoomsWithSingleOwner.ts","sourceRoot":"","sources":["app/lib/server/functions/getRoomsWithSingleOwner.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IUser } from '@rocket.chat/core-typings';\nimport { Subscriptions, Users } from '@rocket.chat/models';\n\nimport { subscriptionHasRole } from '../../../authorization/server';\n\nexport type SubscribedRoomsForUserWithDetails = {\n\trid: string;\n\tt: string;\n\tshouldBeRemoved: boolean;\n\tshouldChangeOwner: boolean;\n\tuserIsLastOwner: boolean;\n\tnewOwner: IUser['_id'] | null;\n};\n\nexport function shouldRemoveOrChangeOwner(subscribedRooms: SubscribedRoomsForUserWithDetails[]): boolean {\n\treturn subscribedRooms.some(({ shouldBeRemoved, shouldChangeOwner }) => shouldBeRemoved || shouldChangeOwner);\n}\n\nexport async function getSubscribedRoomsForUserWithDetails(\n\tuserId: string,\n\tassignNewOwner = true,\n\troomIds: string[] = [],\n): Promise<SubscribedRoomsForUserWithDetails[]> {\n\tconst subscribedRooms: SubscribedRoomsForUserWithDetails[] = [];\n\n\tconst cursor =\n\t\troomIds.length > 0 ? Subscriptions.findByUserIdAndRoomIds(userId, roomIds) : Subscriptions.findByUserIdExceptType(userId, 'd');\n\n\t// Iterate through all the rooms the user is subscribed to, to check if he is the last owner of any of them.\n\tfor await (const subscription of cursor) {\n\t\tconst roomData: SubscribedRoomsForUserWithDetails = {\n\t\t\trid: subscription.rid,\n\t\t\tt: subscription.t,\n\t\t\tshouldBeRemoved: false,\n\t\t\tshouldChangeOwner: false,\n\t\t\tuserIsLastOwner: false,\n\t\t\tnewOwner: null,\n\t\t};\n\n\t\tif (subscriptionHasRole(subscription, 'owner')) {\n\t\t\t// Fetch the number of owners\n\t\t\tconst numOwners = await Subscriptions.countByRoomIdAndRoles(subscription.rid, ['owner']);\n\t\t\t// If it's only one, then this user is the only owner.\n\t\t\troomData.userIsLastOwner = numOwners === 1;\n\t\t\tif (numOwners === 1 && assignNewOwner) {\n\t\t\t\t// Let's check how many subscribers the room has.\n\t\t\t\tconst options = { projection: { 'u._id': 1 }, sort: { ts: 1 as const } };\n\t\t\t\tconst subscribersCursor = Subscriptions.findByRoomId(subscription.rid, options);\n\n\t\t\t\tfor await (const {\n\t\t\t\t\tu: { _id: uid },\n\t\t\t\t} of subscribersCursor) {\n\t\t\t\t\t// If we already changed the owner or this subscription is for the user we are removing, then don't try to give it ownership\n\t\t\t\t\tif (roomData.shouldChangeOwner || uid === userId) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst newOwner = await Users.findOneActiveById(uid, { projection: { _id: 1 } });\n\t\t\t\t\tif (!newOwner) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\troomData.newOwner = uid;\n\t\t\t\t\troomData.shouldChangeOwner = true;\n\t\t\t\t}\n\n\t\t\t\t// If there's no subscriber available to be the new owner and it's not a public room, we can remove it.\n\t\t\t\tif (!roomData.shouldChangeOwner && roomData.t !== 'c') {\n\t\t\t\t\troomData.shouldBeRemoved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (roomData.t !== 'c') {\n\t\t\t// If the user is not an owner, remove the room if the user is the only subscriber\n\t\t\troomData.shouldBeRemoved = (await Subscriptions.countByRoomId(roomData.rid)) === 1;\n\t\t}\n\n\t\tsubscribedRooms.push(roomData);\n\t}\n\n\treturn subscribedRooms;\n}\n"]}}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _asyncIterator;\n    module.link(\"@babel/runtime/helpers/asyncIterator\", {\n      default(v) {\n        _asyncIterator = v;\n      }\n    }, 0);\n    module.export({\n      shouldRemoveOrChangeOwner: () => shouldRemoveOrChangeOwner,\n      getSubscribedRoomsForUserWithDetails: () => getSubscribedRoomsForUserWithDetails\n    });\n    let Subscriptions, Users;\n    module.link(\"@rocket.chat/models\", {\n      Subscriptions(v) {\n        Subscriptions = v;\n      },\n      Users(v) {\n        Users = v;\n      }\n    }, 0);\n    let subscriptionHasRole;\n    module.link(\"../../../authorization/server\", {\n      subscriptionHasRole(v) {\n        subscriptionHasRole = v;\n      }\n    }, 1);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    function shouldRemoveOrChangeOwner(subscribedRooms) {\n      return subscribedRooms.some(_ref => {\n        let {\n          shouldBeRemoved,\n          shouldChangeOwner\n        } = _ref;\n        return shouldBeRemoved || shouldChangeOwner;\n      });\n    }\n    async function getSubscribedRoomsForUserWithDetails(userId) {\n      let assignNewOwner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      let roomIds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      const subscribedRooms = [];\n      const cursor = roomIds.length > 0 ? Subscriptions.findByUserIdAndRoomIds(userId, roomIds) : Subscriptions.findByUserIdExceptType(userId, 'd');\n      // Iterate through all the rooms the user is subscribed to, to check if he is the last owner of any of them.\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(cursor), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const subscription = _step.value;\n          {\n            const roomData = {\n              rid: subscription.rid,\n              t: subscription.t,\n              shouldBeRemoved: false,\n              shouldChangeOwner: false,\n              userIsLastOwner: false,\n              newOwner: null\n            };\n            if (subscriptionHasRole(subscription, 'owner')) {\n              // Fetch the number of owners\n              const numOwners = await Subscriptions.countByRoomIdAndRoles(subscription.rid, ['owner']);\n              // If it's only one, then this user is the only owner.\n              roomData.userIsLastOwner = numOwners === 1;\n              if (numOwners === 1 && assignNewOwner) {\n                // Let's check how many subscribers the room has.\n                const options = {\n                  projection: {\n                    'u._id': 1\n                  },\n                  sort: {\n                    ts: 1\n                  }\n                };\n                const subscribersCursor = Subscriptions.findByRoomId(subscription.rid, options);\n                var _iteratorAbruptCompletion2 = false;\n                var _didIteratorError2 = false;\n                var _iteratorError2;\n                try {\n                  for (var _iterator2 = _asyncIterator(subscribersCursor), _step2; _iteratorAbruptCompletion2 = !(_step2 = await _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n                    const {\n                      u: {\n                        _id: uid\n                      }\n                    } = _step2.value;\n                    {\n                      // If we already changed the owner or this subscription is for the user we are removing, then don't try to give it ownership\n                      if (roomData.shouldChangeOwner || uid === userId) {\n                        continue;\n                      }\n                      const newOwner = await Users.findOneActiveById(uid, {\n                        projection: {\n                          _id: 1\n                        }\n                      });\n                      if (!newOwner) {\n                        continue;\n                      }\n                      roomData.newOwner = uid;\n                      roomData.shouldChangeOwner = true;\n                    }\n                  }\n                  // If there's no subscriber available to be the new owner and it's not a public room, we can remove it.\n                } catch (err) {\n                  _didIteratorError2 = true;\n                  _iteratorError2 = err;\n                } finally {\n                  try {\n                    if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n                      await _iterator2.return();\n                    }\n                  } finally {\n                    if (_didIteratorError2) {\n                      throw _iteratorError2;\n                    }\n                  }\n                }\n                if (!roomData.shouldChangeOwner && roomData.t !== 'c') {\n                  roomData.shouldBeRemoved = true;\n                }\n              }\n            } else if (roomData.t !== 'c') {\n              // If the user is not an owner, remove the room if the user is the only subscriber\n              roomData.shouldBeRemoved = (await Subscriptions.countByRoomId(roomData.rid)) === 1;\n            }\n            subscribedRooms.push(roomData);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            await _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return subscribedRooms;\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_asyncIterator","module","link","default","v","export","shouldRemoveOrChangeOwner","getSubscribedRoomsForUserWithDetails","Subscriptions","Users","subscriptionHasRole","__reifyWaitForDeps__","subscribedRooms","some","_ref","shouldBeRemoved","shouldChangeOwner","userId","assignNewOwner","arguments","length","undefined","roomIds","cursor","findByUserIdAndRoomIds","findByUserIdExceptType","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","subscription","value","roomData","rid","t","userIsLastOwner","newOwner","numOwners","countByRoomIdAndRoles","options","projection","sort","ts","subscribersCursor","findByRoomId","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","u","_id","uid","findOneActiveById","err","return","countByRoomId","push","__reify_async_result__","_reifyError","self","async"],"sources":["app/lib/server/functions/getRoomsWithSingleOwner.ts"],"sourcesContent":["import type { IUser } from '@rocket.chat/core-typings';\nimport { Subscriptions, Users } from '@rocket.chat/models';\n\nimport { subscriptionHasRole } from '../../../authorization/server';\n\nexport type SubscribedRoomsForUserWithDetails = {\n\trid: string;\n\tt: string;\n\tshouldBeRemoved: boolean;\n\tshouldChangeOwner: boolean;\n\tuserIsLastOwner: boolean;\n\tnewOwner: IUser['_id'] | null;\n};\n\nexport function shouldRemoveOrChangeOwner(subscribedRooms: SubscribedRoomsForUserWithDetails[]): boolean {\n\treturn subscribedRooms.some(({ shouldBeRemoved, shouldChangeOwner }) => shouldBeRemoved || shouldChangeOwner);\n}\n\nexport async function getSubscribedRoomsForUserWithDetails(\n\tuserId: string,\n\tassignNewOwner = true,\n\troomIds: string[] = [],\n): Promise<SubscribedRoomsForUserWithDetails[]> {\n\tconst subscribedRooms: SubscribedRoomsForUserWithDetails[] = [];\n\n\tconst cursor =\n\t\troomIds.length > 0 ? Subscriptions.findByUserIdAndRoomIds(userId, roomIds) : Subscriptions.findByUserIdExceptType(userId, 'd');\n\n\t// Iterate through all the rooms the user is subscribed to, to check if he is the last owner of any of them.\n\tfor await (const subscription of cursor) {\n\t\tconst roomData: SubscribedRoomsForUserWithDetails = {\n\t\t\trid: subscription.rid,\n\t\t\tt: subscription.t,\n\t\t\tshouldBeRemoved: false,\n\t\t\tshouldChangeOwner: false,\n\t\t\tuserIsLastOwner: false,\n\t\t\tnewOwner: null,\n\t\t};\n\n\t\tif (subscriptionHasRole(subscription, 'owner')) {\n\t\t\t// Fetch the number of owners\n\t\t\tconst numOwners = await Subscriptions.countByRoomIdAndRoles(subscription.rid, ['owner']);\n\t\t\t// If it's only one, then this user is the only owner.\n\t\t\troomData.userIsLastOwner = numOwners === 1;\n\t\t\tif (numOwners === 1 && assignNewOwner) {\n\t\t\t\t// Let's check how many subscribers the room has.\n\t\t\t\tconst options = { projection: { 'u._id': 1 }, sort: { ts: 1 as const } };\n\t\t\t\tconst subscribersCursor = Subscriptions.findByRoomId(subscription.rid, options);\n\n\t\t\t\tfor await (const {\n\t\t\t\t\tu: { _id: uid },\n\t\t\t\t} of subscribersCursor) {\n\t\t\t\t\t// If we already changed the owner or this subscription is for the user we are removing, then don't try to give it ownership\n\t\t\t\t\tif (roomData.shouldChangeOwner || uid === userId) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst newOwner = await Users.findOneActiveById(uid, { projection: { _id: 1 } });\n\t\t\t\t\tif (!newOwner) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\troomData.newOwner = uid;\n\t\t\t\t\troomData.shouldChangeOwner = true;\n\t\t\t\t}\n\n\t\t\t\t// If there's no subscriber available to be the new owner and it's not a public room, we can remove it.\n\t\t\t\tif (!roomData.shouldChangeOwner && roomData.t !== 'c') {\n\t\t\t\t\troomData.shouldBeRemoved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (roomData.t !== 'c') {\n\t\t\t// If the user is not an owner, remove the room if the user is the only subscriber\n\t\t\troomData.shouldBeRemoved = (await Subscriptions.countByRoomId(roomData.rid)) === 1;\n\t\t}\n\n\t\tsubscribedRooms.push(roomData);\n\t}\n\n\treturn subscribedRooms;\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"c5ae7fe0c5e2a9047f5ca97ba3e7a658c0768c99"}
