{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/client/lib/voip/VoIPUser.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"client/lib/voip/VoIPUser.ts","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/client/lib/voip/VoIPUser.ts","inputSourceMap":{"version":3,"file":"client/lib/voip/VoIPUser.ts","sourceRoot":"","sources":["client/lib/voip/VoIPUser.ts"],"names":[],"mappings":"AAqBA,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,aAAa,EAAE,MAAM,2BAA2B,CAAC;AAChF,OAAO,EAAE,OAAO,EAAE,MAAM,sBAAsB,CAAC;AAE/C,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,YAAY,EAAE,UAAU,EAAE,mBAAmB,EAAE,OAAO,EAAE,MAAM,QAAQ,CAAC;AAEvG,OAAO,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAEtC,OAAO,EAAE,yBAAyB,EAAE,MAAM,yBAAyB,CAAC;AAEpE,OAAO,EAAE,uBAAuB,EAAE,MAAM,UAAU,CAAC;AACnD,OAAO,WAAW,MAAM,eAAe,CAAC;AACxC,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AACpD,OAAO,YAAY,MAAM,gBAAgB,CAAC;AAE1C,MAAM,OAAO,QAAS,SAAQ,OAAmB;IA0DnB;IAzD7B,KAAK,GAAW;QACf,OAAO,EAAE,KAAK;QACd,WAAW,EAAE,KAAK;KAClB,CAAC;IAEM,YAAY,CAA2B;IAE/C,gBAAgB,GAAqB,EAAE,CAAC;IAExC,SAAS,CAAwB;IAEjC,UAAU,CAAyB;IAEnC,mBAAmB,CAAwB;IAEnC,gBAAgB,GAAoB,SAAS,CAAC;IAE9C,KAAK,GAAG,KAAK,CAAC;IAEd,IAAI,CAAgB;IAEpB,SAAS,CAAkB;IAE3B,oBAAoB,CAAC;IAErB,IAAI,CAAC;IAEL,cAAc,CAAiC;IAE/C,qBAAqB,CAAa;IAElC,oBAAoB,CAAa;IAEjC,wBAAwB,GAAG,CAAC,CAAC;IAE7B,iCAAiC,GAAG,CAAC,CAAC;IAEtC,mBAAmB,GAAG,KAAK,CAAC;IAE1B,OAAO,CAAsB;IAE7B,UAAU,GAAe,SAAS,CAAC;IAEnC,WAAW,CAA0B;IAErC,UAAU,GAAc,SAAS,CAAC,IAAI,CAAC;IAEvC,aAAa,GAAc,SAAS,CAAC,OAAO,CAAC;IAEvD,IAAI,mBAAmB;QACtB,OAAO,IAAI,CAAC,aAAa,CAAC;IAC3B,CAAC;IAED,IAAI,SAAS;QACZ,OAAO,IAAI,CAAC,UAAU,CAAC;IACxB,CAAC;IAED,YAA6B,MAA6B,EAAE,aAAoC;QAC/F,KAAK,EAAE,CAAC;QADoB,WAAM,GAAN,MAAM,CAAuB;QAEzD,IAAI,CAAC,mBAAmB,GAAG,aAAa,CAAC;QACzC,IAAI,CAAC,cAAc,GAAG,IAAI,OAAO,EAAyB,CAAC;QAC3D,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,MAAM,CAAC,oBAAoB,CAAC;QAC7D,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;QAElB,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC9D,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5D,CAAC;IAED;;;;;;;;OAQG;IAEH,KAAK,CAAC,IAAI;QACT,MAAM,MAAM,GAAG,OAAO,IAAI,CAAC,MAAM,CAAC,YAAY,IAAI,IAAI,CAAC,MAAM,CAAC,wBAAwB,EAAE,CAAC;QACzF,MAAM,gBAAgB,GAAG;YACxB,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,YAAY;YAChC,iBAAiB,EAAE,GAAG,EAAE,2BAA2B;YACnD,iBAAiB,EAAE,EAAE;YACrB,kBAAkB;SAClB,CAAC;QACF,MAAM,iBAAiB,GAAG;YACzB,mBAAmB,EAAE,EAAE;YACvB,2BAA2B,EAAE;gBAC5B,UAAU,EAAE,IAAI,CAAC,MAAM,CAAC,UAAU;aAClC;SACD,CAAC;QACF,IAAI,CAAC,gBAAgB,GAAG;YACvB,QAAQ,EAAE;gBACT,QAAQ,EAAE,KAAK,EAAE,UAAsB,EAAiB,EAAE;oBACzD,MAAM,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;gBAC3C,CAAC;aACD;YACD,qBAAqB,EAAE,IAAI,CAAC,MAAM,CAAC,YAAY;YAC/C,qBAAqB,EAAE,IAAI,CAAC,MAAM,CAAC,YAAY;YAC/C,GAAG,EAAE,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC;YAC9B,gBAAgB;YAChB,uCAAuC,EAAE,iBAAiB;YAC1D,gBAAgB,EAAE,KAAK;YACvB,QAAQ,EAAE,OAAO;SACjB,CAAC;QAEF,IAAI,CAAC,SAAS,GAAG,IAAI,SAAS,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACtD,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;QACvC,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC,UAAU,CAAC;QAC1C,IAAI,CAAC;YACJ,IAAI,CAAC,UAAU,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAEjD,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACjE,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,YAAY,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACvE,MAAM,CAAC,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;YAC7D,MAAM,CAAC,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAAC,qBAAqB,CAAC,CAAC;YAC/D,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;YAC7B,IAAI,IAAI,CAAC,MAAM,CAAC,8CAA8C,EAAE,CAAC;gBAChE,IAAI,CAAC,mCAAmC,EAAE,CAAC;YAC5C,CAAC;QACF,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC;YAChC,MAAM,KAAK,CAAC;QACb,CAAC;IACF,CAAC;IAED,KAAK,CAAC,WAAW;QAChB,IAAI,CAAC,gBAAgB,GAAG,kBAAkB,CAAC;QAC3C,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC;QAC1B,IAAI,CAAC,WAAW,EAAE,CAAC;QACnB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACtC;;;WAGG;QAEH,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE,CAAC;YACrD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;QACjC,CAAC;IACF,CAAC;IAED,cAAc,CAAC,KAAU;QACxB,IAAI,CAAC,gBAAgB,GAAG,qBAAqB,CAAC;QAC9C,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC,OAAO,CAAC;QACvC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QACzC,IAAI,KAAK,EAAE,CAAC;YACX,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,iBAAiB,EAAE,KAAK,CAAC,CAAC;YACnD,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC;YAC3B;;;;;;eAMG;YACH,8BAA8B;YAC9B,IAAI,CAAC,mBAAmB,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;QACpC,CAAC;IACF,CAAC;IAED,iBAAiB;QAChB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;QAC/C,IAAI,IAAI,CAAC,gBAAgB,KAAK,qBAAqB,EAAE,CAAC;YACrD;;;;;;;;iBAQK;YACL,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC3B,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE,CAAC;gBACrD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;YACjC,CAAC;QACF,CAAC;IACF,CAAC;IAED,aAAa;QACZ,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;QAChD,IAAI,CAAC,gBAAgB,GAAG,qBAAqB,CAAC;IAC/C,CAAC;IAED,IAAI,UAAU;QACb,OAAO,IAAI,CAAC,MAAM,CAAC;IACpB,CAAC;IAED,IAAI,SAAS;QACZ,OAAO,IAAI,CAAC,UAAU,CAAC;IACxB,CAAC;IAED,IAAI,eAAe;QAClB,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC9B,CAAC;IAED,IAAI,UAAU;QACb,IACC,IAAI,CAAC,SAAS,KAAK,SAAS;YAC5B,IAAI,CAAC,SAAS,KAAK,gBAAgB;YACnC,IAAI,CAAC,SAAS,KAAK,SAAS;YAC5B,IAAI,CAAC,SAAS,KAAK,YAAY,EAC9B,CAAC;YACF,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;gBACvB,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;YACxD,CAAC;YACD,OAAO;gBACN,KAAK,EAAE,IAAI,CAAC,SAAS;gBACrB,MAAM,EAAE,IAAI,CAAC,WAAW;gBACxB,SAAS,EAAE,IAAI,CAAC,UAAU;aAC1B,CAAC;QACH,CAAC;QACD,OAAO;YACN,KAAK,EAAE,IAAI,CAAC,SAAS;YACrB,SAAS,EAAE,IAAI,CAAC,UAAU;SAC1B,CAAC;IACH,CAAC;IAED,kCAAkC;IAClC,8DAA8D;IAC9D,IAAI,gBAAgB;QACnB,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,EAAE,yBAAyB,CAAC;QACpD,IAAI,CAAC,GAAG,EAAE,CAAC;YACV,OAAO,SAAS,CAAC;QAClB,CAAC;QACD,IAAI,CAAC,CAAC,GAAG,YAAY,yBAAyB,CAAC,EAAE,CAAC;YACjD,MAAM,IAAI,KAAK,CAAC,2EAA2E,CAAC,CAAC;QAC9F,CAAC;QACD,OAAO,GAAG,CAAC,gBAAgB,CAAC;IAC7B,CAAC;IAED,gCAAgC;IAChC,2CAA2C;IAC3C,2BAA2B;QAC1B,IAAI,IAAI,CAAC,aAAa,KAAK,SAAS,CAAC,WAAW,EAAE,CAAC;YAClD,IAAI,CAAC,UAAU,GAAG,YAAY,CAAC;YAC/B,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YACxB,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC3B,CAAC;QACD,IAAI,IAAI,CAAC,aAAa,KAAK,SAAS,CAAC,aAAa,EAAE,CAAC;YACpD,IAAI,CAAC,UAAU,GAAG,cAAc,CAAC;YACjC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YAC1B,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC3B,CAAC;IACF,CAAC;IAED,2BAA2B,CAAC,KAAU;QACrC,IAAI,IAAI,CAAC,aAAa,KAAK,SAAS,CAAC,WAAW,EAAE,CAAC;YAClD,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,KAAK,CAAC,CAAC;QACvC,CAAC;QACD,IAAI,IAAI,CAAC,aAAa,KAAK,SAAS,CAAC,aAAa,EAAE,CAAC;YACpD,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE,KAAK,CAAC,CAAC;QACzC,CAAC;IACF,CAAC;IACD,yCAAyC;IAEjC,KAAK,CAAC,kBAAkB,CAAC,UAAsB;QACtD,IAAI,IAAI,CAAC,SAAS,KAAK,YAAY,EAAE,CAAC;YACrC,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC,iBAAiB,CAAC;YACjD,IAAI,CAAC,UAAU,GAAG,gBAAgB,CAAC;YACnC,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC,GAAG,CAAC;YAChC,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC;YAC1B,IAAI,CAAC,yBAAyB,CAAC,UAAU,CAAC,CAAC;YAC3C,MAAM,UAAU,GAAgB;gBAC/B,QAAQ,EAAE,UAAU,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;gBACtF,UAAU,EAAE,UAAU,CAAC,cAAc,CAAC,WAAW;gBACjD,IAAI,EAAE,UAAU,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI;aACxC,CAAC;YACF,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;YAC9B,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,UAAU,CAAC,CAAC;YACtC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YAC1B,OAAO;QACR,CAAC;QAED,MAAM,UAAU,CAAC,MAAM,EAAE,CAAC;IAC3B,CAAC;IAED;;;;;;;;;OASG;IAEO,yBAAyB,CAAC,OAAgB;QACnD,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC,WAAW,CAAC,CAAC,KAAmB,EAAE,EAAE;YAC7D,IAAI,IAAI,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;gBAC9B,OAAO,CAAC,0CAA0C;YACnD,CAAC;YACD,QAAQ,KAAK,EAAE,CAAC;gBACf,KAAK,YAAY,CAAC,OAAO;oBACxB,MAAM;gBACP,KAAK,YAAY,CAAC,YAAY;oBAC7B,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,UAAU,EAAE,QAAQ,EAAE,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;oBACjF,MAAM;gBACP,KAAK,YAAY,CAAC,WAAW;oBAC5B,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,CAAC,GAAG,EAAE,CAAC;wBACvC;;;;;;;;;;;;;;;6BAeK;wBACL,IAAI,CAAC,UAAU,GAAG,iBAAiB,CAAC;oBACrC,CAAC;oBACD,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC,OAAO,CAAC;oBACvC,IAAI,CAAC,gBAAgB,EAAE,CAAC;oBACxB,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;oBAC5B,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,UAAU,EAAE,QAAQ,EAAE,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;oBACzF,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;oBAC1B,MAAM;gBACP,KAAK,YAAY,CAAC,WAAW,CAAC;gBAC9B,eAAe;gBACf,KAAK,YAAY,CAAC,UAAU;oBAC3B,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;oBACzB,IAAI,CAAC,UAAU,GAAG,YAAY,CAAC;oBAC/B,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC,OAAO,CAAC;oBACvC,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC,IAAI,CAAC;oBACjC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;oBAC5B,IAAI,CAAC,YAAY,EAAE,KAAK,EAAE,CAAC;oBAC3B,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;oBAC1B,MAAM;gBACP;oBACC,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;YAC5C,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,YAAY,CAAC,MAAW;QACvB,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IAC7B,CAAC;IAED,cAAc,CAAC,MAAW;QACzB,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;IAC/B,CAAC;IAED;;;;;;OAMG;IACK,gBAAgB;QACvB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;QAC5C,CAAC;QACD,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,EAAE,yBAAyB,CAAC;QACpD,IAAI,CAAC,GAAG,EAAE,CAAC;YACV,OAAO,SAAS,CAAC;QAClB,CAAC;QACD,IAAI,CAAC,CAAC,GAAG,YAAY,yBAAyB,CAAC,EAAE,CAAC;YACjD,MAAM,IAAI,KAAK,CAAC,2EAA2E,CAAC,CAAC;QAC9F,CAAC;QAED,MAAM,YAAY,GAAG,GAAG,CAAC,iBAAiB,CAAC;QAC3C,IAAI,CAAC,YAAY,EAAE,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;QACtD,CAAC;QAED,IAAI,CAAC,YAAY,GAAG,IAAI,YAAY,CAAC,YAAY,CAAC,CAAC;QACnD,MAAM,YAAY,GAAG,IAAI,CAAC,mBAAmB,EAAE,kBAAkB,CAAC;QAClE,IAAI,YAAY,EAAE,CAAC;YAClB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YACrC,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC7D,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACjE,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;QAC1B,CAAC;IACF,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,gBAAgB,CAAC,SAAkB;QAChD,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC;QACzB,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;YAC9B,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;QAC1B,CAAC;QACD,IAAI,CAAC,OAAO,EAAE,CAAC;YACd,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;QACtC,CAAC;QAED,MAAM,yBAAyB,GAAG,IAAI,CAAC,OAAO,EAAE,yBAAyB,CAAC;QAC1E,IAAI,CAAC,CAAC,yBAAyB,YAAY,yBAAyB,CAAC,EAAE,CAAC;YACvE,MAAM,IAAI,KAAK,CAAC,kFAAkF,CAAC,CAAC;QACrG,CAAC;QAED,MAAM,OAAO,GAAyB;YACrC,eAAe,EAAE;gBAChB,QAAQ,EAAE,GAAS,EAAE;oBACpB,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;oBACvB,uBAAuB,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;oBAC1D,uBAAuB,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;gBACzD,CAAC;gBACD,QAAQ,EAAE,GAAS,EAAE;oBACpB,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBACxB,CAAC;aACD;SACD,CAAC;QAEF,MAAM,EAAE,cAAc,EAAE,GAAG,yBAAyB,CAAC;QACrD,IAAI,CAAC,cAAc,EAAE,CAAC;YACrB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;QAC5C,CAAC;QACD,OAAO,IAAI,CAAC,OAAO;YAClB,EAAE,MAAM,CAAC,OAAO,CAAC;aAChB,IAAI,CAAC,GAAG,EAAE;YACV,uBAAuB,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;YAC1D,uBAAuB,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;QACzD,CAAC,CAAC;aACD,KAAK,CAAC,CAAC,KAAY,EAAE,EAAE;YACvB,IAAI,KAAK,YAAY,mBAAmB,EAAE,CAAC;gBAC1C,OAAO,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE,0CAA0C,CAAC,CAAC;YAC/E,CAAC;YACD,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YACvB,MAAM,KAAK,CAAC;QACb,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,gBAAgB,CAAC,SAAkB;QAChD,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC;QACzB,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;YAC9B,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;QAC1B,CAAC;QACD,IAAI,CAAC,OAAO,EAAE,CAAC;YACd,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;QACtC,CAAC;QAED,MAAM,yBAAyB,GAAG,IAAI,CAAC,OAAO,EAAE,yBAAyB,CAAC;QAC1E,IAAI,CAAC,CAAC,yBAAyB,YAAY,yBAAyB,CAAC,EAAE,CAAC;YACvE,MAAM,IAAI,KAAK,CAAC,kFAAkF,CAAC,CAAC;QACrG,CAAC;QACD,MAAM,OAAO,GAAyB;YACrC,eAAe,EAAE;gBAChB,QAAQ,EAAE,GAAS,EAAE;oBACpB,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;oBACvB,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC;oBACpD,uBAAuB,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;oBAC1D,uBAAuB,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;oBACxD,IAAI,CAAC,UAAU,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBACxE,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;gBAC3B,CAAC;gBACD,QAAQ,EAAE,GAAS,EAAE;oBACpB,uBAAuB,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;oBAC1D,uBAAuB,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;oBACxD,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBACxB,CAAC;aACD;SACD,CAAC;QAEF,4EAA4E;QAC5E,EAAE;QACF,8CAA8C;QAC9C,qDAAqD;QACrD,4FAA4F;QAC5F,uCAAuC;QACvC,qDAAqD;QACrD,4FAA4F;QAC5F,EAAE;QACF,sDAAsD;QACtD,6CAA6C;QAC7C,qFAAqF;QACrF,uCAAuC;QACvC,qDAAqD;QACrD,qEAAqE;QAErE,MAAM,gCAAgC,GAAG,OAAO,CAAC,wCAA4E,CAAC;QAC9H,gCAAgC,CAAC,IAAI,GAAG,SAAS,CAAC;QAClD,OAAO,CAAC,wCAAwC,GAAG,gCAAgC,CAAC;QAEpF,MAAM,EAAE,cAAc,EAAE,GAAG,yBAAyB,CAAC;QACrD,IAAI,CAAC,cAAc,EAAE,CAAC;YACrB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;QAC5C,CAAC;QACD,OAAO,IAAI,CAAC,OAAO;YAClB,EAAE,MAAM,CAAC,OAAO,CAAC;aAChB,IAAI,CAAC,GAAG,EAAE;YACV,uBAAuB,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;YAC1D,uBAAuB,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;QACzD,CAAC,CAAC;aACD,KAAK,CAAC,CAAC,KAAY,EAAE,EAAE;YACvB,IAAI,KAAK,YAAY,mBAAmB,EAAE,CAAC;gBAC1C,OAAO,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE,0CAA0C,CAAC,CAAC;YAC/E,CAAC;YACD,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YACvB,MAAM,KAAK,CAAC;QACb,CAAC,CAAC,CAAC;IACL,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,MAA6B,EAAE,aAAoC;QACtF,MAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC;QACjD,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;QAClB,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;;;;;;;;;;;;;;OAeG;IAEH,WAAW,CAAC,uBAAiD;QAC5D,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,CAAC,wBAAwB,CAAC,CAAC;QAC3F,MAAM,eAAe,GAAG,IAAI,CAAC,SAAS,EAAE,aAAa,CAAC,0BAA0B,CAAC,SAAS,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;QAC/G,IAAI,eAAe,EAAE,CAAC;YACrB,IAAI,CAAC,SAAS,EAAE,aAAa,CAAC,OAAO,CAAC,eAAe,EAAE,uBAAuB,CAAC,CAAC;QACjF,CAAC;IACF,CAAC;IACD;;;OAGG;IAEH,QAAQ;QACP,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC,WAAW,CAAC;QAC3C,IAAI,CAAC,UAAU,EAAE,QAAQ,CAAC;YACzB,eAAe,EAAE;gBAChB,QAAQ,EAAE,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,IAAI,CAAC;gBACrD,QAAQ,EAAE,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,IAAI,CAAC;aACrD;SACD,CAAC,CAAC;IACJ,CAAC;IAED;;;OAGG;IAEH,UAAU;QACT,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC,aAAa,CAAC;QAC7C,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC;YAC3B,GAAG,EAAE,IAAI;YACT,eAAe,EAAE;gBAChB,QAAQ,EAAE,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,IAAI,CAAC;gBACrD,QAAQ,EAAE,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,IAAI,CAAC;aACrD;SACD,CAAC,CAAC;IACJ,CAAC;IACD;;;OAGG;IAEH,KAAK,CAAC,UAAU,CAAC,aAAmC;QACnD,IAAI,aAAa,EAAE,CAAC;YACnB,IAAI,CAAC,mBAAmB,GAAG,aAAa,CAAC;QAC1C,CAAC;QACD,wCAAwC;QACxC,IAAI,IAAI,CAAC,UAAU,KAAK,gBAAgB,IAAI,IAAI,CAAC,aAAa,KAAK,SAAS,CAAC,iBAAiB,EAAE,CAAC;YAChG,IAAI,CAAC,UAAU,GAAG,aAAa,CAAC;YAChC,gEAAgE;YAChE,IAAI,CAAC,CAAC,IAAI,CAAC,OAAO,YAAY,UAAU,CAAC,EAAE,CAAC;gBAC3C,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;YACxD,CAAC;YACD;;;;;;;;;;;;;;;eAeG;YACH,IAAI,WAAW,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;YAE5C,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC;YAC9B,IAAI,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;gBAC5C,WAAW,GAAG,KAAK,CAAC;YACrB,CAAC;YAED,MAAM,uBAAuB,GAA4B;gBACxD,gCAAgC,EAAE;oBACjC,WAAW,EAAE;wBACZ,KAAK,EAAE,IAAI;wBACX,KAAK,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,IAAI,WAAW;qBAC/C;iBACD;aACD,CAAC;YAEF,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,uBAAuB,CAAC,CAAC;QACrD,CAAC;QACD,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;IACzC,CAAC;IAED,qDAAqD;IAE7C,aAAa;QACpB,OAAO,CAAC,gBAAgB,EAAE,YAAY,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACnE,CAAC;IAEO,gBAAgB;QACvB,OAAO,CAAC,aAAa,EAAE,iBAAiB,EAAE,SAAS,EAAE,SAAS,EAAE,YAAY,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACzG,CAAC;IAED,mDAAmD;IAEnD;;;OAGG;IACH,UAAU;QACT,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;QAC5C,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE,CAAC;YAC3B,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;QAC7D,CAAC;QACD,IAAI,CAAC,CAAC,IAAI,CAAC,OAAO,YAAY,UAAU,CAAC,EAAE,CAAC;YAC3C,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;QACxD,CAAC;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;IAC9B,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,OAAO;QACZ,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;QAC5C,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,EAAE,CAAC;YAC9B,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;QAC7D,CAAC;QAED,8CAA8C;QAC9C,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC1B,QAAQ,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;YAC5B,KAAK,YAAY,CAAC,OAAO;gBACxB,IAAI,IAAI,CAAC,OAAO,YAAY,UAAU,EAAE,CAAC;oBACxC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;gBAC9B,CAAC;gBACD,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;YACxD,KAAK,YAAY,CAAC,YAAY;gBAC7B,IAAI,IAAI,CAAC,OAAO,YAAY,UAAU,EAAE,CAAC;oBACxC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;gBAC9B,CAAC;gBACD,IAAI,IAAI,CAAC,OAAO,YAAY,OAAO,EAAE,CAAC;oBACrC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;gBAC9B,CAAC;gBACD,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;YACxD,KAAK,YAAY,CAAC,WAAW;gBAC5B,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;YAC3B,KAAK,YAAY,CAAC,WAAW;gBAC5B,MAAM;YACP,KAAK,YAAY,CAAC,UAAU;gBAC3B,MAAM;YACP;gBACC,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;QACnC,CAAC;IACF,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,QAAQ,CAAC,SAAkB;QAChC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;QAC5C,CAAC;QACD,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAAE,CAAC;YACnC,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;QAC7D,CAAC;QACD,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;IAClC,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,QAAQ,CAAC,SAAkB;QAChC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;QAC5C,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,EAAE,CAAC;YAC9B,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;QAC7D,CAAC;QACD,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;IAClC,CAAC;IAED,0CAA0C;IAC1C,OAAO;QACN,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC;IAC3B,CAAC;IAED;;OAEG;IACH,mBAAmB,CAAC,aAAmC;QACtD,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;YACvB,IAAI,CAAC,mBAAmB,GAAG,aAAa,CAAC;YACzC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC,CAAC;YACzD,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC7D,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACjE,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;QAC1B,CAAC;IACF,CAAC;IAED,eAAe,CAAC,IAAmB;QAClC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,IAAI,KAAK,aAAa,CAAC,mBAAmB,EAAE,CAAC;YAChD,IAAI,CAAC,SAAS,GAAG,IAAI,eAAe,EAAE,CAAC;QACxC,CAAC;IACF,CAAC;IAED,yBAAyB,CAAC,YAA0C;QACnE,IAAI,IAAI,CAAC,IAAI,KAAK,aAAa,CAAC,mBAAmB,EAAE,CAAC;YACrD,OAAO;QACR,CAAC;QACD,IAAI,CAAC,SAAS,EAAE,aAAa,CAAC,YAAY,CAAC,CAAC;IAC7C,CAAC;IAED,aAAa;QACZ,OAAO,IAAI,CAAC,SAAS,CAAC;IACvB,CAAC;IAED,iBAAiB;QAChB,OAAO,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,QAAQ,EAAE,CAAC,iBAAiB,EAAE,CAAC;IAC9D,CAAC;IAED,KAAK;QACJ,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC,UAAU,CAAC;QAC1C;;;;;;WAMG;QACH,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,CAAC;QACvB,IAAI,CAAC,UAAU,EAAE,OAAO,EAAE,CAAC;QAC3B,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC;QAE/B,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACpB,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,SAAS,GAAG,SAAS,CAAC;YAC/C,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,YAAY,GAAG,SAAS,CAAC;YAClD,MAAM,CAAC,mBAAmB,CAAC,QAAQ,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;YAChE,MAAM,CAAC,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAC,qBAAqB,CAAC,CAAC;QACnE,CAAC;IACF,CAAC;IAED,cAAc,CAAC,KAAsB,EAAE,OAAmB;QACzD,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IACxC,CAAC;IAED,eAAe,CAAC,KAAsB,EAAE,OAAmB;QAC1D,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IACzC,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAkCG;IAEH,KAAK,CAAC,mBAAmB,CAAC,mBAAmB,GAAG,CAAC,EAAE,iBAAiB,GAAG,KAAK;QAC3E,MAAM,oBAAoB,GAAG,IAAI,CAAC,oBAAoB,CAAC;QACvD,IAAI,CAAC,gBAAgB,GAAG,qBAAqB,CAAC;QAC9C,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACrB,OAAO;QACR,CAAC;QACD,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;YACf,OAAO;QACR,CAAC;QACD,2DAA2D;QAC3D,IAAI,oBAAoB,KAAK,CAAC,CAAC,IAAI,mBAAmB,GAAG,oBAAoB,EAAE,CAAC;YAC/E,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC;YAChC,OAAO;QACR,CAAC;QAED,MAAM,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,mBAAmB,GAAG,CAAC,CAAC,CAAC;QAE/D,OAAO,CAAC,KAAK,CAAC,2EAA2E,iBAAiB,GAAG,CAAC,CAAC;QAC/G,UAAU,CAAC,GAAG,EAAE;YACf,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;gBACf,OAAO;YACR,CAAC;YACD,IAAI,IAAI,CAAC,gBAAgB,KAAK,kBAAkB,EAAE,CAAC;gBAClD,OAAO;YACR,CAAC;YACD,IAAI,CAAC,SAAS;gBACb,EAAE,SAAS,EAAE;iBACZ,IAAI,CAAC,GAAG,EAAE;gBACV,IAAI,CAAC,gBAAgB,GAAG,kBAAkB,CAAC;YAC5C,CAAC,CAAC;iBACD,KAAK,CAAC,GAAG,EAAE;gBACX,IAAI,CAAC,mBAAmB,CAAC,EAAE,mBAAmB,EAAE,iBAAiB,CAAC,CAAC;YACpE,CAAC,CAAC,CAAC;QACL,CAAC,EAAE,iBAAiB,GAAG,IAAI,CAAC,CAAC;IAC9B,CAAC;IAED,KAAK,CAAC,0BAA0B;QAC/B;;;;;;aAMK;QACL,IAAI,CAAC,WAAW,CAAC;YAChB,QAAQ,EAAE,GAAS,EAAE;gBACpB,IAAI,CAAC,sCAAsC,EAAE,CAAC;YAC/C,CAAC;YACD,QAAQ,EAAE,CAAC,KAAc,EAAQ,EAAE;gBAClC,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,wDAAwD,CAAC,CAAC;YAClF,CAAC;SACD,CAAC,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,+BAA+B,CAAC,YAAY,GAAG,KAAK;QACzD,MAAM,OAAO,GAAG,IAAI,OAAO,CAAU,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACxD,IAAI,iBAAiB,GAAG,KAAK,CAAC;YAC9B,IAAI,gBAAgB,GAAG,IAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC;YACzD,IAAI,YAAY,EAAE,CAAC;gBAClB,gBAAgB,IAAI,IAAI,CAAC,iCAAiC,CAAC;YAC5D,CAAC;YAED,IAAI,CAAC,WAAW,CAAC;gBAChB,QAAQ,EAAE,GAAS,EAAE;oBACpB,iBAAiB,GAAG,IAAI,CAAC;gBAC1B,CAAC;gBACD,QAAQ,EAAE,CAAC,MAAe,EAAQ,EAAE;oBACnC,OAAO,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAC;gBACxC,CAAC;aACD,CAAC,CAAC;YACH,UAAU,CAAC,KAAK,IAAI,EAAE;gBACrB,IAAI,CAAC,iBAAiB,EAAE,CAAC;oBACxB,MAAM,CAAC,KAAK,CAAC,CAAC;gBACf,CAAC;qBAAM,CAAC;oBACP,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;wBAC9B,IAAI,CAAC,0BAA0B,EAAE,CAAC;wBAClC,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;oBAClC,CAAC;oBACD,OAAO,CAAC,IAAI,CAAC,CAAC;gBACf,CAAC;YACF,CAAC,EAAE,gBAAgB,GAAG,IAAI,CAAC,CAAC;QAC7B,CAAC,CAAC,CAAC;QACH,OAAO,OAAO,CAAC;IAChB,CAAC;IAED,KAAK,CAAC,mCAAmC;QACxC,UAAU,CAAC,KAAK,IAAI,EAAE;YACrB,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;gBAClC,OAAO;YACR,CAAC;YACD,IAAI,IAAI,CAAC,gBAAgB,KAAK,qBAAqB,EAAE,CAAC;gBACrD,IAAI,WAAW,GAAG,KAAK,CAAC;gBACxB,IAAI,CAAC;oBACJ,MAAM,IAAI,CAAC,+BAA+B,EAAE,CAAC;oBAC7C,WAAW,GAAG,IAAI,CAAC;gBACpB,CAAC;gBAAC,OAAO,CAAC,EAAE,CAAC;oBACZ,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,8BAA8B,CAAC,CAAC;gBACpD,CAAC;wBAAS,CAAC;oBACV,sFAAsF;oBACtF,CAAC,WAAW,IAAI,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;oBACzD,WAAW,IAAI,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBACtD,CAAC;YACF,CAAC;YACD,iFAAiF;YACjF,IAAI,CAAC,mCAAmC,EAAE,CAAC;QAC5C,CAAC,EAAE,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC,CAAC;IAC1C,CAAC;IAED,KAAK,CAAC,sCAAsC;QAC3C;;;;;;aAMK;QACL,MAAM,OAAO,GAAG,IAAI,OAAO,CAAO,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAE;YACvD,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC;gBAC3B,GAAG,EAAE,IAAI;gBACT,eAAe,EAAE;oBAChB,QAAQ,EAAE,GAAS,EAAE;wBACpB,QAAQ,EAAE,CAAC;oBACZ,CAAC;oBACD,QAAQ,EAAE,CAAC,KAAK,EAAQ,EAAE;wBACzB,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,sCAAsC,CAAC,CAAC;wBAC/D,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE,KAAK,CAAC,CAAC;wBACxC,OAAO,CAAC,wBAAwB,CAAC,CAAC;oBACnC,CAAC;iBACD;aACD,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;QACH,IAAI,CAAC;YACJ,MAAM,OAAO,CAAC;QACf,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YAChB,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,wCAAwC,CAAC,CAAC;QAClE,CAAC;QACD,IAAI,CAAC,UAAU,EAAE,QAAQ,CAAC;YACzB,eAAe,EAAE;gBAChB,QAAQ,EAAE,CAAC,KAAK,EAAQ,EAAE;oBACzB,IAAI,CAAC,UAAU,GAAG,cAAc,CAAC;oBACjC,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,KAAK,CAAC,CAAC;oBACtC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;gBAC3B,CAAC;aACD;SACD,CAAC,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,sBAAsB,CAAC,WAAmC;QAC/D,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACnB,OAAO,CAAC,IAAI,CAAC,kDAAkD,CAAC,CAAC;YACjE,OAAO,KAAK,CAAC;QACd,CAAC;QACD,MAAM,SAAS,GAAG,MAAM,WAAW,CAAC,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QAChF,IAAI,CAAC,SAAS,EAAE,CAAC;YAChB,OAAO,CAAC,IAAI,CAAC,kEAAkE,CAAC,CAAC;YACjF,OAAO,KAAK,CAAC;QACd,CAAC;QACD,MAAM,EAAE,cAAc,EAAE,GAAG,IAAI,CAAC,OAAO,EAAE,yBAAsD,CAAC;QAChG,IAAI,CAAC,cAAc,EAAE,CAAC;YACrB,OAAO,CAAC,IAAI,CAAC,0DAA0D,CAAC,CAAC;YACzE,OAAO,KAAK,CAAC;QACd,CAAC;QACD,WAAW,CAAC,YAAY,CAAC,cAAc,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;QAC7D,OAAO,IAAI,CAAC;IACb,CAAC;IAED,0EAA0E;IAC1E,kFAAkF;IAClF,wBAAwB;IACxB,sEAAsE;IACtE,kBAAkB;IAClB,KAAK;IACL,+EAA+E;IAC/E,sFAAsF;IACtF,kBAAkB;IAClB,KAAK;IACL,oEAAoE;IACpE,mHAAmH;IACnH,qBAAqB;IACrB,sFAAsF;IACtF,kBAAkB;IAClB,KAAK;IACL,oGAAoG;IACpG,0BAA0B;IAC1B,8EAA8E;IAC9E,kBAAkB;IAClB,KAAK;IACL,iEAAiE;IACjE,gBAAgB;IAChB,IAAI;IACJ,6DAA6D;IAE7D,KAAK,CAAC,WAAW,CAAC,OAAe,EAAE,cAAqC;QACvE,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACpC,CAAC;IAED,KAAK,CAAC,QAAQ,CAAC,aAAqB;QACnC,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACpC,CAAC;CACD","sourcesContent":["/**\n * Class representing SIP UserAgent\n * @remarks\n * This class encapsulates all the details of sip.js and exposes\n * a very simple functions and callback handlers to the outside world.\n * This class thus abstracts user from Browser specific media details as well as\n * SIP specific protocol details.\n */\nimport type {\n\tCallStates,\n\tConnectionState,\n\tICallerInfo,\n\tIQueueMembershipSubscription,\n\tSignalingSocketEvents,\n\tSocketEventKeys,\n\tIMediaStreamRenderer,\n\tVoIPUserConfiguration,\n\tVoIpCallerInfo,\n\tIState,\n\tVoipEvents,\n} from '@rocket.chat/core-typings';\nimport { Operation, UserState, WorkflowTypes } from '@rocket.chat/core-typings';\nimport { Emitter } from '@rocket.chat/emitter';\nimport type { UserAgentOptions, InvitationAcceptOptions, Session, SessionInviteOptions } from 'sip.js';\nimport { UserAgent, Invitation, SessionState, Registerer, RequestPendingError, Inviter } from 'sip.js';\nimport type { OutgoingByeRequest, OutgoingRequestDelegate } from 'sip.js/lib/core';\nimport { URI } from 'sip.js/lib/core';\nimport type { SessionDescriptionHandlerOptions } from 'sip.js/lib/platform/web';\nimport { SessionDescriptionHandler } from 'sip.js/lib/platform/web';\n\nimport { toggleMediaStreamTracks } from './Helper';\nimport LocalStream from './LocalStream';\nimport { QueueAggregator } from './QueueAggregator';\nimport RemoteStream from './RemoteStream';\n\nexport class VoIPUser extends Emitter<VoipEvents> {\n\tstate: IState = {\n\t\tisReady: false,\n\t\tenableVideo: false,\n\t};\n\n\tprivate remoteStream: RemoteStream | undefined;\n\n\tuserAgentOptions: UserAgentOptions = {};\n\n\tuserAgent: UserAgent | undefined;\n\n\tregisterer: Registerer | undefined;\n\n\tmediaStreamRendered?: IMediaStreamRenderer;\n\n\tprivate _connectionState: ConnectionState = 'INITIAL';\n\n\tprivate _held = false;\n\n\tprivate mode: WorkflowTypes;\n\n\tprivate queueInfo: QueueAggregator;\n\n\tprivate connectionRetryCount;\n\n\tprivate stop;\n\n\tprivate networkEmitter: Emitter<SignalingSocketEvents>;\n\n\tprivate offlineNetworkHandler: () => void;\n\n\tprivate onlineNetworkHandler: () => void;\n\n\tprivate optionsKeepaliveInterval = 5;\n\n\tprivate optionsKeepAliveDebounceTimeInSec = 5;\n\n\tprivate attemptRegistration = false;\n\n\tprotected session: Session | undefined;\n\n\tprotected _callState: CallStates = 'INITIAL';\n\n\tprotected _callerInfo: ICallerInfo | undefined;\n\n\tprotected _userState: UserState = UserState.IDLE;\n\n\tprotected _opInProgress: Operation = Operation.OP_NONE;\n\n\tget operationInProgress(): Operation {\n\t\treturn this._opInProgress;\n\t}\n\n\tget userState(): UserState | undefined {\n\t\treturn this._userState;\n\t}\n\n\tconstructor(private readonly config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer) {\n\t\tsuper();\n\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\tthis.networkEmitter = new Emitter<SignalingSocketEvents>();\n\t\tthis.connectionRetryCount = this.config.connectionRetryCount;\n\t\tthis.stop = false;\n\n\t\tthis.onlineNetworkHandler = this.onNetworkRestored.bind(this);\n\t\tthis.offlineNetworkHandler = this.onNetworkLost.bind(this);\n\t}\n\n\t/**\n\t * Configures and initializes sip.js UserAgent\n\t * call gets established.\n\t * @remarks\n\t * This class configures transport properties such as websocket url, passed down in config,\n\t * sets up ICE servers,\n\t * SIP UserAgent options such as userName, Password, URI.\n\t * Once initialized, it starts the userAgent.\n\t */\n\n\tasync init(): Promise<void> {\n\t\tconst sipUri = `sip:${this.config.authUserName}@${this.config.sipRegistrarHostnameOrIP}`;\n\t\tconst transportOptions = {\n\t\t\tserver: this.config.webSocketURI,\n\t\t\tconnectionTimeout: 100, // Replace this with config\n\t\t\tkeepAliveInterval: 20,\n\t\t\t// traceSip: true,\n\t\t};\n\t\tconst sdpFactoryOptions = {\n\t\t\ticeGatheringTimeout: 10,\n\t\t\tpeerConnectionConfiguration: {\n\t\t\t\ticeServers: this.config.iceServers,\n\t\t\t},\n\t\t};\n\t\tthis.userAgentOptions = {\n\t\t\tdelegate: {\n\t\t\t\tonInvite: async (invitation: Invitation): Promise<void> => {\n\t\t\t\t\tawait this.handleIncomingCall(invitation);\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthorizationPassword: this.config.authPassword,\n\t\t\tauthorizationUsername: this.config.authUserName,\n\t\t\turi: UserAgent.makeURI(sipUri),\n\t\t\ttransportOptions,\n\t\t\tsessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n\t\t\tlogConfiguration: false,\n\t\t\tlogLevel: 'error',\n\t\t};\n\n\t\tthis.userAgent = new UserAgent(this.userAgentOptions);\n\t\tthis.userAgent.transport.isConnected();\n\t\tthis._opInProgress = Operation.OP_CONNECT;\n\t\ttry {\n\t\t\tthis.registerer = new Registerer(this.userAgent);\n\n\t\t\tthis.userAgent.transport.onConnect = this.onConnected.bind(this);\n\t\t\tthis.userAgent.transport.onDisconnect = this.onDisconnected.bind(this);\n\t\t\twindow.addEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.addEventListener('offline', this.offlineNetworkHandler);\n\t\t\tawait this.userAgent.start();\n\t\t\tif (this.config.enableKeepAliveUsingOptionsForUnstableNetworks) {\n\t\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync onConnected(): Promise<void> {\n\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\tthis.state.isReady = true;\n\t\tthis.sendOptions();\n\t\tthis.networkEmitter.emit('connected');\n\t\t/**\n\t\t * Re-registration post network recovery should be attempted\n\t\t * if it was previously registered or incall/onhold\n\t\t */\n\n\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\tthis.attemptRegistration = true;\n\t\t}\n\t}\n\n\tonDisconnected(error: any): void {\n\t\tthis._connectionState = 'SERVER_DISCONNECTED';\n\t\tthis._opInProgress = Operation.OP_NONE;\n\t\tthis.networkEmitter.emit('disconnected');\n\t\tif (error) {\n\t\t\tthis.networkEmitter.emit('connectionerror', error);\n\t\t\tthis.state.isReady = false;\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted assuming\n\t\t\t * that the disconnect happened from the remote side or due to sleep\n\t\t\t * In case of remote side disconnection, if config.connectionRetryCount is -1,\n\t\t\t * attemptReconnection attempts continuously. Else stops after |config.connectionRetryCount|\n\t\t\t *\n\t\t\t */\n\t\t\t// this.attemptReconnection();\n\t\t\tthis.attemptReconnection(0, false);\n\t\t}\n\t}\n\n\tonNetworkRestored(): void {\n\t\tthis.networkEmitter.emit('localnetworkonline');\n\t\tif (this._connectionState === 'WAITING_FOR_NETWORK') {\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted when online event handler\n\t\t\t * gets notified.\n\t\t\t * Important thing to note is that the second parameter |checkRegistration| = true passed here\n\t\t\t * because after the network recovery and after reconnecting to the server,\n\t\t\t * the transport layer of SIPUA does not call onConnected. So by passing |checkRegistration = true |\n\t\t\t * the code will check if the endpoint was previously registered before the disconnection.\n\t\t\t * If such is the case, it will first unregister and then re-register.\n\t\t\t * */\n\t\t\tthis.attemptReconnection();\n\t\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\t\tthis.attemptRegistration = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tonNetworkLost(): void {\n\t\tthis.networkEmitter.emit('localnetworkoffline');\n\t\tthis._connectionState = 'WAITING_FOR_NETWORK';\n\t}\n\n\tget userConfig(): VoIPUserConfiguration {\n\t\treturn this.config;\n\t}\n\n\tget callState(): CallStates {\n\t\treturn this._callState;\n\t}\n\n\tget connectionState(): ConnectionState {\n\t\treturn this._connectionState;\n\t}\n\n\tget callerInfo(): VoIpCallerInfo {\n\t\tif (\n\t\t\tthis.callState === 'IN_CALL' ||\n\t\t\tthis.callState === 'OFFER_RECEIVED' ||\n\t\t\tthis.callState === 'ON_HOLD' ||\n\t\t\tthis.callState === 'OFFER_SENT'\n\t\t) {\n\t\t\tif (!this._callerInfo) {\n\t\t\t\tthrow new Error('[VoIPUser callerInfo] invalid state');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: this.callState,\n\t\t\t\tcaller: this._callerInfo,\n\t\t\t\tuserState: this._userState,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tstate: this.callState,\n\t\t\tuserState: this._userState,\n\t\t};\n\t}\n\n\t/* Media Stream functions begin */\n\t/** The local media stream. Undefined if call not answered. */\n\tget localMediaStream(): MediaStream | undefined {\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\t\treturn sdh.localMediaStream;\n\t}\n\n\t/* Media Stream functions end */\n\t/* OutgoingRequestDelegate methods begin */\n\tonRegistrationRequestAccept(): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis._callState = 'REGISTERED';\n\t\t\tthis.emit('registered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\tthis.emit('unregistered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t}\n\n\tonRegistrationRequestReject(error: any): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis.emit('registrationerror', error);\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis.emit('unregistrationerror', error);\n\t\t}\n\t}\n\t/* OutgoingRequestDelegate methods end */\n\n\tprivate async handleIncomingCall(invitation: Invitation): Promise<void> {\n\t\tif (this.callState === 'REGISTERED') {\n\t\t\tthis._opInProgress = Operation.OP_PROCESS_INVITE;\n\t\t\tthis._callState = 'OFFER_RECEIVED';\n\t\t\tthis._userState = UserState.UAS;\n\t\t\tthis.session = invitation;\n\t\t\tthis.setupSessionEventHandlers(invitation);\n\t\t\tconst callerInfo: ICallerInfo = {\n\t\t\t\tcallerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n\t\t\t\tcallerName: invitation.remoteIdentity.displayName,\n\t\t\t\thost: invitation.remoteIdentity.uri.host,\n\t\t\t};\n\t\t\tthis._callerInfo = callerInfo;\n\t\t\tthis.emit('incomingcall', callerInfo);\n\t\t\tthis.emit('stateChanged');\n\t\t\treturn;\n\t\t}\n\n\t\tawait invitation.reject();\n\t}\n\n\t/**\n\t * Sets up an listener handler for handling session's state change\n\t * @remarks\n\t * Called for setting up various state listeners. These listeners will\n\t * decide the next action to be taken when the session state changes.\n\t * e.g when session.state changes from |Establishing| to |Established|\n\t * one must set up local and remote media rendering.\n\t *\n\t * This class handles such session state changes and takes necessary actions.\n\t */\n\n\tprotected setupSessionEventHandlers(session: Session): void {\n\t\tthis.session?.stateChange.addListener((state: SessionState) => {\n\t\t\tif (this.session !== session) {\n\t\t\t\treturn; // if our session has changed, just return\n\t\t\t}\n\t\t\tswitch (state) {\n\t\t\t\tcase SessionState.Initial:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Establishing:\n\t\t\t\t\tthis.emit('ringing', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Established:\n\t\t\t\t\tif (this._userState === UserState.UAC) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * We need to decide about user-state ANSWER-RECEIVED for outbound.\n\t\t\t\t\t\t * This state is there for the symmetry of ANSWER-SENT.\n\t\t\t\t\t\t * ANSWER-SENT occurs when there is incoming invite. So then the UA\n\t\t\t\t\t\t * accepts a call, it sends the answer and state becomes ANSWER-SENT.\n\t\t\t\t\t\t * The call gets established only when the remote party sends ACK.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * But in case of UAC where the invite is sent out, there is no intermediate\n\t\t\t\t\t\t * state where the UA can be in ANSWER-RECEIVED. As soon this UA receives the answer,\n\t\t\t\t\t\t * it sends ack and changes the SessionState to established.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * So we do not have an actual state transitions from ANSWER-RECEIVED to IN-CALL.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Nevertheless, this state is just added to maintain the symmetry. This can be safely removed.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * */\n\t\t\t\t\t\tthis._callState = 'ANSWER_RECEIVED';\n\t\t\t\t\t}\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis.setupRemoteMedia();\n\t\t\t\t\tthis._callState = 'IN_CALL';\n\t\t\t\t\tthis.emit('callestablished', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Terminating:\n\t\t\t\t// fall through\n\t\t\t\tcase SessionState.Terminated:\n\t\t\t\t\tthis.session = undefined;\n\t\t\t\t\tthis._callState = 'REGISTERED';\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._userState = UserState.IDLE;\n\t\t\t\t\tthis.emit('callterminated');\n\t\t\t\t\tthis.remoteStream?.clear();\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown session state.');\n\t\t\t}\n\t\t});\n\t}\n\n\tonTrackAdded(_event: any): void {\n\t\tconsole.log('onTrackAdded');\n\t}\n\n\tonTrackRemoved(_event: any): void {\n\t\tconsole.log('onTrackRemoved');\n\t}\n\n\t/**\n\t * Carries out necessary steps for rendering remote media whe\n\t * call gets established.\n\t * @remarks\n\t * Sets up Stream class and plays the stream on given Media element/\n\t * Also sets up various event handlers.\n\t */\n\tprivate setupRemoteMedia(): any {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\n\t\tconst remoteStream = sdh.remoteMediaStream;\n\t\tif (!remoteStream) {\n\t\t\tthrow new Error('Remote media stream is undefined.');\n\t\t}\n\n\t\tthis.remoteStream = new RemoteStream(remoteStream);\n\t\tconst mediaElement = this.mediaStreamRendered?.remoteMediaElement;\n\t\tif (mediaElement) {\n\t\t\tthis.remoteStream.init(mediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\t/**\n\t * Handles call mute-unmute\n\t */\n\tprivate async handleMuteUnmute(muteState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === muteState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = muteState;\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\tthis.emit('muteerror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A mute request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('muteerror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles call hold-unhold\n\t */\n\tprivate async handleHoldUnhold(holdState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === holdState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = holdState;\n\t\t\t\t\tthis._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis.emit('holderror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Session properties used to pass options to the SessionDescriptionHandler:\n\t\t//\n\t\t// 1) Session.sessionDescriptionHandlerOptions\n\t\t//    SDH options for the initial INVITE transaction.\n\t\t//    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n\t\t//\n\t\t// 2) Session.sessionDescriptionHandlerOptionsReInvite\n\t\t//    SDH options for re-INVITE transactions.\n\t\t//    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Session.invite().\n\n\t\tconst sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite as SessionDescriptionHandlerOptions;\n\t\tsessionDescriptionHandlerOptions.hold = holdState;\n\t\tsession.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A hold request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('holderror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tstatic async create(config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer): Promise<VoIPUser> {\n\t\tconst voip = new VoIPUser(config, mediaRenderer);\n\t\tawait voip.init();\n\t\treturn voip;\n\t}\n\n\t/**\n\t * Sends SIP OPTIONS message to asterisk\n\t *\n\t * There is an interesting problem that happens with Asterisk.\n\t * After websocket connection succeeds and if there is no SIP\n\t * message goes in 30 seconds, asterisk disconnects the socket.\n\t *\n\t * If any SIP message goes before 30 seconds, asterisk holds the connection.\n\t * This problem could be solved in multiple ways. One is that\n\t * whenever disconnect happens make sure that the socket is connected back using\n\t * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n\t * every 30 seconds till we send register message.\n\t *\n\t * Another approach is to send SIP OPTIONS just to tell server that\n\t * there is a UA using this socket. This is implemented below\n\t */\n\n\tsendOptions(outgoingRequestDelegate?: OutgoingRequestDelegate): void {\n\t\tconst uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n\t\tconst outgoingMessage = this.userAgent?.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\t\tif (outgoingMessage) {\n\t\t\tthis.userAgent?.userAgentCore.request(outgoingMessage, outgoingRequestDelegate);\n\t\t}\n\t}\n\t/**\n\t * Public method called from outside to register the SIP UA with call server.\n\t * @remarks\n\t */\n\n\tregister(): void {\n\t\tthis._opInProgress = Operation.OP_REGISTER;\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Public method called from outside to unregister the SIP UA.\n\t * @remarks\n\t */\n\n\tunregister(): void {\n\t\tthis._opInProgress = Operation.OP_UNREGISTER;\n\t\tthis.registerer?.unregister({\n\t\t\tall: true,\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\t/**\n\t * Public method called from outside to accept incoming call.\n\t * @remarks\n\t */\n\n\tasync acceptCall(mediaRenderer: IMediaStreamRenderer): Promise<void> {\n\t\tif (mediaRenderer) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t}\n\t\t// Call state must be in offer_received.\n\t\tif (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n\t\t\tthis._callState = 'ANSWER_SENT';\n\t\t\t// Something is wrong, this session is not an instance of INVITE\n\t\t\tif (!(this.session instanceof Invitation)) {\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\t}\n\t\t\t/**\n\t\t\t * It is important to decide when to add video option to the outgoing offer.\n\t\t\t * This would matter when the reinvite goes out (In case of hold/unhold)\n\t\t\t * This was added because there were failures in hold-unhold.\n\t\t\t * The scenario was that if this client does hold-unhold first, and remote client does\n\t\t\t * later, remote client goes in inconsistent state and hold-unhold does not work\n\t\t\t * Where as if the remote client does hold-unhold first, this client can do it any number\n\t\t\t * of times.\n\t\t\t *\n\t\t\t * Logic below works as follows\n\t\t\t * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n\t\t\t * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n\t\t\t * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n\t\t\t * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n\t\t\t *\n\t\t\t */\n\t\t\tlet videoInvite = !!this.config.enableVideo;\n\n\t\t\tconst { body } = this.session;\n\t\t\tif (body && body.indexOf('m=video') === -1) {\n\t\t\t\tvideoInvite = false;\n\t\t\t}\n\n\t\t\tconst invitationAcceptOptions: InvitationAcceptOptions = {\n\t\t\t\tsessionDescriptionHandlerOptions: {\n\t\t\t\t\tconstraints: {\n\t\t\t\t\t\taudio: true,\n\t\t\t\t\t\tvideo: !!this.config.enableVideo && videoInvite,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\treturn this.session.accept(invitationAcceptOptions);\n\t\t}\n\t\tthrow new Error('Something went wrong');\n\t}\n\n\t/* Helper routines for checking call actions BEGIN */\n\n\tprivate canRejectCall(): boolean {\n\t\treturn ['OFFER_RECEIVED', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\tprivate canEndOrHoldCall(): boolean {\n\t\treturn ['ANSWER_SENT', 'ANSWER_RECEIVED', 'IN_CALL', 'ON_HOLD', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\t/* Helper routines for checking call actions END */\n\n\t/**\n\t * Public method called from outside to reject a call.\n\t * @remarks\n\t */\n\trejectCall(): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canRejectCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tif (!(this.session instanceof Invitation)) {\n\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t}\n\t\treturn this.session.reject();\n\t}\n\n\t/**\n\t * Public method called from outside to end a call.\n\t * @remarks\n\t */\n\tasync endCall(): Promise<OutgoingByeRequest | void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\n\t\t// When call ends, force state to be revisited\n\t\tthis.emit('stateChanged');\n\t\tswitch (this.session.state) {\n\t\t\tcase SessionState.Initial:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Establishing:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tif (this.session instanceof Inviter) {\n\t\t\t\t\treturn this.session.cancel();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Established:\n\t\t\t\treturn this.session.bye();\n\t\t\tcase SessionState.Terminating:\n\t\t\t\tbreak;\n\t\t\tcase SessionState.Terminated:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown state');\n\t\t}\n\t}\n\n\t/**\n\t * Public method called from outside to mute the call.\n\t * @remarks\n\t */\n\tasync muteCall(muteState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'IN_CALL') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleMuteUnmute(muteState);\n\t}\n\n\t/**\n\t * Public method called from outside to hold the call.\n\t * @remarks\n\t */\n\tasync holdCall(holdState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleHoldUnhold(holdState);\n\t}\n\n\t/* CallEventDelegate implementation end */\n\tisReady(): boolean {\n\t\treturn this.state.isReady;\n\t}\n\n\t/**\n\t * This function allows to change the media renderer media elements.\n\t */\n\tswitchMediaRenderer(mediaRenderer: IMediaStreamRenderer): void {\n\t\tif (this.remoteStream) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t\tthis.remoteStream.init(mediaRenderer.remoteMediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\tsetWorkflowMode(mode: WorkflowTypes): void {\n\t\tthis.mode = mode;\n\t\tif (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\tthis.queueInfo = new QueueAggregator();\n\t\t}\n\t}\n\n\tsetMembershipSubscription(subscription: IQueueMembershipSubscription): void {\n\t\tif (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\treturn;\n\t\t}\n\t\tthis.queueInfo?.setMembership(subscription);\n\t}\n\n\tgetAggregator(): QueueAggregator {\n\t\treturn this.queueInfo;\n\t}\n\n\tgetRegistrarState(): string | undefined {\n\t\treturn this.registerer?.state.toString().toLocaleLowerCase();\n\t}\n\n\tclear(): void {\n\t\tthis._opInProgress = Operation.OP_CLEANUP;\n\t\t/** Socket reconnection is attempted when the socket is disconnected with some error.\n\t\t * While disconnecting, if there is any socket error, there should be no reconnection attempt.\n\t\t * So when userAgent.stop() is called which closes the sockets, it should be made sure that\n\t\t * if the socket is disconnected with error, connection attempts are not started or\n\t\t * if there are any previously ongoing attempts, they should be terminated.\n\t\t * flag attemptReconnect is used for ensuring this.\n\t\t */\n\t\tthis.stop = true;\n\t\tthis.userAgent?.stop();\n\t\tthis.registerer?.dispose();\n\t\tthis._connectionState = 'STOP';\n\n\t\tif (this.userAgent) {\n\t\t\tthis.userAgent.transport.onConnect = undefined;\n\t\t\tthis.userAgent.transport.onDisconnect = undefined;\n\t\t\twindow.removeEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.removeEventListener('offline', this.offlineNetworkHandler);\n\t\t}\n\t}\n\n\tonNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.on(event, handler);\n\t}\n\n\toffNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.off(event, handler);\n\t}\n\n\t/**\n\t * Connection is lost in 3 ways\n\t * 1. When local network is lost (Router is disconnected, switching networks, devtools->network->offline)\n\t * In this case, the SIP.js's transport layer does not detect the disconnection. Hence, it does not\n\t * call |onDisconnect|. To detect this kind of disconnection, window event listeners have been added.\n\t * These event listeners would be get called when the browser detects that network is offline or online.\n\t * When the network is restored, the code tries to reconnect. The useragent.transport \"does not\" generate the\n\t * onconnected event in this case as well. so onlineNetworkHandler calls attemptReconnection.\n\t * Which calls attemptRegistrationPostRecovery based on correct state. attemptRegistrationPostRecovery first tries to\n\t * unregister and then re-register.\n\t * Important note : We use the event listeners using bind function object offlineNetworkHandler and onlineNetworkHandler\n\t * It is done so because the same event handlers need to be used for removeEventListener, which becomes impossible\n\t * if done inline.\n\t *\n\t * 2. Computer goes to sleep. In this case onDisconnect is triggered. The code tries to reconnect but cant go ahead\n\t * as it goes to sleep. On waking up, The attemptReconnection gets executed, connection is completed.\n\t * In this case, it generates onConnected event. In this onConnected event it calls attemptRegistrationPostRecovery\n\t *\n\t * 3. When Asterisk disconnects all the endpoints either because it crashes or restarted,\n\t * As soon as the agent successfully connects to asterisk, it should re-register\n\t *\n\t * Retry count :\n\t * connectionRetryCount is the parameter called |Retry Count| in\n\t * Administration -> Call Center -> Server configuration -> Retry count.\n\t * The retry is implemented with backoff, maxbackoff = 8 seconds.\n\t * For continuous retries (In case Asterisk restart happens) Set this parameter to -1.\n\t *\n\t * Important to note is how attemptRegistrationPostRecovery is called. In case of\n\t * the router connection loss or while switching the networks,\n\t * there is no disconnect and connect event from the transport layer of the userAgent.\n\t * So in this case, when the connection is successful after reconnect, the code should try to re-register by calling\n\t * attemptRegistrationPostRecovery.\n\t * In case of computer waking from sleep or asterisk getting restored, connect and disconnect events are generated.\n\t * In this case, re-registration should be triggered (by calling) only when onConnected gets called and not otherwise.\n\t */\n\n\tasync attemptReconnection(reconnectionAttempt = 0, checkRegistration = false): Promise<void> {\n\t\tconst reconnectionAttempts = this.connectionRetryCount;\n\t\tthis._connectionState = 'SERVER_RECONNECTING';\n\t\tif (!this.userAgent) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.stop) {\n\t\t\treturn;\n\t\t}\n\t\t// reconnectionAttempts == -1 then keep continuously trying\n\t\tif (reconnectionAttempts !== -1 && reconnectionAttempt > reconnectionAttempts) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\treturn;\n\t\t}\n\n\t\tconst reconnectionDelay = Math.pow(2, reconnectionAttempt % 4);\n\n\t\tconsole.error(`Attempting to reconnect with backoff due to network loss. Backoff time [${reconnectionDelay}]`);\n\t\tsetTimeout(() => {\n\t\t\tif (this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState === 'SERVER_CONNECTED') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.userAgent\n\t\t\t\t?.reconnect()\n\t\t\t\t.then(() => {\n\t\t\t\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\t\t\t})\n\t\t\t\t.catch(() => {\n\t\t\t\t\tthis.attemptReconnection(++reconnectionAttempt, checkRegistration);\n\t\t\t\t});\n\t\t}, reconnectionDelay * 1000);\n\t}\n\n\tasync attemptPostRecoveryRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tthis.sendOptions({\n\t\t\tonAccept: (): void => {\n\t\t\t\tthis.attemptPostRecoveryRegistrationRoutine();\n\t\t\t},\n\t\t\tonReject: (error: unknown): void => {\n\t\t\t\tconsole.error(`[${error}] Failed to do options in attemptPostRecoveryRoutine()`);\n\t\t\t},\n\t\t});\n\t}\n\n\tasync sendKeepAliveAndWaitForResponse(withDebounce = false): Promise<boolean> {\n\t\tconst promise = new Promise<boolean>((resolve, reject) => {\n\t\t\tlet keepAliveAccepted = false;\n\t\t\tlet responseWaitTime = this.optionsKeepaliveInterval / 2;\n\t\t\tif (withDebounce) {\n\t\t\t\tresponseWaitTime += this.optionsKeepAliveDebounceTimeInSec;\n\t\t\t}\n\n\t\t\tthis.sendOptions({\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tkeepAliveAccepted = true;\n\t\t\t\t},\n\t\t\t\tonReject: (_error: unknown): void => {\n\t\t\t\t\tconsole.error('Failed to do options.');\n\t\t\t\t},\n\t\t\t});\n\t\t\tsetTimeout(async () => {\n\t\t\t\tif (!keepAliveAccepted) {\n\t\t\t\t\treject(false);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.attemptRegistration) {\n\t\t\t\t\t\tthis.attemptPostRecoveryRoutine();\n\t\t\t\t\t\tthis.attemptRegistration = false;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(true);\n\t\t\t\t}\n\t\t\t}, responseWaitTime * 1000);\n\t\t});\n\t\treturn promise;\n\t}\n\n\tasync startOptionsPingForUnstableNetworks(): Promise<void> {\n\t\tsetTimeout(async () => {\n\t\t\tif (!this.userAgent || this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState !== 'SERVER_RECONNECTING') {\n\t\t\t\tlet isConnected = false;\n\t\t\t\ttry {\n\t\t\t\t\tawait this.sendKeepAliveAndWaitForResponse();\n\t\t\t\t\tisConnected = true;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(`[${e}] Failed to do options ping.`);\n\t\t\t\t} finally {\n\t\t\t\t\t// Send event only if it's a \"change\" on the status (avoid unnecessary event flooding)\n\t\t\t\t\t!isConnected && this.networkEmitter.emit('disconnected');\n\t\t\t\t\tisConnected && this.networkEmitter.emit('connected');\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Each seconds check if the network can reach asterisk. If not, try to reconnect\n\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t}, this.optionsKeepaliveInterval * 1000);\n\t}\n\n\tasync attemptPostRecoveryRegistrationRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tconst promise = new Promise<void>((_resolve, _reject) => {\n\t\t\tthis.registerer?.unregister({\n\t\t\t\tall: true,\n\t\t\t\trequestDelegate: {\n\t\t\t\t\tonAccept: (): void => {\n\t\t\t\t\t\t_resolve();\n\t\t\t\t\t},\n\t\t\t\t\tonReject: (error): void => {\n\t\t\t\t\t\tconsole.error(`[${error}] While unregistering after recovery`);\n\t\t\t\t\t\tthis.emit('unregistrationerror', error);\n\t\t\t\t\t\t_reject('Error in Unregistering');\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t\ttry {\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\tconsole.error(`[${error}] While waiting for unregister promise`);\n\t\t}\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonReject: (error): void => {\n\t\t\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\t\t\tthis.emit('registrationerror', error);\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\tasync changeAudioInputDevice(constraints: MediaStreamConstraints): Promise<boolean> {\n\t\tif (!this.session) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No session. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst newStream = await LocalStream.requestNewStream(constraints, this.session);\n\t\tif (!newStream) {\n\t\t\tconsole.warn('changeAudioInputDevice() : Unable to get local stream. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No peer connection. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tLocalStream.replaceTrack(peerConnection, newStream, 'audio');\n\t\treturn true;\n\t}\n\n\t// Commenting this as Video Configuration is not part of the scope for now\n\t// async changeVideoInputDevice(selectedVideoDevices: IDevice): Promise<boolean> {\n\t// \tif (!this.session) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No session. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tif (!this.config.enableVideo || this.deviceManager.hasVideoInputDevice()) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable change video device. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tthis.deviceManager.changeVideoInputDevice(selectedVideoDevices);\n\t// \tconst newStream = await LocalStream.requestNewStream(this.deviceManager.getConstraints('video'), this.session);\n\t// \tif (!newStream) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable to get local stream. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t// \tif (!peerConnection) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No peer connection. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tLocalStream.replaceTrack(peerConnection, newStream, 'video');\n\t// \treturn true;\n\t// }\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\tasync makeCallURI(_callee: string, _mediaRenderer?: IMediaStreamRenderer): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\tasync makeCall(_calleeNumber: string): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n}\n"]},"targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null,null]},"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"DoWhileStatement":{"exit":[null]},"ForInStatement":{"exit":[null]},"ForStatement":{"exit":[null]},"WhileStatement":{"exit":[null]},"ForOfStatement":{"exit":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-regenerator","visitor":{"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/client/lib/voip/VoIPUser.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"client/lib/voip/VoIPUser.ts","inputSourceMap":{"version":3,"file":"client/lib/voip/VoIPUser.ts","sourceRoot":"","sources":["client/lib/voip/VoIPUser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Class representing SIP UserAgent\n * @remarks\n * This class encapsulates all the details of sip.js and exposes\n * a very simple functions and callback handlers to the outside world.\n * This class thus abstracts user from Browser specific media details as well as\n * SIP specific protocol details.\n */\nimport type {\n\tCallStates,\n\tConnectionState,\n\tICallerInfo,\n\tIQueueMembershipSubscription,\n\tSignalingSocketEvents,\n\tSocketEventKeys,\n\tIMediaStreamRenderer,\n\tVoIPUserConfiguration,\n\tVoIpCallerInfo,\n\tIState,\n\tVoipEvents,\n} from '@rocket.chat/core-typings';\nimport { Operation, UserState, WorkflowTypes } from '@rocket.chat/core-typings';\nimport { Emitter } from '@rocket.chat/emitter';\nimport type { UserAgentOptions, InvitationAcceptOptions, Session, SessionInviteOptions } from 'sip.js';\nimport { UserAgent, Invitation, SessionState, Registerer, RequestPendingError, Inviter } from 'sip.js';\nimport type { OutgoingByeRequest, OutgoingRequestDelegate } from 'sip.js/lib/core';\nimport { URI } from 'sip.js/lib/core';\nimport type { SessionDescriptionHandlerOptions } from 'sip.js/lib/platform/web';\nimport { SessionDescriptionHandler } from 'sip.js/lib/platform/web';\n\nimport { toggleMediaStreamTracks } from './Helper';\nimport LocalStream from './LocalStream';\nimport { QueueAggregator } from './QueueAggregator';\nimport RemoteStream from './RemoteStream';\n\nexport class VoIPUser extends Emitter<VoipEvents> {\n\tstate: IState = {\n\t\tisReady: false,\n\t\tenableVideo: false,\n\t};\n\n\tprivate remoteStream: RemoteStream | undefined;\n\n\tuserAgentOptions: UserAgentOptions = {};\n\n\tuserAgent: UserAgent | undefined;\n\n\tregisterer: Registerer | undefined;\n\n\tmediaStreamRendered?: IMediaStreamRenderer;\n\n\tprivate _connectionState: ConnectionState = 'INITIAL';\n\n\tprivate _held = false;\n\n\tprivate mode: WorkflowTypes;\n\n\tprivate queueInfo: QueueAggregator;\n\n\tprivate connectionRetryCount;\n\n\tprivate stop;\n\n\tprivate networkEmitter: Emitter<SignalingSocketEvents>;\n\n\tprivate offlineNetworkHandler: () => void;\n\n\tprivate onlineNetworkHandler: () => void;\n\n\tprivate optionsKeepaliveInterval = 5;\n\n\tprivate optionsKeepAliveDebounceTimeInSec = 5;\n\n\tprivate attemptRegistration = false;\n\n\tprotected session: Session | undefined;\n\n\tprotected _callState: CallStates = 'INITIAL';\n\n\tprotected _callerInfo: ICallerInfo | undefined;\n\n\tprotected _userState: UserState = UserState.IDLE;\n\n\tprotected _opInProgress: Operation = Operation.OP_NONE;\n\n\tget operationInProgress(): Operation {\n\t\treturn this._opInProgress;\n\t}\n\n\tget userState(): UserState | undefined {\n\t\treturn this._userState;\n\t}\n\n\tconstructor(private readonly config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer) {\n\t\tsuper();\n\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\tthis.networkEmitter = new Emitter<SignalingSocketEvents>();\n\t\tthis.connectionRetryCount = this.config.connectionRetryCount;\n\t\tthis.stop = false;\n\n\t\tthis.onlineNetworkHandler = this.onNetworkRestored.bind(this);\n\t\tthis.offlineNetworkHandler = this.onNetworkLost.bind(this);\n\t}\n\n\t/**\n\t * Configures and initializes sip.js UserAgent\n\t * call gets established.\n\t * @remarks\n\t * This class configures transport properties such as websocket url, passed down in config,\n\t * sets up ICE servers,\n\t * SIP UserAgent options such as userName, Password, URI.\n\t * Once initialized, it starts the userAgent.\n\t */\n\n\tasync init(): Promise<void> {\n\t\tconst sipUri = `sip:${this.config.authUserName}@${this.config.sipRegistrarHostnameOrIP}`;\n\t\tconst transportOptions = {\n\t\t\tserver: this.config.webSocketURI,\n\t\t\tconnectionTimeout: 100, // Replace this with config\n\t\t\tkeepAliveInterval: 20,\n\t\t\t// traceSip: true,\n\t\t};\n\t\tconst sdpFactoryOptions = {\n\t\t\ticeGatheringTimeout: 10,\n\t\t\tpeerConnectionConfiguration: {\n\t\t\t\ticeServers: this.config.iceServers,\n\t\t\t},\n\t\t};\n\t\tthis.userAgentOptions = {\n\t\t\tdelegate: {\n\t\t\t\tonInvite: async (invitation: Invitation): Promise<void> => {\n\t\t\t\t\tawait this.handleIncomingCall(invitation);\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthorizationPassword: this.config.authPassword,\n\t\t\tauthorizationUsername: this.config.authUserName,\n\t\t\turi: UserAgent.makeURI(sipUri),\n\t\t\ttransportOptions,\n\t\t\tsessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n\t\t\tlogConfiguration: false,\n\t\t\tlogLevel: 'error',\n\t\t};\n\n\t\tthis.userAgent = new UserAgent(this.userAgentOptions);\n\t\tthis.userAgent.transport.isConnected();\n\t\tthis._opInProgress = Operation.OP_CONNECT;\n\t\ttry {\n\t\t\tthis.registerer = new Registerer(this.userAgent);\n\n\t\t\tthis.userAgent.transport.onConnect = this.onConnected.bind(this);\n\t\t\tthis.userAgent.transport.onDisconnect = this.onDisconnected.bind(this);\n\t\t\twindow.addEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.addEventListener('offline', this.offlineNetworkHandler);\n\t\t\tawait this.userAgent.start();\n\t\t\tif (this.config.enableKeepAliveUsingOptionsForUnstableNetworks) {\n\t\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync onConnected(): Promise<void> {\n\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\tthis.state.isReady = true;\n\t\tthis.sendOptions();\n\t\tthis.networkEmitter.emit('connected');\n\t\t/**\n\t\t * Re-registration post network recovery should be attempted\n\t\t * if it was previously registered or incall/onhold\n\t\t */\n\n\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\tthis.attemptRegistration = true;\n\t\t}\n\t}\n\n\tonDisconnected(error: any): void {\n\t\tthis._connectionState = 'SERVER_DISCONNECTED';\n\t\tthis._opInProgress = Operation.OP_NONE;\n\t\tthis.networkEmitter.emit('disconnected');\n\t\tif (error) {\n\t\t\tthis.networkEmitter.emit('connectionerror', error);\n\t\t\tthis.state.isReady = false;\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted assuming\n\t\t\t * that the disconnect happened from the remote side or due to sleep\n\t\t\t * In case of remote side disconnection, if config.connectionRetryCount is -1,\n\t\t\t * attemptReconnection attempts continuously. Else stops after |config.connectionRetryCount|\n\t\t\t *\n\t\t\t */\n\t\t\t// this.attemptReconnection();\n\t\t\tthis.attemptReconnection(0, false);\n\t\t}\n\t}\n\n\tonNetworkRestored(): void {\n\t\tthis.networkEmitter.emit('localnetworkonline');\n\t\tif (this._connectionState === 'WAITING_FOR_NETWORK') {\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted when online event handler\n\t\t\t * gets notified.\n\t\t\t * Important thing to note is that the second parameter |checkRegistration| = true passed here\n\t\t\t * because after the network recovery and after reconnecting to the server,\n\t\t\t * the transport layer of SIPUA does not call onConnected. So by passing |checkRegistration = true |\n\t\t\t * the code will check if the endpoint was previously registered before the disconnection.\n\t\t\t * If such is the case, it will first unregister and then re-register.\n\t\t\t * */\n\t\t\tthis.attemptReconnection();\n\t\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\t\tthis.attemptRegistration = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tonNetworkLost(): void {\n\t\tthis.networkEmitter.emit('localnetworkoffline');\n\t\tthis._connectionState = 'WAITING_FOR_NETWORK';\n\t}\n\n\tget userConfig(): VoIPUserConfiguration {\n\t\treturn this.config;\n\t}\n\n\tget callState(): CallStates {\n\t\treturn this._callState;\n\t}\n\n\tget connectionState(): ConnectionState {\n\t\treturn this._connectionState;\n\t}\n\n\tget callerInfo(): VoIpCallerInfo {\n\t\tif (\n\t\t\tthis.callState === 'IN_CALL' ||\n\t\t\tthis.callState === 'OFFER_RECEIVED' ||\n\t\t\tthis.callState === 'ON_HOLD' ||\n\t\t\tthis.callState === 'OFFER_SENT'\n\t\t) {\n\t\t\tif (!this._callerInfo) {\n\t\t\t\tthrow new Error('[VoIPUser callerInfo] invalid state');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: this.callState,\n\t\t\t\tcaller: this._callerInfo,\n\t\t\t\tuserState: this._userState,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tstate: this.callState,\n\t\t\tuserState: this._userState,\n\t\t};\n\t}\n\n\t/* Media Stream functions begin */\n\t/** The local media stream. Undefined if call not answered. */\n\tget localMediaStream(): MediaStream | undefined {\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\t\treturn sdh.localMediaStream;\n\t}\n\n\t/* Media Stream functions end */\n\t/* OutgoingRequestDelegate methods begin */\n\tonRegistrationRequestAccept(): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis._callState = 'REGISTERED';\n\t\t\tthis.emit('registered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\tthis.emit('unregistered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t}\n\n\tonRegistrationRequestReject(error: any): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis.emit('registrationerror', error);\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis.emit('unregistrationerror', error);\n\t\t}\n\t}\n\t/* OutgoingRequestDelegate methods end */\n\n\tprivate async handleIncomingCall(invitation: Invitation): Promise<void> {\n\t\tif (this.callState === 'REGISTERED') {\n\t\t\tthis._opInProgress = Operation.OP_PROCESS_INVITE;\n\t\t\tthis._callState = 'OFFER_RECEIVED';\n\t\t\tthis._userState = UserState.UAS;\n\t\t\tthis.session = invitation;\n\t\t\tthis.setupSessionEventHandlers(invitation);\n\t\t\tconst callerInfo: ICallerInfo = {\n\t\t\t\tcallerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n\t\t\t\tcallerName: invitation.remoteIdentity.displayName,\n\t\t\t\thost: invitation.remoteIdentity.uri.host,\n\t\t\t};\n\t\t\tthis._callerInfo = callerInfo;\n\t\t\tthis.emit('incomingcall', callerInfo);\n\t\t\tthis.emit('stateChanged');\n\t\t\treturn;\n\t\t}\n\n\t\tawait invitation.reject();\n\t}\n\n\t/**\n\t * Sets up an listener handler for handling session's state change\n\t * @remarks\n\t * Called for setting up various state listeners. These listeners will\n\t * decide the next action to be taken when the session state changes.\n\t * e.g when session.state changes from |Establishing| to |Established|\n\t * one must set up local and remote media rendering.\n\t *\n\t * This class handles such session state changes and takes necessary actions.\n\t */\n\n\tprotected setupSessionEventHandlers(session: Session): void {\n\t\tthis.session?.stateChange.addListener((state: SessionState) => {\n\t\t\tif (this.session !== session) {\n\t\t\t\treturn; // if our session has changed, just return\n\t\t\t}\n\t\t\tswitch (state) {\n\t\t\t\tcase SessionState.Initial:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Establishing:\n\t\t\t\t\tthis.emit('ringing', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Established:\n\t\t\t\t\tif (this._userState === UserState.UAC) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * We need to decide about user-state ANSWER-RECEIVED for outbound.\n\t\t\t\t\t\t * This state is there for the symmetry of ANSWER-SENT.\n\t\t\t\t\t\t * ANSWER-SENT occurs when there is incoming invite. So then the UA\n\t\t\t\t\t\t * accepts a call, it sends the answer and state becomes ANSWER-SENT.\n\t\t\t\t\t\t * The call gets established only when the remote party sends ACK.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * But in case of UAC where the invite is sent out, there is no intermediate\n\t\t\t\t\t\t * state where the UA can be in ANSWER-RECEIVED. As soon this UA receives the answer,\n\t\t\t\t\t\t * it sends ack and changes the SessionState to established.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * So we do not have an actual state transitions from ANSWER-RECEIVED to IN-CALL.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Nevertheless, this state is just added to maintain the symmetry. This can be safely removed.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * */\n\t\t\t\t\t\tthis._callState = 'ANSWER_RECEIVED';\n\t\t\t\t\t}\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis.setupRemoteMedia();\n\t\t\t\t\tthis._callState = 'IN_CALL';\n\t\t\t\t\tthis.emit('callestablished', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Terminating:\n\t\t\t\t// fall through\n\t\t\t\tcase SessionState.Terminated:\n\t\t\t\t\tthis.session = undefined;\n\t\t\t\t\tthis._callState = 'REGISTERED';\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._userState = UserState.IDLE;\n\t\t\t\t\tthis.emit('callterminated');\n\t\t\t\t\tthis.remoteStream?.clear();\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown session state.');\n\t\t\t}\n\t\t});\n\t}\n\n\tonTrackAdded(_event: any): void {\n\t\tconsole.log('onTrackAdded');\n\t}\n\n\tonTrackRemoved(_event: any): void {\n\t\tconsole.log('onTrackRemoved');\n\t}\n\n\t/**\n\t * Carries out necessary steps for rendering remote media whe\n\t * call gets established.\n\t * @remarks\n\t * Sets up Stream class and plays the stream on given Media element/\n\t * Also sets up various event handlers.\n\t */\n\tprivate setupRemoteMedia(): any {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\n\t\tconst remoteStream = sdh.remoteMediaStream;\n\t\tif (!remoteStream) {\n\t\t\tthrow new Error('Remote media stream is undefined.');\n\t\t}\n\n\t\tthis.remoteStream = new RemoteStream(remoteStream);\n\t\tconst mediaElement = this.mediaStreamRendered?.remoteMediaElement;\n\t\tif (mediaElement) {\n\t\t\tthis.remoteStream.init(mediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\t/**\n\t * Handles call mute-unmute\n\t */\n\tprivate async handleMuteUnmute(muteState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === muteState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = muteState;\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\tthis.emit('muteerror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A mute request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('muteerror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles call hold-unhold\n\t */\n\tprivate async handleHoldUnhold(holdState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === holdState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = holdState;\n\t\t\t\t\tthis._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis.emit('holderror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Session properties used to pass options to the SessionDescriptionHandler:\n\t\t//\n\t\t// 1) Session.sessionDescriptionHandlerOptions\n\t\t//    SDH options for the initial INVITE transaction.\n\t\t//    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n\t\t//\n\t\t// 2) Session.sessionDescriptionHandlerOptionsReInvite\n\t\t//    SDH options for re-INVITE transactions.\n\t\t//    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Session.invite().\n\n\t\tconst sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite as SessionDescriptionHandlerOptions;\n\t\tsessionDescriptionHandlerOptions.hold = holdState;\n\t\tsession.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A hold request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('holderror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tstatic async create(config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer): Promise<VoIPUser> {\n\t\tconst voip = new VoIPUser(config, mediaRenderer);\n\t\tawait voip.init();\n\t\treturn voip;\n\t}\n\n\t/**\n\t * Sends SIP OPTIONS message to asterisk\n\t *\n\t * There is an interesting problem that happens with Asterisk.\n\t * After websocket connection succeeds and if there is no SIP\n\t * message goes in 30 seconds, asterisk disconnects the socket.\n\t *\n\t * If any SIP message goes before 30 seconds, asterisk holds the connection.\n\t * This problem could be solved in multiple ways. One is that\n\t * whenever disconnect happens make sure that the socket is connected back using\n\t * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n\t * every 30 seconds till we send register message.\n\t *\n\t * Another approach is to send SIP OPTIONS just to tell server that\n\t * there is a UA using this socket. This is implemented below\n\t */\n\n\tsendOptions(outgoingRequestDelegate?: OutgoingRequestDelegate): void {\n\t\tconst uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n\t\tconst outgoingMessage = this.userAgent?.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\t\tif (outgoingMessage) {\n\t\t\tthis.userAgent?.userAgentCore.request(outgoingMessage, outgoingRequestDelegate);\n\t\t}\n\t}\n\t/**\n\t * Public method called from outside to register the SIP UA with call server.\n\t * @remarks\n\t */\n\n\tregister(): void {\n\t\tthis._opInProgress = Operation.OP_REGISTER;\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Public method called from outside to unregister the SIP UA.\n\t * @remarks\n\t */\n\n\tunregister(): void {\n\t\tthis._opInProgress = Operation.OP_UNREGISTER;\n\t\tthis.registerer?.unregister({\n\t\t\tall: true,\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\t/**\n\t * Public method called from outside to accept incoming call.\n\t * @remarks\n\t */\n\n\tasync acceptCall(mediaRenderer: IMediaStreamRenderer): Promise<void> {\n\t\tif (mediaRenderer) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t}\n\t\t// Call state must be in offer_received.\n\t\tif (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n\t\t\tthis._callState = 'ANSWER_SENT';\n\t\t\t// Something is wrong, this session is not an instance of INVITE\n\t\t\tif (!(this.session instanceof Invitation)) {\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\t}\n\t\t\t/**\n\t\t\t * It is important to decide when to add video option to the outgoing offer.\n\t\t\t * This would matter when the reinvite goes out (In case of hold/unhold)\n\t\t\t * This was added because there were failures in hold-unhold.\n\t\t\t * The scenario was that if this client does hold-unhold first, and remote client does\n\t\t\t * later, remote client goes in inconsistent state and hold-unhold does not work\n\t\t\t * Where as if the remote client does hold-unhold first, this client can do it any number\n\t\t\t * of times.\n\t\t\t *\n\t\t\t * Logic below works as follows\n\t\t\t * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n\t\t\t * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n\t\t\t * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n\t\t\t * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n\t\t\t *\n\t\t\t */\n\t\t\tlet videoInvite = !!this.config.enableVideo;\n\n\t\t\tconst { body } = this.session;\n\t\t\tif (body && body.indexOf('m=video') === -1) {\n\t\t\t\tvideoInvite = false;\n\t\t\t}\n\n\t\t\tconst invitationAcceptOptions: InvitationAcceptOptions = {\n\t\t\t\tsessionDescriptionHandlerOptions: {\n\t\t\t\t\tconstraints: {\n\t\t\t\t\t\taudio: true,\n\t\t\t\t\t\tvideo: !!this.config.enableVideo && videoInvite,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\treturn this.session.accept(invitationAcceptOptions);\n\t\t}\n\t\tthrow new Error('Something went wrong');\n\t}\n\n\t/* Helper routines for checking call actions BEGIN */\n\n\tprivate canRejectCall(): boolean {\n\t\treturn ['OFFER_RECEIVED', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\tprivate canEndOrHoldCall(): boolean {\n\t\treturn ['ANSWER_SENT', 'ANSWER_RECEIVED', 'IN_CALL', 'ON_HOLD', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\t/* Helper routines for checking call actions END */\n\n\t/**\n\t * Public method called from outside to reject a call.\n\t * @remarks\n\t */\n\trejectCall(): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canRejectCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tif (!(this.session instanceof Invitation)) {\n\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t}\n\t\treturn this.session.reject();\n\t}\n\n\t/**\n\t * Public method called from outside to end a call.\n\t * @remarks\n\t */\n\tasync endCall(): Promise<OutgoingByeRequest | void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\n\t\t// When call ends, force state to be revisited\n\t\tthis.emit('stateChanged');\n\t\tswitch (this.session.state) {\n\t\t\tcase SessionState.Initial:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Establishing:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tif (this.session instanceof Inviter) {\n\t\t\t\t\treturn this.session.cancel();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Established:\n\t\t\t\treturn this.session.bye();\n\t\t\tcase SessionState.Terminating:\n\t\t\t\tbreak;\n\t\t\tcase SessionState.Terminated:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown state');\n\t\t}\n\t}\n\n\t/**\n\t * Public method called from outside to mute the call.\n\t * @remarks\n\t */\n\tasync muteCall(muteState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'IN_CALL') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleMuteUnmute(muteState);\n\t}\n\n\t/**\n\t * Public method called from outside to hold the call.\n\t * @remarks\n\t */\n\tasync holdCall(holdState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleHoldUnhold(holdState);\n\t}\n\n\t/* CallEventDelegate implementation end */\n\tisReady(): boolean {\n\t\treturn this.state.isReady;\n\t}\n\n\t/**\n\t * This function allows to change the media renderer media elements.\n\t */\n\tswitchMediaRenderer(mediaRenderer: IMediaStreamRenderer): void {\n\t\tif (this.remoteStream) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t\tthis.remoteStream.init(mediaRenderer.remoteMediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\tsetWorkflowMode(mode: WorkflowTypes): void {\n\t\tthis.mode = mode;\n\t\tif (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\tthis.queueInfo = new QueueAggregator();\n\t\t}\n\t}\n\n\tsetMembershipSubscription(subscription: IQueueMembershipSubscription): void {\n\t\tif (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\treturn;\n\t\t}\n\t\tthis.queueInfo?.setMembership(subscription);\n\t}\n\n\tgetAggregator(): QueueAggregator {\n\t\treturn this.queueInfo;\n\t}\n\n\tgetRegistrarState(): string | undefined {\n\t\treturn this.registerer?.state.toString().toLocaleLowerCase();\n\t}\n\n\tclear(): void {\n\t\tthis._opInProgress = Operation.OP_CLEANUP;\n\t\t/** Socket reconnection is attempted when the socket is disconnected with some error.\n\t\t * While disconnecting, if there is any socket error, there should be no reconnection attempt.\n\t\t * So when userAgent.stop() is called which closes the sockets, it should be made sure that\n\t\t * if the socket is disconnected with error, connection attempts are not started or\n\t\t * if there are any previously ongoing attempts, they should be terminated.\n\t\t * flag attemptReconnect is used for ensuring this.\n\t\t */\n\t\tthis.stop = true;\n\t\tthis.userAgent?.stop();\n\t\tthis.registerer?.dispose();\n\t\tthis._connectionState = 'STOP';\n\n\t\tif (this.userAgent) {\n\t\t\tthis.userAgent.transport.onConnect = undefined;\n\t\t\tthis.userAgent.transport.onDisconnect = undefined;\n\t\t\twindow.removeEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.removeEventListener('offline', this.offlineNetworkHandler);\n\t\t}\n\t}\n\n\tonNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.on(event, handler);\n\t}\n\n\toffNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.off(event, handler);\n\t}\n\n\t/**\n\t * Connection is lost in 3 ways\n\t * 1. When local network is lost (Router is disconnected, switching networks, devtools->network->offline)\n\t * In this case, the SIP.js's transport layer does not detect the disconnection. Hence, it does not\n\t * call |onDisconnect|. To detect this kind of disconnection, window event listeners have been added.\n\t * These event listeners would be get called when the browser detects that network is offline or online.\n\t * When the network is restored, the code tries to reconnect. The useragent.transport \"does not\" generate the\n\t * onconnected event in this case as well. so onlineNetworkHandler calls attemptReconnection.\n\t * Which calls attemptRegistrationPostRecovery based on correct state. attemptRegistrationPostRecovery first tries to\n\t * unregister and then re-register.\n\t * Important note : We use the event listeners using bind function object offlineNetworkHandler and onlineNetworkHandler\n\t * It is done so because the same event handlers need to be used for removeEventListener, which becomes impossible\n\t * if done inline.\n\t *\n\t * 2. Computer goes to sleep. In this case onDisconnect is triggered. The code tries to reconnect but cant go ahead\n\t * as it goes to sleep. On waking up, The attemptReconnection gets executed, connection is completed.\n\t * In this case, it generates onConnected event. In this onConnected event it calls attemptRegistrationPostRecovery\n\t *\n\t * 3. When Asterisk disconnects all the endpoints either because it crashes or restarted,\n\t * As soon as the agent successfully connects to asterisk, it should re-register\n\t *\n\t * Retry count :\n\t * connectionRetryCount is the parameter called |Retry Count| in\n\t * Administration -> Call Center -> Server configuration -> Retry count.\n\t * The retry is implemented with backoff, maxbackoff = 8 seconds.\n\t * For continuous retries (In case Asterisk restart happens) Set this parameter to -1.\n\t *\n\t * Important to note is how attemptRegistrationPostRecovery is called. In case of\n\t * the router connection loss or while switching the networks,\n\t * there is no disconnect and connect event from the transport layer of the userAgent.\n\t * So in this case, when the connection is successful after reconnect, the code should try to re-register by calling\n\t * attemptRegistrationPostRecovery.\n\t * In case of computer waking from sleep or asterisk getting restored, connect and disconnect events are generated.\n\t * In this case, re-registration should be triggered (by calling) only when onConnected gets called and not otherwise.\n\t */\n\n\tasync attemptReconnection(reconnectionAttempt = 0, checkRegistration = false): Promise<void> {\n\t\tconst reconnectionAttempts = this.connectionRetryCount;\n\t\tthis._connectionState = 'SERVER_RECONNECTING';\n\t\tif (!this.userAgent) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.stop) {\n\t\t\treturn;\n\t\t}\n\t\t// reconnectionAttempts == -1 then keep continuously trying\n\t\tif (reconnectionAttempts !== -1 && reconnectionAttempt > reconnectionAttempts) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\treturn;\n\t\t}\n\n\t\tconst reconnectionDelay = Math.pow(2, reconnectionAttempt % 4);\n\n\t\tconsole.error(`Attempting to reconnect with backoff due to network loss. Backoff time [${reconnectionDelay}]`);\n\t\tsetTimeout(() => {\n\t\t\tif (this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState === 'SERVER_CONNECTED') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.userAgent\n\t\t\t\t?.reconnect()\n\t\t\t\t.then(() => {\n\t\t\t\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\t\t\t})\n\t\t\t\t.catch(() => {\n\t\t\t\t\tthis.attemptReconnection(++reconnectionAttempt, checkRegistration);\n\t\t\t\t});\n\t\t}, reconnectionDelay * 1000);\n\t}\n\n\tasync attemptPostRecoveryRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tthis.sendOptions({\n\t\t\tonAccept: (): void => {\n\t\t\t\tthis.attemptPostRecoveryRegistrationRoutine();\n\t\t\t},\n\t\t\tonReject: (error: unknown): void => {\n\t\t\t\tconsole.error(`[${error}] Failed to do options in attemptPostRecoveryRoutine()`);\n\t\t\t},\n\t\t});\n\t}\n\n\tasync sendKeepAliveAndWaitForResponse(withDebounce = false): Promise<boolean> {\n\t\tconst promise = new Promise<boolean>((resolve, reject) => {\n\t\t\tlet keepAliveAccepted = false;\n\t\t\tlet responseWaitTime = this.optionsKeepaliveInterval / 2;\n\t\t\tif (withDebounce) {\n\t\t\t\tresponseWaitTime += this.optionsKeepAliveDebounceTimeInSec;\n\t\t\t}\n\n\t\t\tthis.sendOptions({\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tkeepAliveAccepted = true;\n\t\t\t\t},\n\t\t\t\tonReject: (_error: unknown): void => {\n\t\t\t\t\tconsole.error('Failed to do options.');\n\t\t\t\t},\n\t\t\t});\n\t\t\tsetTimeout(async () => {\n\t\t\t\tif (!keepAliveAccepted) {\n\t\t\t\t\treject(false);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.attemptRegistration) {\n\t\t\t\t\t\tthis.attemptPostRecoveryRoutine();\n\t\t\t\t\t\tthis.attemptRegistration = false;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(true);\n\t\t\t\t}\n\t\t\t}, responseWaitTime * 1000);\n\t\t});\n\t\treturn promise;\n\t}\n\n\tasync startOptionsPingForUnstableNetworks(): Promise<void> {\n\t\tsetTimeout(async () => {\n\t\t\tif (!this.userAgent || this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState !== 'SERVER_RECONNECTING') {\n\t\t\t\tlet isConnected = false;\n\t\t\t\ttry {\n\t\t\t\t\tawait this.sendKeepAliveAndWaitForResponse();\n\t\t\t\t\tisConnected = true;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(`[${e}] Failed to do options ping.`);\n\t\t\t\t} finally {\n\t\t\t\t\t// Send event only if it's a \"change\" on the status (avoid unnecessary event flooding)\n\t\t\t\t\t!isConnected && this.networkEmitter.emit('disconnected');\n\t\t\t\t\tisConnected && this.networkEmitter.emit('connected');\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Each seconds check if the network can reach asterisk. If not, try to reconnect\n\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t}, this.optionsKeepaliveInterval * 1000);\n\t}\n\n\tasync attemptPostRecoveryRegistrationRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tconst promise = new Promise<void>((_resolve, _reject) => {\n\t\t\tthis.registerer?.unregister({\n\t\t\t\tall: true,\n\t\t\t\trequestDelegate: {\n\t\t\t\t\tonAccept: (): void => {\n\t\t\t\t\t\t_resolve();\n\t\t\t\t\t},\n\t\t\t\t\tonReject: (error): void => {\n\t\t\t\t\t\tconsole.error(`[${error}] While unregistering after recovery`);\n\t\t\t\t\t\tthis.emit('unregistrationerror', error);\n\t\t\t\t\t\t_reject('Error in Unregistering');\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t\ttry {\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\tconsole.error(`[${error}] While waiting for unregister promise`);\n\t\t}\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonReject: (error): void => {\n\t\t\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\t\t\tthis.emit('registrationerror', error);\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\tasync changeAudioInputDevice(constraints: MediaStreamConstraints): Promise<boolean> {\n\t\tif (!this.session) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No session. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst newStream = await LocalStream.requestNewStream(constraints, this.session);\n\t\tif (!newStream) {\n\t\t\tconsole.warn('changeAudioInputDevice() : Unable to get local stream. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No peer connection. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tLocalStream.replaceTrack(peerConnection, newStream, 'audio');\n\t\treturn true;\n\t}\n\n\t// Commenting this as Video Configuration is not part of the scope for now\n\t// async changeVideoInputDevice(selectedVideoDevices: IDevice): Promise<boolean> {\n\t// \tif (!this.session) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No session. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tif (!this.config.enableVideo || this.deviceManager.hasVideoInputDevice()) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable change video device. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tthis.deviceManager.changeVideoInputDevice(selectedVideoDevices);\n\t// \tconst newStream = await LocalStream.requestNewStream(this.deviceManager.getConstraints('video'), this.session);\n\t// \tif (!newStream) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable to get local stream. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t// \tif (!peerConnection) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No peer connection. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tLocalStream.replaceTrack(peerConnection, newStream, 'video');\n\t// \treturn true;\n\t// }\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\tasync makeCallURI(_callee: string, _mediaRenderer?: IMediaStreamRenderer): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\tasync makeCall(_calleeNumber: string): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n}\n"]}}},"code":"var _regeneratorRuntime;\nmodule.link(\"@babel/runtime/regenerator\", {\n  default: function (v) {\n    _regeneratorRuntime = v;\n  }\n}, 0);\nvar _createClass;\nmodule.link(\"@babel/runtime/helpers/createClass\", {\n  default: function (v) {\n    _createClass = v;\n  }\n}, 1);\nvar _inheritsLoose;\nmodule.link(\"@babel/runtime/helpers/inheritsLoose\", {\n  default: function (v) {\n    _inheritsLoose = v;\n  }\n}, 2);\nmodule.export({\n  VoIPUser: function () {\n    return VoIPUser;\n  }\n});\nvar Operation, UserState, WorkflowTypes;\nmodule.link(\"@rocket.chat/core-typings\", {\n  Operation: function (v) {\n    Operation = v;\n  },\n  UserState: function (v) {\n    UserState = v;\n  },\n  WorkflowTypes: function (v) {\n    WorkflowTypes = v;\n  }\n}, 0);\nvar Emitter;\nmodule.link(\"@rocket.chat/emitter\", {\n  Emitter: function (v) {\n    Emitter = v;\n  }\n}, 1);\nvar UserAgent, Invitation, SessionState, Registerer, RequestPendingError, Inviter;\nmodule.link(\"sip.js\", {\n  UserAgent: function (v) {\n    UserAgent = v;\n  },\n  Invitation: function (v) {\n    Invitation = v;\n  },\n  SessionState: function (v) {\n    SessionState = v;\n  },\n  Registerer: function (v) {\n    Registerer = v;\n  },\n  RequestPendingError: function (v) {\n    RequestPendingError = v;\n  },\n  Inviter: function (v) {\n    Inviter = v;\n  }\n}, 2);\nvar URI;\nmodule.link(\"sip.js/lib/core\", {\n  URI: function (v) {\n    URI = v;\n  }\n}, 3);\nvar SessionDescriptionHandler;\nmodule.link(\"sip.js/lib/platform/web\", {\n  SessionDescriptionHandler: function (v) {\n    SessionDescriptionHandler = v;\n  }\n}, 4);\nvar toggleMediaStreamTracks;\nmodule.link(\"./Helper\", {\n  toggleMediaStreamTracks: function (v) {\n    toggleMediaStreamTracks = v;\n  }\n}, 5);\nvar LocalStream;\nmodule.link(\"./LocalStream\", {\n  \"default\": function (v) {\n    LocalStream = v;\n  }\n}, 6);\nvar QueueAggregator;\nmodule.link(\"./QueueAggregator\", {\n  QueueAggregator: function (v) {\n    QueueAggregator = v;\n  }\n}, 7);\nvar RemoteStream;\nmodule.link(\"./RemoteStream\", {\n  \"default\": function (v) {\n    RemoteStream = v;\n  }\n}, 8);\nvar VoIPUser = /*#__PURE__*/function (_Emitter) {\n  function VoIPUser(config, mediaRenderer) {\n    var _this;\n    _this = _Emitter.call(this) || this;\n    _this.config = void 0;\n    _this.state = {\n      isReady: false,\n      enableVideo: false\n    };\n    _this.remoteStream = void 0;\n    _this.userAgentOptions = {};\n    _this.userAgent = void 0;\n    _this.registerer = void 0;\n    _this.mediaStreamRendered = void 0;\n    _this._connectionState = 'INITIAL';\n    _this._held = false;\n    _this.mode = void 0;\n    _this.queueInfo = void 0;\n    _this.connectionRetryCount = void 0;\n    _this.stop = void 0;\n    _this.networkEmitter = void 0;\n    _this.offlineNetworkHandler = void 0;\n    _this.onlineNetworkHandler = void 0;\n    _this.optionsKeepaliveInterval = 5;\n    _this.optionsKeepAliveDebounceTimeInSec = 5;\n    _this.attemptRegistration = false;\n    _this.session = void 0;\n    _this._callState = 'INITIAL';\n    _this._callerInfo = void 0;\n    _this._userState = UserState.IDLE;\n    _this._opInProgress = Operation.OP_NONE;\n    _this.config = config;\n    _this.mediaStreamRendered = mediaRenderer;\n    _this.networkEmitter = new Emitter();\n    _this.connectionRetryCount = _this.config.connectionRetryCount;\n    _this.stop = false;\n    _this.onlineNetworkHandler = _this.onNetworkRestored.bind(_this);\n    _this.offlineNetworkHandler = _this.onNetworkLost.bind(_this);\n    return _this;\n  }\n  /**\n   * Configures and initializes sip.js UserAgent\n   * call gets established.\n   * @remarks\n   * This class configures transport properties such as websocket url, passed down in config,\n   * sets up ICE servers,\n   * SIP UserAgent options such as userName, Password, URI.\n   * Once initialized, it starts the userAgent.\n   */\n  _inheritsLoose(VoIPUser, _Emitter);\n  var _proto = VoIPUser.prototype;\n  _proto.init = function () {\n    function init() {\n      var _this2 = this;\n      var sipUri, transportOptions, sdpFactoryOptions;\n      return _regeneratorRuntime.async(function () {\n        function init$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              sipUri = \"sip:\" + this.config.authUserName + \"@\" + this.config.sipRegistrarHostnameOrIP;\n              transportOptions = {\n                server: this.config.webSocketURI,\n                connectionTimeout: 100,\n                // Replace this with config\n                keepAliveInterval: 20\n                // traceSip: true,\n              };\n              sdpFactoryOptions = {\n                iceGatheringTimeout: 10,\n                peerConnectionConfiguration: {\n                  iceServers: this.config.iceServers\n                }\n              };\n              this.userAgentOptions = {\n                delegate: {\n                  onInvite: function () {\n                    function _callee2(invitation) {\n                      return _regeneratorRuntime.async(function () {\n                        function _callee2$(_context) {\n                          while (1) switch (_context.prev = _context.next) {\n                            case 0:\n                              _context.next = 2;\n                              return _regeneratorRuntime.awrap(_this2.handleIncomingCall(invitation));\n                            case 2:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                        return _callee2$;\n                      }(), null, null, null, Promise);\n                    }\n                    return _callee2;\n                  }()\n                },\n                authorizationPassword: this.config.authPassword,\n                authorizationUsername: this.config.authUserName,\n                uri: UserAgent.makeURI(sipUri),\n                transportOptions: transportOptions,\n                sessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n                logConfiguration: false,\n                logLevel: 'error'\n              };\n              this.userAgent = new UserAgent(this.userAgentOptions);\n              this.userAgent.transport.isConnected();\n              this._opInProgress = Operation.OP_CONNECT;\n              _context2.prev = 7;\n              this.registerer = new Registerer(this.userAgent);\n              this.userAgent.transport.onConnect = this.onConnected.bind(this);\n              this.userAgent.transport.onDisconnect = this.onDisconnected.bind(this);\n              window.addEventListener('online', this.onlineNetworkHandler);\n              window.addEventListener('offline', this.offlineNetworkHandler);\n              _context2.next = 15;\n              return _regeneratorRuntime.awrap(this.userAgent.start());\n            case 15:\n              if (this.config.enableKeepAliveUsingOptionsForUnstableNetworks) {\n                this.startOptionsPingForUnstableNetworks();\n              }\n              _context2.next = 22;\n              break;\n            case 18:\n              _context2.prev = 18;\n              _context2.t0 = _context2[\"catch\"](7);\n              this._connectionState = 'ERROR';\n              throw _context2.t0;\n            case 22:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n        return init$;\n      }(), null, this, [[7, 18]], Promise);\n    }\n    return init;\n  }();\n  _proto.onConnected = function () {\n    function onConnected() {\n      return _regeneratorRuntime.async(function () {\n        function onConnected$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              this._connectionState = 'SERVER_CONNECTED';\n              this.state.isReady = true;\n              this.sendOptions();\n              this.networkEmitter.emit('connected');\n              /**\n               * Re-registration post network recovery should be attempted\n               * if it was previously registered or incall/onhold\n               */\n              if (this.registerer && this.callState !== 'INITIAL') {\n                this.attemptRegistration = true;\n              }\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n        return onConnected$;\n      }(), null, this, null, Promise);\n    }\n    return onConnected;\n  }();\n  _proto.onDisconnected = function () {\n    function onDisconnected(error) {\n      this._connectionState = 'SERVER_DISCONNECTED';\n      this._opInProgress = Operation.OP_NONE;\n      this.networkEmitter.emit('disconnected');\n      if (error) {\n        this.networkEmitter.emit('connectionerror', error);\n        this.state.isReady = false;\n        /**\n         * Signalling socket reconnection should be attempted assuming\n         * that the disconnect happened from the remote side or due to sleep\n         * In case of remote side disconnection, if config.connectionRetryCount is -1,\n         * attemptReconnection attempts continuously. Else stops after |config.connectionRetryCount|\n         *\n         */\n        // this.attemptReconnection();\n        this.attemptReconnection(0, false);\n      }\n    }\n    return onDisconnected;\n  }();\n  _proto.onNetworkRestored = function () {\n    function onNetworkRestored() {\n      this.networkEmitter.emit('localnetworkonline');\n      if (this._connectionState === 'WAITING_FOR_NETWORK') {\n        /**\n         * Signalling socket reconnection should be attempted when online event handler\n         * gets notified.\n         * Important thing to note is that the second parameter |checkRegistration| = true passed here\n         * because after the network recovery and after reconnecting to the server,\n         * the transport layer of SIPUA does not call onConnected. So by passing |checkRegistration = true |\n         * the code will check if the endpoint was previously registered before the disconnection.\n         * If such is the case, it will first unregister and then re-register.\n         * */\n        this.attemptReconnection();\n        if (this.registerer && this.callState !== 'INITIAL') {\n          this.attemptRegistration = true;\n        }\n      }\n    }\n    return onNetworkRestored;\n  }();\n  _proto.onNetworkLost = function () {\n    function onNetworkLost() {\n      this.networkEmitter.emit('localnetworkoffline');\n      this._connectionState = 'WAITING_FOR_NETWORK';\n    }\n    return onNetworkLost;\n  }();\n  /* Media Stream functions end */\n  /* OutgoingRequestDelegate methods begin */\n  _proto.onRegistrationRequestAccept = function () {\n    function onRegistrationRequestAccept() {\n      if (this._opInProgress === Operation.OP_REGISTER) {\n        this._callState = 'REGISTERED';\n        this.emit('registered');\n        this.emit('stateChanged');\n      }\n      if (this._opInProgress === Operation.OP_UNREGISTER) {\n        this._callState = 'UNREGISTERED';\n        this.emit('unregistered');\n        this.emit('stateChanged');\n      }\n    }\n    return onRegistrationRequestAccept;\n  }();\n  _proto.onRegistrationRequestReject = function () {\n    function onRegistrationRequestReject(error) {\n      if (this._opInProgress === Operation.OP_REGISTER) {\n        this.emit('registrationerror', error);\n      }\n      if (this._opInProgress === Operation.OP_UNREGISTER) {\n        this.emit('unregistrationerror', error);\n      }\n    }\n    return onRegistrationRequestReject;\n  }() /* OutgoingRequestDelegate methods end */;\n  _proto.handleIncomingCall = function () {\n    function handleIncomingCall(invitation) {\n      var callerInfo;\n      return _regeneratorRuntime.async(function () {\n        function handleIncomingCall$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(this.callState === 'REGISTERED')) {\n                _context4.next = 11;\n                break;\n              }\n              this._opInProgress = Operation.OP_PROCESS_INVITE;\n              this._callState = 'OFFER_RECEIVED';\n              this._userState = UserState.UAS;\n              this.session = invitation;\n              this.setupSessionEventHandlers(invitation);\n              callerInfo = {\n                callerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n                callerName: invitation.remoteIdentity.displayName,\n                host: invitation.remoteIdentity.uri.host\n              };\n              this._callerInfo = callerInfo;\n              this.emit('incomingcall', callerInfo);\n              this.emit('stateChanged');\n              return _context4.abrupt(\"return\");\n            case 11:\n              _context4.next = 13;\n              return _regeneratorRuntime.awrap(invitation.reject());\n            case 13:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n        return handleIncomingCall$;\n      }(), null, this, null, Promise);\n    }\n    return handleIncomingCall;\n  }()\n  /**\n   * Sets up an listener handler for handling session's state change\n   * @remarks\n   * Called for setting up various state listeners. These listeners will\n   * decide the next action to be taken when the session state changes.\n   * e.g when session.state changes from |Establishing| to |Established|\n   * one must set up local and remote media rendering.\n   *\n   * This class handles such session state changes and takes necessary actions.\n   */\n  ;\n  _proto.setupSessionEventHandlers = function () {\n    function setupSessionEventHandlers(session) {\n      var _this$session,\n        _this3 = this;\n      (_this$session = this.session) === null || _this$session === void 0 ? void 0 : _this$session.stateChange.addListener(function (state) {\n        var _this3$remoteStream;\n        if (_this3.session !== session) {\n          return; // if our session has changed, just return\n        }\n        switch (state) {\n          case SessionState.Initial:\n            break;\n          case SessionState.Establishing:\n            _this3.emit('ringing', {\n              userState: _this3._userState,\n              callInfo: _this3._callerInfo\n            });\n            break;\n          case SessionState.Established:\n            if (_this3._userState === UserState.UAC) {\n              /**\n               * We need to decide about user-state ANSWER-RECEIVED for outbound.\n               * This state is there for the symmetry of ANSWER-SENT.\n               * ANSWER-SENT occurs when there is incoming invite. So then the UA\n               * accepts a call, it sends the answer and state becomes ANSWER-SENT.\n               * The call gets established only when the remote party sends ACK.\n               *\n               * But in case of UAC where the invite is sent out, there is no intermediate\n               * state where the UA can be in ANSWER-RECEIVED. As soon this UA receives the answer,\n               * it sends ack and changes the SessionState to established.\n               *\n               * So we do not have an actual state transitions from ANSWER-RECEIVED to IN-CALL.\n               *\n               * Nevertheless, this state is just added to maintain the symmetry. This can be safely removed.\n               *\n               * */\n              _this3._callState = 'ANSWER_RECEIVED';\n            }\n            _this3._opInProgress = Operation.OP_NONE;\n            _this3.setupRemoteMedia();\n            _this3._callState = 'IN_CALL';\n            _this3.emit('callestablished', {\n              userState: _this3._userState,\n              callInfo: _this3._callerInfo\n            });\n            _this3.emit('stateChanged');\n            break;\n          case SessionState.Terminating:\n          // fall through\n          case SessionState.Terminated:\n            _this3.session = undefined;\n            _this3._callState = 'REGISTERED';\n            _this3._opInProgress = Operation.OP_NONE;\n            _this3._userState = UserState.IDLE;\n            _this3.emit('callterminated');\n            (_this3$remoteStream = _this3.remoteStream) === null || _this3$remoteStream === void 0 ? void 0 : _this3$remoteStream.clear();\n            _this3.emit('stateChanged');\n            break;\n          default:\n            throw new Error('Unknown session state.');\n        }\n      });\n    }\n    return setupSessionEventHandlers;\n  }();\n  _proto.onTrackAdded = function () {\n    function onTrackAdded(_event) {\n      console.log('onTrackAdded');\n    }\n    return onTrackAdded;\n  }();\n  _proto.onTrackRemoved = function () {\n    function onTrackRemoved(_event) {\n      console.log('onTrackRemoved');\n    }\n    return onTrackRemoved;\n  }()\n  /**\n   * Carries out necessary steps for rendering remote media whe\n   * call gets established.\n   * @remarks\n   * Sets up Stream class and plays the stream on given Media element/\n   * Also sets up various event handlers.\n   */\n  ;\n  _proto.setupRemoteMedia = function () {\n    function setupRemoteMedia() {\n      var _this$session2, _this$mediaStreamRend;\n      if (!this.session) {\n        throw new Error('Session does not exist.');\n      }\n      var sdh = (_this$session2 = this.session) === null || _this$session2 === void 0 ? void 0 : _this$session2.sessionDescriptionHandler;\n      if (!sdh) {\n        return undefined;\n      }\n      if (!(sdh instanceof SessionDescriptionHandler)) {\n        throw new Error('Session description handler not instance of web SessionDescriptionHandler');\n      }\n      var remoteStream = sdh.remoteMediaStream;\n      if (!remoteStream) {\n        throw new Error('Remote media stream is undefined.');\n      }\n      this.remoteStream = new RemoteStream(remoteStream);\n      var mediaElement = (_this$mediaStreamRend = this.mediaStreamRendered) === null || _this$mediaStreamRend === void 0 ? void 0 : _this$mediaStreamRend.remoteMediaElement;\n      if (mediaElement) {\n        this.remoteStream.init(mediaElement);\n        this.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n        this.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n        this.remoteStream.play();\n      }\n    }\n    return setupRemoteMedia;\n  }()\n  /**\n   * Handles call mute-unmute\n   */\n  ;\n  _proto.handleMuteUnmute = function () {\n    function handleMuteUnmute(muteState) {\n      var _this$session3,\n        _this4 = this,\n        _this$session4;\n      var session, sessionDescriptionHandler, options, peerConnection;\n      return _regeneratorRuntime.async(function () {\n        function handleMuteUnmute$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              session = this.session;\n              if (!(this._held === muteState)) {\n                _context5.next = 3;\n                break;\n              }\n              return _context5.abrupt(\"return\", Promise.resolve());\n            case 3:\n              if (session) {\n                _context5.next = 5;\n                break;\n              }\n              throw new Error('Session not found');\n            case 5:\n              sessionDescriptionHandler = (_this$session3 = this.session) === null || _this$session3 === void 0 ? void 0 : _this$session3.sessionDescriptionHandler;\n              if (sessionDescriptionHandler instanceof SessionDescriptionHandler) {\n                _context5.next = 8;\n                break;\n              }\n              throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n            case 8:\n              options = {\n                requestDelegate: {\n                  onAccept: function () {\n                    _this4._held = muteState;\n                    toggleMediaStreamTracks(!_this4._held, session, 'receiver');\n                    toggleMediaStreamTracks(!_this4._held, session, 'sender');\n                  },\n                  onReject: function () {\n                    _this4.emit('muteerror');\n                  }\n                }\n              };\n              peerConnection = sessionDescriptionHandler.peerConnection;\n              if (peerConnection) {\n                _context5.next = 12;\n                break;\n              }\n              throw new Error('Peer connection closed.');\n            case 12:\n              return _context5.abrupt(\"return\", (_this$session4 = this.session) === null || _this$session4 === void 0 ? void 0 : _this$session4.invite(options).then(function () {\n                toggleMediaStreamTracks(!_this4._held, session, 'receiver');\n                toggleMediaStreamTracks(!_this4._held, session, 'sender');\n              }).catch(function (error) {\n                if (error instanceof RequestPendingError) {\n                  var _this4$session;\n                  console.error(\"[\" + ((_this4$session = _this4.session) === null || _this4$session === void 0 ? void 0 : _this4$session.id) + \"] A mute request is already in progress.\");\n                }\n                _this4.emit('muteerror');\n                throw error;\n              }));\n            case 13:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n        return handleMuteUnmute$;\n      }(), null, this, null, Promise);\n    }\n    return handleMuteUnmute;\n  }()\n  /**\n   * Handles call hold-unhold\n   */\n  ;\n  _proto.handleHoldUnhold = function () {\n    function handleHoldUnhold(holdState) {\n      var _this$session5,\n        _this5 = this,\n        _this$session6;\n      var session, sessionDescriptionHandler, options, sessionDescriptionHandlerOptions, peerConnection;\n      return _regeneratorRuntime.async(function () {\n        function handleHoldUnhold$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              session = this.session;\n              if (!(this._held === holdState)) {\n                _context6.next = 3;\n                break;\n              }\n              return _context6.abrupt(\"return\", Promise.resolve());\n            case 3:\n              if (session) {\n                _context6.next = 5;\n                break;\n              }\n              throw new Error('Session not found');\n            case 5:\n              sessionDescriptionHandler = (_this$session5 = this.session) === null || _this$session5 === void 0 ? void 0 : _this$session5.sessionDescriptionHandler;\n              if (sessionDescriptionHandler instanceof SessionDescriptionHandler) {\n                _context6.next = 8;\n                break;\n              }\n              throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n            case 8:\n              options = {\n                requestDelegate: {\n                  onAccept: function () {\n                    _this5._held = holdState;\n                    _this5._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n                    toggleMediaStreamTracks(!_this5._held, session, 'receiver');\n                    toggleMediaStreamTracks(!_this5._held, session, 'sender');\n                    _this5._callState === 'ON_HOLD' ? _this5.emit('hold') : _this5.emit('unhold');\n                    _this5.emit('stateChanged');\n                  },\n                  onReject: function () {\n                    toggleMediaStreamTracks(!_this5._held, session, 'receiver');\n                    toggleMediaStreamTracks(!_this5._held, session, 'sender');\n                    _this5.emit('holderror');\n                  }\n                }\n              }; // Session properties used to pass options to the SessionDescriptionHandler:\n              //\n              // 1) Session.sessionDescriptionHandlerOptions\n              //    SDH options for the initial INVITE transaction.\n              //    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n              //    - May be set directly at anytime.\n              //    - May optionally be set via constructor option.\n              //    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n              //\n              // 2) Session.sessionDescriptionHandlerOptionsReInvite\n              //    SDH options for re-INVITE transactions.\n              //    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n              //    - May be set directly at anytime.\n              //    - May optionally be set via constructor option.\n              //    - May optionally be set via options passed to Session.invite().\n              sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite;\n              sessionDescriptionHandlerOptions.hold = holdState;\n              session.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n              peerConnection = sessionDescriptionHandler.peerConnection;\n              if (peerConnection) {\n                _context6.next = 15;\n                break;\n              }\n              throw new Error('Peer connection closed.');\n            case 15:\n              return _context6.abrupt(\"return\", (_this$session6 = this.session) === null || _this$session6 === void 0 ? void 0 : _this$session6.invite(options).then(function () {\n                toggleMediaStreamTracks(!_this5._held, session, 'receiver');\n                toggleMediaStreamTracks(!_this5._held, session, 'sender');\n              }).catch(function (error) {\n                if (error instanceof RequestPendingError) {\n                  var _this5$session;\n                  console.error(\"[\" + ((_this5$session = _this5.session) === null || _this5$session === void 0 ? void 0 : _this5$session.id) + \"] A hold request is already in progress.\");\n                }\n                _this5.emit('holderror');\n                throw error;\n              }));\n            case 16:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n        return handleHoldUnhold$;\n      }(), null, this, null, Promise);\n    }\n    return handleHoldUnhold;\n  }();\n  VoIPUser.create = function () {\n    function create(config, mediaRenderer) {\n      var voip;\n      return _regeneratorRuntime.async(function () {\n        function create$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              voip = new VoIPUser(config, mediaRenderer);\n              _context7.next = 3;\n              return _regeneratorRuntime.awrap(voip.init());\n            case 3:\n              return _context7.abrupt(\"return\", voip);\n            case 4:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n        return create$;\n      }(), null, null, null, Promise);\n    }\n    return create;\n  }()\n  /**\n   * Sends SIP OPTIONS message to asterisk\n   *\n   * There is an interesting problem that happens with Asterisk.\n   * After websocket connection succeeds and if there is no SIP\n   * message goes in 30 seconds, asterisk disconnects the socket.\n   *\n   * If any SIP message goes before 30 seconds, asterisk holds the connection.\n   * This problem could be solved in multiple ways. One is that\n   * whenever disconnect happens make sure that the socket is connected back using\n   * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n   * every 30 seconds till we send register message.\n   *\n   * Another approach is to send SIP OPTIONS just to tell server that\n   * there is a UA using this socket. This is implemented below\n   */\n  ;\n  _proto.sendOptions = function () {\n    function sendOptions(outgoingRequestDelegate) {\n      var _this$userAgent;\n      var uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n      var outgoingMessage = (_this$userAgent = this.userAgent) === null || _this$userAgent === void 0 ? void 0 : _this$userAgent.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n      if (outgoingMessage) {\n        var _this$userAgent2;\n        (_this$userAgent2 = this.userAgent) === null || _this$userAgent2 === void 0 ? void 0 : _this$userAgent2.userAgentCore.request(outgoingMessage, outgoingRequestDelegate);\n      }\n    }\n    return sendOptions;\n  }()\n  /**\n   * Public method called from outside to register the SIP UA with call server.\n   * @remarks\n   */\n  ;\n  _proto.register = function () {\n    function register() {\n      var _this$registerer;\n      this._opInProgress = Operation.OP_REGISTER;\n      (_this$registerer = this.registerer) === null || _this$registerer === void 0 ? void 0 : _this$registerer.register({\n        requestDelegate: {\n          onAccept: this.onRegistrationRequestAccept.bind(this),\n          onReject: this.onRegistrationRequestReject.bind(this)\n        }\n      });\n    }\n    return register;\n  }()\n  /**\n   * Public method called from outside to unregister the SIP UA.\n   * @remarks\n   */\n  ;\n  _proto.unregister = function () {\n    function unregister() {\n      var _this$registerer2;\n      this._opInProgress = Operation.OP_UNREGISTER;\n      (_this$registerer2 = this.registerer) === null || _this$registerer2 === void 0 ? void 0 : _this$registerer2.unregister({\n        all: true,\n        requestDelegate: {\n          onAccept: this.onRegistrationRequestAccept.bind(this),\n          onReject: this.onRegistrationRequestReject.bind(this)\n        }\n      });\n    }\n    return unregister;\n  }()\n  /**\n   * Public method called from outside to accept incoming call.\n   * @remarks\n   */\n  ;\n  _proto.acceptCall = function () {\n    function acceptCall(mediaRenderer) {\n      var videoInvite, body, invitationAcceptOptions;\n      return _regeneratorRuntime.async(function () {\n        function acceptCall$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (mediaRenderer) {\n                this.mediaStreamRendered = mediaRenderer;\n              }\n              // Call state must be in offer_received.\n              if (!(this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE)) {\n                _context8.next = 10;\n                break;\n              }\n              this._callState = 'ANSWER_SENT';\n              // Something is wrong, this session is not an instance of INVITE\n              if (this.session instanceof Invitation) {\n                _context8.next = 5;\n                break;\n              }\n              throw new Error('Session not instance of Invitation.');\n            case 5:\n              /**\n               * It is important to decide when to add video option to the outgoing offer.\n               * This would matter when the reinvite goes out (In case of hold/unhold)\n               * This was added because there were failures in hold-unhold.\n               * The scenario was that if this client does hold-unhold first, and remote client does\n               * later, remote client goes in inconsistent state and hold-unhold does not work\n               * Where as if the remote client does hold-unhold first, this client can do it any number\n               * of times.\n               *\n               * Logic below works as follows\n               * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n               * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n               * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n               * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n               *\n               */\n              videoInvite = !!this.config.enableVideo;\n              body = this.session.body;\n              if (body && body.indexOf('m=video') === -1) {\n                videoInvite = false;\n              }\n              invitationAcceptOptions = {\n                sessionDescriptionHandlerOptions: {\n                  constraints: {\n                    audio: true,\n                    video: !!this.config.enableVideo && videoInvite\n                  }\n                }\n              };\n              return _context8.abrupt(\"return\", this.session.accept(invitationAcceptOptions));\n            case 10:\n              throw new Error('Something went wrong');\n            case 11:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n        return acceptCall$;\n      }(), null, this, null, Promise);\n    }\n    return acceptCall;\n  }() /* Helper routines for checking call actions BEGIN */;\n  _proto.canRejectCall = function () {\n    function canRejectCall() {\n      return ['OFFER_RECEIVED', 'OFFER_SENT'].includes(this._callState);\n    }\n    return canRejectCall;\n  }();\n  _proto.canEndOrHoldCall = function () {\n    function canEndOrHoldCall() {\n      return ['ANSWER_SENT', 'ANSWER_RECEIVED', 'IN_CALL', 'ON_HOLD', 'OFFER_SENT'].includes(this._callState);\n    }\n    return canEndOrHoldCall;\n  }()\n  /* Helper routines for checking call actions END */\n  /**\n   * Public method called from outside to reject a call.\n   * @remarks\n   */\n  ;\n  _proto.rejectCall = function () {\n    function rejectCall() {\n      if (!this.session) {\n        throw new Error('Session does not exist.');\n      }\n      if (!this.canRejectCall()) {\n        throw new Error(\"Incorrect call State = \" + this.callState);\n      }\n      if (!(this.session instanceof Invitation)) {\n        throw new Error('Session not instance of Invitation.');\n      }\n      return this.session.reject();\n    }\n    return rejectCall;\n  }()\n  /**\n   * Public method called from outside to end a call.\n   * @remarks\n   */\n  ;\n  _proto.endCall = function () {\n    function endCall() {\n      return _regeneratorRuntime.async(function () {\n        function endCall$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              if (this.session) {\n                _context9.next = 2;\n                break;\n              }\n              throw new Error('Session does not exist.');\n            case 2:\n              if (this.canEndOrHoldCall()) {\n                _context9.next = 4;\n                break;\n              }\n              throw new Error(\"Incorrect call State = \" + this.callState);\n            case 4:\n              // When call ends, force state to be revisited\n              this.emit('stateChanged');\n              _context9.t0 = this.session.state;\n              _context9.next = _context9.t0 === SessionState.Initial ? 8 : _context9.t0 === SessionState.Establishing ? 11 : _context9.t0 === SessionState.Established ? 16 : _context9.t0 === SessionState.Terminating ? 17 : _context9.t0 === SessionState.Terminated ? 18 : 19;\n              break;\n            case 8:\n              if (!(this.session instanceof Invitation)) {\n                _context9.next = 10;\n                break;\n              }\n              return _context9.abrupt(\"return\", this.session.reject());\n            case 10:\n              throw new Error('Session not instance of Invitation.');\n            case 11:\n              if (!(this.session instanceof Invitation)) {\n                _context9.next = 13;\n                break;\n              }\n              return _context9.abrupt(\"return\", this.session.reject());\n            case 13:\n              if (!(this.session instanceof Inviter)) {\n                _context9.next = 15;\n                break;\n              }\n              return _context9.abrupt(\"return\", this.session.cancel());\n            case 15:\n              throw new Error('Session not instance of Invitation.');\n            case 16:\n              return _context9.abrupt(\"return\", this.session.bye());\n            case 17:\n              return _context9.abrupt(\"break\", 20);\n            case 18:\n              return _context9.abrupt(\"break\", 20);\n            case 19:\n              throw new Error('Unknown state');\n            case 20:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n        return endCall$;\n      }(), null, this, null, Promise);\n    }\n    return endCall;\n  }()\n  /**\n   * Public method called from outside to mute the call.\n   * @remarks\n   */\n  ;\n  _proto.muteCall = function () {\n    function muteCall(muteState) {\n      return _regeneratorRuntime.async(function () {\n        function muteCall$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              if (this.session) {\n                _context10.next = 2;\n                break;\n              }\n              throw new Error('Session does not exist.');\n            case 2:\n              if (!(this._callState !== 'IN_CALL')) {\n                _context10.next = 4;\n                break;\n              }\n              throw new Error(\"Incorrect call State = \" + this.callState);\n            case 4:\n              this.handleMuteUnmute(muteState);\n            case 5:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n        return muteCall$;\n      }(), null, this, null, Promise);\n    }\n    return muteCall;\n  }()\n  /**\n   * Public method called from outside to hold the call.\n   * @remarks\n   */\n  ;\n  _proto.holdCall = function () {\n    function holdCall(holdState) {\n      return _regeneratorRuntime.async(function () {\n        function holdCall$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              if (this.session) {\n                _context11.next = 2;\n                break;\n              }\n              throw new Error('Session does not exist.');\n            case 2:\n              if (this.canEndOrHoldCall()) {\n                _context11.next = 4;\n                break;\n              }\n              throw new Error(\"Incorrect call State = \" + this.callState);\n            case 4:\n              this.handleHoldUnhold(holdState);\n            case 5:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n        return holdCall$;\n      }(), null, this, null, Promise);\n    }\n    return holdCall;\n  }() /* CallEventDelegate implementation end */;\n  _proto.isReady = function () {\n    function isReady() {\n      return this.state.isReady;\n    }\n    return isReady;\n  }()\n  /**\n   * This function allows to change the media renderer media elements.\n   */\n  ;\n  _proto.switchMediaRenderer = function () {\n    function switchMediaRenderer(mediaRenderer) {\n      if (this.remoteStream) {\n        this.mediaStreamRendered = mediaRenderer;\n        this.remoteStream.init(mediaRenderer.remoteMediaElement);\n        this.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n        this.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n        this.remoteStream.play();\n      }\n    }\n    return switchMediaRenderer;\n  }();\n  _proto.setWorkflowMode = function () {\n    function setWorkflowMode(mode) {\n      this.mode = mode;\n      if (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n        this.queueInfo = new QueueAggregator();\n      }\n    }\n    return setWorkflowMode;\n  }();\n  _proto.setMembershipSubscription = function () {\n    function setMembershipSubscription(subscription) {\n      var _this$queueInfo;\n      if (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n        return;\n      }\n      (_this$queueInfo = this.queueInfo) === null || _this$queueInfo === void 0 ? void 0 : _this$queueInfo.setMembership(subscription);\n    }\n    return setMembershipSubscription;\n  }();\n  _proto.getAggregator = function () {\n    function getAggregator() {\n      return this.queueInfo;\n    }\n    return getAggregator;\n  }();\n  _proto.getRegistrarState = function () {\n    function getRegistrarState() {\n      var _this$registerer3;\n      return (_this$registerer3 = this.registerer) === null || _this$registerer3 === void 0 ? void 0 : _this$registerer3.state.toString().toLocaleLowerCase();\n    }\n    return getRegistrarState;\n  }();\n  _proto.clear = function () {\n    function clear() {\n      var _this$userAgent3, _this$registerer4;\n      this._opInProgress = Operation.OP_CLEANUP;\n      /** Socket reconnection is attempted when the socket is disconnected with some error.\n       * While disconnecting, if there is any socket error, there should be no reconnection attempt.\n       * So when userAgent.stop() is called which closes the sockets, it should be made sure that\n       * if the socket is disconnected with error, connection attempts are not started or\n       * if there are any previously ongoing attempts, they should be terminated.\n       * flag attemptReconnect is used for ensuring this.\n       */\n      this.stop = true;\n      (_this$userAgent3 = this.userAgent) === null || _this$userAgent3 === void 0 ? void 0 : _this$userAgent3.stop();\n      (_this$registerer4 = this.registerer) === null || _this$registerer4 === void 0 ? void 0 : _this$registerer4.dispose();\n      this._connectionState = 'STOP';\n      if (this.userAgent) {\n        this.userAgent.transport.onConnect = undefined;\n        this.userAgent.transport.onDisconnect = undefined;\n        window.removeEventListener('online', this.onlineNetworkHandler);\n        window.removeEventListener('offline', this.offlineNetworkHandler);\n      }\n    }\n    return clear;\n  }();\n  _proto.onNetworkEvent = function () {\n    function onNetworkEvent(event, handler) {\n      this.networkEmitter.on(event, handler);\n    }\n    return onNetworkEvent;\n  }();\n  _proto.offNetworkEvent = function () {\n    function offNetworkEvent(event, handler) {\n      this.networkEmitter.off(event, handler);\n    }\n    return offNetworkEvent;\n  }()\n  /**\n   * Connection is lost in 3 ways\n   * 1. When local network is lost (Router is disconnected, switching networks, devtools->network->offline)\n   * In this case, the SIP.js's transport layer does not detect the disconnection. Hence, it does not\n   * call |onDisconnect|. To detect this kind of disconnection, window event listeners have been added.\n   * These event listeners would be get called when the browser detects that network is offline or online.\n   * When the network is restored, the code tries to reconnect. The useragent.transport \"does not\" generate the\n   * onconnected event in this case as well. so onlineNetworkHandler calls attemptReconnection.\n   * Which calls attemptRegistrationPostRecovery based on correct state. attemptRegistrationPostRecovery first tries to\n   * unregister and then re-register.\n   * Important note : We use the event listeners using bind function object offlineNetworkHandler and onlineNetworkHandler\n   * It is done so because the same event handlers need to be used for removeEventListener, which becomes impossible\n   * if done inline.\n   *\n   * 2. Computer goes to sleep. In this case onDisconnect is triggered. The code tries to reconnect but cant go ahead\n   * as it goes to sleep. On waking up, The attemptReconnection gets executed, connection is completed.\n   * In this case, it generates onConnected event. In this onConnected event it calls attemptRegistrationPostRecovery\n   *\n   * 3. When Asterisk disconnects all the endpoints either because it crashes or restarted,\n   * As soon as the agent successfully connects to asterisk, it should re-register\n   *\n   * Retry count :\n   * connectionRetryCount is the parameter called |Retry Count| in\n   * Administration -> Call Center -> Server configuration -> Retry count.\n   * The retry is implemented with backoff, maxbackoff = 8 seconds.\n   * For continuous retries (In case Asterisk restart happens) Set this parameter to -1.\n   *\n   * Important to note is how attemptRegistrationPostRecovery is called. In case of\n   * the router connection loss or while switching the networks,\n   * there is no disconnect and connect event from the transport layer of the userAgent.\n   * So in this case, when the connection is successful after reconnect, the code should try to re-register by calling\n   * attemptRegistrationPostRecovery.\n   * In case of computer waking from sleep or asterisk getting restored, connect and disconnect events are generated.\n   * In this case, re-registration should be triggered (by calling) only when onConnected gets called and not otherwise.\n   */\n  ;\n  _proto.attemptReconnection = function () {\n    function attemptReconnection() {\n      var _this6 = this;\n      var reconnectionAttempt,\n        checkRegistration,\n        reconnectionAttempts,\n        reconnectionDelay,\n        _args12 = arguments;\n      return _regeneratorRuntime.async(function () {\n        function attemptReconnection$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              reconnectionAttempt = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : 0;\n              checkRegistration = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : false;\n              reconnectionAttempts = this.connectionRetryCount;\n              this._connectionState = 'SERVER_RECONNECTING';\n              if (this.userAgent) {\n                _context12.next = 6;\n                break;\n              }\n              return _context12.abrupt(\"return\");\n            case 6:\n              if (!this.stop) {\n                _context12.next = 8;\n                break;\n              }\n              return _context12.abrupt(\"return\");\n            case 8:\n              if (!(reconnectionAttempts !== -1 && reconnectionAttempt > reconnectionAttempts)) {\n                _context12.next = 11;\n                break;\n              }\n              this._connectionState = 'ERROR';\n              return _context12.abrupt(\"return\");\n            case 11:\n              reconnectionDelay = Math.pow(2, reconnectionAttempt % 4);\n              console.error(\"Attempting to reconnect with backoff due to network loss. Backoff time [\" + reconnectionDelay + \"]\");\n              setTimeout(function () {\n                var _this6$userAgent;\n                if (_this6.stop) {\n                  return;\n                }\n                if (_this6._connectionState === 'SERVER_CONNECTED') {\n                  return;\n                }\n                (_this6$userAgent = _this6.userAgent) === null || _this6$userAgent === void 0 ? void 0 : _this6$userAgent.reconnect().then(function () {\n                  _this6._connectionState = 'SERVER_CONNECTED';\n                }).catch(function () {\n                  _this6.attemptReconnection(++reconnectionAttempt, checkRegistration);\n                });\n              }, reconnectionDelay * 1000);\n            case 14:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n        return attemptReconnection$;\n      }(), null, this, null, Promise);\n    }\n    return attemptReconnection;\n  }();\n  _proto.attemptPostRecoveryRoutine = function () {\n    function attemptPostRecoveryRoutine() {\n      var _this7 = this;\n      return _regeneratorRuntime.async(function () {\n        function attemptPostRecoveryRoutine$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              /**\n               * It might happen that the whole network loss can happen\n               * while there is ongoing call. In that case, we want to maintain\n               * the call.\n               *\n               * So after re-registration, it should remain in the same state.\n               * */\n              this.sendOptions({\n                onAccept: function () {\n                  _this7.attemptPostRecoveryRegistrationRoutine();\n                },\n                onReject: function (error) {\n                  console.error(\"[\" + error + \"] Failed to do options in attemptPostRecoveryRoutine()\");\n                }\n              });\n            case 1:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n        return attemptPostRecoveryRoutine$;\n      }(), null, this, null, Promise);\n    }\n    return attemptPostRecoveryRoutine;\n  }();\n  _proto.sendKeepAliveAndWaitForResponse = function () {\n    function sendKeepAliveAndWaitForResponse() {\n      var _this8 = this;\n      var withDebounce,\n        promise,\n        _args15 = arguments;\n      return _regeneratorRuntime.async(function () {\n        function sendKeepAliveAndWaitForResponse$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              withDebounce = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : false;\n              promise = new Promise(function (resolve, reject) {\n                var keepAliveAccepted = false;\n                var responseWaitTime = _this8.optionsKeepaliveInterval / 2;\n                if (withDebounce) {\n                  responseWaitTime += _this8.optionsKeepAliveDebounceTimeInSec;\n                }\n                _this8.sendOptions({\n                  onAccept: function () {\n                    keepAliveAccepted = true;\n                  },\n                  onReject: function (_error) {\n                    console.error('Failed to do options.');\n                  }\n                });\n                setTimeout(function () {\n                  function _callee3() {\n                    return _regeneratorRuntime.async(function () {\n                      function _callee3$(_context14) {\n                        while (1) switch (_context14.prev = _context14.next) {\n                          case 0:\n                            if (!keepAliveAccepted) {\n                              reject(false);\n                            } else {\n                              if (_this8.attemptRegistration) {\n                                _this8.attemptPostRecoveryRoutine();\n                                _this8.attemptRegistration = false;\n                              }\n                              resolve(true);\n                            }\n                          case 1:\n                          case \"end\":\n                            return _context14.stop();\n                        }\n                      }\n                      return _callee3$;\n                    }(), null, null, null, Promise);\n                  }\n                  return _callee3;\n                }(), responseWaitTime * 1000);\n              });\n              return _context15.abrupt(\"return\", promise);\n            case 3:\n            case \"end\":\n              return _context15.stop();\n          }\n        }\n        return sendKeepAliveAndWaitForResponse$;\n      }(), null, null, null, Promise);\n    }\n    return sendKeepAliveAndWaitForResponse;\n  }();\n  _proto.startOptionsPingForUnstableNetworks = function () {\n    function startOptionsPingForUnstableNetworks() {\n      var _this9 = this;\n      return _regeneratorRuntime.async(function () {\n        function startOptionsPingForUnstableNetworks$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              setTimeout(function () {\n                function _callee4() {\n                  var isConnected;\n                  return _regeneratorRuntime.async(function () {\n                    function _callee4$(_context16) {\n                      while (1) switch (_context16.prev = _context16.next) {\n                        case 0:\n                          if (!(!_this9.userAgent || _this9.stop)) {\n                            _context16.next = 2;\n                            break;\n                          }\n                          return _context16.abrupt(\"return\");\n                        case 2:\n                          if (!(_this9._connectionState !== 'SERVER_RECONNECTING')) {\n                            _context16.next = 17;\n                            break;\n                          }\n                          isConnected = false;\n                          _context16.prev = 4;\n                          _context16.next = 7;\n                          return _regeneratorRuntime.awrap(_this9.sendKeepAliveAndWaitForResponse());\n                        case 7:\n                          isConnected = true;\n                          _context16.next = 13;\n                          break;\n                        case 10:\n                          _context16.prev = 10;\n                          _context16.t0 = _context16[\"catch\"](4);\n                          console.error(\"[\" + _context16.t0 + \"] Failed to do options ping.\");\n                        case 13:\n                          _context16.prev = 13;\n                          // Send event only if it's a \"change\" on the status (avoid unnecessary event flooding)\n                          !isConnected && _this9.networkEmitter.emit('disconnected');\n                          isConnected && _this9.networkEmitter.emit('connected');\n                          return _context16.finish(13);\n                        case 17:\n                          // Each seconds check if the network can reach asterisk. If not, try to reconnect\n                          _this9.startOptionsPingForUnstableNetworks();\n                        case 18:\n                        case \"end\":\n                          return _context16.stop();\n                      }\n                    }\n                    return _callee4$;\n                  }(), null, null, [[4, 10, 13, 17]], Promise);\n                }\n                return _callee4;\n              }(), this.optionsKeepaliveInterval * 1000);\n            case 1:\n            case \"end\":\n              return _context17.stop();\n          }\n        }\n        return startOptionsPingForUnstableNetworks$;\n      }(), null, this, null, Promise);\n    }\n    return startOptionsPingForUnstableNetworks;\n  }();\n  _proto.attemptPostRecoveryRegistrationRoutine = function () {\n    function attemptPostRecoveryRegistrationRoutine() {\n      var _this10 = this,\n        _this$registerer5;\n      var promise;\n      return _regeneratorRuntime.async(function () {\n        function attemptPostRecoveryRegistrationRoutine$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              /**\n               * It might happen that the whole network loss can happen\n               * while there is ongoing call. In that case, we want to maintain\n               * the call.\n               *\n               * So after re-registration, it should remain in the same state.\n               * */\n              promise = new Promise(function (_resolve, _reject) {\n                var _this10$registerer;\n                (_this10$registerer = _this10.registerer) === null || _this10$registerer === void 0 ? void 0 : _this10$registerer.unregister({\n                  all: true,\n                  requestDelegate: {\n                    onAccept: function () {\n                      _resolve();\n                    },\n                    onReject: function (error) {\n                      console.error(\"[\" + error + \"] While unregistering after recovery\");\n                      _this10.emit('unregistrationerror', error);\n                      _reject('Error in Unregistering');\n                    }\n                  }\n                });\n              });\n              _context18.prev = 1;\n              _context18.next = 4;\n              return _regeneratorRuntime.awrap(promise);\n            case 4:\n              _context18.next = 9;\n              break;\n            case 6:\n              _context18.prev = 6;\n              _context18.t0 = _context18[\"catch\"](1);\n              console.error(\"[\" + _context18.t0 + \"] While waiting for unregister promise\");\n            case 9:\n              (_this$registerer5 = this.registerer) === null || _this$registerer5 === void 0 ? void 0 : _this$registerer5.register({\n                requestDelegate: {\n                  onReject: function (error) {\n                    _this10._callState = 'UNREGISTERED';\n                    _this10.emit('registrationerror', error);\n                    _this10.emit('stateChanged');\n                  }\n                }\n              });\n            case 10:\n            case \"end\":\n              return _context18.stop();\n          }\n        }\n        return attemptPostRecoveryRegistrationRoutine$;\n      }(), null, this, [[1, 6]], Promise);\n    }\n    return attemptPostRecoveryRegistrationRoutine;\n  }();\n  _proto.changeAudioInputDevice = function () {\n    function changeAudioInputDevice(constraints) {\n      var _this$session7;\n      var newStream, _this$session$session, peerConnection;\n      return _regeneratorRuntime.async(function () {\n        function changeAudioInputDevice$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              if (this.session) {\n                _context19.next = 3;\n                break;\n              }\n              console.warn('changeAudioInputDevice() : No session. Returning');\n              return _context19.abrupt(\"return\", false);\n            case 3:\n              _context19.next = 5;\n              return _regeneratorRuntime.awrap(LocalStream.requestNewStream(constraints, this.session));\n            case 5:\n              newStream = _context19.sent;\n              if (newStream) {\n                _context19.next = 9;\n                break;\n              }\n              console.warn('changeAudioInputDevice() : Unable to get local stream. Returning');\n              return _context19.abrupt(\"return\", false);\n            case 9:\n              _this$session$session = (_this$session7 = this.session) === null || _this$session7 === void 0 ? void 0 : _this$session7.sessionDescriptionHandler, peerConnection = _this$session$session.peerConnection;\n              if (peerConnection) {\n                _context19.next = 13;\n                break;\n              }\n              console.warn('changeAudioInputDevice() : No peer connection. Returning');\n              return _context19.abrupt(\"return\", false);\n            case 13:\n              LocalStream.replaceTrack(peerConnection, newStream, 'audio');\n              return _context19.abrupt(\"return\", true);\n            case 15:\n            case \"end\":\n              return _context19.stop();\n          }\n        }\n        return changeAudioInputDevice$;\n      }(), null, this, null, Promise);\n    }\n    return changeAudioInputDevice;\n  }() // Commenting this as Video Configuration is not part of the scope for now\n  // async changeVideoInputDevice(selectedVideoDevices: IDevice): Promise<boolean> {\n  // \tif (!this.session) {\n  // \t\tconsole.warn('changeVideoInputDevice() : No session. Returning');\n  // \t\treturn false;\n  // \t}\n  // \tif (!this.config.enableVideo || this.deviceManager.hasVideoInputDevice()) {\n  // \t\tconsole.warn('changeVideoInputDevice() : Unable change video device. Returning');\n  // \t\treturn false;\n  // \t}\n  // \tthis.deviceManager.changeVideoInputDevice(selectedVideoDevices);\n  // \tconst newStream = await LocalStream.requestNewStream(this.deviceManager.getConstraints('video'), this.session);\n  // \tif (!newStream) {\n  // \t\tconsole.warn('changeVideoInputDevice() : Unable to get local stream. Returning');\n  // \t\treturn false;\n  // \t}\n  // \tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n  // \tif (!peerConnection) {\n  // \t\tconsole.warn('changeVideoInputDevice() : No peer connection. Returning');\n  // \t\treturn false;\n  // \t}\n  // \tLocalStream.replaceTrack(peerConnection, newStream, 'video');\n  // \treturn true;\n  // }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ;\n  _proto.makeCallURI = function () {\n    function makeCallURI(_callee, _mediaRenderer) {\n      return _regeneratorRuntime.async(function () {\n        function makeCallURI$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              throw new Error('Not implemented');\n            case 1:\n            case \"end\":\n              return _context20.stop();\n          }\n        }\n        return makeCallURI$;\n      }(), null, null, null, Promise);\n    }\n    return makeCallURI;\n  }();\n  _proto.makeCall = function () {\n    function makeCall(_calleeNumber) {\n      return _regeneratorRuntime.async(function () {\n        function makeCall$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              throw new Error('Not implemented');\n            case 1:\n            case \"end\":\n              return _context21.stop();\n          }\n        }\n        return makeCall$;\n      }(), null, null, null, Promise);\n    }\n    return makeCall;\n  }();\n  return _createClass(VoIPUser, [{\n    key: \"operationInProgress\",\n    get: function () {\n      return this._opInProgress;\n    }\n  }, {\n    key: \"userState\",\n    get: function () {\n      return this._userState;\n    }\n  }, {\n    key: \"userConfig\",\n    get: function () {\n      return this.config;\n    }\n  }, {\n    key: \"callState\",\n    get: function () {\n      return this._callState;\n    }\n  }, {\n    key: \"connectionState\",\n    get: function () {\n      return this._connectionState;\n    }\n  }, {\n    key: \"callerInfo\",\n    get: function () {\n      if (this.callState === 'IN_CALL' || this.callState === 'OFFER_RECEIVED' || this.callState === 'ON_HOLD' || this.callState === 'OFFER_SENT') {\n        if (!this._callerInfo) {\n          throw new Error('[VoIPUser callerInfo] invalid state');\n        }\n        return {\n          state: this.callState,\n          caller: this._callerInfo,\n          userState: this._userState\n        };\n      }\n      return {\n        state: this.callState,\n        userState: this._userState\n      };\n    }\n    /* Media Stream functions begin */\n    /** The local media stream. Undefined if call not answered. */\n  }, {\n    key: \"localMediaStream\",\n    get: function () {\n      var _this$session8;\n      var sdh = (_this$session8 = this.session) === null || _this$session8 === void 0 ? void 0 : _this$session8.sessionDescriptionHandler;\n      if (!sdh) {\n        return undefined;\n      }\n      if (!(sdh instanceof SessionDescriptionHandler)) {\n        throw new Error('Session description handler not instance of web SessionDescriptionHandler');\n      }\n      return sdh.localMediaStream;\n    }\n  }]);\n}(Emitter);","map":{"version":3,"names":["_regeneratorRuntime","module","link","default","v","_createClass","_inheritsLoose","export","VoIPUser","Operation","UserState","WorkflowTypes","Emitter","UserAgent","Invitation","SessionState","Registerer","RequestPendingError","Inviter","URI","SessionDescriptionHandler","toggleMediaStreamTracks","LocalStream","QueueAggregator","RemoteStream","_Emitter","config","mediaRenderer","_this","call","state","isReady","enableVideo","remoteStream","userAgentOptions","userAgent","registerer","mediaStreamRendered","_connectionState","_held","mode","queueInfo","connectionRetryCount","stop","networkEmitter","offlineNetworkHandler","onlineNetworkHandler","optionsKeepaliveInterval","optionsKeepAliveDebounceTimeInSec","attemptRegistration","session","_callState","_callerInfo","_userState","IDLE","_opInProgress","OP_NONE","onNetworkRestored","bind","onNetworkLost","_proto","prototype","init","_this2","sipUri","transportOptions","sdpFactoryOptions","async","init$","_context2","prev","next","authUserName","sipRegistrarHostnameOrIP","server","webSocketURI","connectionTimeout","keepAliveInterval","iceGatheringTimeout","peerConnectionConfiguration","iceServers","delegate","onInvite","_callee2","invitation","_callee2$","_context","awrap","handleIncomingCall","Promise","authorizationPassword","authPassword","authorizationUsername","uri","makeURI","sessionDescriptionHandlerFactoryOptions","logConfiguration","logLevel","transport","isConnected","OP_CONNECT","onConnect","onConnected","onDisconnect","onDisconnected","window","addEventListener","start","enableKeepAliveUsingOptionsForUnstableNetworks","startOptionsPingForUnstableNetworks","t0","onConnected$","_context3","sendOptions","emit","callState","error","attemptReconnection","onRegistrationRequestAccept","OP_REGISTER","OP_UNREGISTER","onRegistrationRequestReject","callerInfo","handleIncomingCall$","_context4","OP_PROCESS_INVITE","UAS","setupSessionEventHandlers","callerId","remoteIdentity","user","callerName","displayName","host","abrupt","reject","_this$session","_this3","stateChange","addListener","_this3$remoteStream","Initial","Establishing","userState","callInfo","Established","UAC","setupRemoteMedia","Terminating","Terminated","undefined","clear","Error","onTrackAdded","_event","console","log","onTrackRemoved","_this$session2","_this$mediaStreamRend","sdh","sessionDescriptionHandler","remoteMediaStream","mediaElement","remoteMediaElement","play","handleMuteUnmute","muteState","_this$session3","_this4","_this$session4","options","peerConnection","handleMuteUnmute$","_context5","resolve","requestDelegate","onAccept","onReject","invite","then","catch","_this4$session","id","handleHoldUnhold","holdState","_this$session5","_this5","_this$session6","sessionDescriptionHandlerOptions","handleHoldUnhold$","_context6","sessionDescriptionHandlerOptionsReInvite","hold","_this5$session","create","voip","create$","_context7","outgoingRequestDelegate","_this$userAgent","outgoingMessage","userAgentCore","makeOutgoingRequestMessage","_this$userAgent2","request","register","_this$registerer","unregister","_this$registerer2","all","acceptCall","videoInvite","body","invitationAcceptOptions","acceptCall$","_context8","indexOf","constraints","audio","video","accept","canRejectCall","includes","canEndOrHoldCall","rejectCall","endCall","endCall$","_context9","cancel","bye","muteCall","muteCall$","_context10","holdCall","holdCall$","_context11","switchMediaRenderer","setWorkflowMode","CONTACT_CENTER_USER","setMembershipSubscription","subscription","_this$queueInfo","setMembership","getAggregator","getRegistrarState","_this$registerer3","toString","toLocaleLowerCase","_this$userAgent3","_this$registerer4","OP_CLEANUP","dispose","removeEventListener","onNetworkEvent","event","handler","on","offNetworkEvent","off","_this6","reconnectionAttempt","checkRegistration","reconnectionAttempts","reconnectionDelay","_args12","arguments","attemptReconnection$","_context12","length","Math","pow","setTimeout","_this6$userAgent","reconnect","attemptPostRecoveryRoutine","_this7","attemptPostRecoveryRoutine$","_context13","attemptPostRecoveryRegistrationRoutine","sendKeepAliveAndWaitForResponse","_this8","withDebounce","promise","_args15","sendKeepAliveAndWaitForResponse$","_context15","keepAliveAccepted","responseWaitTime","_error","_callee3","_callee3$","_context14","_this9","startOptionsPingForUnstableNetworks$","_context17","_callee4","_callee4$","_context16","finish","_this10","_this$registerer5","attemptPostRecoveryRegistrationRoutine$","_context18","_resolve","_reject","_this10$registerer","changeAudioInputDevice","_this$session7","newStream","_this$session$session","changeAudioInputDevice$","_context19","warn","requestNewStream","sent","replaceTrack","makeCallURI","_callee","_mediaRenderer","makeCallURI$","_context20","makeCall","_calleeNumber","makeCall$","_context21","key","get","caller","_this$session8","localMediaStream"],"sources":["client/lib/voip/VoIPUser.ts"],"sourcesContent":["/**\n * Class representing SIP UserAgent\n * @remarks\n * This class encapsulates all the details of sip.js and exposes\n * a very simple functions and callback handlers to the outside world.\n * This class thus abstracts user from Browser specific media details as well as\n * SIP specific protocol details.\n */\nimport type {\n\tCallStates,\n\tConnectionState,\n\tICallerInfo,\n\tIQueueMembershipSubscription,\n\tSignalingSocketEvents,\n\tSocketEventKeys,\n\tIMediaStreamRenderer,\n\tVoIPUserConfiguration,\n\tVoIpCallerInfo,\n\tIState,\n\tVoipEvents,\n} from '@rocket.chat/core-typings';\nimport { Operation, UserState, WorkflowTypes } from '@rocket.chat/core-typings';\nimport { Emitter } from '@rocket.chat/emitter';\nimport type { UserAgentOptions, InvitationAcceptOptions, Session, SessionInviteOptions } from 'sip.js';\nimport { UserAgent, Invitation, SessionState, Registerer, RequestPendingError, Inviter } from 'sip.js';\nimport type { OutgoingByeRequest, OutgoingRequestDelegate } from 'sip.js/lib/core';\nimport { URI } from 'sip.js/lib/core';\nimport type { SessionDescriptionHandlerOptions } from 'sip.js/lib/platform/web';\nimport { SessionDescriptionHandler } from 'sip.js/lib/platform/web';\n\nimport { toggleMediaStreamTracks } from './Helper';\nimport LocalStream from './LocalStream';\nimport { QueueAggregator } from './QueueAggregator';\nimport RemoteStream from './RemoteStream';\n\nexport class VoIPUser extends Emitter<VoipEvents> {\n\tstate: IState = {\n\t\tisReady: false,\n\t\tenableVideo: false,\n\t};\n\n\tprivate remoteStream: RemoteStream | undefined;\n\n\tuserAgentOptions: UserAgentOptions = {};\n\n\tuserAgent: UserAgent | undefined;\n\n\tregisterer: Registerer | undefined;\n\n\tmediaStreamRendered?: IMediaStreamRenderer;\n\n\tprivate _connectionState: ConnectionState = 'INITIAL';\n\n\tprivate _held = false;\n\n\tprivate mode: WorkflowTypes;\n\n\tprivate queueInfo: QueueAggregator;\n\n\tprivate connectionRetryCount;\n\n\tprivate stop;\n\n\tprivate networkEmitter: Emitter<SignalingSocketEvents>;\n\n\tprivate offlineNetworkHandler: () => void;\n\n\tprivate onlineNetworkHandler: () => void;\n\n\tprivate optionsKeepaliveInterval = 5;\n\n\tprivate optionsKeepAliveDebounceTimeInSec = 5;\n\n\tprivate attemptRegistration = false;\n\n\tprotected session: Session | undefined;\n\n\tprotected _callState: CallStates = 'INITIAL';\n\n\tprotected _callerInfo: ICallerInfo | undefined;\n\n\tprotected _userState: UserState = UserState.IDLE;\n\n\tprotected _opInProgress: Operation = Operation.OP_NONE;\n\n\tget operationInProgress(): Operation {\n\t\treturn this._opInProgress;\n\t}\n\n\tget userState(): UserState | undefined {\n\t\treturn this._userState;\n\t}\n\n\tconstructor(private readonly config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer) {\n\t\tsuper();\n\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\tthis.networkEmitter = new Emitter<SignalingSocketEvents>();\n\t\tthis.connectionRetryCount = this.config.connectionRetryCount;\n\t\tthis.stop = false;\n\n\t\tthis.onlineNetworkHandler = this.onNetworkRestored.bind(this);\n\t\tthis.offlineNetworkHandler = this.onNetworkLost.bind(this);\n\t}\n\n\t/**\n\t * Configures and initializes sip.js UserAgent\n\t * call gets established.\n\t * @remarks\n\t * This class configures transport properties such as websocket url, passed down in config,\n\t * sets up ICE servers,\n\t * SIP UserAgent options such as userName, Password, URI.\n\t * Once initialized, it starts the userAgent.\n\t */\n\n\tasync init(): Promise<void> {\n\t\tconst sipUri = `sip:${this.config.authUserName}@${this.config.sipRegistrarHostnameOrIP}`;\n\t\tconst transportOptions = {\n\t\t\tserver: this.config.webSocketURI,\n\t\t\tconnectionTimeout: 100, // Replace this with config\n\t\t\tkeepAliveInterval: 20,\n\t\t\t// traceSip: true,\n\t\t};\n\t\tconst sdpFactoryOptions = {\n\t\t\ticeGatheringTimeout: 10,\n\t\t\tpeerConnectionConfiguration: {\n\t\t\t\ticeServers: this.config.iceServers,\n\t\t\t},\n\t\t};\n\t\tthis.userAgentOptions = {\n\t\t\tdelegate: {\n\t\t\t\tonInvite: async (invitation: Invitation): Promise<void> => {\n\t\t\t\t\tawait this.handleIncomingCall(invitation);\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthorizationPassword: this.config.authPassword,\n\t\t\tauthorizationUsername: this.config.authUserName,\n\t\t\turi: UserAgent.makeURI(sipUri),\n\t\t\ttransportOptions,\n\t\t\tsessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n\t\t\tlogConfiguration: false,\n\t\t\tlogLevel: 'error',\n\t\t};\n\n\t\tthis.userAgent = new UserAgent(this.userAgentOptions);\n\t\tthis.userAgent.transport.isConnected();\n\t\tthis._opInProgress = Operation.OP_CONNECT;\n\t\ttry {\n\t\t\tthis.registerer = new Registerer(this.userAgent);\n\n\t\t\tthis.userAgent.transport.onConnect = this.onConnected.bind(this);\n\t\t\tthis.userAgent.transport.onDisconnect = this.onDisconnected.bind(this);\n\t\t\twindow.addEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.addEventListener('offline', this.offlineNetworkHandler);\n\t\t\tawait this.userAgent.start();\n\t\t\tif (this.config.enableKeepAliveUsingOptionsForUnstableNetworks) {\n\t\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync onConnected(): Promise<void> {\n\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\tthis.state.isReady = true;\n\t\tthis.sendOptions();\n\t\tthis.networkEmitter.emit('connected');\n\t\t/**\n\t\t * Re-registration post network recovery should be attempted\n\t\t * if it was previously registered or incall/onhold\n\t\t */\n\n\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\tthis.attemptRegistration = true;\n\t\t}\n\t}\n\n\tonDisconnected(error: any): void {\n\t\tthis._connectionState = 'SERVER_DISCONNECTED';\n\t\tthis._opInProgress = Operation.OP_NONE;\n\t\tthis.networkEmitter.emit('disconnected');\n\t\tif (error) {\n\t\t\tthis.networkEmitter.emit('connectionerror', error);\n\t\t\tthis.state.isReady = false;\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted assuming\n\t\t\t * that the disconnect happened from the remote side or due to sleep\n\t\t\t * In case of remote side disconnection, if config.connectionRetryCount is -1,\n\t\t\t * attemptReconnection attempts continuously. Else stops after |config.connectionRetryCount|\n\t\t\t *\n\t\t\t */\n\t\t\t// this.attemptReconnection();\n\t\t\tthis.attemptReconnection(0, false);\n\t\t}\n\t}\n\n\tonNetworkRestored(): void {\n\t\tthis.networkEmitter.emit('localnetworkonline');\n\t\tif (this._connectionState === 'WAITING_FOR_NETWORK') {\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted when online event handler\n\t\t\t * gets notified.\n\t\t\t * Important thing to note is that the second parameter |checkRegistration| = true passed here\n\t\t\t * because after the network recovery and after reconnecting to the server,\n\t\t\t * the transport layer of SIPUA does not call onConnected. So by passing |checkRegistration = true |\n\t\t\t * the code will check if the endpoint was previously registered before the disconnection.\n\t\t\t * If such is the case, it will first unregister and then re-register.\n\t\t\t * */\n\t\t\tthis.attemptReconnection();\n\t\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\t\tthis.attemptRegistration = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tonNetworkLost(): void {\n\t\tthis.networkEmitter.emit('localnetworkoffline');\n\t\tthis._connectionState = 'WAITING_FOR_NETWORK';\n\t}\n\n\tget userConfig(): VoIPUserConfiguration {\n\t\treturn this.config;\n\t}\n\n\tget callState(): CallStates {\n\t\treturn this._callState;\n\t}\n\n\tget connectionState(): ConnectionState {\n\t\treturn this._connectionState;\n\t}\n\n\tget callerInfo(): VoIpCallerInfo {\n\t\tif (\n\t\t\tthis.callState === 'IN_CALL' ||\n\t\t\tthis.callState === 'OFFER_RECEIVED' ||\n\t\t\tthis.callState === 'ON_HOLD' ||\n\t\t\tthis.callState === 'OFFER_SENT'\n\t\t) {\n\t\t\tif (!this._callerInfo) {\n\t\t\t\tthrow new Error('[VoIPUser callerInfo] invalid state');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: this.callState,\n\t\t\t\tcaller: this._callerInfo,\n\t\t\t\tuserState: this._userState,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tstate: this.callState,\n\t\t\tuserState: this._userState,\n\t\t};\n\t}\n\n\t/* Media Stream functions begin */\n\t/** The local media stream. Undefined if call not answered. */\n\tget localMediaStream(): MediaStream | undefined {\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\t\treturn sdh.localMediaStream;\n\t}\n\n\t/* Media Stream functions end */\n\t/* OutgoingRequestDelegate methods begin */\n\tonRegistrationRequestAccept(): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis._callState = 'REGISTERED';\n\t\t\tthis.emit('registered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\tthis.emit('unregistered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t}\n\n\tonRegistrationRequestReject(error: any): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis.emit('registrationerror', error);\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis.emit('unregistrationerror', error);\n\t\t}\n\t}\n\t/* OutgoingRequestDelegate methods end */\n\n\tprivate async handleIncomingCall(invitation: Invitation): Promise<void> {\n\t\tif (this.callState === 'REGISTERED') {\n\t\t\tthis._opInProgress = Operation.OP_PROCESS_INVITE;\n\t\t\tthis._callState = 'OFFER_RECEIVED';\n\t\t\tthis._userState = UserState.UAS;\n\t\t\tthis.session = invitation;\n\t\t\tthis.setupSessionEventHandlers(invitation);\n\t\t\tconst callerInfo: ICallerInfo = {\n\t\t\t\tcallerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n\t\t\t\tcallerName: invitation.remoteIdentity.displayName,\n\t\t\t\thost: invitation.remoteIdentity.uri.host,\n\t\t\t};\n\t\t\tthis._callerInfo = callerInfo;\n\t\t\tthis.emit('incomingcall', callerInfo);\n\t\t\tthis.emit('stateChanged');\n\t\t\treturn;\n\t\t}\n\n\t\tawait invitation.reject();\n\t}\n\n\t/**\n\t * Sets up an listener handler for handling session's state change\n\t * @remarks\n\t * Called for setting up various state listeners. These listeners will\n\t * decide the next action to be taken when the session state changes.\n\t * e.g when session.state changes from |Establishing| to |Established|\n\t * one must set up local and remote media rendering.\n\t *\n\t * This class handles such session state changes and takes necessary actions.\n\t */\n\n\tprotected setupSessionEventHandlers(session: Session): void {\n\t\tthis.session?.stateChange.addListener((state: SessionState) => {\n\t\t\tif (this.session !== session) {\n\t\t\t\treturn; // if our session has changed, just return\n\t\t\t}\n\t\t\tswitch (state) {\n\t\t\t\tcase SessionState.Initial:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Establishing:\n\t\t\t\t\tthis.emit('ringing', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Established:\n\t\t\t\t\tif (this._userState === UserState.UAC) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * We need to decide about user-state ANSWER-RECEIVED for outbound.\n\t\t\t\t\t\t * This state is there for the symmetry of ANSWER-SENT.\n\t\t\t\t\t\t * ANSWER-SENT occurs when there is incoming invite. So then the UA\n\t\t\t\t\t\t * accepts a call, it sends the answer and state becomes ANSWER-SENT.\n\t\t\t\t\t\t * The call gets established only when the remote party sends ACK.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * But in case of UAC where the invite is sent out, there is no intermediate\n\t\t\t\t\t\t * state where the UA can be in ANSWER-RECEIVED. As soon this UA receives the answer,\n\t\t\t\t\t\t * it sends ack and changes the SessionState to established.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * So we do not have an actual state transitions from ANSWER-RECEIVED to IN-CALL.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Nevertheless, this state is just added to maintain the symmetry. This can be safely removed.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * */\n\t\t\t\t\t\tthis._callState = 'ANSWER_RECEIVED';\n\t\t\t\t\t}\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis.setupRemoteMedia();\n\t\t\t\t\tthis._callState = 'IN_CALL';\n\t\t\t\t\tthis.emit('callestablished', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Terminating:\n\t\t\t\t// fall through\n\t\t\t\tcase SessionState.Terminated:\n\t\t\t\t\tthis.session = undefined;\n\t\t\t\t\tthis._callState = 'REGISTERED';\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._userState = UserState.IDLE;\n\t\t\t\t\tthis.emit('callterminated');\n\t\t\t\t\tthis.remoteStream?.clear();\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown session state.');\n\t\t\t}\n\t\t});\n\t}\n\n\tonTrackAdded(_event: any): void {\n\t\tconsole.log('onTrackAdded');\n\t}\n\n\tonTrackRemoved(_event: any): void {\n\t\tconsole.log('onTrackRemoved');\n\t}\n\n\t/**\n\t * Carries out necessary steps for rendering remote media whe\n\t * call gets established.\n\t * @remarks\n\t * Sets up Stream class and plays the stream on given Media element/\n\t * Also sets up various event handlers.\n\t */\n\tprivate setupRemoteMedia(): any {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\n\t\tconst remoteStream = sdh.remoteMediaStream;\n\t\tif (!remoteStream) {\n\t\t\tthrow new Error('Remote media stream is undefined.');\n\t\t}\n\n\t\tthis.remoteStream = new RemoteStream(remoteStream);\n\t\tconst mediaElement = this.mediaStreamRendered?.remoteMediaElement;\n\t\tif (mediaElement) {\n\t\t\tthis.remoteStream.init(mediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\t/**\n\t * Handles call mute-unmute\n\t */\n\tprivate async handleMuteUnmute(muteState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === muteState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = muteState;\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\tthis.emit('muteerror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A mute request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('muteerror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles call hold-unhold\n\t */\n\tprivate async handleHoldUnhold(holdState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === holdState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = holdState;\n\t\t\t\t\tthis._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis.emit('holderror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Session properties used to pass options to the SessionDescriptionHandler:\n\t\t//\n\t\t// 1) Session.sessionDescriptionHandlerOptions\n\t\t//    SDH options for the initial INVITE transaction.\n\t\t//    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n\t\t//\n\t\t// 2) Session.sessionDescriptionHandlerOptionsReInvite\n\t\t//    SDH options for re-INVITE transactions.\n\t\t//    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Session.invite().\n\n\t\tconst sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite as SessionDescriptionHandlerOptions;\n\t\tsessionDescriptionHandlerOptions.hold = holdState;\n\t\tsession.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A hold request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('holderror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tstatic async create(config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer): Promise<VoIPUser> {\n\t\tconst voip = new VoIPUser(config, mediaRenderer);\n\t\tawait voip.init();\n\t\treturn voip;\n\t}\n\n\t/**\n\t * Sends SIP OPTIONS message to asterisk\n\t *\n\t * There is an interesting problem that happens with Asterisk.\n\t * After websocket connection succeeds and if there is no SIP\n\t * message goes in 30 seconds, asterisk disconnects the socket.\n\t *\n\t * If any SIP message goes before 30 seconds, asterisk holds the connection.\n\t * This problem could be solved in multiple ways. One is that\n\t * whenever disconnect happens make sure that the socket is connected back using\n\t * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n\t * every 30 seconds till we send register message.\n\t *\n\t * Another approach is to send SIP OPTIONS just to tell server that\n\t * there is a UA using this socket. This is implemented below\n\t */\n\n\tsendOptions(outgoingRequestDelegate?: OutgoingRequestDelegate): void {\n\t\tconst uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n\t\tconst outgoingMessage = this.userAgent?.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\t\tif (outgoingMessage) {\n\t\t\tthis.userAgent?.userAgentCore.request(outgoingMessage, outgoingRequestDelegate);\n\t\t}\n\t}\n\t/**\n\t * Public method called from outside to register the SIP UA with call server.\n\t * @remarks\n\t */\n\n\tregister(): void {\n\t\tthis._opInProgress = Operation.OP_REGISTER;\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Public method called from outside to unregister the SIP UA.\n\t * @remarks\n\t */\n\n\tunregister(): void {\n\t\tthis._opInProgress = Operation.OP_UNREGISTER;\n\t\tthis.registerer?.unregister({\n\t\t\tall: true,\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\t/**\n\t * Public method called from outside to accept incoming call.\n\t * @remarks\n\t */\n\n\tasync acceptCall(mediaRenderer: IMediaStreamRenderer): Promise<void> {\n\t\tif (mediaRenderer) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t}\n\t\t// Call state must be in offer_received.\n\t\tif (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n\t\t\tthis._callState = 'ANSWER_SENT';\n\t\t\t// Something is wrong, this session is not an instance of INVITE\n\t\t\tif (!(this.session instanceof Invitation)) {\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\t}\n\t\t\t/**\n\t\t\t * It is important to decide when to add video option to the outgoing offer.\n\t\t\t * This would matter when the reinvite goes out (In case of hold/unhold)\n\t\t\t * This was added because there were failures in hold-unhold.\n\t\t\t * The scenario was that if this client does hold-unhold first, and remote client does\n\t\t\t * later, remote client goes in inconsistent state and hold-unhold does not work\n\t\t\t * Where as if the remote client does hold-unhold first, this client can do it any number\n\t\t\t * of times.\n\t\t\t *\n\t\t\t * Logic below works as follows\n\t\t\t * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n\t\t\t * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n\t\t\t * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n\t\t\t * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n\t\t\t *\n\t\t\t */\n\t\t\tlet videoInvite = !!this.config.enableVideo;\n\n\t\t\tconst { body } = this.session;\n\t\t\tif (body && body.indexOf('m=video') === -1) {\n\t\t\t\tvideoInvite = false;\n\t\t\t}\n\n\t\t\tconst invitationAcceptOptions: InvitationAcceptOptions = {\n\t\t\t\tsessionDescriptionHandlerOptions: {\n\t\t\t\t\tconstraints: {\n\t\t\t\t\t\taudio: true,\n\t\t\t\t\t\tvideo: !!this.config.enableVideo && videoInvite,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\treturn this.session.accept(invitationAcceptOptions);\n\t\t}\n\t\tthrow new Error('Something went wrong');\n\t}\n\n\t/* Helper routines for checking call actions BEGIN */\n\n\tprivate canRejectCall(): boolean {\n\t\treturn ['OFFER_RECEIVED', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\tprivate canEndOrHoldCall(): boolean {\n\t\treturn ['ANSWER_SENT', 'ANSWER_RECEIVED', 'IN_CALL', 'ON_HOLD', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\t/* Helper routines for checking call actions END */\n\n\t/**\n\t * Public method called from outside to reject a call.\n\t * @remarks\n\t */\n\trejectCall(): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canRejectCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tif (!(this.session instanceof Invitation)) {\n\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t}\n\t\treturn this.session.reject();\n\t}\n\n\t/**\n\t * Public method called from outside to end a call.\n\t * @remarks\n\t */\n\tasync endCall(): Promise<OutgoingByeRequest | void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\n\t\t// When call ends, force state to be revisited\n\t\tthis.emit('stateChanged');\n\t\tswitch (this.session.state) {\n\t\t\tcase SessionState.Initial:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Establishing:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tif (this.session instanceof Inviter) {\n\t\t\t\t\treturn this.session.cancel();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Established:\n\t\t\t\treturn this.session.bye();\n\t\t\tcase SessionState.Terminating:\n\t\t\t\tbreak;\n\t\t\tcase SessionState.Terminated:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown state');\n\t\t}\n\t}\n\n\t/**\n\t * Public method called from outside to mute the call.\n\t * @remarks\n\t */\n\tasync muteCall(muteState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'IN_CALL') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleMuteUnmute(muteState);\n\t}\n\n\t/**\n\t * Public method called from outside to hold the call.\n\t * @remarks\n\t */\n\tasync holdCall(holdState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleHoldUnhold(holdState);\n\t}\n\n\t/* CallEventDelegate implementation end */\n\tisReady(): boolean {\n\t\treturn this.state.isReady;\n\t}\n\n\t/**\n\t * This function allows to change the media renderer media elements.\n\t */\n\tswitchMediaRenderer(mediaRenderer: IMediaStreamRenderer): void {\n\t\tif (this.remoteStream) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t\tthis.remoteStream.init(mediaRenderer.remoteMediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\tsetWorkflowMode(mode: WorkflowTypes): void {\n\t\tthis.mode = mode;\n\t\tif (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\tthis.queueInfo = new QueueAggregator();\n\t\t}\n\t}\n\n\tsetMembershipSubscription(subscription: IQueueMembershipSubscription): void {\n\t\tif (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\treturn;\n\t\t}\n\t\tthis.queueInfo?.setMembership(subscription);\n\t}\n\n\tgetAggregator(): QueueAggregator {\n\t\treturn this.queueInfo;\n\t}\n\n\tgetRegistrarState(): string | undefined {\n\t\treturn this.registerer?.state.toString().toLocaleLowerCase();\n\t}\n\n\tclear(): void {\n\t\tthis._opInProgress = Operation.OP_CLEANUP;\n\t\t/** Socket reconnection is attempted when the socket is disconnected with some error.\n\t\t * While disconnecting, if there is any socket error, there should be no reconnection attempt.\n\t\t * So when userAgent.stop() is called which closes the sockets, it should be made sure that\n\t\t * if the socket is disconnected with error, connection attempts are not started or\n\t\t * if there are any previously ongoing attempts, they should be terminated.\n\t\t * flag attemptReconnect is used for ensuring this.\n\t\t */\n\t\tthis.stop = true;\n\t\tthis.userAgent?.stop();\n\t\tthis.registerer?.dispose();\n\t\tthis._connectionState = 'STOP';\n\n\t\tif (this.userAgent) {\n\t\t\tthis.userAgent.transport.onConnect = undefined;\n\t\t\tthis.userAgent.transport.onDisconnect = undefined;\n\t\t\twindow.removeEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.removeEventListener('offline', this.offlineNetworkHandler);\n\t\t}\n\t}\n\n\tonNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.on(event, handler);\n\t}\n\n\toffNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.off(event, handler);\n\t}\n\n\t/**\n\t * Connection is lost in 3 ways\n\t * 1. When local network is lost (Router is disconnected, switching networks, devtools->network->offline)\n\t * In this case, the SIP.js's transport layer does not detect the disconnection. Hence, it does not\n\t * call |onDisconnect|. To detect this kind of disconnection, window event listeners have been added.\n\t * These event listeners would be get called when the browser detects that network is offline or online.\n\t * When the network is restored, the code tries to reconnect. The useragent.transport \"does not\" generate the\n\t * onconnected event in this case as well. so onlineNetworkHandler calls attemptReconnection.\n\t * Which calls attemptRegistrationPostRecovery based on correct state. attemptRegistrationPostRecovery first tries to\n\t * unregister and then re-register.\n\t * Important note : We use the event listeners using bind function object offlineNetworkHandler and onlineNetworkHandler\n\t * It is done so because the same event handlers need to be used for removeEventListener, which becomes impossible\n\t * if done inline.\n\t *\n\t * 2. Computer goes to sleep. In this case onDisconnect is triggered. The code tries to reconnect but cant go ahead\n\t * as it goes to sleep. On waking up, The attemptReconnection gets executed, connection is completed.\n\t * In this case, it generates onConnected event. In this onConnected event it calls attemptRegistrationPostRecovery\n\t *\n\t * 3. When Asterisk disconnects all the endpoints either because it crashes or restarted,\n\t * As soon as the agent successfully connects to asterisk, it should re-register\n\t *\n\t * Retry count :\n\t * connectionRetryCount is the parameter called |Retry Count| in\n\t * Administration -> Call Center -> Server configuration -> Retry count.\n\t * The retry is implemented with backoff, maxbackoff = 8 seconds.\n\t * For continuous retries (In case Asterisk restart happens) Set this parameter to -1.\n\t *\n\t * Important to note is how attemptRegistrationPostRecovery is called. In case of\n\t * the router connection loss or while switching the networks,\n\t * there is no disconnect and connect event from the transport layer of the userAgent.\n\t * So in this case, when the connection is successful after reconnect, the code should try to re-register by calling\n\t * attemptRegistrationPostRecovery.\n\t * In case of computer waking from sleep or asterisk getting restored, connect and disconnect events are generated.\n\t * In this case, re-registration should be triggered (by calling) only when onConnected gets called and not otherwise.\n\t */\n\n\tasync attemptReconnection(reconnectionAttempt = 0, checkRegistration = false): Promise<void> {\n\t\tconst reconnectionAttempts = this.connectionRetryCount;\n\t\tthis._connectionState = 'SERVER_RECONNECTING';\n\t\tif (!this.userAgent) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.stop) {\n\t\t\treturn;\n\t\t}\n\t\t// reconnectionAttempts == -1 then keep continuously trying\n\t\tif (reconnectionAttempts !== -1 && reconnectionAttempt > reconnectionAttempts) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\treturn;\n\t\t}\n\n\t\tconst reconnectionDelay = Math.pow(2, reconnectionAttempt % 4);\n\n\t\tconsole.error(`Attempting to reconnect with backoff due to network loss. Backoff time [${reconnectionDelay}]`);\n\t\tsetTimeout(() => {\n\t\t\tif (this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState === 'SERVER_CONNECTED') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.userAgent\n\t\t\t\t?.reconnect()\n\t\t\t\t.then(() => {\n\t\t\t\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\t\t\t})\n\t\t\t\t.catch(() => {\n\t\t\t\t\tthis.attemptReconnection(++reconnectionAttempt, checkRegistration);\n\t\t\t\t});\n\t\t}, reconnectionDelay * 1000);\n\t}\n\n\tasync attemptPostRecoveryRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tthis.sendOptions({\n\t\t\tonAccept: (): void => {\n\t\t\t\tthis.attemptPostRecoveryRegistrationRoutine();\n\t\t\t},\n\t\t\tonReject: (error: unknown): void => {\n\t\t\t\tconsole.error(`[${error}] Failed to do options in attemptPostRecoveryRoutine()`);\n\t\t\t},\n\t\t});\n\t}\n\n\tasync sendKeepAliveAndWaitForResponse(withDebounce = false): Promise<boolean> {\n\t\tconst promise = new Promise<boolean>((resolve, reject) => {\n\t\t\tlet keepAliveAccepted = false;\n\t\t\tlet responseWaitTime = this.optionsKeepaliveInterval / 2;\n\t\t\tif (withDebounce) {\n\t\t\t\tresponseWaitTime += this.optionsKeepAliveDebounceTimeInSec;\n\t\t\t}\n\n\t\t\tthis.sendOptions({\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tkeepAliveAccepted = true;\n\t\t\t\t},\n\t\t\t\tonReject: (_error: unknown): void => {\n\t\t\t\t\tconsole.error('Failed to do options.');\n\t\t\t\t},\n\t\t\t});\n\t\t\tsetTimeout(async () => {\n\t\t\t\tif (!keepAliveAccepted) {\n\t\t\t\t\treject(false);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.attemptRegistration) {\n\t\t\t\t\t\tthis.attemptPostRecoveryRoutine();\n\t\t\t\t\t\tthis.attemptRegistration = false;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(true);\n\t\t\t\t}\n\t\t\t}, responseWaitTime * 1000);\n\t\t});\n\t\treturn promise;\n\t}\n\n\tasync startOptionsPingForUnstableNetworks(): Promise<void> {\n\t\tsetTimeout(async () => {\n\t\t\tif (!this.userAgent || this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState !== 'SERVER_RECONNECTING') {\n\t\t\t\tlet isConnected = false;\n\t\t\t\ttry {\n\t\t\t\t\tawait this.sendKeepAliveAndWaitForResponse();\n\t\t\t\t\tisConnected = true;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(`[${e}] Failed to do options ping.`);\n\t\t\t\t} finally {\n\t\t\t\t\t// Send event only if it's a \"change\" on the status (avoid unnecessary event flooding)\n\t\t\t\t\t!isConnected && this.networkEmitter.emit('disconnected');\n\t\t\t\t\tisConnected && this.networkEmitter.emit('connected');\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Each seconds check if the network can reach asterisk. If not, try to reconnect\n\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t}, this.optionsKeepaliveInterval * 1000);\n\t}\n\n\tasync attemptPostRecoveryRegistrationRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tconst promise = new Promise<void>((_resolve, _reject) => {\n\t\t\tthis.registerer?.unregister({\n\t\t\t\tall: true,\n\t\t\t\trequestDelegate: {\n\t\t\t\t\tonAccept: (): void => {\n\t\t\t\t\t\t_resolve();\n\t\t\t\t\t},\n\t\t\t\t\tonReject: (error): void => {\n\t\t\t\t\t\tconsole.error(`[${error}] While unregistering after recovery`);\n\t\t\t\t\t\tthis.emit('unregistrationerror', error);\n\t\t\t\t\t\t_reject('Error in Unregistering');\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t\ttry {\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\tconsole.error(`[${error}] While waiting for unregister promise`);\n\t\t}\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonReject: (error): void => {\n\t\t\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\t\t\tthis.emit('registrationerror', error);\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\tasync changeAudioInputDevice(constraints: MediaStreamConstraints): Promise<boolean> {\n\t\tif (!this.session) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No session. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst newStream = await LocalStream.requestNewStream(constraints, this.session);\n\t\tif (!newStream) {\n\t\t\tconsole.warn('changeAudioInputDevice() : Unable to get local stream. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No peer connection. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tLocalStream.replaceTrack(peerConnection, newStream, 'audio');\n\t\treturn true;\n\t}\n\n\t// Commenting this as Video Configuration is not part of the scope for now\n\t// async changeVideoInputDevice(selectedVideoDevices: IDevice): Promise<boolean> {\n\t// \tif (!this.session) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No session. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tif (!this.config.enableVideo || this.deviceManager.hasVideoInputDevice()) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable change video device. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tthis.deviceManager.changeVideoInputDevice(selectedVideoDevices);\n\t// \tconst newStream = await LocalStream.requestNewStream(this.deviceManager.getConstraints('video'), this.session);\n\t// \tif (!newStream) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable to get local stream. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t// \tif (!peerConnection) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No peer connection. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tLocalStream.replaceTrack(peerConnection, newStream, 'video');\n\t// \treturn true;\n\t// }\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\tasync makeCallURI(_callee: string, _mediaRenderer?: IMediaStreamRenderer): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\tasync makeCall(_calleeNumber: string): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n}\n"],"mappings":"AAqBA,IAAAA,mBAAoB;AAAAC,MAAS,CAAEC,IAAA,6BAAqB;EAAAC,OAAA,WAAAA,CAA4BC,CAAA;IAAAJ,mBAAA,GAAAI,CAAA;EAAA;AAAA;AAAA,IAAAC,YAAA;AAAAJ,MAAA,CAAAC,IAAA;EAAAC,OAAA,WAAAA,CAAAC,CAAA;IAAAC,YAAA,GAAAD,CAAA;EAAA;AAAA;AAAA,IAAAE,cAAA;AAAAL,MAAA,CAAAC,IAAA;EAAAC,OAAA,WAAAA,CAAAC,CAAA;IAAAE,cAAA,GAAAF,CAAA;EAAA;AAAA;AAAhFH,MAAA,CAAOM,MAAE;EAAAC,QAAW,WAAAA,CAAA,EAAW;IAAA,OAAAA,QAAe;EAAA;AAAA,CAAM;AAAA,IAAAC,SAAA,EAAAC,SAAA,EAAAC,aAA4B;AAAAV,MAAA,CAAAC,IAAA;EAAAO,SAAA,WAAAA,CAAAL,CAAA;IAAAK,SAAA,GAAAL,CAAA;EAAA;EAAAM,SAAA,WAAAA,CAAAN,CAAA;IAAAM,SAAA,GAAAN,CAAA;EAAA;EAAAO,aAAA,WAAAA,CAAAP,CAAA;IAAAO,aAAA,GAAAP,CAAA;EAAA;AAAA;AAAA,IAAAQ,OAAA;AAAAX,MAAA,CAAAC,IAAA;EAAAU,OAAA,WAAAA,CAAAR,CAAA;IAAAQ,OAAA,GAAAR,CAAA;EAAA;AAAA;AAAA,IAAAS,SAAA,EAAAC,UAAA,EAAAC,YAAA,EAAAC,UAAA,EAAAC,mBAAA,EAAAC,OAAA;AAAAjB,MAAA,CAAAC,IAAA;EAAAW,SAAA,WAAAA,CAAAT,CAAA;IAAAS,SAAA,GAAAT,CAAA;EAAA;EAAAU,UAAA,WAAAA,CAAAV,CAAA;IAAAU,UAAA,GAAAV,CAAA;EAAA;EAAAW,YAAA,WAAAA,CAAAX,CAAA;IAAAW,YAAA,GAAAX,CAAA;EAAA;EAAAY,UAAA,WAAAA,CAAAZ,CAAA;IAAAY,UAAA,GAAAZ,CAAA;EAAA;EAAAa,mBAAA,WAAAA,CAAAb,CAAA;IAAAa,mBAAA,GAAAb,CAAA;EAAA;EAAAc,OAAA,WAAAA,CAAAd,CAAA;IAAAc,OAAA,GAAAd,CAAA;EAAA;AAAA;AAAA,IAAAe,GAAA;AAAAlB,MAAA,CAAAC,IAAA;EAAAiB,GAAA,WAAAA,CAAAf,CAAA;IAAAe,GAAA,GAAAf,CAAA;EAAA;AAAA;AAAA,IAAAgB,yBAAA;AAAAnB,MAAA,CAAAC,IAAA;EAAAkB,yBAAA,WAAAA,CAAAhB,CAAA;IAAAgB,yBAAA,GAAAhB,CAAA;EAAA;AAAA;AAAA,IAAAiB,uBAAA;AAAApB,MAAA,CAAAC,IAAA;EAAAmB,uBAAA,WAAAA,CAAAjB,CAAA;IAAAiB,uBAAA,GAAAjB,CAAA;EAAA;AAAA;AAAA,IAAAkB,WAAA;AAAArB,MAAA,CAAAC,IAAA;EAAA,oBAAAC,CAAAC,CAAA;IAAAkB,WAAA,GAAAlB,CAAA;EAAA;AAAA;AAAA,IAAAmB,eAAA;AAAAtB,MAAA,CAAAC,IAAA;EAAAqB,eAAA,WAAAA,CAAAnB,CAAA;IAAAmB,eAAA,GAAAnB,CAAA;EAAA;AAAA;AAAA,IAAAoB,YAAA;AAAAvB,MAAA,CAAAC,IAAA;EAAA,oBAAAC,CAAAC,CAAA;IAAAoB,YAAA,GAAApB,CAAA;EAAA;AAAA;AAAA,IAcnEI,QAAS,0BAAAiB,QAAA;EA0DrB,SAAAjB,SAA6BkB,MAA6B,EAAEC,aAAoC;IAAA,IAAAC,KAAA;IAC/FA,KAAA,GAAAH,QAAA,CAAAI,IAAA,KAAK,CAAE;IAACD,KAAA,CADoBF,MAAA;IAAAE,KAAA,CAzD7BE,KAAK,GAAW;MACfC,OAAO,EAAE,KAAK;MACdC,WAAW,EAAE;KACb;IAAAJ,KAAA,CAEOK,YAAY;IAAAL,KAAA,CAEpBM,gBAAgB,GAAqB,EAAE;IAAAN,KAAA,CAEvCO,SAAS;IAAAP,KAAA,CAETQ,UAAU;IAAAR,KAAA,CAEVS,mBAAmB;IAAAT,KAAA,CAEXU,gBAAgB,GAAoB,SAAS;IAAAV,KAAA,CAE7CW,KAAK,GAAG,KAAK;IAAAX,KAAA,CAEbY,IAAI;IAAAZ,KAAA,CAEJa,SAAS;IAAAb,KAAA,CAETc,oBAAoB;IAAAd,KAAA,CAEpBe,IAAI;IAAAf,KAAA,CAEJgB,cAAc;IAAAhB,KAAA,CAEdiB,qBAAqB;IAAAjB,KAAA,CAErBkB,oBAAoB;IAAAlB,KAAA,CAEpBmB,wBAAwB,GAAG,CAAC;IAAAnB,KAAA,CAE5BoB,iCAAiC,GAAG,CAAC;IAAApB,KAAA,CAErCqB,mBAAmB,GAAG,KAAK;IAAArB,KAAA,CAEzBsB,OAAO;IAAAtB,KAAA,CAEPuB,UAAU,GAAe,SAAS;IAAAvB,KAAA,CAElCwB,WAAW;IAAAxB,KAAA,CAEXyB,UAAU,GAAc3C,SAAS,CAAC4C,IAAI;IAAA1B,KAAA,CAEtC2B,aAAa,GAAc9C,SAAS,CAAC+C,OAAO;IAUzB5B,KAAA,CAAAF,MAAM,GAANA,MAAM;IAElCE,KAAA,CAAKS,mBAAmB,GAAGV,aAAa;IACxCC,KAAA,CAAKgB,cAAc,GAAG,IAAIhC,OAAO,EAAyB;IAC1DgB,KAAA,CAAKc,oBAAoB,GAAGd,KAAA,CAAKF,MAAM,CAACgB,oBAAoB;IAC5Dd,KAAA,CAAKe,IAAI,GAAG,KAAK;IAEjBf,KAAA,CAAKkB,oBAAoB,GAAGlB,KAAA,CAAK6B,iBAAiB,CAACC,IAAI,CAAA9B,KAAK,CAAC;IAC7DA,KAAA,CAAKiB,qBAAqB,GAAGjB,KAAA,CAAK+B,aAAa,CAACD,IAAI,CAAA9B,KAAK,CAAC;IAAC,OAAAA,KAAA;EAC5D;EAEA;;;;;;;;;EAAAtB,cAAA,CAAAE,QAAA,EAAAiB,QAAA;EAAA,IAAAmC,MAAA,GAAApD,QAAA,CAAAqD,SAAA;EAAAD,MAAA,CAUME,IAAI;IAAV,SAAAA,KAAA;MAAA,IAAAC,MAAA;MAAA,IAAAC,MAAA,EAAAC,gBAAA,EAAAC,iBAAA;MAAA,OAAAlE,mBAAA,CAAAmE,KAAA;QAAA,SAAAC,MAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAC,IAAA,GAAAD,SAAA,CAAAE,IAAA;YAAA;cACOP,MAAM,YAAU,IAAI,CAACtC,MAAM,CAAC8C,YAAY,SAAI,IAAI,CAAC9C,MAAM,CAAC+C,wBAAwB;cAChFR,gBAAgB,GAAG;gBACxBS,MAAM,EAAE,IAAI,CAAChD,MAAM,CAACiD,YAAY;gBAChCC,iBAAiB,EAAE,GAAG;gBAAE;gBACxBC,iBAAiB,EAAE;gBACnB;eACA;cACKX,iBAAiB,GAAG;gBACzBY,mBAAmB,EAAE,EAAE;gBACvBC,2BAA2B,EAAE;kBAC5BC,UAAU,EAAE,IAAI,CAACtD,MAAM,CAACsD;;eAEzB;cACD,IAAI,CAAC9C,gBAAgB,GAAG;gBACvB+C,QAAQ,EAAE;kBACTC,QAAQ;oBAAE,SAAAC,SAAOC,UAAsB;sBAAA,OAAApF,mBAAA,CAAAmE,KAAA;wBAAA,SAAAkB,UAAAC,QAAA;0BAAA,kBAAAA,QAAA,CAAAhB,IAAA,GAAAgB,QAAA,CAAAf,IAAA;4BAAA;8BAAAe,QAAA,CAAAf,IAAA;8BAAA,OAAAvE,mBAAA,CAAAuF,KAAA,CAChCxB,MAAI,CAACyB,kBAAkB,CAACJ,UAAU,CAAC;4BAAA;4BAAA;8BAAA,OAAAE,QAAA,CAAA3C,IAAA;0BAAA;wBAAA;wBAAA,OAAA0C,SAAA;sBAAA,uBAAAI,OAAA;oBAAA;oBACzC,OAAAN,QAAA;kBAAA;iBACD;gBACDO,qBAAqB,EAAE,IAAI,CAAChE,MAAM,CAACiE,YAAY;gBAC/CC,qBAAqB,EAAE,IAAI,CAAClE,MAAM,CAAC8C,YAAY;gBAC/CqB,GAAG,EAAEhF,SAAS,CAACiF,OAAO,CAAC9B,MAAM,CAAC;gBAC9BC,gBAAgB,EAAhBA,gBAAgB;gBAChB8B,uCAAuC,EAAE7B,iBAAiB;gBAC1D8B,gBAAgB,EAAE,KAAK;gBACvBC,QAAQ,EAAE;eACV;cAED,IAAI,CAAC9D,SAAS,GAAG,IAAItB,SAAS,CAAC,IAAI,CAACqB,gBAAgB,CAAC;cACrD,IAAI,CAACC,SAAS,CAAC+D,SAAS,CAACC,WAAW,EAAE;cACtC,IAAI,CAAC5C,aAAa,GAAG9C,SAAS,CAAC2F,UAAU;cAAC/B,SAAA,CAAAC,IAAA;cAEzC,IAAI,CAAClC,UAAU,GAAG,IAAIpB,UAAU,CAAC,IAAI,CAACmB,SAAS,CAAC;cAEhD,IAAI,CAACA,SAAS,CAAC+D,SAAS,CAACG,SAAS,GAAG,IAAI,CAACC,WAAW,CAAC5C,IAAI,CAAC,IAAI,CAAC;cAChE,IAAI,CAACvB,SAAS,CAAC+D,SAAS,CAACK,YAAY,GAAG,IAAI,CAACC,cAAc,CAAC9C,IAAI,CAAC,IAAI,CAAC;cACtE+C,MAAM,CAACC,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAAC5D,oBAAoB,CAAC;cAC5D2D,MAAM,CAACC,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAAC7D,qBAAqB,CAAC;cAACwB,SAAA,CAAAE,IAAA;cAAA,OAAAvE,mBAAA,CAAAuF,KAAA,CACzD,IAAI,CAACpD,SAAS,CAACwE,KAAK,EAAE;YAAA;cAC5B,IAAI,IAAI,CAACjF,MAAM,CAACkF,8CAA8C,EAAE;gBAC/D,IAAI,CAACC,mCAAmC,EAAE;cAC3C;cAACxC,SAAA,CAAAE,IAAA;cAAA;YAAA;cAAAF,SAAA,CAAAC,IAAA;cAAAD,SAAA,CAAAyC,EAAA,GAAAzC,SAAA;cAED,IAAI,CAAC/B,gBAAgB,GAAG,OAAO;cAAC,MAAA+B,SAAA,CAAAyC,EAAA;YAAA;YAAA;cAAA,OAAAzC,SAAA,CAAA1B,IAAA;UAAA;QAAA;QAAA,OAAAyB,KAAA;MAAA,4BAAAqB,OAAA;IAAA;IAGjC,OAAA3B,IAAA;EAAA;EAAAF,MAAA,CAEK0C,WAAW;IAAjB,SAAAA,YAAA;MAAA,OAAAtG,mBAAA,CAAAmE,KAAA;QAAA,SAAA4C,aAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAA1C,IAAA,GAAA0C,SAAA,CAAAzC,IAAA;YAAA;cACC,IAAI,CAACjC,gBAAgB,GAAG,kBAAkB;cAC1C,IAAI,CAACR,KAAK,CAACC,OAAO,GAAG,IAAI;cACzB,IAAI,CAACkF,WAAW,EAAE;cAClB,IAAI,CAACrE,cAAc,CAACsE,IAAI,CAAC,WAAW,CAAC;cACrC;;;;cAKA,IAAI,IAAI,CAAC9E,UAAU,IAAI,IAAI,CAAC+E,SAAS,KAAK,SAAS,EAAE;gBACpD,IAAI,CAAClE,mBAAmB,GAAG,IAAI;cAChC;YAAC;YAAA;cAAA,OAAA+D,SAAA,CAAArE,IAAA;UAAA;QAAA;QAAA,OAAAoE,YAAA;MAAA,uBAAAtB,OAAA;IAAA;IACD,OAAAa,WAAA;EAAA;EAAA1C,MAAA,CAED4C,cAAc;IAAd,SAAAA,eAAeY,KAAU;MACxB,IAAI,CAAC9E,gBAAgB,GAAG,qBAAqB;MAC7C,IAAI,CAACiB,aAAa,GAAG9C,SAAS,CAAC+C,OAAO;MACtC,IAAI,CAACZ,cAAc,CAACsE,IAAI,CAAC,cAAc,CAAC;MACxC,IAAIE,KAAK,EAAE;QACV,IAAI,CAACxE,cAAc,CAACsE,IAAI,CAAC,iBAAiB,EAAEE,KAAK,CAAC;QAClD,IAAI,CAACtF,KAAK,CAACC,OAAO,GAAG,KAAK;QAC1B;;;;;;;QAOA;QACA,IAAI,CAACsF,mBAAmB,CAAC,CAAC,EAAE,KAAK,CAAC;MACnC;IACD;IAAC,OAAAb,cAAA;EAAA;EAAA5C,MAAA,CAEDH,iBAAiB;IAAjB,SAAAA,kBAAA,EAAiB;MAChB,IAAI,CAACb,cAAc,CAACsE,IAAI,CAAC,oBAAoB,CAAC;MAC9C,IAAI,IAAI,CAAC5E,gBAAgB,KAAK,qBAAqB,EAAE;QACpD;;;;;;;;;QASA,IAAI,CAAC+E,mBAAmB,EAAE;QAC1B,IAAI,IAAI,CAACjF,UAAU,IAAI,IAAI,CAAC+E,SAAS,KAAK,SAAS,EAAE;UACpD,IAAI,CAAClE,mBAAmB,GAAG,IAAI;QAChC;MACD;IACD;IAAC,OAAAQ,iBAAA;EAAA;EAAAG,MAAA,CAEDD,aAAa;IAAb,SAAAA,cAAA,EAAa;MACZ,IAAI,CAACf,cAAc,CAACsE,IAAI,CAAC,qBAAqB,CAAC;MAC/C,IAAI,CAAC5E,gBAAgB,GAAG,qBAAqB;IAC9C;IAAC,OAAAqB,aAAA;EAAA;EAiDD;EACA;EAAAC,MAAA,CACA0D,2BAA2B;IAA3B,SAAAA,4BAAA,EAA2B;MAC1B,IAAI,IAAI,CAAC/D,aAAa,KAAK9C,SAAS,CAAC8G,WAAW,EAAE;QACjD,IAAI,CAACpE,UAAU,GAAG,YAAY;QAC9B,IAAI,CAAC+D,IAAI,CAAC,YAAY,CAAC;QACvB,IAAI,CAACA,IAAI,CAAC,cAAc,CAAC;MAC1B;MACA,IAAI,IAAI,CAAC3D,aAAa,KAAK9C,SAAS,CAAC+G,aAAa,EAAE;QACnD,IAAI,CAACrE,UAAU,GAAG,cAAc;QAChC,IAAI,CAAC+D,IAAI,CAAC,cAAc,CAAC;QACzB,IAAI,CAACA,IAAI,CAAC,cAAc,CAAC;MAC1B;IACD;IAAC,OAAAI,2BAAA;EAAA;EAAA1D,MAAA,CAED6D,2BAA2B;IAA3B,SAAAA,4BAA4BL,KAAU;MACrC,IAAI,IAAI,CAAC7D,aAAa,KAAK9C,SAAS,CAAC8G,WAAW,EAAE;QACjD,IAAI,CAACL,IAAI,CAAC,mBAAmB,EAAEE,KAAK,CAAC;MACtC;MACA,IAAI,IAAI,CAAC7D,aAAa,KAAK9C,SAAS,CAAC+G,aAAa,EAAE;QACnD,IAAI,CAACN,IAAI,CAAC,qBAAqB,EAAEE,KAAK,CAAC;MACxC;IACD;IAAC,OAAAK,2BAAA;EAAA,IACD;EAAA7D,MAAA,CAEc4B,kBAAkB;IAAxB,SAAAA,mBAAyBJ,UAAsB;MAAA,IAAAsC,UAAA;MAAA,OAAA1H,mBAAA,CAAAmE,KAAA;QAAA,SAAAwD,oBAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAtD,IAAA,GAAAsD,SAAA,CAAArD,IAAA;YAAA;cAAA,MAClD,IAAI,CAAC4C,SAAS,KAAK,YAAY;gBAAAS,SAAA,CAAArD,IAAA;gBAAA;cAAA;cAClC,IAAI,CAAChB,aAAa,GAAG9C,SAAS,CAACoH,iBAAiB;cAChD,IAAI,CAAC1E,UAAU,GAAG,gBAAgB;cAClC,IAAI,CAACE,UAAU,GAAG3C,SAAS,CAACoH,GAAG;cAC/B,IAAI,CAAC5E,OAAO,GAAGkC,UAAU;cACzB,IAAI,CAAC2C,yBAAyB,CAAC3C,UAAU,CAAC;cACpCsC,UAAU,GAAgB;gBAC/BM,QAAQ,EAAE5C,UAAU,CAAC6C,cAAc,CAACpC,GAAG,CAACqC,IAAI,GAAG9C,UAAU,CAAC6C,cAAc,CAACpC,GAAG,CAACqC,IAAI,GAAG,EAAE;gBACtFC,UAAU,EAAE/C,UAAU,CAAC6C,cAAc,CAACG,WAAW;gBACjDC,IAAI,EAAEjD,UAAU,CAAC6C,cAAc,CAACpC,GAAG,CAACwC;eACpC;cACD,IAAI,CAACjF,WAAW,GAAGsE,UAAU;cAC7B,IAAI,CAACR,IAAI,CAAC,cAAc,EAAEQ,UAAU,CAAC;cACrC,IAAI,CAACR,IAAI,CAAC,cAAc,CAAC;cAAC,OAAAU,SAAA,CAAAU,MAAA;YAAA;cAAAV,SAAA,CAAArD,IAAA;cAAA,OAAAvE,mBAAA,CAAAuF,KAAA,CAIrBH,UAAU,CAACmD,MAAM,EAAE;YAAA;YAAA;cAAA,OAAAX,SAAA,CAAAjF,IAAA;UAAA;QAAA;QAAA,OAAAgF,mBAAA;MAAA,uBAAAlC,OAAA;IAAA;IACzB,OAAAD,kBAAA;EAAA;EAED;;;;;;;;;;EAAA;EAAA5B,MAAA,CAWUmE,yBAAyB;IAAzB,SAAAA,0BAA0B7E,OAAgB;MAAA,IAAAsF,aAAA;QAAAC,MAAA;MACnD,CAAAD,aAAA,OAAI,CAACtF,OAAO,cAAAsF,aAAA,uBAAZA,aAAA,CAAcE,WAAW,CAACC,WAAW,CAAC,UAAC7G,KAAmB,EAAI;QAAA,IAAA8G,mBAAA;QAC7D,IAAIH,MAAI,CAACvF,OAAO,KAAKA,OAAO,EAAE;UAC7B,OAAO,CAAC;QACT;QACA,QAAQpB,KAAK;UACZ,KAAKf,YAAY,CAAC8H,OAAO;YACxB;UACD,KAAK9H,YAAY,CAAC+H,YAAY;YAC7BL,MAAI,CAACvB,IAAI,CAAC,SAAS,EAAE;cAAE6B,SAAS,EAAEN,MAAI,CAACpF,UAAU;cAAE2F,QAAQ,EAAEP,MAAI,CAACrF;YAAW,CAAE,CAAC;YAChF;UACD,KAAKrC,YAAY,CAACkI,WAAW;YAC5B,IAAIR,MAAI,CAACpF,UAAU,KAAK3C,SAAS,CAACwI,GAAG,EAAE;cACtC;;;;;;;;;;;;;;;;cAgBAT,MAAI,CAACtF,UAAU,GAAG,iBAAiB;YACpC;YACAsF,MAAI,CAAClF,aAAa,GAAG9C,SAAS,CAAC+C,OAAO;YACtCiF,MAAI,CAACU,gBAAgB,EAAE;YACvBV,MAAI,CAACtF,UAAU,GAAG,SAAS;YAC3BsF,MAAI,CAACvB,IAAI,CAAC,iBAAiB,EAAE;cAAE6B,SAAS,EAAEN,MAAI,CAACpF,UAAU;cAAE2F,QAAQ,EAAEP,MAAI,CAACrF;YAAW,CAAE,CAAC;YACxFqF,MAAI,CAACvB,IAAI,CAAC,cAAc,CAAC;YACzB;UACD,KAAKnG,YAAY,CAACqI,WAAW;UAC7B;UACA,KAAKrI,YAAY,CAACsI,UAAU;YAC3BZ,MAAI,CAACvF,OAAO,GAAGoG,SAAS;YACxBb,MAAI,CAACtF,UAAU,GAAG,YAAY;YAC9BsF,MAAI,CAAClF,aAAa,GAAG9C,SAAS,CAAC+C,OAAO;YACtCiF,MAAI,CAACpF,UAAU,GAAG3C,SAAS,CAAC4C,IAAI;YAChCmF,MAAI,CAACvB,IAAI,CAAC,gBAAgB,CAAC;YAC3B,CAAA0B,mBAAA,GAAAH,MAAI,CAACxG,YAAY,cAAA2G,mBAAA,uBAAjBA,mBAAA,CAAmBW,KAAK,EAAE;YAC1Bd,MAAI,CAACvB,IAAI,CAAC,cAAc,CAAC;YACzB;UACD;YACC,MAAM,IAAIsC,KAAK,CAAC,wBAAwB,CAAC;QAC3C;MACD,CAAC,CAAC;IACH;IAAC,OAAAzB,yBAAA;EAAA;EAAAnE,MAAA,CAED6F,YAAY;IAAZ,SAAAA,aAAaC,MAAW;MACvBC,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;IAC5B;IAAC,OAAAH,YAAA;EAAA;EAAA7F,MAAA,CAEDiG,cAAc;IAAd,SAAAA,eAAeH,MAAW;MACzBC,OAAO,CAACC,GAAG,CAAC,gBAAgB,CAAC;IAC9B;IAAC,OAAAC,cAAA;EAAA;EAED;;;;;;;EAAA;EAAAjG,MAAA,CAOQuF,gBAAgB;IAAhB,SAAAA,iBAAA,EAAgB;MAAA,IAAAW,cAAA,EAAAC,qBAAA;MACvB,IAAI,CAAC,IAAI,CAAC7G,OAAO,EAAE;QAClB,MAAM,IAAIsG,KAAK,CAAC,yBAAyB,CAAC;MAC3C;MACA,IAAMQ,GAAG,IAAAF,cAAA,GAAG,IAAI,CAAC5G,OAAO,cAAA4G,cAAA,uBAAZA,cAAA,CAAcG,yBAAyB;MACnD,IAAI,CAACD,GAAG,EAAE;QACT,OAAOV,SAAS;MACjB;MACA,IAAI,EAAEU,GAAG,YAAY5I,yBAAyB,CAAC,EAAE;QAChD,MAAM,IAAIoI,KAAK,CAAC,2EAA2E,CAAC;MAC7F;MAEA,IAAMvH,YAAY,GAAG+H,GAAG,CAACE,iBAAiB;MAC1C,IAAI,CAACjI,YAAY,EAAE;QAClB,MAAM,IAAIuH,KAAK,CAAC,mCAAmC,CAAC;MACrD;MAEA,IAAI,CAACvH,YAAY,GAAG,IAAIT,YAAY,CAACS,YAAY,CAAC;MAClD,IAAMkI,YAAY,IAAAJ,qBAAA,GAAG,IAAI,CAAC1H,mBAAmB,cAAA0H,qBAAA,uBAAxBA,qBAAA,CAA0BK,kBAAkB;MACjE,IAAID,YAAY,EAAE;QACjB,IAAI,CAAClI,YAAY,CAAC6B,IAAI,CAACqG,YAAY,CAAC;QACpC,IAAI,CAAClI,YAAY,CAACwH,YAAY,CAAC,IAAI,CAACA,YAAY,CAAC/F,IAAI,CAAC,IAAI,CAAC,CAAC;QAC5D,IAAI,CAACzB,YAAY,CAAC4H,cAAc,CAAC,IAAI,CAACA,cAAc,CAACnG,IAAI,CAAC,IAAI,CAAC,CAAC;QAChE,IAAI,CAACzB,YAAY,CAACoI,IAAI,EAAE;MACzB;IACD;IAAC,OAAAlB,gBAAA;EAAA;EAED;;;EAAA;EAAAvF,MAAA,CAGc0G,gBAAgB;IAAtB,SAAAA,iBAAuBC,SAAkB;MAAA,IAAAC,cAAA;QAAAC,MAAA;QAAAC,cAAA;MAAA,IAAAxH,OAAA,EAAA+G,yBAAA,EAAAU,OAAA,EAAAC,cAAA;MAAA,OAAA5K,mBAAA,CAAAmE,KAAA;QAAA,SAAA0G,kBAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAxG,IAAA,GAAAwG,SAAA,CAAAvG,IAAA;YAAA;cACxCrB,OAAO,GAAK,IAAI,CAAhBA,OAAO;cAAA,MACX,IAAI,CAACX,KAAK,KAAKgI,SAAS;gBAAAO,SAAA,CAAAvG,IAAA;gBAAA;cAAA;cAAA,OAAAuG,SAAA,CAAAxC,MAAA,WACpB7C,OAAO,CAACsF,OAAO,EAAE;YAAA;cAAA,IAEpB7H,OAAO;gBAAA4H,SAAA,CAAAvG,IAAA;gBAAA;cAAA;cAAA,MACL,IAAIiF,KAAK,CAAC,mBAAmB,CAAC;YAAA;cAG/BS,yBAAyB,IAAAO,cAAA,GAAG,IAAI,CAACtH,OAAO,cAAAsH,cAAA,uBAAZA,cAAA,CAAcP,yBAAyB;cAAA,IACnEA,yBAAyB,YAAY7I,yBAAyB;gBAAA0J,SAAA,CAAAvG,IAAA;gBAAA;cAAA;cAAA,MAC7D,IAAIiF,KAAK,CAAC,kFAAkF,CAAC;YAAA;cAG9FmB,OAAO,GAAyB;gBACrCK,eAAe,EAAE;kBAChBC,QAAQ,EAAE,SAAAA,CAAA,EAAW;oBACpBR,MAAI,CAAClI,KAAK,GAAGgI,SAAS;oBACtBlJ,uBAAuB,CAAC,CAACoJ,MAAI,CAAClI,KAAK,EAAEW,OAAO,EAAE,UAAU,CAAC;oBACzD7B,uBAAuB,CAAC,CAACoJ,MAAI,CAAClI,KAAK,EAAEW,OAAO,EAAE,QAAQ,CAAC;kBACxD,CAAC;kBACDgI,QAAQ,EAAE,SAAAA,CAAA,EAAW;oBACpBT,MAAI,CAACvD,IAAI,CAAC,WAAW,CAAC;kBACvB;;eAED;cAEO0D,cAAc,GAAKX,yBAAyB,CAA5CW,cAAc;cAAA,IACjBA,cAAc;gBAAAE,SAAA,CAAAvG,IAAA;gBAAA;cAAA;cAAA,MACZ,IAAIiF,KAAK,CAAC,yBAAyB,CAAC;YAAA;cAAA,OAAAsB,SAAA,CAAAxC,MAAA,YAAAoC,cAAA,GAEpC,IAAI,CAACxH,OAAO,cAAAwH,cAAA,uBAAZA,cAAA,CACJS,MAAM,CAACR,OAAO,CAAC,CAChBS,IAAI,CAAC,YAAK;gBACV/J,uBAAuB,CAAC,CAACoJ,MAAI,CAAClI,KAAK,EAAEW,OAAO,EAAE,UAAU,CAAC;gBACzD7B,uBAAuB,CAAC,CAACoJ,MAAI,CAAClI,KAAK,EAAEW,OAAO,EAAE,QAAQ,CAAC;cACxD,CAAC,CAAC,CACDmI,KAAK,CAAC,UAACjE,KAAY,EAAI;gBACvB,IAAIA,KAAK,YAAYnG,mBAAmB,EAAE;kBAAA,IAAAqK,cAAA;kBACzC3B,OAAO,CAACvC,KAAK,SAAAkE,cAAA,GAAKb,MAAI,CAACvH,OAAO,cAAAoI,cAAA,uBAAZA,cAAA,CAAcC,EAAE,8CAA0C,CAAC;gBAC9E;gBACAd,MAAI,CAACvD,IAAI,CAAC,WAAW,CAAC;gBACtB,MAAME,KAAK;cACZ,CAAC,CAAC;YAAA;YAAA;cAAA,OAAA0D,SAAA,CAAAnI,IAAA;UAAA;QAAA;QAAA,OAAAkI,iBAAA;MAAA,uBAAApF,OAAA;IAAA;IACH,OAAA6E,gBAAA;EAAA;EAED;;;EAAA;EAAA1G,MAAA,CAGc4H,gBAAgB;IAAtB,SAAAA,iBAAuBC,SAAkB;MAAA,IAAAC,cAAA;QAAAC,MAAA;QAAAC,cAAA;MAAA,IAAA1I,OAAA,EAAA+G,yBAAA,EAAAU,OAAA,EAAAkB,gCAAA,EAAAjB,cAAA;MAAA,OAAA5K,mBAAA,CAAAmE,KAAA;QAAA,SAAA2H,kBAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAzH,IAAA,GAAAyH,SAAA,CAAAxH,IAAA;YAAA;cACxCrB,OAAO,GAAK,IAAI,CAAhBA,OAAO;cAAA,MACX,IAAI,CAACX,KAAK,KAAKkJ,SAAS;gBAAAM,SAAA,CAAAxH,IAAA;gBAAA;cAAA;cAAA,OAAAwH,SAAA,CAAAzD,MAAA,WACpB7C,OAAO,CAACsF,OAAO,EAAE;YAAA;cAAA,IAEpB7H,OAAO;gBAAA6I,SAAA,CAAAxH,IAAA;gBAAA;cAAA;cAAA,MACL,IAAIiF,KAAK,CAAC,mBAAmB,CAAC;YAAA;cAG/BS,yBAAyB,IAAAyB,cAAA,GAAG,IAAI,CAACxI,OAAO,cAAAwI,cAAA,uBAAZA,cAAA,CAAczB,yBAAyB;cAAA,IACnEA,yBAAyB,YAAY7I,yBAAyB;gBAAA2K,SAAA,CAAAxH,IAAA;gBAAA;cAAA;cAAA,MAC7D,IAAIiF,KAAK,CAAC,kFAAkF,CAAC;YAAA;cAE9FmB,OAAO,GAAyB;gBACrCK,eAAe,EAAE;kBAChBC,QAAQ,EAAE,SAAAA,CAAA,EAAW;oBACpBU,MAAI,CAACpJ,KAAK,GAAGkJ,SAAS;oBACtBE,MAAI,CAACxI,UAAU,GAAGsI,SAAS,GAAG,SAAS,GAAG,SAAS;oBACnDpK,uBAAuB,CAAC,CAACsK,MAAI,CAACpJ,KAAK,EAAEW,OAAO,EAAE,UAAU,CAAC;oBACzD7B,uBAAuB,CAAC,CAACsK,MAAI,CAACpJ,KAAK,EAAEW,OAAO,EAAE,QAAQ,CAAC;oBACvDyI,MAAI,CAACxI,UAAU,KAAK,SAAS,GAAGwI,MAAI,CAACzE,IAAI,CAAC,MAAM,CAAC,GAAGyE,MAAI,CAACzE,IAAI,CAAC,QAAQ,CAAC;oBACvEyE,MAAI,CAACzE,IAAI,CAAC,cAAc,CAAC;kBAC1B,CAAC;kBACDgE,QAAQ,EAAE,SAAAA,CAAA,EAAW;oBACpB7J,uBAAuB,CAAC,CAACsK,MAAI,CAACpJ,KAAK,EAAEW,OAAO,EAAE,UAAU,CAAC;oBACzD7B,uBAAuB,CAAC,CAACsK,MAAI,CAACpJ,KAAK,EAAEW,OAAO,EAAE,QAAQ,CAAC;oBACvDyI,MAAI,CAACzE,IAAI,CAAC,WAAW,CAAC;kBACvB;;eAED,EAED;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cAEM2E,gCAAgC,GAAG3I,OAAO,CAAC8I,wCAA4E;cAC7HH,gCAAgC,CAACI,IAAI,GAAGR,SAAS;cACjDvI,OAAO,CAAC8I,wCAAwC,GAAGH,gCAAgC;cAE3EjB,cAAc,GAAKX,yBAAyB,CAA5CW,cAAc;cAAA,IACjBA,cAAc;gBAAAmB,SAAA,CAAAxH,IAAA;gBAAA;cAAA;cAAA,MACZ,IAAIiF,KAAK,CAAC,yBAAyB,CAAC;YAAA;cAAA,OAAAuC,SAAA,CAAAzD,MAAA,YAAAsD,cAAA,GAEpC,IAAI,CAAC1I,OAAO,cAAA0I,cAAA,uBAAZA,cAAA,CACJT,MAAM,CAACR,OAAO,CAAC,CAChBS,IAAI,CAAC,YAAK;gBACV/J,uBAAuB,CAAC,CAACsK,MAAI,CAACpJ,KAAK,EAAEW,OAAO,EAAE,UAAU,CAAC;gBACzD7B,uBAAuB,CAAC,CAACsK,MAAI,CAACpJ,KAAK,EAAEW,OAAO,EAAE,QAAQ,CAAC;cACxD,CAAC,CAAC,CACDmI,KAAK,CAAC,UAACjE,KAAY,EAAI;gBACvB,IAAIA,KAAK,YAAYnG,mBAAmB,EAAE;kBAAA,IAAAiL,cAAA;kBACzCvC,OAAO,CAACvC,KAAK,SAAA8E,cAAA,GAAKP,MAAI,CAACzI,OAAO,cAAAgJ,cAAA,uBAAZA,cAAA,CAAcX,EAAE,8CAA0C,CAAC;gBAC9E;gBACAI,MAAI,CAACzE,IAAI,CAAC,WAAW,CAAC;gBACtB,MAAME,KAAK;cACZ,CAAC,CAAC;YAAA;YAAA;cAAA,OAAA2E,SAAA,CAAApJ,IAAA;UAAA;QAAA;QAAA,OAAAmJ,iBAAA;MAAA,uBAAArG,OAAA;IAAA;IACH,OAAA+F,gBAAA;EAAA;EAAAhL,QAAA,CAEY2L,MAAM;IAAnB,SAAAA,OAAoBzK,MAA6B,EAAEC,aAAoC;MAAA,IAAAyK,IAAA;MAAA,OAAApM,mBAAA,CAAAmE,KAAA;QAAA,SAAAkI,QAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAhI,IAAA,GAAAgI,SAAA,CAAA/H,IAAA;YAAA;cAChF6H,IAAI,GAAG,IAAI5L,QAAQ,CAACkB,MAAM,EAAEC,aAAa,CAAC;cAAA2K,SAAA,CAAA/H,IAAA;cAAA,OAAAvE,mBAAA,CAAAuF,KAAA,CAC1C6G,IAAI,CAACtI,IAAI,EAAE;YAAA;cAAA,OAAAwI,SAAA,CAAAhE,MAAA,WACV8D,IAAI;YAAA;YAAA;cAAA,OAAAE,SAAA,CAAA3J,IAAA;UAAA;QAAA;QAAA,OAAA0J,OAAA;MAAA,uBAAA5G,OAAA;IAAA;IACX,OAAA0G,MAAA;EAAA;EAED;;;;;;;;;;;;;;;;EAAA;EAAAvI,MAAA,CAiBAqD,WAAW;IAAX,SAAAA,YAAYsF,uBAAiD;MAAA,IAAAC,eAAA;MAC5D,IAAM3G,GAAG,GAAG,IAAI1E,GAAG,CAAC,KAAK,EAAE,IAAI,CAACO,MAAM,CAAC8C,YAAY,EAAE,IAAI,CAAC9C,MAAM,CAAC+C,wBAAwB,CAAC;MAC1F,IAAMgI,eAAe,IAAAD,eAAA,GAAG,IAAI,CAACrK,SAAS,cAAAqK,eAAA,uBAAdA,eAAA,CAAgBE,aAAa,CAACC,0BAA0B,CAAC,SAAS,EAAE9G,GAAG,EAAEA,GAAG,EAAEA,GAAG,EAAE,EAAE,CAAC;MAC9G,IAAI4G,eAAe,EAAE;QAAA,IAAAG,gBAAA;QACpB,CAAAA,gBAAA,OAAI,CAACzK,SAAS,cAAAyK,gBAAA,uBAAdA,gBAAA,CAAgBF,aAAa,CAACG,OAAO,CAACJ,eAAe,EAAEF,uBAAuB,CAAC;MAChF;IACD;IAAC,OAAAtF,WAAA;EAAA;EACD;;;;EAAA;EAAArD,MAAA,CAKAkJ,QAAQ;IAAR,SAAAA,SAAA,EAAQ;MAAA,IAAAC,gBAAA;MACP,IAAI,CAACxJ,aAAa,GAAG9C,SAAS,CAAC8G,WAAW;MAC1C,CAAAwF,gBAAA,OAAI,CAAC3K,UAAU,cAAA2K,gBAAA,uBAAfA,gBAAA,CAAiBD,QAAQ,CAAC;QACzB9B,eAAe,EAAE;UAChBC,QAAQ,EAAE,IAAI,CAAC3D,2BAA2B,CAAC5D,IAAI,CAAC,IAAI,CAAC;UACrDwH,QAAQ,EAAE,IAAI,CAACzD,2BAA2B,CAAC/D,IAAI,CAAC,IAAI;;OAErD,CAAC;IACH;IAAC,OAAAoJ,QAAA;EAAA;EAED;;;;EAAA;EAAAlJ,MAAA,CAKAoJ,UAAU;IAAV,SAAAA,WAAA,EAAU;MAAA,IAAAC,iBAAA;MACT,IAAI,CAAC1J,aAAa,GAAG9C,SAAS,CAAC+G,aAAa;MAC5C,CAAAyF,iBAAA,OAAI,CAAC7K,UAAU,cAAA6K,iBAAA,uBAAfA,iBAAA,CAAiBD,UAAU,CAAC;QAC3BE,GAAG,EAAE,IAAI;QACTlC,eAAe,EAAE;UAChBC,QAAQ,EAAE,IAAI,CAAC3D,2BAA2B,CAAC5D,IAAI,CAAC,IAAI,CAAC;UACrDwH,QAAQ,EAAE,IAAI,CAACzD,2BAA2B,CAAC/D,IAAI,CAAC,IAAI;;OAErD,CAAC;IACH;IAAC,OAAAsJ,UAAA;EAAA;EACD;;;;EAAA;EAAApJ,MAAA,CAKMuJ,UAAU;IAAhB,SAAAA,WAAiBxL,aAAmC;MAAA,IAAAyL,WAAA,EAAAC,IAAA,EAAAC,uBAAA;MAAA,OAAAtN,mBAAA,CAAAmE,KAAA;QAAA,SAAAoJ,YAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAlJ,IAAA,GAAAkJ,SAAA,CAAAjJ,IAAA;YAAA;cACnD,IAAI5C,aAAa,EAAE;gBAClB,IAAI,CAACU,mBAAmB,GAAGV,aAAa;cACzC;cACA;cAAA,MACI,IAAI,CAACwB,UAAU,KAAK,gBAAgB,IAAI,IAAI,CAACI,aAAa,KAAK9C,SAAS,CAACoH,iBAAiB;gBAAA2F,SAAA,CAAAjJ,IAAA;gBAAA;cAAA;cAC7F,IAAI,CAACpB,UAAU,GAAG,aAAa;cAC/B;cAAA,IACM,IAAI,CAACD,OAAO,YAAYpC,UAAU;gBAAA0M,SAAA,CAAAjJ,IAAA;gBAAA;cAAA;cAAA,MACjC,IAAIiF,KAAK,CAAC,qCAAqC,CAAC;YAAA;cAEvD;;;;;;;;;;;;;;;;cAgBI4D,WAAW,GAAG,CAAC,CAAC,IAAI,CAAC1L,MAAM,CAACM,WAAW;cAEnCqL,IAAI,GAAK,IAAI,CAACnK,OAAO,CAArBmK,IAAI;cACZ,IAAIA,IAAI,IAAIA,IAAI,CAACI,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE;gBAC3CL,WAAW,GAAG,KAAK;cACpB;cAEME,uBAAuB,GAA4B;gBACxDzB,gCAAgC,EAAE;kBACjC6B,WAAW,EAAE;oBACZC,KAAK,EAAE,IAAI;oBACXC,KAAK,EAAE,CAAC,CAAC,IAAI,CAAClM,MAAM,CAACM,WAAW,IAAIoL;;;eAGtC;cAAA,OAAAI,SAAA,CAAAlF,MAAA,WAEM,IAAI,CAACpF,OAAO,CAAC2K,MAAM,CAACP,uBAAuB,CAAC;YAAA;cAAA,MAE9C,IAAI9D,KAAK,CAAC,sBAAsB,CAAC;YAAA;YAAA;cAAA,OAAAgE,SAAA,CAAA7K,IAAA;UAAA;QAAA;QAAA,OAAA4K,WAAA;MAAA,uBAAA9H,OAAA;IAAA;IACvC,OAAA0H,UAAA;EAAA,IAED;EAAAvJ,MAAA,CAEQkK,aAAa;IAAb,SAAAA,cAAA,EAAa;MACpB,OAAO,CAAC,gBAAgB,EAAE,YAAY,CAAC,CAACC,QAAQ,CAAC,IAAI,CAAC5K,UAAU,CAAC;IAClE;IAAC,OAAA2K,aAAA;EAAA;EAAAlK,MAAA,CAEOoK,gBAAgB;IAAhB,SAAAA,iBAAA,EAAgB;MACvB,OAAO,CAAC,aAAa,EAAE,iBAAiB,EAAE,SAAS,EAAE,SAAS,EAAE,YAAY,CAAC,CAACD,QAAQ,CAAC,IAAI,CAAC5K,UAAU,CAAC;IACxG;IAAC,OAAA6K,gBAAA;EAAA;EAED;EAEA;;;;EAAA;EAAApK,MAAA,CAIAqK,UAAU;IAAV,SAAAA,WAAA,EAAU;MACT,IAAI,CAAC,IAAI,CAAC/K,OAAO,EAAE;QAClB,MAAM,IAAIsG,KAAK,CAAC,yBAAyB,CAAC;MAC3C;MACA,IAAI,CAAC,IAAI,CAACsE,aAAa,EAAE,EAAE;QAC1B,MAAM,IAAItE,KAAK,6BAA2B,IAAI,CAACrC,SAAW,CAAC;MAC5D;MACA,IAAI,EAAE,IAAI,CAACjE,OAAO,YAAYpC,UAAU,CAAC,EAAE;QAC1C,MAAM,IAAI0I,KAAK,CAAC,qCAAqC,CAAC;MACvD;MACA,OAAO,IAAI,CAACtG,OAAO,CAACqF,MAAM,EAAE;IAC7B;IAAC,OAAA0F,UAAA;EAAA;EAED;;;;EAAA;EAAArK,MAAA,CAIMsK,OAAO;IAAb,SAAAA,QAAA;MAAA,OAAAlO,mBAAA,CAAAmE,KAAA;QAAA,SAAAgK,SAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAA9J,IAAA,GAAA8J,SAAA,CAAA7J,IAAA;YAAA;cAAA,IACM,IAAI,CAACrB,OAAO;gBAAAkL,SAAA,CAAA7J,IAAA;gBAAA;cAAA;cAAA,MACV,IAAIiF,KAAK,CAAC,yBAAyB,CAAC;YAAA;cAAA,IAEtC,IAAI,CAACwE,gBAAgB,EAAE;gBAAAI,SAAA,CAAA7J,IAAA;gBAAA;cAAA;cAAA,MACrB,IAAIiF,KAAK,6BAA2B,IAAI,CAACrC,SAAW,CAAC;YAAA;cAG5D;cACA,IAAI,CAACD,IAAI,CAAC,cAAc,CAAC;cAACkH,SAAA,CAAAtH,EAAA,GAClB,IAAI,CAAC5D,OAAO,CAACpB,KAAK;cAAAsM,SAAA,CAAA7J,IAAA,GAAA6J,SAAA,CAAAtH,EAAA,KACpB/F,YAAY,CAAC8H,OAAO,OAAAuF,SAAA,CAAAtH,EAAA,KAKpB/F,YAAY,CAAC+H,YAAY,QAAAsF,SAAA,CAAAtH,EAAA,KAQzB/F,YAAY,CAACkI,WAAW,QAAAmF,SAAA,CAAAtH,EAAA,KAExB/F,YAAY,CAACqI,WAAW,QAAAgF,SAAA,CAAAtH,EAAA,KAExB/F,YAAY,CAACsI,UAAU;cAAA;YAAA;cAAA,MAhBvB,IAAI,CAACnG,OAAO,YAAYpC,UAAU;gBAAAsN,SAAA,CAAA7J,IAAA;gBAAA;cAAA;cAAA,OAAA6J,SAAA,CAAA9F,MAAA,WAC9B,IAAI,CAACpF,OAAO,CAACqF,MAAM,EAAE;YAAA;cAAA,MAEvB,IAAIiB,KAAK,CAAC,qCAAqC,CAAC;YAAA;cAAA,MAElD,IAAI,CAACtG,OAAO,YAAYpC,UAAU;gBAAAsN,SAAA,CAAA7J,IAAA;gBAAA;cAAA;cAAA,OAAA6J,SAAA,CAAA9F,MAAA,WAC9B,IAAI,CAACpF,OAAO,CAACqF,MAAM,EAAE;YAAA;cAAA,MAEzB,IAAI,CAACrF,OAAO,YAAYhC,OAAO;gBAAAkN,SAAA,CAAA7J,IAAA;gBAAA;cAAA;cAAA,OAAA6J,SAAA,CAAA9F,MAAA,WAC3B,IAAI,CAACpF,OAAO,CAACmL,MAAM,EAAE;YAAA;cAAA,MAEvB,IAAI7E,KAAK,CAAC,qCAAqC,CAAC;YAAA;cAAA,OAAA4E,SAAA,CAAA9F,MAAA,WAE/C,IAAI,CAACpF,OAAO,CAACoL,GAAG,EAAE;YAAA;cAAA,OAAAF,SAAA,CAAA9F,MAAA;YAAA;cAAA,OAAA8F,SAAA,CAAA9F,MAAA;YAAA;cAAA,MAMnB,IAAIkB,KAAK,CAAC,eAAe,CAAC;YAAA;YAAA;cAAA,OAAA4E,SAAA,CAAAzL,IAAA;UAAA;QAAA;QAAA,OAAAwL,QAAA;MAAA,uBAAA1I,OAAA;IAAA;IAElC,OAAAyI,OAAA;EAAA;EAED;;;;EAAA;EAAAtK,MAAA,CAIM2K,QAAQ;IAAd,SAAAA,SAAehE,SAAkB;MAAA,OAAAvK,mBAAA,CAAAmE,KAAA;QAAA,SAAAqK,UAAAC,UAAA;UAAA,kBAAAA,UAAA,CAAAnK,IAAA,GAAAmK,UAAA,CAAAlK,IAAA;YAAA;cAAA,IAC3B,IAAI,CAACrB,OAAO;gBAAAuL,UAAA,CAAAlK,IAAA;gBAAA;cAAA;cAAA,MACV,IAAIiF,KAAK,CAAC,yBAAyB,CAAC;YAAA;cAAA,MAEvC,IAAI,CAACrG,UAAU,KAAK,SAAS;gBAAAsL,UAAA,CAAAlK,IAAA;gBAAA;cAAA;cAAA,MAC1B,IAAIiF,KAAK,6BAA2B,IAAI,CAACrC,SAAW,CAAC;YAAA;cAE5D,IAAI,CAACmD,gBAAgB,CAACC,SAAS,CAAC;YAAC;YAAA;cAAA,OAAAkE,UAAA,CAAA9L,IAAA;UAAA;QAAA;QAAA,OAAA6L,SAAA;MAAA,uBAAA/I,OAAA;IAAA;IACjC,OAAA8I,QAAA;EAAA;EAED;;;;EAAA;EAAA3K,MAAA,CAIM8K,QAAQ;IAAd,SAAAA,SAAejD,SAAkB;MAAA,OAAAzL,mBAAA,CAAAmE,KAAA;QAAA,SAAAwK,UAAAC,UAAA;UAAA,kBAAAA,UAAA,CAAAtK,IAAA,GAAAsK,UAAA,CAAArK,IAAA;YAAA;cAAA,IAC3B,IAAI,CAACrB,OAAO;gBAAA0L,UAAA,CAAArK,IAAA;gBAAA;cAAA;cAAA,MACV,IAAIiF,KAAK,CAAC,yBAAyB,CAAC;YAAA;cAAA,IAEtC,IAAI,CAACwE,gBAAgB,EAAE;gBAAAY,UAAA,CAAArK,IAAA;gBAAA;cAAA;cAAA,MACrB,IAAIiF,KAAK,6BAA2B,IAAI,CAACrC,SAAW,CAAC;YAAA;cAE5D,IAAI,CAACqE,gBAAgB,CAACC,SAAS,CAAC;YAAC;YAAA;cAAA,OAAAmD,UAAA,CAAAjM,IAAA;UAAA;QAAA;QAAA,OAAAgM,SAAA;MAAA,uBAAAlJ,OAAA;IAAA;IACjC,OAAAiJ,QAAA;EAAA,IAED;EAAA9K,MAAA,CACA7B,OAAO;IAAP,SAAAA,QAAA,EAAO;MACN,OAAO,IAAI,CAACD,KAAK,CAACC,OAAO;IAC1B;IAAC,OAAAA,OAAA;EAAA;EAED;;;EAAA;EAAA6B,MAAA,CAGAiL,mBAAmB;IAAnB,SAAAA,oBAAoBlN,aAAmC;MACtD,IAAI,IAAI,CAACM,YAAY,EAAE;QACtB,IAAI,CAACI,mBAAmB,GAAGV,aAAa;QACxC,IAAI,CAACM,YAAY,CAAC6B,IAAI,CAACnC,aAAa,CAACyI,kBAAkB,CAAC;QACxD,IAAI,CAACnI,YAAY,CAACwH,YAAY,CAAC,IAAI,CAACA,YAAY,CAAC/F,IAAI,CAAC,IAAI,CAAC,CAAC;QAC5D,IAAI,CAACzB,YAAY,CAAC4H,cAAc,CAAC,IAAI,CAACA,cAAc,CAACnG,IAAI,CAAC,IAAI,CAAC,CAAC;QAChE,IAAI,CAACzB,YAAY,CAACoI,IAAI,EAAE;MACzB;IACD;IAAC,OAAAwE,mBAAA;EAAA;EAAAjL,MAAA,CAEDkL,eAAe;IAAf,SAAAA,gBAAgBtM,IAAmB;MAClC,IAAI,CAACA,IAAI,GAAGA,IAAI;MAChB,IAAIA,IAAI,KAAK7B,aAAa,CAACoO,mBAAmB,EAAE;QAC/C,IAAI,CAACtM,SAAS,GAAG,IAAIlB,eAAe,EAAE;MACvC;IACD;IAAC,OAAAuN,eAAA;EAAA;EAAAlL,MAAA,CAEDoL,yBAAyB;IAAzB,SAAAA,0BAA0BC,YAA0C;MAAA,IAAAC,eAAA;MACnE,IAAI,IAAI,CAAC1M,IAAI,KAAK7B,aAAa,CAACoO,mBAAmB,EAAE;QACpD;MACD;MACA,CAAAG,eAAA,OAAI,CAACzM,SAAS,cAAAyM,eAAA,uBAAdA,eAAA,CAAgBC,aAAa,CAACF,YAAY,CAAC;IAC5C;IAAC,OAAAD,yBAAA;EAAA;EAAApL,MAAA,CAEDwL,aAAa;IAAb,SAAAA,cAAA,EAAa;MACZ,OAAO,IAAI,CAAC3M,SAAS;IACtB;IAAC,OAAA2M,aAAA;EAAA;EAAAxL,MAAA,CAEDyL,iBAAiB;IAAjB,SAAAA,kBAAA,EAAiB;MAAA,IAAAC,iBAAA;MAChB,QAAAA,iBAAA,GAAO,IAAI,CAAClN,UAAU,cAAAkN,iBAAA,uBAAfA,iBAAA,CAAiBxN,KAAK,CAACyN,QAAQ,EAAE,CAACC,iBAAiB,EAAE;IAC7D;IAAC,OAAAH,iBAAA;EAAA;EAAAzL,MAAA,CAED2F,KAAK;IAAL,SAAAA,MAAA,EAAK;MAAA,IAAAkG,gBAAA,EAAAC,iBAAA;MACJ,IAAI,CAACnM,aAAa,GAAG9C,SAAS,CAACkP,UAAU;MACzC;;;;;;;MAOA,IAAI,CAAChN,IAAI,GAAG,IAAI;MAChB,CAAA8M,gBAAA,OAAI,CAACtN,SAAS,cAAAsN,gBAAA,uBAAdA,gBAAA,CAAgB9M,IAAI,EAAE;MACtB,CAAA+M,iBAAA,OAAI,CAACtN,UAAU,cAAAsN,iBAAA,uBAAfA,iBAAA,CAAiBE,OAAO,EAAE;MAC1B,IAAI,CAACtN,gBAAgB,GAAG,MAAM;MAE9B,IAAI,IAAI,CAACH,SAAS,EAAE;QACnB,IAAI,CAACA,SAAS,CAAC+D,SAAS,CAACG,SAAS,GAAGiD,SAAS;QAC9C,IAAI,CAACnH,SAAS,CAAC+D,SAAS,CAACK,YAAY,GAAG+C,SAAS;QACjD7C,MAAM,CAACoJ,mBAAmB,CAAC,QAAQ,EAAE,IAAI,CAAC/M,oBAAoB,CAAC;QAC/D2D,MAAM,CAACoJ,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAChN,qBAAqB,CAAC;MAClE;IACD;IAAC,OAAA0G,KAAA;EAAA;EAAA3F,MAAA,CAEDkM,cAAc;IAAd,SAAAA,eAAeC,KAAsB,EAAEC,OAAmB;MACzD,IAAI,CAACpN,cAAc,CAACqN,EAAE,CAACF,KAAK,EAAEC,OAAO,CAAC;IACvC;IAAC,OAAAF,cAAA;EAAA;EAAAlM,MAAA,CAEDsM,eAAe;IAAf,SAAAA,gBAAgBH,KAAsB,EAAEC,OAAmB;MAC1D,IAAI,CAACpN,cAAc,CAACuN,GAAG,CAACJ,KAAK,EAAEC,OAAO,CAAC;IACxC;IAAC,OAAAE,eAAA;EAAA;EAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;EAAAtM,MAAA,CAoCMyD,mBAAmB;IAAzB,SAAAA,oBAAA;MAAA,IAAA+I,MAAA;MAAA,IAAAC,mBAAA;QAAAC,iBAAA;QAAAC,oBAAA;QAAAC,iBAAA;QAAAC,OAAA,GAAAC,SAAA;MAAA,OAAA1Q,mBAAA,CAAAmE,KAAA;QAAA,SAAAwM,qBAAAC,UAAA;UAAA,kBAAAA,UAAA,CAAAtM,IAAA,GAAAsM,UAAA,CAAArM,IAAA;YAAA;cAA0B8L,mBAAmB,GAAAI,OAAA,CAAAI,MAAA,QAAAJ,OAAA,QAAAnH,SAAA,GAAAmH,OAAA,MAAG,CAAC;cAAEH,iBAAiB,GAAAG,OAAA,CAAAI,MAAA,QAAAJ,OAAA,QAAAnH,SAAA,GAAAmH,OAAA,MAAG,KAAK;cACrEF,oBAAoB,GAAG,IAAI,CAAC7N,oBAAoB;cACtD,IAAI,CAACJ,gBAAgB,GAAG,qBAAqB;cAAC,IACzC,IAAI,CAACH,SAAS;gBAAAyO,UAAA,CAAArM,IAAA;gBAAA;cAAA;cAAA,OAAAqM,UAAA,CAAAtI,MAAA;YAAA;cAAA,KAGf,IAAI,CAAC3F,IAAI;gBAAAiO,UAAA,CAAArM,IAAA;gBAAA;cAAA;cAAA,OAAAqM,UAAA,CAAAtI,MAAA;YAAA;cAAA,MAITiI,oBAAoB,KAAK,CAAC,CAAC,IAAIF,mBAAmB,GAAGE,oBAAoB;gBAAAK,UAAA,CAAArM,IAAA;gBAAA;cAAA;cAC5E,IAAI,CAACjC,gBAAgB,GAAG,OAAO;cAAC,OAAAsO,UAAA,CAAAtI,MAAA;YAAA;cAI3BkI,iBAAiB,GAAGM,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEV,mBAAmB,GAAG,CAAC,CAAC;cAE9D1G,OAAO,CAACvC,KAAK,8EAA4EoJ,iBAAiB,MAAG,CAAC;cAC9GQ,UAAU,CAAC,YAAK;gBAAA,IAAAC,gBAAA;gBACf,IAAIb,MAAI,CAACzN,IAAI,EAAE;kBACd;gBACD;gBACA,IAAIyN,MAAI,CAAC9N,gBAAgB,KAAK,kBAAkB,EAAE;kBACjD;gBACD;gBACA,CAAA2O,gBAAA,GAAAb,MAAI,CAACjO,SAAS,cAAA8O,gBAAA,uBAAdA,gBAAA,CACGC,SAAS,EAAE,CACZ9F,IAAI,CAAC,YAAK;kBACVgF,MAAI,CAAC9N,gBAAgB,GAAG,kBAAkB;gBAC3C,CAAC,CAAC,CACD+I,KAAK,CAAC,YAAK;kBACX+E,MAAI,CAAC/I,mBAAmB,CAAC,EAAEgJ,mBAAmB,EAAEC,iBAAiB,CAAC;gBACnE,CAAC,CAAC;cACJ,CAAC,EAAEE,iBAAiB,GAAG,IAAI,CAAC;YAAC;YAAA;cAAA,OAAAI,UAAA,CAAAjO,IAAA;UAAA;QAAA;QAAA,OAAAgO,oBAAA;MAAA,uBAAAlL,OAAA;IAAA;IAC7B,OAAA4B,mBAAA;EAAA;EAAAzD,MAAA,CAEKuN,0BAA0B;IAAhC,SAAAA,2BAAA;MAAA,IAAAC,MAAA;MAAA,OAAApR,mBAAA,CAAAmE,KAAA;QAAA,SAAAkN,4BAAAC,UAAA;UAAA,kBAAAA,UAAA,CAAAhN,IAAA,GAAAgN,UAAA,CAAA/M,IAAA;YAAA;cACC;;;;;;;cAOA,IAAI,CAAC0C,WAAW,CAAC;gBAChBgE,QAAQ,EAAE,SAAAA,CAAA,EAAW;kBACpBmG,MAAI,CAACG,sCAAsC,EAAE;gBAC9C,CAAC;gBACDrG,QAAQ,EAAE,SAAAA,CAAC9D,KAAc,EAAU;kBAClCuC,OAAO,CAACvC,KAAK,OAAKA,KAAK,2DAAwD,CAAC;gBACjF;eACA,CAAC;YAAC;YAAA;cAAA,OAAAkK,UAAA,CAAA3O,IAAA;UAAA;QAAA;QAAA,OAAA0O,2BAAA;MAAA,uBAAA5L,OAAA;IAAA;IACH,OAAA0L,0BAAA;EAAA;EAAAvN,MAAA,CAEK4N,+BAA+B;IAArC,SAAAA,gCAAA;MAAA,IAAAC,MAAA;MAAA,IAAAC,YAAA;QAAAC,OAAA;QAAAC,OAAA,GAAAlB,SAAA;MAAA,OAAA1Q,mBAAA,CAAAmE,KAAA;QAAA,SAAA0N,iCAAAC,UAAA;UAAA,kBAAAA,UAAA,CAAAxN,IAAA,GAAAwN,UAAA,CAAAvN,IAAA;YAAA;cAAsCmN,YAAY,GAAAE,OAAA,CAAAf,MAAA,QAAAe,OAAA,QAAAtI,SAAA,GAAAsI,OAAA,MAAG,KAAK;cACnDD,OAAO,GAAG,IAAIlM,OAAO,CAAU,UAACsF,OAAO,EAAExC,MAAM,EAAI;gBACxD,IAAIwJ,iBAAiB,GAAG,KAAK;gBAC7B,IAAIC,gBAAgB,GAAGP,MAAI,CAAC1O,wBAAwB,GAAG,CAAC;gBACxD,IAAI2O,YAAY,EAAE;kBACjBM,gBAAgB,IAAIP,MAAI,CAACzO,iCAAiC;gBAC3D;gBAEAyO,MAAI,CAACxK,WAAW,CAAC;kBAChBgE,QAAQ,EAAE,SAAAA,CAAA,EAAW;oBACpB8G,iBAAiB,GAAG,IAAI;kBACzB,CAAC;kBACD7G,QAAQ,EAAE,SAAAA,CAAC+G,MAAe,EAAU;oBACnCtI,OAAO,CAACvC,KAAK,CAAC,uBAAuB,CAAC;kBACvC;iBACA,CAAC;gBACF4J,UAAU;kBAAC,SAAAkB,SAAA;oBAAA,OAAAlS,mBAAA,CAAAmE,KAAA;sBAAA,SAAAgO,UAAAC,UAAA;wBAAA,kBAAAA,UAAA,CAAA9N,IAAA,GAAA8N,UAAA,CAAA7N,IAAA;0BAAA;4BACV,IAAI,CAACwN,iBAAiB,EAAE;8BACvBxJ,MAAM,CAAC,KAAK,CAAC;4BACd,CAAC,MAAM;8BACN,IAAIkJ,MAAI,CAACxO,mBAAmB,EAAE;gCAC7BwO,MAAI,CAACN,0BAA0B,EAAE;gCACjCM,MAAI,CAACxO,mBAAmB,GAAG,KAAK;8BACjC;8BACA8H,OAAO,CAAC,IAAI,CAAC;4BACd;0BAAC;0BAAA;4BAAA,OAAAqH,UAAA,CAAAzP,IAAA;wBAAA;sBAAA;sBAAA,OAAAwP,SAAA;oBAAA,uBAAA1M,OAAA;kBAAA;kBACD,OAAAyM,QAAA;gBAAA,KAAEF,gBAAgB,GAAG,IAAI,CAAC;cAC5B,CAAC,CAAC;cAAA,OAAAF,UAAA,CAAAxJ,MAAA,WACKqJ,OAAO;YAAA;YAAA;cAAA,OAAAG,UAAA,CAAAnP,IAAA;UAAA;QAAA;QAAA,OAAAkP,gCAAA;MAAA,uBAAApM,OAAA;IAAA;IACd,OAAA+L,+BAAA;EAAA;EAAA5N,MAAA,CAEKiD,mCAAmC;IAAzC,SAAAA,oCAAA;MAAA,IAAAwL,MAAA;MAAA,OAAArS,mBAAA,CAAAmE,KAAA;QAAA,SAAAmO,qCAAAC,UAAA;UAAA,kBAAAA,UAAA,CAAAjO,IAAA,GAAAiO,UAAA,CAAAhO,IAAA;YAAA;cACCyM,UAAU;gBAAC,SAAAwB,SAAA;kBAAA,IAAArM,WAAA;kBAAA,OAAAnG,mBAAA,CAAAmE,KAAA;oBAAA,SAAAsO,UAAAC,UAAA;sBAAA,kBAAAA,UAAA,CAAApO,IAAA,GAAAoO,UAAA,CAAAnO,IAAA;wBAAA;0BAAA,MACN,CAAC8N,MAAI,CAAClQ,SAAS,IAAIkQ,MAAI,CAAC1P,IAAI;4BAAA+P,UAAA,CAAAnO,IAAA;4BAAA;0BAAA;0BAAA,OAAAmO,UAAA,CAAApK,MAAA;wBAAA;0BAAA,MAG5B+J,MAAI,CAAC/P,gBAAgB,KAAK,qBAAqB;4BAAAoQ,UAAA,CAAAnO,IAAA;4BAAA;0BAAA;0BAC9C4B,WAAW,GAAG,KAAK;0BAAAuM,UAAA,CAAApO,IAAA;0BAAAoO,UAAA,CAAAnO,IAAA;0BAAA,OAAAvE,mBAAA,CAAAuF,KAAA,CAEhB8M,MAAI,CAACb,+BAA+B,EAAE;wBAAA;0BAC5CrL,WAAW,GAAG,IAAI;0BAACuM,UAAA,CAAAnO,IAAA;0BAAA;wBAAA;0BAAAmO,UAAA,CAAApO,IAAA;0BAAAoO,UAAA,CAAA5L,EAAA,GAAA4L,UAAA;0BAEnB/I,OAAO,CAACvC,KAAK,OAAAsL,UAAA,CAAA5L,EAAA,iCAAoC,CAAC;wBAAC;0BAAA4L,UAAA,CAAApO,IAAA;0BAEnD;0BACA,CAAC6B,WAAW,IAAIkM,MAAI,CAACzP,cAAc,CAACsE,IAAI,CAAC,cAAc,CAAC;0BACxDf,WAAW,IAAIkM,MAAI,CAACzP,cAAc,CAACsE,IAAI,CAAC,WAAW,CAAC;0BAAC,OAAAwL,UAAA,CAAAC,MAAA;wBAAA;0BAGvD;0BACAN,MAAI,CAACxL,mCAAmC,EAAE;wBAAC;wBAAA;0BAAA,OAAA6L,UAAA,CAAA/P,IAAA;sBAAA;oBAAA;oBAAA,OAAA8P,SAAA;kBAAA,oCAAAhN,OAAA;gBAAA;gBAC3C,OAAA+M,QAAA;cAAA,KAAE,IAAI,CAACzP,wBAAwB,GAAG,IAAI,CAAC;YAAC;YAAA;cAAA,OAAAwP,UAAA,CAAA5P,IAAA;UAAA;QAAA;QAAA,OAAA2P,oCAAA;MAAA,uBAAA7M,OAAA;IAAA;IACzC,OAAAoB,mCAAA;EAAA;EAAAjD,MAAA,CAEK2N,sCAAsC;IAA5C,SAAAA,uCAAA;MAAA,IAAAqB,OAAA;QAAAC,iBAAA;MAAA,IAAAlB,OAAA;MAAA,OAAA3R,mBAAA,CAAAmE,KAAA;QAAA,SAAA2O,wCAAAC,UAAA;UAAA,kBAAAA,UAAA,CAAAzO,IAAA,GAAAyO,UAAA,CAAAxO,IAAA;YAAA;cACC;;;;;;;cAOMoN,OAAO,GAAG,IAAIlM,OAAO,CAAO,UAACuN,QAAQ,EAAEC,OAAO,EAAI;gBAAA,IAAAC,kBAAA;gBACvD,CAAAA,kBAAA,GAAAN,OAAI,CAACxQ,UAAU,cAAA8Q,kBAAA,uBAAfA,kBAAA,CAAiBlG,UAAU,CAAC;kBAC3BE,GAAG,EAAE,IAAI;kBACTlC,eAAe,EAAE;oBAChBC,QAAQ,EAAE,SAAAA,CAAA,EAAW;sBACpB+H,QAAQ,EAAE;oBACX,CAAC;oBACD9H,QAAQ,EAAE,SAAAA,CAAC9D,KAAK,EAAU;sBACzBuC,OAAO,CAACvC,KAAK,OAAKA,KAAK,yCAAsC,CAAC;sBAC9DwL,OAAI,CAAC1L,IAAI,CAAC,qBAAqB,EAAEE,KAAK,CAAC;sBACvC6L,OAAO,CAAC,wBAAwB,CAAC;oBAClC;;iBAED,CAAC;cACH,CAAC,CAAC;cAAAF,UAAA,CAAAzO,IAAA;cAAAyO,UAAA,CAAAxO,IAAA;cAAA,OAAAvE,mBAAA,CAAAuF,KAAA,CAEKoM,OAAO;YAAA;cAAAoB,UAAA,CAAAxO,IAAA;cAAA;YAAA;cAAAwO,UAAA,CAAAzO,IAAA;cAAAyO,UAAA,CAAAjM,EAAA,GAAAiM,UAAA;cAEbpJ,OAAO,CAACvC,KAAK,OAAA2L,UAAA,CAAAjM,EAAA,2CAAkD,CAAC;YAAC;cAElE,CAAA+L,iBAAA,OAAI,CAACzQ,UAAU,cAAAyQ,iBAAA,uBAAfA,iBAAA,CAAiB/F,QAAQ,CAAC;gBACzB9B,eAAe,EAAE;kBAChBE,QAAQ,EAAE,SAAAA,CAAC9D,KAAK,EAAU;oBACzBwL,OAAI,CAACzP,UAAU,GAAG,cAAc;oBAChCyP,OAAI,CAAC1L,IAAI,CAAC,mBAAmB,EAAEE,KAAK,CAAC;oBACrCwL,OAAI,CAAC1L,IAAI,CAAC,cAAc,CAAC;kBAC1B;;eAED,CAAC;YAAC;YAAA;cAAA,OAAA6L,UAAA,CAAApQ,IAAA;UAAA;QAAA;QAAA,OAAAmQ,uCAAA;MAAA,2BAAArN,OAAA;IAAA;IACH,OAAA8L,sCAAA;EAAA;EAAA3N,MAAA,CAEKuP,sBAAsB;IAA5B,SAAAA,uBAA6BzF,WAAmC;MAAA,IAAA0F,cAAA;MAAA,IAAAC,SAAA,EAAAC,qBAAA,EAAA1I,cAAA;MAAA,OAAA5K,mBAAA,CAAAmE,KAAA;QAAA,SAAAoP,wBAAAC,UAAA;UAAA,kBAAAA,UAAA,CAAAlP,IAAA,GAAAkP,UAAA,CAAAjP,IAAA;YAAA;cAAA,IAC1D,IAAI,CAACrB,OAAO;gBAAAsQ,UAAA,CAAAjP,IAAA;gBAAA;cAAA;cAChBoF,OAAO,CAAC8J,IAAI,CAAC,kDAAkD,CAAC;cAAC,OAAAD,UAAA,CAAAlL,MAAA,WAC1D,KAAK;YAAA;cAAAkL,UAAA,CAAAjP,IAAA;cAAA,OAAAvE,mBAAA,CAAAuF,KAAA,CAEWjE,WAAW,CAACoS,gBAAgB,CAAChG,WAAW,EAAE,IAAI,CAACxK,OAAO,CAAC;YAAA;cAAzEmQ,SAAS,GAAAG,UAAA,CAAAG,IAAA;cAAA,IACVN,SAAS;gBAAAG,UAAA,CAAAjP,IAAA;gBAAA;cAAA;cACboF,OAAO,CAAC8J,IAAI,CAAC,kEAAkE,CAAC;cAAC,OAAAD,UAAA,CAAAlL,MAAA,WAC1E,KAAK;YAAA;cAAAgL,qBAAA,IAAAF,cAAA,GAEc,IAAI,CAAClQ,OAAO,cAAAkQ,cAAA,uBAAZA,cAAA,CAAcnJ,yBAAsD,EAAvFW,cAAc,GAAA0I,qBAAA,CAAd1I,cAAc;cAAA,IACjBA,cAAc;gBAAA4I,UAAA,CAAAjP,IAAA;gBAAA;cAAA;cAClBoF,OAAO,CAAC8J,IAAI,CAAC,0DAA0D,CAAC;cAAC,OAAAD,UAAA,CAAAlL,MAAA,WAClE,KAAK;YAAA;cAEbhH,WAAW,CAACsS,YAAY,CAAChJ,cAAc,EAAEyI,SAAS,EAAE,OAAO,CAAC;cAAC,OAAAG,UAAA,CAAAlL,MAAA,WACtD,IAAI;YAAA;YAAA;cAAA,OAAAkL,UAAA,CAAA7Q,IAAA;UAAA;QAAA;QAAA,OAAA4Q,uBAAA;MAAA,uBAAA9N,OAAA;IAAA;IACX,OAAA0N,sBAAA;EAAA,IAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAAA;EAAAvP,MAAA,CAEMiQ,WAAW;IAAjB,SAAAA,YAAkBC,OAAe,EAAEC,cAAqC;MAAA,OAAA/T,mBAAA,CAAAmE,KAAA;QAAA,SAAA6P,aAAAC,UAAA;UAAA,kBAAAA,UAAA,CAAA3P,IAAA,GAAA2P,UAAA,CAAA1P,IAAA;YAAA;cAAA,MACjE,IAAIiF,KAAK,CAAC,iBAAiB,CAAC;YAAA;YAAA;cAAA,OAAAyK,UAAA,CAAAtR,IAAA;UAAA;QAAA;QAAA,OAAAqR,YAAA;MAAA,uBAAAvO,OAAA;IAAA;IAClC,OAAAoO,WAAA;EAAA;EAAAjQ,MAAA,CAEKsQ,QAAQ;IAAd,SAAAA,SAAeC,aAAqB;MAAA,OAAAnU,mBAAA,CAAAmE,KAAA;QAAA,SAAAiQ,UAAAC,UAAA;UAAA,kBAAAA,UAAA,CAAA/P,IAAA,GAAA+P,UAAA,CAAA9P,IAAA;YAAA;cAAA,MAC7B,IAAIiF,KAAK,CAAC,iBAAiB,CAAC;YAAA;YAAA;cAAA,OAAA6K,UAAA,CAAA1R,IAAA;UAAA;QAAA;QAAA,OAAAyR,SAAA;MAAA,uBAAA3O,OAAA;IAAA;IAClC,OAAAyO,QAAA;EAAA;EAAA,OAAA7T,YAAA,CAAAG,QAAA;IAAA8T,GAAA;IAAAC,GAAA,EA38BD,SAAAA,CAAA,EAAuB;MACtB,OAAO,IAAI,CAAChR,aAAa;IAC1B;EAAC;IAAA+Q,GAAA;IAAAC,GAAA,EAED,SAAAA,CAAA,EAAa;MACZ,OAAO,IAAI,CAAClR,UAAU;IACvB;EAAC;IAAAiR,GAAA;IAAAC,GAAA,EAkID,SAAAA,CAAA,EAAc;MACb,OAAO,IAAI,CAAC7S,MAAM;IACnB;EAAC;IAAA4S,GAAA;IAAAC,GAAA,EAED,SAAAA,CAAA,EAAa;MACZ,OAAO,IAAI,CAACpR,UAAU;IACvB;EAAC;IAAAmR,GAAA;IAAAC,GAAA,EAED,SAAAA,CAAA,EAAmB;MAClB,OAAO,IAAI,CAACjS,gBAAgB;IAC7B;EAAC;IAAAgS,GAAA;IAAAC,GAAA,EAED,SAAAA,CAAA,EAAc;MACb,IACC,IAAI,CAACpN,SAAS,KAAK,SAAS,IAC5B,IAAI,CAACA,SAAS,KAAK,gBAAgB,IACnC,IAAI,CAACA,SAAS,KAAK,SAAS,IAC5B,IAAI,CAACA,SAAS,KAAK,YAAY,EAC9B;QACD,IAAI,CAAC,IAAI,CAAC/D,WAAW,EAAE;UACtB,MAAM,IAAIoG,KAAK,CAAC,qCAAqC,CAAC;QACvD;QACA,OAAO;UACN1H,KAAK,EAAE,IAAI,CAACqF,SAAS;UACrBqN,MAAM,EAAE,IAAI,CAACpR,WAAW;UACxB2F,SAAS,EAAE,IAAI,CAAC1F;SAChB;MACF;MACA,OAAO;QACNvB,KAAK,EAAE,IAAI,CAACqF,SAAS;QACrB4B,SAAS,EAAE,IAAI,CAAC1F;OAChB;IACF;IAEA;IACA;EAAA;IAAAiR,GAAA;IAAAC,GAAA,EACA,SAAAA,CAAA,EAAoB;MAAA,IAAAE,cAAA;MACnB,IAAMzK,GAAG,IAAAyK,cAAA,GAAG,IAAI,CAACvR,OAAO,cAAAuR,cAAA,uBAAZA,cAAA,CAAcxK,yBAAyB;MACnD,IAAI,CAACD,GAAG,EAAE;QACT,OAAOV,SAAS;MACjB;MACA,IAAI,EAAEU,GAAG,YAAY5I,yBAAyB,CAAC,EAAE;QAChD,MAAM,IAAIoI,KAAK,CAAC,2EAA2E,CAAC;MAC7F;MACA,OAAOQ,GAAG,CAAC0K,gBAAgB;IAC5B;EAAC;AAAA,EAvO4B9T,OAAmB","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"53cdcc30a279477ff4f2bfd1f5ebddb2e37c8f85"}
