{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/settings/server/CachedSettings.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"app/settings/server/CachedSettings.ts","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/settings/server/CachedSettings.ts","inputSourceMap":{"version":3,"file":"app/settings/server/CachedSettings.ts","sourceRoot":"","sources":["app/settings/server/CachedSettings.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ISetting, SettingValue } from '@rocket.chat/core-typings';\nimport { Emitter } from '@rocket.chat/emitter';\nimport _ from 'underscore';\n\nimport { SystemLogger } from '../../../server/lib/logger/system';\n\nconst warn = process.env.NODE_ENV === 'development' || process.env.TEST_MODE;\n\ntype SettingsConfig = {\n\tdebounce: number;\n};\n\ntype OverCustomSettingsConfig = Partial<SettingsConfig>;\n\nexport interface ICachedSettings {\n\t/*\n\t * @description: The settings object as ready\n\t */\n\tinitialized(): void;\n\n\thas(_id: ISetting['_id']): boolean;\n\n\tgetSetting(_id: ISetting['_id']): ISetting | undefined;\n\n\tget<T extends SettingValue = SettingValue>(_id: ISetting['_id']): T;\n\n\tgetByRegexp<T extends SettingValue = SettingValue>(_id: RegExp): [string, T][];\n\n\twatchMultiple<T extends SettingValue = SettingValue>(_id: ISetting['_id'][], callback: (settings: T[]) => void): () => void;\n\n\twatch<T extends SettingValue = SettingValue>(_id: ISetting['_id'], cb: (args: T) => void, config?: OverCustomSettingsConfig): () => void;\n\n\twatchOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\tchange<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\tchangeMultiple<T extends SettingValue = SettingValue>(\n\t\t_ids: ISetting['_id'][],\n\t\tcallback: (settings: T[]) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\tchangeOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\tset(record: ISetting): void;\n\n\tgetConfig(config?: OverCustomSettingsConfig): SettingsConfig;\n\n\twatchByRegex(regex: RegExp, cb: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void;\n\n\tchangeByRegex(regex: RegExp, callback: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void;\n\n\tonReady(cb: () => void): void;\n}\n\n/**\n * Class responsible for setting up the settings, cache and propagation changes\n * Should be agnostic to the actual settings implementation, running on meteor or standalone\n *\n * You should not instantiate this class directly, only for testing purposes\n *\n * @extends Emitter\n * @alpha\n */\nexport class CachedSettings\n\textends Emitter<\n\t\t{\n\t\t\t'*': [string, SettingValue];\n\t\t} & {\n\t\t\tready: undefined;\n\t\t\t[k: string]: SettingValue;\n\t\t}\n\t>\n\timplements ICachedSettings\n{\n\tready = false;\n\n\tstore = new Map<string, ISetting>();\n\n\t/**\n\t * The settings object as ready\n\t */\n\tinitialized(): void {\n\t\tif (this.ready) {\n\t\t\treturn;\n\t\t}\n\t\tthis.ready = true;\n\t\tthis.emit('ready');\n\t\tSystemLogger.debug('Settings initialized');\n\t}\n\n\t/**\n\t * returns if the setting is defined\n\t * @param _id - The setting id\n\t * @returns {boolean}\n\t */\n\tpublic has(_id: ISetting['_id']): boolean {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.has(_id);\n\t}\n\n\t/**\n\t * Gets the current Object of the setting\n\t * @param _id - The setting id\n\t * @returns {ISetting} - The current Object of the setting\n\t */\n\tpublic getSetting(_id: ISetting['_id']): ISetting | undefined {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.get(_id);\n\t}\n\n\t/**\n\t * Gets the current value of the setting\n\t * - In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * - The setting's value will be cached in memory so it won't call the DB every time you fetch a particular setting\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t */\n\tpublic get<T extends SettingValue = SettingValue>(_id: ISetting['_id']): T {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.get(_id)?.value as T;\n\t}\n\n\t/**\n\t * Gets the current value of the setting\n\t * - In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * @deprecated\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t */\n\tpublic getByRegexp<T extends SettingValue = SettingValue>(_id: RegExp): [string, T][] {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\n\t\treturn [...this.store.entries()].filter(([key]) => _id.test(key)).map(([key, setting]) => [key, setting.value]) as [string, T][];\n\t}\n\n\t/**\n\t * Get the current value of the settings, and keep track of changes\n\t * - This callback is debounced\n\t * - The callback is not fire until the settings got initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watchMultiple<T extends SettingValue = SettingValue>(_id: ISetting['_id'][], callback: (settings: T[]) => void): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watchMultiple(_id, callback));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\n\t\tif (_id.every((id) => this.store.has(id))) {\n\t\t\tconst settings = _id.map((id) => this.store.get(id)?.value);\n\t\t\tcallback(settings as T[]);\n\t\t}\n\t\tconst mergeFunction = _.debounce((): void => {\n\t\t\tcallback(_id.map((id) => this.store.get(id)?.value) as T[]);\n\t\t}, 100);\n\n\t\tconst fns = _id.map((id) => this.on(id, mergeFunction));\n\t\treturn (): void => {\n\t\t\tfns.forEach((fn) => fn());\n\t\t};\n\t}\n\n\t/**\n\t * Get the current value of the setting, and keep track of changes\n\t * - This callback is debounced\n\t * - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watch<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watch(_id, cb, config));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\n\t\tthis.store.has(_id) && cb(this.store.get(_id)?.value as T);\n\t\treturn this.change(_id, cb, config);\n\t}\n\n\t/**\n\t * Get the current value of the setting, or wait until the initialized\n\t * - This is a one time run\n\t * - This callback is debounced\n\t * - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watchOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tif (this.store.has(_id)) {\n\t\t\tcb(this.store.get(_id)?.value as T);\n\t\t\treturn (): void => undefined;\n\t\t}\n\t\treturn this.changeOnce(_id, cb, config);\n\t}\n\n\t/**\n\t * Observes the given setting by id and keep track of changes\n\t * - This callback is debounced\n\t * - The callback is not fire until the setting is changed\n\t * - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic change<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst { debounce } = this.getConfig(config);\n\t\treturn this.on(_id, _.debounce(callback, debounce) as any);\n\t}\n\n\t/**\n\t * Observes multiple settings and keep track of changes\n\t * - This callback is debounced\n\t * - The callback is not fire until the setting is changed\n\t * - The callback is not fire until all the settings get initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic changeMultiple<T extends SettingValue = SettingValue>(\n\t\t_ids: ISetting['_id'][],\n\t\tcallback: (settings: T[]) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst fns = _ids.map((id) =>\n\t\t\tthis.change(\n\t\t\t\tid,\n\t\t\t\t(): void => {\n\t\t\t\t\tcallback(_ids.map((id) => this.store.get(id)?.value) as T[]);\n\t\t\t\t},\n\t\t\t\tconfig,\n\t\t\t),\n\t\t);\n\t\treturn (): void => {\n\t\t\tfns.forEach((fn) => fn());\n\t\t};\n\t}\n\n\t/**\n\t * Observes the setting and fires only if there is a change. Runs only once\n\t * - This is a one time run\n\t * - This callback is debounced\n\t * - The callback is not fire until the setting is changed\n\t * - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic changeOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst { debounce } = this.getConfig(config);\n\t\treturn this.once(_id, _.debounce(callback, debounce) as any);\n\t}\n\n\t/**\n\t * Sets the value of the setting\n\t * - if the value set is the same as the current value, the change will not be fired\n\t * - if the value is set before the initialization, the emit will be queued and will be fired after initialization\n\t * @param _id - The setting id\n\t * @param value - The value to set\n\t * @returns {void}\n\t */\n\tpublic set(record: ISetting): void {\n\t\tif (this.store.has(record._id) && this.store.get(record._id)?.value === record.value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.store.set(record._id, record);\n\t\tif (!this.ready) {\n\t\t\tthis.once('ready', () => {\n\t\t\t\tthis.emit(record._id, this.store.get(record._id)?.value);\n\t\t\t\tthis.emit('*', [record._id, this.store.get(record._id)?.value]);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tthis.emit(record._id, this.store.get(record._id)?.value);\n\t\tthis.emit('*', [record._id, this.store.get(record._id)?.value]);\n\t}\n\n\tpublic getConfig = (config?: OverCustomSettingsConfig): SettingsConfig => ({\n\t\tdebounce: process.env.TEST_MODE ? 0 : 500,\n\t\t...config,\n\t});\n\n\t/** @deprecated */\n\tpublic watchByRegex(regex: RegExp, cb: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watchByRegex(regex, cb, config));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\t\t[...this.store.entries()].forEach(([key, setting]) => {\n\t\t\tif (regex.test(key)) {\n\t\t\t\tcb(key, setting.value);\n\t\t\t}\n\t\t});\n\n\t\treturn this.changeByRegex(regex, cb, config);\n\t}\n\n\t/** @deprecated */\n\tpublic changeByRegex(regex: RegExp, callback: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void {\n\t\tconst store: Map<string, (...args: [string, SettingValue]) => void> = new Map();\n\t\treturn this.on('*', ([_id, value]) => {\n\t\t\tif (regex.test(_id)) {\n\t\t\t\tconst { debounce } = this.getConfig(config);\n\t\t\t\tconst cb = store.get(_id) || _.debounce(callback, debounce);\n\t\t\t\tcb(_id, value);\n\t\t\t\tstore.set(_id, cb);\n\t\t\t}\n\t\t\tregex.lastIndex = 0;\n\t\t});\n\t}\n\n\t/**\n\t * Wait until the settings get ready then run the callback\n\t */\n\tpublic onReady(cb: () => void): void {\n\t\tif (this.ready) {\n\t\t\treturn cb();\n\t\t}\n\t\tthis.once('ready', cb);\n\t}\n}\n"]},"targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/settings/server/CachedSettings.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/settings/server/CachedSettings.ts","inputSourceMap":{"version":3,"file":"app/settings/server/CachedSettings.ts","sourceRoot":"","sources":["app/settings/server/CachedSettings.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ISetting, SettingValue } from '@rocket.chat/core-typings';\nimport { Emitter } from '@rocket.chat/emitter';\nimport _ from 'underscore';\n\nimport { SystemLogger } from '../../../server/lib/logger/system';\n\nconst warn = process.env.NODE_ENV === 'development' || process.env.TEST_MODE;\n\ntype SettingsConfig = {\n\tdebounce: number;\n};\n\ntype OverCustomSettingsConfig = Partial<SettingsConfig>;\n\nexport interface ICachedSettings {\n\t/*\n\t * @description: The settings object as ready\n\t */\n\tinitialized(): void;\n\n\thas(_id: ISetting['_id']): boolean;\n\n\tgetSetting(_id: ISetting['_id']): ISetting | undefined;\n\n\tget<T extends SettingValue = SettingValue>(_id: ISetting['_id']): T;\n\n\tgetByRegexp<T extends SettingValue = SettingValue>(_id: RegExp): [string, T][];\n\n\twatchMultiple<T extends SettingValue = SettingValue>(_id: ISetting['_id'][], callback: (settings: T[]) => void): () => void;\n\n\twatch<T extends SettingValue = SettingValue>(_id: ISetting['_id'], cb: (args: T) => void, config?: OverCustomSettingsConfig): () => void;\n\n\twatchOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\tchange<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\tchangeMultiple<T extends SettingValue = SettingValue>(\n\t\t_ids: ISetting['_id'][],\n\t\tcallback: (settings: T[]) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\tchangeOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\tset(record: ISetting): void;\n\n\tgetConfig(config?: OverCustomSettingsConfig): SettingsConfig;\n\n\twatchByRegex(regex: RegExp, cb: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void;\n\n\tchangeByRegex(regex: RegExp, callback: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void;\n\n\tonReady(cb: () => void): void;\n}\n\n/**\n * Class responsible for setting up the settings, cache and propagation changes\n * Should be agnostic to the actual settings implementation, running on meteor or standalone\n *\n * You should not instantiate this class directly, only for testing purposes\n *\n * @extends Emitter\n * @alpha\n */\nexport class CachedSettings\n\textends Emitter<\n\t\t{\n\t\t\t'*': [string, SettingValue];\n\t\t} & {\n\t\t\tready: undefined;\n\t\t\t[k: string]: SettingValue;\n\t\t}\n\t>\n\timplements ICachedSettings\n{\n\tready = false;\n\n\tstore = new Map<string, ISetting>();\n\n\t/**\n\t * The settings object as ready\n\t */\n\tinitialized(): void {\n\t\tif (this.ready) {\n\t\t\treturn;\n\t\t}\n\t\tthis.ready = true;\n\t\tthis.emit('ready');\n\t\tSystemLogger.debug('Settings initialized');\n\t}\n\n\t/**\n\t * returns if the setting is defined\n\t * @param _id - The setting id\n\t * @returns {boolean}\n\t */\n\tpublic has(_id: ISetting['_id']): boolean {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.has(_id);\n\t}\n\n\t/**\n\t * Gets the current Object of the setting\n\t * @param _id - The setting id\n\t * @returns {ISetting} - The current Object of the setting\n\t */\n\tpublic getSetting(_id: ISetting['_id']): ISetting | undefined {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.get(_id);\n\t}\n\n\t/**\n\t * Gets the current value of the setting\n\t * - In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * - The setting's value will be cached in memory so it won't call the DB every time you fetch a particular setting\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t */\n\tpublic get<T extends SettingValue = SettingValue>(_id: ISetting['_id']): T {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.get(_id)?.value as T;\n\t}\n\n\t/**\n\t * Gets the current value of the setting\n\t * - In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * @deprecated\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t */\n\tpublic getByRegexp<T extends SettingValue = SettingValue>(_id: RegExp): [string, T][] {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\n\t\treturn [...this.store.entries()].filter(([key]) => _id.test(key)).map(([key, setting]) => [key, setting.value]) as [string, T][];\n\t}\n\n\t/**\n\t * Get the current value of the settings, and keep track of changes\n\t * - This callback is debounced\n\t * - The callback is not fire until the settings got initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watchMultiple<T extends SettingValue = SettingValue>(_id: ISetting['_id'][], callback: (settings: T[]) => void): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watchMultiple(_id, callback));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\n\t\tif (_id.every((id) => this.store.has(id))) {\n\t\t\tconst settings = _id.map((id) => this.store.get(id)?.value);\n\t\t\tcallback(settings as T[]);\n\t\t}\n\t\tconst mergeFunction = _.debounce((): void => {\n\t\t\tcallback(_id.map((id) => this.store.get(id)?.value) as T[]);\n\t\t}, 100);\n\n\t\tconst fns = _id.map((id) => this.on(id, mergeFunction));\n\t\treturn (): void => {\n\t\t\tfns.forEach((fn) => fn());\n\t\t};\n\t}\n\n\t/**\n\t * Get the current value of the setting, and keep track of changes\n\t * - This callback is debounced\n\t * - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watch<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watch(_id, cb, config));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\n\t\tthis.store.has(_id) && cb(this.store.get(_id)?.value as T);\n\t\treturn this.change(_id, cb, config);\n\t}\n\n\t/**\n\t * Get the current value of the setting, or wait until the initialized\n\t * - This is a one time run\n\t * - This callback is debounced\n\t * - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watchOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tif (this.store.has(_id)) {\n\t\t\tcb(this.store.get(_id)?.value as T);\n\t\t\treturn (): void => undefined;\n\t\t}\n\t\treturn this.changeOnce(_id, cb, config);\n\t}\n\n\t/**\n\t * Observes the given setting by id and keep track of changes\n\t * - This callback is debounced\n\t * - The callback is not fire until the setting is changed\n\t * - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic change<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst { debounce } = this.getConfig(config);\n\t\treturn this.on(_id, _.debounce(callback, debounce) as any);\n\t}\n\n\t/**\n\t * Observes multiple settings and keep track of changes\n\t * - This callback is debounced\n\t * - The callback is not fire until the setting is changed\n\t * - The callback is not fire until all the settings get initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic changeMultiple<T extends SettingValue = SettingValue>(\n\t\t_ids: ISetting['_id'][],\n\t\tcallback: (settings: T[]) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst fns = _ids.map((id) =>\n\t\t\tthis.change(\n\t\t\t\tid,\n\t\t\t\t(): void => {\n\t\t\t\t\tcallback(_ids.map((id) => this.store.get(id)?.value) as T[]);\n\t\t\t\t},\n\t\t\t\tconfig,\n\t\t\t),\n\t\t);\n\t\treturn (): void => {\n\t\t\tfns.forEach((fn) => fn());\n\t\t};\n\t}\n\n\t/**\n\t * Observes the setting and fires only if there is a change. Runs only once\n\t * - This is a one time run\n\t * - This callback is debounced\n\t * - The callback is not fire until the setting is changed\n\t * - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic changeOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst { debounce } = this.getConfig(config);\n\t\treturn this.once(_id, _.debounce(callback, debounce) as any);\n\t}\n\n\t/**\n\t * Sets the value of the setting\n\t * - if the value set is the same as the current value, the change will not be fired\n\t * - if the value is set before the initialization, the emit will be queued and will be fired after initialization\n\t * @param _id - The setting id\n\t * @param value - The value to set\n\t * @returns {void}\n\t */\n\tpublic set(record: ISetting): void {\n\t\tif (this.store.has(record._id) && this.store.get(record._id)?.value === record.value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.store.set(record._id, record);\n\t\tif (!this.ready) {\n\t\t\tthis.once('ready', () => {\n\t\t\t\tthis.emit(record._id, this.store.get(record._id)?.value);\n\t\t\t\tthis.emit('*', [record._id, this.store.get(record._id)?.value]);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tthis.emit(record._id, this.store.get(record._id)?.value);\n\t\tthis.emit('*', [record._id, this.store.get(record._id)?.value]);\n\t}\n\n\tpublic getConfig = (config?: OverCustomSettingsConfig): SettingsConfig => ({\n\t\tdebounce: process.env.TEST_MODE ? 0 : 500,\n\t\t...config,\n\t});\n\n\t/** @deprecated */\n\tpublic watchByRegex(regex: RegExp, cb: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watchByRegex(regex, cb, config));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\t\t[...this.store.entries()].forEach(([key, setting]) => {\n\t\t\tif (regex.test(key)) {\n\t\t\t\tcb(key, setting.value);\n\t\t\t}\n\t\t});\n\n\t\treturn this.changeByRegex(regex, cb, config);\n\t}\n\n\t/** @deprecated */\n\tpublic changeByRegex(regex: RegExp, callback: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void {\n\t\tconst store: Map<string, (...args: [string, SettingValue]) => void> = new Map();\n\t\treturn this.on('*', ([_id, value]) => {\n\t\t\tif (regex.test(_id)) {\n\t\t\t\tconst { debounce } = this.getConfig(config);\n\t\t\t\tconst cb = store.get(_id) || _.debounce(callback, debounce);\n\t\t\t\tcb(_id, value);\n\t\t\t\tstore.set(_id, cb);\n\t\t\t}\n\t\t\tregex.lastIndex = 0;\n\t\t});\n\t}\n\n\t/**\n\t * Wait until the settings get ready then run the callback\n\t */\n\tpublic onReady(cb: () => void): void {\n\t\tif (this.ready) {\n\t\t\treturn cb();\n\t\t}\n\t\tthis.once('ready', cb);\n\t}\n}\n"]}}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    module.export({\n      CachedSettings: () => CachedSettings\n    });\n    let Emitter;\n    module.link(\"@rocket.chat/emitter\", {\n      Emitter(v) {\n        Emitter = v;\n      }\n    }, 0);\n    let _;\n    module.link(\"underscore\", {\n      default(v) {\n        _ = v;\n      }\n    }, 1);\n    let SystemLogger;\n    module.link(\"../../../server/lib/logger/system\", {\n      SystemLogger(v) {\n        SystemLogger = v;\n      }\n    }, 2);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    const warn = process.env.NODE_ENV === 'development' || process.env.TEST_MODE;\n    /**\n     * Class responsible for setting up the settings, cache and propagation changes\n     * Should be agnostic to the actual settings implementation, running on meteor or standalone\n     *\n     * You should not instantiate this class directly, only for testing purposes\n     *\n     * @extends Emitter\n     * @alpha\n     */\n    class CachedSettings extends Emitter {\n      constructor() {\n        super(...arguments);\n        this.ready = false;\n        this.store = new Map();\n        this.getConfig = config => _objectSpread({\n          debounce: process.env.TEST_MODE ? 0 : 500\n        }, config);\n      }\n      /**\n       * The settings object as ready\n       */\n      initialized() {\n        if (this.ready) {\n          return;\n        }\n        this.ready = true;\n        this.emit('ready');\n        SystemLogger.debug('Settings initialized');\n      }\n      /**\n       * returns if the setting is defined\n       * @param _id - The setting id\n       * @returns {boolean}\n       */\n      has(_id) {\n        if (!this.ready && warn) {\n          SystemLogger.warn(\"Settings not initialized yet. getting: \".concat(_id));\n        }\n        return this.store.has(_id);\n      }\n      /**\n       * Gets the current Object of the setting\n       * @param _id - The setting id\n       * @returns {ISetting} - The current Object of the setting\n       */\n      getSetting(_id) {\n        if (!this.ready && warn) {\n          SystemLogger.warn(\"Settings not initialized yet. getting: \".concat(_id));\n        }\n        return this.store.get(_id);\n      }\n      /**\n       * Gets the current value of the setting\n       * - In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n       * - The setting's value will be cached in memory so it won't call the DB every time you fetch a particular setting\n       * @param _id - The setting id\n       * @returns {SettingValue} - The current value of the setting\n       */\n      get(_id) {\n        var _this$store$get;\n        if (!this.ready && warn) {\n          SystemLogger.warn(\"Settings not initialized yet. getting: \".concat(_id));\n        }\n        return (_this$store$get = this.store.get(_id)) === null || _this$store$get === void 0 ? void 0 : _this$store$get.value;\n      }\n      /**\n       * Gets the current value of the setting\n       * - In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n       * @deprecated\n       * @param _id - The setting id\n       * @returns {SettingValue} - The current value of the setting\n       */\n      getByRegexp(_id) {\n        if (!this.ready && warn) {\n          SystemLogger.warn(\"Settings not initialized yet. getting: \".concat(_id));\n        }\n        return [...this.store.entries()].filter(_ref => {\n          let [key] = _ref;\n          return _id.test(key);\n        }).map(_ref2 => {\n          let [key, setting] = _ref2;\n          return [key, setting.value];\n        });\n      }\n      /**\n       * Get the current value of the settings, and keep track of changes\n       * - This callback is debounced\n       * - The callback is not fire until the settings got initialized\n       * @param _ids - Array of setting id\n       * @param callback - The callback to run\n       * @returns {() => void} - A function that can be used to cancel the observe\n       */\n      watchMultiple(_id, callback) {\n        if (!this.ready) {\n          const cancel = new Set();\n          cancel.add(this.once('ready', () => {\n            cancel.clear();\n            cancel.add(this.watchMultiple(_id, callback));\n          }));\n          return () => {\n            cancel.forEach(fn => fn());\n          };\n        }\n        if (_id.every(id => this.store.has(id))) {\n          const settings = _id.map(id => {\n            var _this$store$get2;\n            return (_this$store$get2 = this.store.get(id)) === null || _this$store$get2 === void 0 ? void 0 : _this$store$get2.value;\n          });\n          callback(settings);\n        }\n        const mergeFunction = _.debounce(() => {\n          callback(_id.map(id => {\n            var _this$store$get3;\n            return (_this$store$get3 = this.store.get(id)) === null || _this$store$get3 === void 0 ? void 0 : _this$store$get3.value;\n          }));\n        }, 100);\n        const fns = _id.map(id => this.on(id, mergeFunction));\n        return () => {\n          fns.forEach(fn => fn());\n        };\n      }\n      /**\n       * Get the current value of the setting, and keep track of changes\n       * - This callback is debounced\n       * - The callback is not fire until the settings got initialized\n       * @param _id - The setting id\n       * @param callback - The callback to run\n       * @returns {() => void} - A function that can be used to cancel the observe\n       */\n      watch(_id, cb, config) {\n        var _this$store$get4;\n        if (!this.ready) {\n          const cancel = new Set();\n          cancel.add(this.once('ready', () => {\n            cancel.clear();\n            cancel.add(this.watch(_id, cb, config));\n          }));\n          return () => {\n            cancel.forEach(fn => fn());\n          };\n        }\n        this.store.has(_id) && cb((_this$store$get4 = this.store.get(_id)) === null || _this$store$get4 === void 0 ? void 0 : _this$store$get4.value);\n        return this.change(_id, cb, config);\n      }\n      /**\n       * Get the current value of the setting, or wait until the initialized\n       * - This is a one time run\n       * - This callback is debounced\n       * - The callback is not fire until the settings got initialized\n       * @param _id - The setting id\n       * @param callback - The callback to run\n       * @returns {() => void} - A function that can be used to cancel the observe\n       */\n      watchOnce(_id, cb, config) {\n        if (this.store.has(_id)) {\n          var _this$store$get5;\n          cb((_this$store$get5 = this.store.get(_id)) === null || _this$store$get5 === void 0 ? void 0 : _this$store$get5.value);\n          return () => undefined;\n        }\n        return this.changeOnce(_id, cb, config);\n      }\n      /**\n       * Observes the given setting by id and keep track of changes\n       * - This callback is debounced\n       * - The callback is not fire until the setting is changed\n       * - The callback is not fire until all the settings get initialized\n       * @param _id - The setting id\n       * @param callback - The callback to run\n       * @returns {() => void} - A function that can be used to cancel the observe\n       */\n      change(_id, callback, config) {\n        const {\n          debounce\n        } = this.getConfig(config);\n        return this.on(_id, _.debounce(callback, debounce));\n      }\n      /**\n       * Observes multiple settings and keep track of changes\n       * - This callback is debounced\n       * - The callback is not fire until the setting is changed\n       * - The callback is not fire until all the settings get initialized\n       * @param _ids - Array of setting id\n       * @param callback - The callback to run\n       * @returns {() => void} - A function that can be used to cancel the observe\n       */\n      changeMultiple(_ids, callback, config) {\n        const fns = _ids.map(id => this.change(id, () => {\n          callback(_ids.map(id => {\n            var _this$store$get6;\n            return (_this$store$get6 = this.store.get(id)) === null || _this$store$get6 === void 0 ? void 0 : _this$store$get6.value;\n          }));\n        }, config));\n        return () => {\n          fns.forEach(fn => fn());\n        };\n      }\n      /**\n       * Observes the setting and fires only if there is a change. Runs only once\n       * - This is a one time run\n       * - This callback is debounced\n       * - The callback is not fire until the setting is changed\n       * - The callback is not fire until all the settings get initialized\n       * @param _id - The setting id\n       * @param callback - The callback to run\n       * @returns {() => void} - A function that can be used to cancel the observe\n       */\n      changeOnce(_id, callback, config) {\n        const {\n          debounce\n        } = this.getConfig(config);\n        return this.once(_id, _.debounce(callback, debounce));\n      }\n      /**\n       * Sets the value of the setting\n       * - if the value set is the same as the current value, the change will not be fired\n       * - if the value is set before the initialization, the emit will be queued and will be fired after initialization\n       * @param _id - The setting id\n       * @param value - The value to set\n       * @returns {void}\n       */\n      set(record) {\n        var _this$store$get7, _this$store$get10, _this$store$get11;\n        if (this.store.has(record._id) && ((_this$store$get7 = this.store.get(record._id)) === null || _this$store$get7 === void 0 ? void 0 : _this$store$get7.value) === record.value) {\n          return;\n        }\n        this.store.set(record._id, record);\n        if (!this.ready) {\n          this.once('ready', () => {\n            var _this$store$get8, _this$store$get9;\n            this.emit(record._id, (_this$store$get8 = this.store.get(record._id)) === null || _this$store$get8 === void 0 ? void 0 : _this$store$get8.value);\n            this.emit('*', [record._id, (_this$store$get9 = this.store.get(record._id)) === null || _this$store$get9 === void 0 ? void 0 : _this$store$get9.value]);\n          });\n          return;\n        }\n        this.emit(record._id, (_this$store$get10 = this.store.get(record._id)) === null || _this$store$get10 === void 0 ? void 0 : _this$store$get10.value);\n        this.emit('*', [record._id, (_this$store$get11 = this.store.get(record._id)) === null || _this$store$get11 === void 0 ? void 0 : _this$store$get11.value]);\n      }\n      /** @deprecated */\n      watchByRegex(regex, cb, config) {\n        if (!this.ready) {\n          const cancel = new Set();\n          cancel.add(this.once('ready', () => {\n            cancel.clear();\n            cancel.add(this.watchByRegex(regex, cb, config));\n          }));\n          return () => {\n            cancel.forEach(fn => fn());\n          };\n        }\n        [...this.store.entries()].forEach(_ref3 => {\n          let [key, setting] = _ref3;\n          if (regex.test(key)) {\n            cb(key, setting.value);\n          }\n        });\n        return this.changeByRegex(regex, cb, config);\n      }\n      /** @deprecated */\n      changeByRegex(regex, callback, config) {\n        const store = new Map();\n        return this.on('*', _ref4 => {\n          let [_id, value] = _ref4;\n          if (regex.test(_id)) {\n            const {\n              debounce\n            } = this.getConfig(config);\n            const cb = store.get(_id) || _.debounce(callback, debounce);\n            cb(_id, value);\n            store.set(_id, cb);\n          }\n          regex.lastIndex = 0;\n        });\n      }\n      /**\n       * Wait until the settings get ready then run the callback\n       */\n      onReady(cb) {\n        if (this.ready) {\n          return cb();\n        }\n        this.once('ready', cb);\n      }\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_objectSpread","module","link","default","v","export","CachedSettings","Emitter","_","SystemLogger","__reifyWaitForDeps__","warn","process","env","NODE_ENV","TEST_MODE","constructor","arguments","ready","store","Map","getConfig","config","debounce","initialized","emit","debug","has","_id","concat","getSetting","get","_this$store$get","value","getByRegexp","entries","filter","_ref","key","test","map","_ref2","setting","watchMultiple","callback","cancel","Set","add","once","clear","forEach","fn","every","id","settings","_this$store$get2","mergeFunction","_this$store$get3","fns","on","watch","cb","_this$store$get4","change","watchOnce","_this$store$get5","undefined","changeOnce","changeMultiple","_ids","_this$store$get6","set","record","_this$store$get7","_this$store$get10","_this$store$get11","_this$store$get8","_this$store$get9","watchByRegex","regex","_ref3","changeByRegex","_ref4","lastIndex","onReady","__reify_async_result__","_reifyError","self","async"],"sources":["app/settings/server/CachedSettings.ts"],"sourcesContent":["import type { ISetting, SettingValue } from '@rocket.chat/core-typings';\nimport { Emitter } from '@rocket.chat/emitter';\nimport _ from 'underscore';\n\nimport { SystemLogger } from '../../../server/lib/logger/system';\n\nconst warn = process.env.NODE_ENV === 'development' || process.env.TEST_MODE;\n\ntype SettingsConfig = {\n\tdebounce: number;\n};\n\ntype OverCustomSettingsConfig = Partial<SettingsConfig>;\n\nexport interface ICachedSettings {\n\t/*\n\t * @description: The settings object as ready\n\t */\n\tinitialized(): void;\n\n\thas(_id: ISetting['_id']): boolean;\n\n\tgetSetting(_id: ISetting['_id']): ISetting | undefined;\n\n\tget<T extends SettingValue = SettingValue>(_id: ISetting['_id']): T;\n\n\tgetByRegexp<T extends SettingValue = SettingValue>(_id: RegExp): [string, T][];\n\n\twatchMultiple<T extends SettingValue = SettingValue>(_id: ISetting['_id'][], callback: (settings: T[]) => void): () => void;\n\n\twatch<T extends SettingValue = SettingValue>(_id: ISetting['_id'], cb: (args: T) => void, config?: OverCustomSettingsConfig): () => void;\n\n\twatchOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\tchange<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\tchangeMultiple<T extends SettingValue = SettingValue>(\n\t\t_ids: ISetting['_id'][],\n\t\tcallback: (settings: T[]) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\tchangeOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void;\n\n\tset(record: ISetting): void;\n\n\tgetConfig(config?: OverCustomSettingsConfig): SettingsConfig;\n\n\twatchByRegex(regex: RegExp, cb: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void;\n\n\tchangeByRegex(regex: RegExp, callback: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void;\n\n\tonReady(cb: () => void): void;\n}\n\n/**\n * Class responsible for setting up the settings, cache and propagation changes\n * Should be agnostic to the actual settings implementation, running on meteor or standalone\n *\n * You should not instantiate this class directly, only for testing purposes\n *\n * @extends Emitter\n * @alpha\n */\nexport class CachedSettings\n\textends Emitter<\n\t\t{\n\t\t\t'*': [string, SettingValue];\n\t\t} & {\n\t\t\tready: undefined;\n\t\t\t[k: string]: SettingValue;\n\t\t}\n\t>\n\timplements ICachedSettings\n{\n\tready = false;\n\n\tstore = new Map<string, ISetting>();\n\n\t/**\n\t * The settings object as ready\n\t */\n\tinitialized(): void {\n\t\tif (this.ready) {\n\t\t\treturn;\n\t\t}\n\t\tthis.ready = true;\n\t\tthis.emit('ready');\n\t\tSystemLogger.debug('Settings initialized');\n\t}\n\n\t/**\n\t * returns if the setting is defined\n\t * @param _id - The setting id\n\t * @returns {boolean}\n\t */\n\tpublic has(_id: ISetting['_id']): boolean {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.has(_id);\n\t}\n\n\t/**\n\t * Gets the current Object of the setting\n\t * @param _id - The setting id\n\t * @returns {ISetting} - The current Object of the setting\n\t */\n\tpublic getSetting(_id: ISetting['_id']): ISetting | undefined {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.get(_id);\n\t}\n\n\t/**\n\t * Gets the current value of the setting\n\t * - In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * - The setting's value will be cached in memory so it won't call the DB every time you fetch a particular setting\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t */\n\tpublic get<T extends SettingValue = SettingValue>(_id: ISetting['_id']): T {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\t\treturn this.store.get(_id)?.value as T;\n\t}\n\n\t/**\n\t * Gets the current value of the setting\n\t * - In development mode if you are trying to get the value of a setting that is not defined, it will give an warning, in theory it makes sense, there no reason to do that\n\t * @deprecated\n\t * @param _id - The setting id\n\t * @returns {SettingValue} - The current value of the setting\n\t */\n\tpublic getByRegexp<T extends SettingValue = SettingValue>(_id: RegExp): [string, T][] {\n\t\tif (!this.ready && warn) {\n\t\t\tSystemLogger.warn(`Settings not initialized yet. getting: ${_id}`);\n\t\t}\n\n\t\treturn [...this.store.entries()].filter(([key]) => _id.test(key)).map(([key, setting]) => [key, setting.value]) as [string, T][];\n\t}\n\n\t/**\n\t * Get the current value of the settings, and keep track of changes\n\t * - This callback is debounced\n\t * - The callback is not fire until the settings got initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watchMultiple<T extends SettingValue = SettingValue>(_id: ISetting['_id'][], callback: (settings: T[]) => void): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watchMultiple(_id, callback));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\n\t\tif (_id.every((id) => this.store.has(id))) {\n\t\t\tconst settings = _id.map((id) => this.store.get(id)?.value);\n\t\t\tcallback(settings as T[]);\n\t\t}\n\t\tconst mergeFunction = _.debounce((): void => {\n\t\t\tcallback(_id.map((id) => this.store.get(id)?.value) as T[]);\n\t\t}, 100);\n\n\t\tconst fns = _id.map((id) => this.on(id, mergeFunction));\n\t\treturn (): void => {\n\t\t\tfns.forEach((fn) => fn());\n\t\t};\n\t}\n\n\t/**\n\t * Get the current value of the setting, and keep track of changes\n\t * - This callback is debounced\n\t * - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watch<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watch(_id, cb, config));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\n\t\tthis.store.has(_id) && cb(this.store.get(_id)?.value as T);\n\t\treturn this.change(_id, cb, config);\n\t}\n\n\t/**\n\t * Get the current value of the setting, or wait until the initialized\n\t * - This is a one time run\n\t * - This callback is debounced\n\t * - The callback is not fire until the settings got initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic watchOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcb: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tif (this.store.has(_id)) {\n\t\t\tcb(this.store.get(_id)?.value as T);\n\t\t\treturn (): void => undefined;\n\t\t}\n\t\treturn this.changeOnce(_id, cb, config);\n\t}\n\n\t/**\n\t * Observes the given setting by id and keep track of changes\n\t * - This callback is debounced\n\t * - The callback is not fire until the setting is changed\n\t * - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic change<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst { debounce } = this.getConfig(config);\n\t\treturn this.on(_id, _.debounce(callback, debounce) as any);\n\t}\n\n\t/**\n\t * Observes multiple settings and keep track of changes\n\t * - This callback is debounced\n\t * - The callback is not fire until the setting is changed\n\t * - The callback is not fire until all the settings get initialized\n\t * @param _ids - Array of setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic changeMultiple<T extends SettingValue = SettingValue>(\n\t\t_ids: ISetting['_id'][],\n\t\tcallback: (settings: T[]) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst fns = _ids.map((id) =>\n\t\t\tthis.change(\n\t\t\t\tid,\n\t\t\t\t(): void => {\n\t\t\t\t\tcallback(_ids.map((id) => this.store.get(id)?.value) as T[]);\n\t\t\t\t},\n\t\t\t\tconfig,\n\t\t\t),\n\t\t);\n\t\treturn (): void => {\n\t\t\tfns.forEach((fn) => fn());\n\t\t};\n\t}\n\n\t/**\n\t * Observes the setting and fires only if there is a change. Runs only once\n\t * - This is a one time run\n\t * - This callback is debounced\n\t * - The callback is not fire until the setting is changed\n\t * - The callback is not fire until all the settings get initialized\n\t * @param _id - The setting id\n\t * @param callback - The callback to run\n\t * @returns {() => void} - A function that can be used to cancel the observe\n\t */\n\tpublic changeOnce<T extends SettingValue = SettingValue>(\n\t\t_id: ISetting['_id'],\n\t\tcallback: (args: T) => void,\n\t\tconfig?: OverCustomSettingsConfig,\n\t): () => void {\n\t\tconst { debounce } = this.getConfig(config);\n\t\treturn this.once(_id, _.debounce(callback, debounce) as any);\n\t}\n\n\t/**\n\t * Sets the value of the setting\n\t * - if the value set is the same as the current value, the change will not be fired\n\t * - if the value is set before the initialization, the emit will be queued and will be fired after initialization\n\t * @param _id - The setting id\n\t * @param value - The value to set\n\t * @returns {void}\n\t */\n\tpublic set(record: ISetting): void {\n\t\tif (this.store.has(record._id) && this.store.get(record._id)?.value === record.value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.store.set(record._id, record);\n\t\tif (!this.ready) {\n\t\t\tthis.once('ready', () => {\n\t\t\t\tthis.emit(record._id, this.store.get(record._id)?.value);\n\t\t\t\tthis.emit('*', [record._id, this.store.get(record._id)?.value]);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tthis.emit(record._id, this.store.get(record._id)?.value);\n\t\tthis.emit('*', [record._id, this.store.get(record._id)?.value]);\n\t}\n\n\tpublic getConfig = (config?: OverCustomSettingsConfig): SettingsConfig => ({\n\t\tdebounce: process.env.TEST_MODE ? 0 : 500,\n\t\t...config,\n\t});\n\n\t/** @deprecated */\n\tpublic watchByRegex(regex: RegExp, cb: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void {\n\t\tif (!this.ready) {\n\t\t\tconst cancel = new Set<() => void>();\n\t\t\tcancel.add(\n\t\t\t\tthis.once('ready', (): void => {\n\t\t\t\t\tcancel.clear();\n\t\t\t\t\tcancel.add(this.watchByRegex(regex, cb, config));\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn (): void => {\n\t\t\t\tcancel.forEach((fn) => fn());\n\t\t\t};\n\t\t}\n\t\t[...this.store.entries()].forEach(([key, setting]) => {\n\t\t\tif (regex.test(key)) {\n\t\t\t\tcb(key, setting.value);\n\t\t\t}\n\t\t});\n\n\t\treturn this.changeByRegex(regex, cb, config);\n\t}\n\n\t/** @deprecated */\n\tpublic changeByRegex(regex: RegExp, callback: (...args: [string, SettingValue]) => void, config?: OverCustomSettingsConfig): () => void {\n\t\tconst store: Map<string, (...args: [string, SettingValue]) => void> = new Map();\n\t\treturn this.on('*', ([_id, value]) => {\n\t\t\tif (regex.test(_id)) {\n\t\t\t\tconst { debounce } = this.getConfig(config);\n\t\t\t\tconst cb = store.get(_id) || _.debounce(callback, debounce);\n\t\t\t\tcb(_id, value);\n\t\t\t\tstore.set(_id, cb);\n\t\t\t}\n\t\t\tregex.lastIndex = 0;\n\t\t});\n\t}\n\n\t/**\n\t * Wait until the settings get ready then run the callback\n\t */\n\tpublic onReady(cb: () => void): void {\n\t\tif (this.ready) {\n\t\t\treturn cb();\n\t\t}\n\t\tthis.once('ready', cb);\n\t}\n}\n"],"mappings":";;;IACA,IAAAA,aAAgB;IAAEC,MAAM,CAAAC,IAAA,uCAAuB;MAAAC,QAAAC,CAAA;QAAAJ,aAAA,GAAAI,CAAA;MAAA;IAAA;IAA/CH,MAAA,CAAOI,MAAE;MAAAC,cAAe,EAAAA,CAAA,KAAAA;IAAuB;IAAA,IAAAC,OAAA;IAAAN,MAAA,CAAAC,IAAA;MAAAK,QAAAH,CAAA;QAAAG,OAAA,GAAAH,CAAA;MAAA;IAAA;IAAA,IAAAI,CAAA;IAAAP,MAAA,CAAAC,IAAA;MAAAC,QAAAC,CAAA;QAAAI,CAAA,GAAAJ,CAAA;MAAA;IAAA;IAAA,IAAAK,YAAA;IAAAR,MAAA,CAAAC,IAAA;MAAAO,aAAAL,CAAA;QAAAK,YAAA,GAAAL,CAAA;MAAA;IAAA;IAAA,IAAAM,oBAAA,WAAAA,oBAAA;IAK/C,MAAMC,IAAI,GAAGC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,IAAIF,OAAO,CAACC,GAAG,CAACE,SAAS;IA6D5E;;;;;;;;;IASM,MAAOT,cACZ,SAAQC,OAOP;MAAAS,YAAA;QAAA,SAAAC,SAAA;QAAA,KAGDC,KAAK,GAAG,KAAK;QAAA,KAEbC,KAAK,GAAG,IAAIC,GAAG,EAAoB;QAAA,KAqP5BC,SAAS,GAAIC,MAAiC,IAAAtB,aAAA;UACpDuB,QAAQ,EAAEX,OAAO,CAACC,GAAG,CAACE,SAAS,GAAG,CAAC,GAAG;QAAG,GACtCO,MAAM,CACR;MAAA;MAtPF;;;MAGAE,WAAWA,CAAA;QACV,IAAI,IAAI,CAACN,KAAK,EAAE;UACf;QACD;QACA,IAAI,CAACA,KAAK,GAAG,IAAI;QACjB,IAAI,CAACO,IAAI,CAAC,OAAO,CAAC;QAClBhB,YAAY,CAACiB,KAAK,CAAC,sBAAsB,CAAC;MAC3C;MAEA;;;;;MAKOC,GAAGA,CAACC,GAAoB;QAC9B,IAAI,CAAC,IAAI,CAACV,KAAK,IAAIP,IAAI,EAAE;UACxBF,YAAY,CAACE,IAAI,2CAAAkB,MAAA,CAA2CD,GAAG,CAAE,CAAC;QACnE;QACA,OAAO,IAAI,CAACT,KAAK,CAACQ,GAAG,CAACC,GAAG,CAAC;MAC3B;MAEA;;;;;MAKOE,UAAUA,CAACF,GAAoB;QACrC,IAAI,CAAC,IAAI,CAACV,KAAK,IAAIP,IAAI,EAAE;UACxBF,YAAY,CAACE,IAAI,2CAAAkB,MAAA,CAA2CD,GAAG,CAAE,CAAC;QACnE;QACA,OAAO,IAAI,CAACT,KAAK,CAACY,GAAG,CAACH,GAAG,CAAC;MAC3B;MAEA;;;;;;;MAOOG,GAAGA,CAAwCH,GAAoB;QAAA,IAAAI,eAAA;QACrE,IAAI,CAAC,IAAI,CAACd,KAAK,IAAIP,IAAI,EAAE;UACxBF,YAAY,CAACE,IAAI,2CAAAkB,MAAA,CAA2CD,GAAG,CAAE,CAAC;QACnE;QACA,QAAAI,eAAA,GAAO,IAAI,CAACb,KAAK,CAACY,GAAG,CAACH,GAAG,CAAC,cAAAI,eAAA,uBAAnBA,eAAA,CAAqBC,KAAU;MACvC;MAEA;;;;;;;MAOOC,WAAWA,CAAwCN,GAAW;QACpE,IAAI,CAAC,IAAI,CAACV,KAAK,IAAIP,IAAI,EAAE;UACxBF,YAAY,CAACE,IAAI,2CAAAkB,MAAA,CAA2CD,GAAG,CAAE,CAAC;QACnE;QAEA,OAAO,CAAC,GAAG,IAAI,CAACT,KAAK,CAACgB,OAAO,EAAE,CAAC,CAACC,MAAM,CAACC,IAAA;UAAA,IAAC,CAACC,GAAG,CAAC,GAAAD,IAAA;UAAA,OAAKT,GAAG,CAACW,IAAI,CAACD,GAAG,CAAC;QAAA,EAAC,CAACE,GAAG,CAACC,KAAA;UAAA,IAAC,CAACH,GAAG,EAAEI,OAAO,CAAC,GAAAD,KAAA;UAAA,OAAK,CAACH,GAAG,EAAEI,OAAO,CAACT,KAAK,CAAC;QAAA,EAAkB;MACjI;MAEA;;;;;;;;MAQOU,aAAaA,CAAwCf,GAAsB,EAAEgB,QAAiC;QACpH,IAAI,CAAC,IAAI,CAAC1B,KAAK,EAAE;UAChB,MAAM2B,MAAM,GAAG,IAAIC,GAAG,EAAc;UAEpCD,MAAM,CAACE,GAAG,CACT,IAAI,CAACC,IAAI,CAAC,OAAO,EAAE,MAAW;YAC7BH,MAAM,CAACI,KAAK,EAAE;YACdJ,MAAM,CAACE,GAAG,CAAC,IAAI,CAACJ,aAAa,CAACf,GAAG,EAAEgB,QAAQ,CAAC,CAAC;UAC9C,CAAC,CAAC,CACF;UACD,OAAO,MAAW;YACjBC,MAAM,CAACK,OAAO,CAAEC,EAAE,IAAKA,EAAE,EAAE,CAAC;UAC7B,CAAC;QACF;QAEA,IAAIvB,GAAG,CAACwB,KAAK,CAAEC,EAAE,IAAK,IAAI,CAAClC,KAAK,CAACQ,GAAG,CAAC0B,EAAE,CAAC,CAAC,EAAE;UAC1C,MAAMC,QAAQ,GAAG1B,GAAG,CAACY,GAAG,CAAEa,EAAE;YAAA,IAAAE,gBAAA;YAAA,QAAAA,gBAAA,GAAK,IAAI,CAACpC,KAAK,CAACY,GAAG,CAACsB,EAAE,CAAC,cAAAE,gBAAA,uBAAlBA,gBAAA,CAAoBtB,KAAK;UAAA,EAAC;UAC3DW,QAAQ,CAACU,QAAe,CAAC;QAC1B;QACA,MAAME,aAAa,GAAGhD,CAAC,CAACe,QAAQ,CAAC,MAAW;UAC3CqB,QAAQ,CAAChB,GAAG,CAACY,GAAG,CAAEa,EAAE;YAAA,IAAAI,gBAAA;YAAA,QAAAA,gBAAA,GAAK,IAAI,CAACtC,KAAK,CAACY,GAAG,CAACsB,EAAE,CAAC,cAAAI,gBAAA,uBAAlBA,gBAAA,CAAoBxB,KAAK;UAAA,EAAQ,CAAC;QAC5D,CAAC,EAAE,GAAG,CAAC;QAEP,MAAMyB,GAAG,GAAG9B,GAAG,CAACY,GAAG,CAAEa,EAAE,IAAK,IAAI,CAACM,EAAE,CAACN,EAAE,EAAEG,aAAa,CAAC,CAAC;QACvD,OAAO,MAAW;UACjBE,GAAG,CAACR,OAAO,CAAEC,EAAE,IAAKA,EAAE,EAAE,CAAC;QAC1B,CAAC;MACF;MAEA;;;;;;;;MAQOS,KAAKA,CACXhC,GAAoB,EACpBiC,EAAqB,EACrBvC,MAAiC;QAAA,IAAAwC,gBAAA;QAEjC,IAAI,CAAC,IAAI,CAAC5C,KAAK,EAAE;UAChB,MAAM2B,MAAM,GAAG,IAAIC,GAAG,EAAc;UACpCD,MAAM,CAACE,GAAG,CACT,IAAI,CAACC,IAAI,CAAC,OAAO,EAAE,MAAW;YAC7BH,MAAM,CAACI,KAAK,EAAE;YACdJ,MAAM,CAACE,GAAG,CAAC,IAAI,CAACa,KAAK,CAAChC,GAAG,EAAEiC,EAAE,EAAEvC,MAAM,CAAC,CAAC;UACxC,CAAC,CAAC,CACF;UACD,OAAO,MAAW;YACjBuB,MAAM,CAACK,OAAO,CAAEC,EAAE,IAAKA,EAAE,EAAE,CAAC;UAC7B,CAAC;QACF;QAEA,IAAI,CAAChC,KAAK,CAACQ,GAAG,CAACC,GAAG,CAAC,IAAIiC,EAAE,EAAAC,gBAAA,GAAC,IAAI,CAAC3C,KAAK,CAACY,GAAG,CAACH,GAAG,CAAC,cAAAkC,gBAAA,uBAAnBA,gBAAA,CAAqB7B,KAAU,CAAC;QAC1D,OAAO,IAAI,CAAC8B,MAAM,CAACnC,GAAG,EAAEiC,EAAE,EAAEvC,MAAM,CAAC;MACpC;MAEA;;;;;;;;;MASO0C,SAASA,CACfpC,GAAoB,EACpBiC,EAAqB,EACrBvC,MAAiC;QAEjC,IAAI,IAAI,CAACH,KAAK,CAACQ,GAAG,CAACC,GAAG,CAAC,EAAE;UAAA,IAAAqC,gBAAA;UACxBJ,EAAE,EAAAI,gBAAA,GAAC,IAAI,CAAC9C,KAAK,CAACY,GAAG,CAACH,GAAG,CAAC,cAAAqC,gBAAA,uBAAnBA,gBAAA,CAAqBhC,KAAU,CAAC;UACnC,OAAO,MAAYiC,SAAS;QAC7B;QACA,OAAO,IAAI,CAACC,UAAU,CAACvC,GAAG,EAAEiC,EAAE,EAAEvC,MAAM,CAAC;MACxC;MAEA;;;;;;;;;MASOyC,MAAMA,CACZnC,GAAoB,EACpBgB,QAA2B,EAC3BtB,MAAiC;QAEjC,MAAM;UAAEC;QAAQ,CAAE,GAAG,IAAI,CAACF,SAAS,CAACC,MAAM,CAAC;QAC3C,OAAO,IAAI,CAACqC,EAAE,CAAC/B,GAAG,EAAEpB,CAAC,CAACe,QAAQ,CAACqB,QAAQ,EAAErB,QAAQ,CAAQ,CAAC;MAC3D;MAEA;;;;;;;;;MASO6C,cAAcA,CACpBC,IAAuB,EACvBzB,QAAiC,EACjCtB,MAAiC;QAEjC,MAAMoC,GAAG,GAAGW,IAAI,CAAC7B,GAAG,CAAEa,EAAE,IACvB,IAAI,CAACU,MAAM,CACVV,EAAE,EACF,MAAW;UACVT,QAAQ,CAACyB,IAAI,CAAC7B,GAAG,CAAEa,EAAE;YAAA,IAAAiB,gBAAA;YAAA,QAAAA,gBAAA,GAAK,IAAI,CAACnD,KAAK,CAACY,GAAG,CAACsB,EAAE,CAAC,cAAAiB,gBAAA,uBAAlBA,gBAAA,CAAoBrC,KAAK;UAAA,EAAQ,CAAC;QAC7D,CAAC,EACDX,MAAM,CACN,CACD;QACD,OAAO,MAAW;UACjBoC,GAAG,CAACR,OAAO,CAAEC,EAAE,IAAKA,EAAE,EAAE,CAAC;QAC1B,CAAC;MACF;MAEA;;;;;;;;;;MAUOgB,UAAUA,CAChBvC,GAAoB,EACpBgB,QAA2B,EAC3BtB,MAAiC;QAEjC,MAAM;UAAEC;QAAQ,CAAE,GAAG,IAAI,CAACF,SAAS,CAACC,MAAM,CAAC;QAC3C,OAAO,IAAI,CAAC0B,IAAI,CAACpB,GAAG,EAAEpB,CAAC,CAACe,QAAQ,CAACqB,QAAQ,EAAErB,QAAQ,CAAQ,CAAC;MAC7D;MAEA;;;;;;;;MAQOgD,GAAGA,CAACC,MAAgB;QAAA,IAAAC,gBAAA,EAAAC,iBAAA,EAAAC,iBAAA;QAC1B,IAAI,IAAI,CAACxD,KAAK,CAACQ,GAAG,CAAC6C,MAAM,CAAC5C,GAAG,CAAC,IAAI,EAAA6C,gBAAA,OAAI,CAACtD,KAAK,CAACY,GAAG,CAACyC,MAAM,CAAC5C,GAAG,CAAC,cAAA6C,gBAAA,uBAA1BA,gBAAA,CAA4BxC,KAAK,MAAKuC,MAAM,CAACvC,KAAK,EAAE;UACrF;QACD;QAEA,IAAI,CAACd,KAAK,CAACoD,GAAG,CAACC,MAAM,CAAC5C,GAAG,EAAE4C,MAAM,CAAC;QAClC,IAAI,CAAC,IAAI,CAACtD,KAAK,EAAE;UAChB,IAAI,CAAC8B,IAAI,CAAC,OAAO,EAAE,MAAK;YAAA,IAAA4B,gBAAA,EAAAC,gBAAA;YACvB,IAAI,CAACpD,IAAI,CAAC+C,MAAM,CAAC5C,GAAG,GAAAgD,gBAAA,GAAE,IAAI,CAACzD,KAAK,CAACY,GAAG,CAACyC,MAAM,CAAC5C,GAAG,CAAC,cAAAgD,gBAAA,uBAA1BA,gBAAA,CAA4B3C,KAAK,CAAC;YACxD,IAAI,CAACR,IAAI,CAAC,GAAG,EAAE,CAAC+C,MAAM,CAAC5C,GAAG,GAAAiD,gBAAA,GAAE,IAAI,CAAC1D,KAAK,CAACY,GAAG,CAACyC,MAAM,CAAC5C,GAAG,CAAC,cAAAiD,gBAAA,uBAA1BA,gBAAA,CAA4B5C,KAAK,CAAC,CAAC;UAChE,CAAC,CAAC;UACF;QACD;QACA,IAAI,CAACR,IAAI,CAAC+C,MAAM,CAAC5C,GAAG,GAAA8C,iBAAA,GAAE,IAAI,CAACvD,KAAK,CAACY,GAAG,CAACyC,MAAM,CAAC5C,GAAG,CAAC,cAAA8C,iBAAA,uBAA1BA,iBAAA,CAA4BzC,KAAK,CAAC;QACxD,IAAI,CAACR,IAAI,CAAC,GAAG,EAAE,CAAC+C,MAAM,CAAC5C,GAAG,GAAA+C,iBAAA,GAAE,IAAI,CAACxD,KAAK,CAACY,GAAG,CAACyC,MAAM,CAAC5C,GAAG,CAAC,cAAA+C,iBAAA,uBAA1BA,iBAAA,CAA4B1C,KAAK,CAAC,CAAC;MAChE;MAOA;MACO6C,YAAYA,CAACC,KAAa,EAAElB,EAA6C,EAAEvC,MAAiC;QAClH,IAAI,CAAC,IAAI,CAACJ,KAAK,EAAE;UAChB,MAAM2B,MAAM,GAAG,IAAIC,GAAG,EAAc;UACpCD,MAAM,CAACE,GAAG,CACT,IAAI,CAACC,IAAI,CAAC,OAAO,EAAE,MAAW;YAC7BH,MAAM,CAACI,KAAK,EAAE;YACdJ,MAAM,CAACE,GAAG,CAAC,IAAI,CAAC+B,YAAY,CAACC,KAAK,EAAElB,EAAE,EAAEvC,MAAM,CAAC,CAAC;UACjD,CAAC,CAAC,CACF;UACD,OAAO,MAAW;YACjBuB,MAAM,CAACK,OAAO,CAAEC,EAAE,IAAKA,EAAE,EAAE,CAAC;UAC7B,CAAC;QACF;QACA,CAAC,GAAG,IAAI,CAAChC,KAAK,CAACgB,OAAO,EAAE,CAAC,CAACe,OAAO,CAAC8B,KAAA,IAAmB;UAAA,IAAlB,CAAC1C,GAAG,EAAEI,OAAO,CAAC,GAAAsC,KAAA;UAChD,IAAID,KAAK,CAACxC,IAAI,CAACD,GAAG,CAAC,EAAE;YACpBuB,EAAE,CAACvB,GAAG,EAAEI,OAAO,CAACT,KAAK,CAAC;UACvB;QACD,CAAC,CAAC;QAEF,OAAO,IAAI,CAACgD,aAAa,CAACF,KAAK,EAAElB,EAAE,EAAEvC,MAAM,CAAC;MAC7C;MAEA;MACO2D,aAAaA,CAACF,KAAa,EAAEnC,QAAmD,EAAEtB,MAAiC;QACzH,MAAMH,KAAK,GAA2D,IAAIC,GAAG,EAAE;QAC/E,OAAO,IAAI,CAACuC,EAAE,CAAC,GAAG,EAAEuB,KAAA,IAAiB;UAAA,IAAhB,CAACtD,GAAG,EAAEK,KAAK,CAAC,GAAAiD,KAAA;UAChC,IAAIH,KAAK,CAACxC,IAAI,CAACX,GAAG,CAAC,EAAE;YACpB,MAAM;cAAEL;YAAQ,CAAE,GAAG,IAAI,CAACF,SAAS,CAACC,MAAM,CAAC;YAC3C,MAAMuC,EAAE,GAAG1C,KAAK,CAACY,GAAG,CAACH,GAAG,CAAC,IAAIpB,CAAC,CAACe,QAAQ,CAACqB,QAAQ,EAAErB,QAAQ,CAAC;YAC3DsC,EAAE,CAACjC,GAAG,EAAEK,KAAK,CAAC;YACdd,KAAK,CAACoD,GAAG,CAAC3C,GAAG,EAAEiC,EAAE,CAAC;UACnB;UACAkB,KAAK,CAACI,SAAS,GAAG,CAAC;QACpB,CAAC,CAAC;MACH;MAEA;;;MAGOC,OAAOA,CAACvB,EAAc;QAC5B,IAAI,IAAI,CAAC3C,KAAK,EAAE;UACf,OAAO2C,EAAE,EAAE;QACZ;QACA,IAAI,CAACb,IAAI,CAAC,OAAO,EAAEa,EAAE,CAAC;MACvB;;IACAwB,sBAAA;EAAA,SAAAC,WAAA;IAAA,OAAAD,sBAAA,CAAAC,WAAA;EAAA;EAAAD,sBAAA;AAAA;EAAAE,IAAA;EAAAC,KAAA;AAAA","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"74755486ab6d6d686365c022eb0a4734703d176e"}
