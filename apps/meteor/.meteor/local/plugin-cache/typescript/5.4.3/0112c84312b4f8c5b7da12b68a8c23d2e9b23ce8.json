{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/client/lib/voip/VoIPUser.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"client/lib/voip/VoIPUser.ts","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/client/lib/voip/VoIPUser.ts","inputSourceMap":{"version":3,"file":"client/lib/voip/VoIPUser.ts","sourceRoot":"","sources":["client/lib/voip/VoIPUser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Class representing SIP UserAgent\n * @remarks\n * This class encapsulates all the details of sip.js and exposes\n * a very simple functions and callback handlers to the outside world.\n * This class thus abstracts user from Browser specific media details as well as\n * SIP specific protocol details.\n */\nimport type {\n\tCallStates,\n\tConnectionState,\n\tICallerInfo,\n\tIQueueMembershipSubscription,\n\tSignalingSocketEvents,\n\tSocketEventKeys,\n\tIMediaStreamRenderer,\n\tVoIPUserConfiguration,\n\tVoIpCallerInfo,\n\tIState,\n\tVoipEvents,\n} from '@rocket.chat/core-typings';\nimport { Operation, UserState, WorkflowTypes } from '@rocket.chat/core-typings';\nimport { Emitter } from '@rocket.chat/emitter';\nimport type { UserAgentOptions, InvitationAcceptOptions, Session, SessionInviteOptions } from 'sip.js';\nimport { UserAgent, Invitation, SessionState, Registerer, RequestPendingError, Inviter } from 'sip.js';\nimport type { OutgoingByeRequest, OutgoingRequestDelegate } from 'sip.js/lib/core';\nimport { URI } from 'sip.js/lib/core';\nimport type { SessionDescriptionHandlerOptions } from 'sip.js/lib/platform/web';\nimport { SessionDescriptionHandler } from 'sip.js/lib/platform/web';\n\nimport { toggleMediaStreamTracks } from './Helper';\nimport LocalStream from './LocalStream';\nimport { QueueAggregator } from './QueueAggregator';\nimport RemoteStream from './RemoteStream';\n\nexport class VoIPUser extends Emitter<VoipEvents> {\n\tstate: IState = {\n\t\tisReady: false,\n\t\tenableVideo: false,\n\t};\n\n\tprivate remoteStream: RemoteStream | undefined;\n\n\tuserAgentOptions: UserAgentOptions = {};\n\n\tuserAgent: UserAgent | undefined;\n\n\tregisterer: Registerer | undefined;\n\n\tmediaStreamRendered?: IMediaStreamRenderer;\n\n\tprivate _connectionState: ConnectionState = 'INITIAL';\n\n\tprivate _held = false;\n\n\tprivate mode: WorkflowTypes;\n\n\tprivate queueInfo: QueueAggregator;\n\n\tprivate connectionRetryCount;\n\n\tprivate stop;\n\n\tprivate networkEmitter: Emitter<SignalingSocketEvents>;\n\n\tprivate offlineNetworkHandler: () => void;\n\n\tprivate onlineNetworkHandler: () => void;\n\n\tprivate optionsKeepaliveInterval = 5;\n\n\tprivate optionsKeepAliveDebounceTimeInSec = 5;\n\n\tprivate attemptRegistration = false;\n\n\tprotected session: Session | undefined;\n\n\tprotected _callState: CallStates = 'INITIAL';\n\n\tprotected _callerInfo: ICallerInfo | undefined;\n\n\tprotected _userState: UserState = UserState.IDLE;\n\n\tprotected _opInProgress: Operation = Operation.OP_NONE;\n\n\tget operationInProgress(): Operation {\n\t\treturn this._opInProgress;\n\t}\n\n\tget userState(): UserState | undefined {\n\t\treturn this._userState;\n\t}\n\n\tconstructor(\n\t\tprivate readonly config: VoIPUserConfiguration,\n\t\tmediaRenderer?: IMediaStreamRenderer,\n\t) {\n\t\tsuper();\n\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\tthis.networkEmitter = new Emitter<SignalingSocketEvents>();\n\t\tthis.connectionRetryCount = this.config.connectionRetryCount;\n\t\tthis.stop = false;\n\n\t\tthis.onlineNetworkHandler = this.onNetworkRestored.bind(this);\n\t\tthis.offlineNetworkHandler = this.onNetworkLost.bind(this);\n\t}\n\n\t/**\n\t * Configures and initializes sip.js UserAgent\n\t * call gets established.\n\t * @remarks\n\t * This class configures transport properties such as websocket url, passed down in config,\n\t * sets up ICE servers,\n\t * SIP UserAgent options such as userName, Password, URI.\n\t * Once initialized, it starts the userAgent.\n\t */\n\n\tasync init(): Promise<void> {\n\t\tconst sipUri = `sip:${this.config.authUserName}@${this.config.sipRegistrarHostnameOrIP}`;\n\t\tconst transportOptions = {\n\t\t\tserver: this.config.webSocketURI,\n\t\t\tconnectionTimeout: 100, // Replace this with config\n\t\t\tkeepAliveInterval: 20,\n\t\t\t// traceSip: true,\n\t\t};\n\t\tconst sdpFactoryOptions = {\n\t\t\ticeGatheringTimeout: 10,\n\t\t\tpeerConnectionConfiguration: {\n\t\t\t\ticeServers: this.config.iceServers,\n\t\t\t},\n\t\t};\n\t\tthis.userAgentOptions = {\n\t\t\tdelegate: {\n\t\t\t\tonInvite: async (invitation: Invitation): Promise<void> => {\n\t\t\t\t\tawait this.handleIncomingCall(invitation);\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthorizationPassword: this.config.authPassword,\n\t\t\tauthorizationUsername: this.config.authUserName,\n\t\t\turi: UserAgent.makeURI(sipUri),\n\t\t\ttransportOptions,\n\t\t\tsessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n\t\t\tlogConfiguration: false,\n\t\t\tlogLevel: 'error',\n\t\t};\n\n\t\tthis.userAgent = new UserAgent(this.userAgentOptions);\n\t\tthis.userAgent.transport.isConnected();\n\t\tthis._opInProgress = Operation.OP_CONNECT;\n\t\ttry {\n\t\t\tthis.registerer = new Registerer(this.userAgent);\n\n\t\t\tthis.userAgent.transport.onConnect = this.onConnected.bind(this);\n\t\t\tthis.userAgent.transport.onDisconnect = this.onDisconnected.bind(this);\n\t\t\twindow.addEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.addEventListener('offline', this.offlineNetworkHandler);\n\t\t\tawait this.userAgent.start();\n\t\t\tif (this.config.enableKeepAliveUsingOptionsForUnstableNetworks) {\n\t\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync onConnected(): Promise<void> {\n\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\tthis.state.isReady = true;\n\t\tthis.sendOptions();\n\t\tthis.networkEmitter.emit('connected');\n\t\t/**\n\t\t * Re-registration post network recovery should be attempted\n\t\t * if it was previously registered or incall/onhold\n\t\t */\n\n\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\tthis.attemptRegistration = true;\n\t\t}\n\t}\n\n\tonDisconnected(error: any): void {\n\t\tthis._connectionState = 'SERVER_DISCONNECTED';\n\t\tthis._opInProgress = Operation.OP_NONE;\n\t\tthis.networkEmitter.emit('disconnected');\n\t\tif (error) {\n\t\t\tthis.networkEmitter.emit('connectionerror', error);\n\t\t\tthis.state.isReady = false;\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted assuming\n\t\t\t * that the disconnect happened from the remote side or due to sleep\n\t\t\t * In case of remote side disconnection, if config.connectionRetryCount is -1,\n\t\t\t * attemptReconnection attempts continuously. Else stops after |config.connectionRetryCount|\n\t\t\t *\n\t\t\t */\n\t\t\t// this.attemptReconnection();\n\t\t\tthis.attemptReconnection(0, false);\n\t\t}\n\t}\n\n\tonNetworkRestored(): void {\n\t\tthis.networkEmitter.emit('localnetworkonline');\n\t\tif (this._connectionState === 'WAITING_FOR_NETWORK') {\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted when online event handler\n\t\t\t * gets notified.\n\t\t\t * Important thing to note is that the second parameter |checkRegistration| = true passed here\n\t\t\t * because after the network recovery and after reconnecting to the server,\n\t\t\t * the transport layer of SIPUA does not call onConnected. So by passing |checkRegistration = true |\n\t\t\t * the code will check if the endpoint was previously registered before the disconnection.\n\t\t\t * If such is the case, it will first unregister and then re-register.\n\t\t\t * */\n\t\t\tthis.attemptReconnection();\n\t\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\t\tthis.attemptRegistration = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tonNetworkLost(): void {\n\t\tthis.networkEmitter.emit('localnetworkoffline');\n\t\tthis._connectionState = 'WAITING_FOR_NETWORK';\n\t}\n\n\tget userConfig(): VoIPUserConfiguration {\n\t\treturn this.config;\n\t}\n\n\tget callState(): CallStates {\n\t\treturn this._callState;\n\t}\n\n\tget connectionState(): ConnectionState {\n\t\treturn this._connectionState;\n\t}\n\n\tget callerInfo(): VoIpCallerInfo {\n\t\tif (\n\t\t\tthis.callState === 'IN_CALL' ||\n\t\t\tthis.callState === 'OFFER_RECEIVED' ||\n\t\t\tthis.callState === 'ON_HOLD' ||\n\t\t\tthis.callState === 'OFFER_SENT'\n\t\t) {\n\t\t\tif (!this._callerInfo) {\n\t\t\t\tthrow new Error('[VoIPUser callerInfo] invalid state');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: this.callState,\n\t\t\t\tcaller: this._callerInfo,\n\t\t\t\tuserState: this._userState,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tstate: this.callState,\n\t\t\tuserState: this._userState,\n\t\t};\n\t}\n\n\t/* Media Stream functions begin */\n\t/** The local media stream. Undefined if call not answered. */\n\tget localMediaStream(): MediaStream | undefined {\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\t\treturn sdh.localMediaStream;\n\t}\n\n\t/* Media Stream functions end */\n\t/* OutgoingRequestDelegate methods begin */\n\tonRegistrationRequestAccept(): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis._callState = 'REGISTERED';\n\t\t\tthis.emit('registered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\tthis.emit('unregistered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t}\n\n\tonRegistrationRequestReject(error: any): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis.emit('registrationerror', error);\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis.emit('unregistrationerror', error);\n\t\t}\n\t}\n\t/* OutgoingRequestDelegate methods end */\n\n\tprivate async handleIncomingCall(invitation: Invitation): Promise<void> {\n\t\tif (this.callState === 'REGISTERED') {\n\t\t\tthis._opInProgress = Operation.OP_PROCESS_INVITE;\n\t\t\tthis._callState = 'OFFER_RECEIVED';\n\t\t\tthis._userState = UserState.UAS;\n\t\t\tthis.session = invitation;\n\t\t\tthis.setupSessionEventHandlers(invitation);\n\t\t\tconst callerInfo: ICallerInfo = {\n\t\t\t\tcallerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n\t\t\t\tcallerName: invitation.remoteIdentity.displayName,\n\t\t\t\thost: invitation.remoteIdentity.uri.host,\n\t\t\t};\n\t\t\tthis._callerInfo = callerInfo;\n\t\t\tthis.emit('incomingcall', callerInfo);\n\t\t\tthis.emit('stateChanged');\n\t\t\treturn;\n\t\t}\n\n\t\tawait invitation.reject();\n\t}\n\n\t/**\n\t * Sets up an listener handler for handling session's state change\n\t * @remarks\n\t * Called for setting up various state listeners. These listeners will\n\t * decide the next action to be taken when the session state changes.\n\t * e.g when session.state changes from |Establishing| to |Established|\n\t * one must set up local and remote media rendering.\n\t *\n\t * This class handles such session state changes and takes necessary actions.\n\t */\n\n\tprotected setupSessionEventHandlers(session: Session): void {\n\t\tthis.session?.stateChange.addListener((state: SessionState) => {\n\t\t\tif (this.session !== session) {\n\t\t\t\treturn; // if our session has changed, just return\n\t\t\t}\n\t\t\tswitch (state) {\n\t\t\t\tcase SessionState.Initial:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Establishing:\n\t\t\t\t\tthis.emit('ringing', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Established:\n\t\t\t\t\tif (this._userState === UserState.UAC) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * We need to decide about user-state ANSWER-RECEIVED for outbound.\n\t\t\t\t\t\t * This state is there for the symmetry of ANSWER-SENT.\n\t\t\t\t\t\t * ANSWER-SENT occurs when there is incoming invite. So then the UA\n\t\t\t\t\t\t * accepts a call, it sends the answer and state becomes ANSWER-SENT.\n\t\t\t\t\t\t * The call gets established only when the remote party sends ACK.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * But in case of UAC where the invite is sent out, there is no intermediate\n\t\t\t\t\t\t * state where the UA can be in ANSWER-RECEIVED. As soon this UA receives the answer,\n\t\t\t\t\t\t * it sends ack and changes the SessionState to established.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * So we do not have an actual state transitions from ANSWER-RECEIVED to IN-CALL.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Nevertheless, this state is just added to maintain the symmetry. This can be safely removed.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * */\n\t\t\t\t\t\tthis._callState = 'ANSWER_RECEIVED';\n\t\t\t\t\t}\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis.setupRemoteMedia();\n\t\t\t\t\tthis._callState = 'IN_CALL';\n\t\t\t\t\tthis.emit('callestablished', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Terminating:\n\t\t\t\t// fall through\n\t\t\t\tcase SessionState.Terminated:\n\t\t\t\t\tthis.session = undefined;\n\t\t\t\t\tthis._callState = 'REGISTERED';\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._userState = UserState.IDLE;\n\t\t\t\t\tthis.emit('callterminated');\n\t\t\t\t\tthis.remoteStream?.clear();\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown session state.');\n\t\t\t}\n\t\t});\n\t}\n\n\tonTrackAdded(_event: any): void {\n\t\tconsole.log('onTrackAdded');\n\t}\n\n\tonTrackRemoved(_event: any): void {\n\t\tconsole.log('onTrackRemoved');\n\t}\n\n\t/**\n\t * Carries out necessary steps for rendering remote media whe\n\t * call gets established.\n\t * @remarks\n\t * Sets up Stream class and plays the stream on given Media element/\n\t * Also sets up various event handlers.\n\t */\n\tprivate setupRemoteMedia(): any {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\n\t\tconst remoteStream = sdh.remoteMediaStream;\n\t\tif (!remoteStream) {\n\t\t\tthrow new Error('Remote media stream is undefined.');\n\t\t}\n\n\t\tthis.remoteStream = new RemoteStream(remoteStream);\n\t\tconst mediaElement = this.mediaStreamRendered?.remoteMediaElement;\n\t\tif (mediaElement) {\n\t\t\tthis.remoteStream.init(mediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\t/**\n\t * Handles call mute-unmute\n\t */\n\tprivate async handleMuteUnmute(muteState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === muteState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = muteState;\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\tthis.emit('muteerror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A mute request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('muteerror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles call hold-unhold\n\t */\n\tprivate async handleHoldUnhold(holdState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === holdState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = holdState;\n\t\t\t\t\tthis._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis.emit('holderror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Session properties used to pass options to the SessionDescriptionHandler:\n\t\t//\n\t\t// 1) Session.sessionDescriptionHandlerOptions\n\t\t//    SDH options for the initial INVITE transaction.\n\t\t//    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n\t\t//\n\t\t// 2) Session.sessionDescriptionHandlerOptionsReInvite\n\t\t//    SDH options for re-INVITE transactions.\n\t\t//    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Session.invite().\n\n\t\tconst sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite as SessionDescriptionHandlerOptions;\n\t\tsessionDescriptionHandlerOptions.hold = holdState;\n\t\tsession.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A hold request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('holderror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tstatic async create(config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer): Promise<VoIPUser> {\n\t\tconst voip = new VoIPUser(config, mediaRenderer);\n\t\tawait voip.init();\n\t\treturn voip;\n\t}\n\n\t/**\n\t * Sends SIP OPTIONS message to asterisk\n\t *\n\t * There is an interesting problem that happens with Asterisk.\n\t * After websocket connection succeeds and if there is no SIP\n\t * message goes in 30 seconds, asterisk disconnects the socket.\n\t *\n\t * If any SIP message goes before 30 seconds, asterisk holds the connection.\n\t * This problem could be solved in multiple ways. One is that\n\t * whenever disconnect happens make sure that the socket is connected back using\n\t * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n\t * every 30 seconds till we send register message.\n\t *\n\t * Another approach is to send SIP OPTIONS just to tell server that\n\t * there is a UA using this socket. This is implemented below\n\t */\n\n\tsendOptions(outgoingRequestDelegate?: OutgoingRequestDelegate): void {\n\t\tconst uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n\t\tconst outgoingMessage = this.userAgent?.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\t\tif (outgoingMessage) {\n\t\t\tthis.userAgent?.userAgentCore.request(outgoingMessage, outgoingRequestDelegate);\n\t\t}\n\t}\n\t/**\n\t * Public method called from outside to register the SIP UA with call server.\n\t * @remarks\n\t */\n\n\tregister(): void {\n\t\tthis._opInProgress = Operation.OP_REGISTER;\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Public method called from outside to unregister the SIP UA.\n\t * @remarks\n\t */\n\n\tunregister(): void {\n\t\tthis._opInProgress = Operation.OP_UNREGISTER;\n\t\tthis.registerer?.unregister({\n\t\t\tall: true,\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\t/**\n\t * Public method called from outside to accept incoming call.\n\t * @remarks\n\t */\n\n\tasync acceptCall(mediaRenderer: IMediaStreamRenderer): Promise<void> {\n\t\tif (mediaRenderer) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t}\n\t\t// Call state must be in offer_received.\n\t\tif (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n\t\t\tthis._callState = 'ANSWER_SENT';\n\t\t\t// Something is wrong, this session is not an instance of INVITE\n\t\t\tif (!(this.session instanceof Invitation)) {\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\t}\n\t\t\t/**\n\t\t\t * It is important to decide when to add video option to the outgoing offer.\n\t\t\t * This would matter when the reinvite goes out (In case of hold/unhold)\n\t\t\t * This was added because there were failures in hold-unhold.\n\t\t\t * The scenario was that if this client does hold-unhold first, and remote client does\n\t\t\t * later, remote client goes in inconsistent state and hold-unhold does not work\n\t\t\t * Where as if the remote client does hold-unhold first, this client can do it any number\n\t\t\t * of times.\n\t\t\t *\n\t\t\t * Logic below works as follows\n\t\t\t * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n\t\t\t * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n\t\t\t * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n\t\t\t * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n\t\t\t *\n\t\t\t */\n\t\t\tlet videoInvite = !!this.config.enableVideo;\n\n\t\t\tconst { body } = this.session;\n\t\t\tif (body && body.indexOf('m=video') === -1) {\n\t\t\t\tvideoInvite = false;\n\t\t\t}\n\n\t\t\tconst invitationAcceptOptions: InvitationAcceptOptions = {\n\t\t\t\tsessionDescriptionHandlerOptions: {\n\t\t\t\t\tconstraints: {\n\t\t\t\t\t\taudio: true,\n\t\t\t\t\t\tvideo: !!this.config.enableVideo && videoInvite,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\treturn this.session.accept(invitationAcceptOptions);\n\t\t}\n\t\tthrow new Error('Something went wrong');\n\t}\n\n\t/* Helper routines for checking call actions BEGIN */\n\n\tprivate canRejectCall(): boolean {\n\t\treturn ['OFFER_RECEIVED', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\tprivate canEndOrHoldCall(): boolean {\n\t\treturn ['ANSWER_SENT', 'ANSWER_RECEIVED', 'IN_CALL', 'ON_HOLD', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\t/* Helper routines for checking call actions END */\n\n\t/**\n\t * Public method called from outside to reject a call.\n\t * @remarks\n\t */\n\trejectCall(): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canRejectCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tif (!(this.session instanceof Invitation)) {\n\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t}\n\t\treturn this.session.reject();\n\t}\n\n\t/**\n\t * Public method called from outside to end a call.\n\t * @remarks\n\t */\n\tasync endCall(): Promise<OutgoingByeRequest | void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\n\t\t// When call ends, force state to be revisited\n\t\tthis.emit('stateChanged');\n\t\tswitch (this.session.state) {\n\t\t\tcase SessionState.Initial:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Establishing:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tif (this.session instanceof Inviter) {\n\t\t\t\t\treturn this.session.cancel();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Established:\n\t\t\t\treturn this.session.bye();\n\t\t\tcase SessionState.Terminating:\n\t\t\t\tbreak;\n\t\t\tcase SessionState.Terminated:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown state');\n\t\t}\n\t}\n\n\t/**\n\t * Public method called from outside to mute the call.\n\t * @remarks\n\t */\n\tasync muteCall(muteState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'IN_CALL') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleMuteUnmute(muteState);\n\t}\n\n\t/**\n\t * Public method called from outside to hold the call.\n\t * @remarks\n\t */\n\tasync holdCall(holdState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleHoldUnhold(holdState);\n\t}\n\n\t/* CallEventDelegate implementation end */\n\tisReady(): boolean {\n\t\treturn this.state.isReady;\n\t}\n\n\t/**\n\t * This function allows to change the media renderer media elements.\n\t */\n\tswitchMediaRenderer(mediaRenderer: IMediaStreamRenderer): void {\n\t\tif (this.remoteStream) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t\tthis.remoteStream.init(mediaRenderer.remoteMediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\tsetWorkflowMode(mode: WorkflowTypes): void {\n\t\tthis.mode = mode;\n\t\tif (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\tthis.queueInfo = new QueueAggregator();\n\t\t}\n\t}\n\n\tsetMembershipSubscription(subscription: IQueueMembershipSubscription): void {\n\t\tif (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\treturn;\n\t\t}\n\t\tthis.queueInfo?.setMembership(subscription);\n\t}\n\n\tgetAggregator(): QueueAggregator {\n\t\treturn this.queueInfo;\n\t}\n\n\tgetRegistrarState(): string | undefined {\n\t\treturn this.registerer?.state.toString().toLocaleLowerCase();\n\t}\n\n\tclear(): void {\n\t\tthis._opInProgress = Operation.OP_CLEANUP;\n\t\t/** Socket reconnection is attempted when the socket is disconnected with some error.\n\t\t * While disconnecting, if there is any socket error, there should be no reconnection attempt.\n\t\t * So when userAgent.stop() is called which closes the sockets, it should be made sure that\n\t\t * if the socket is disconnected with error, connection attempts are not started or\n\t\t * if there are any previously ongoing attempts, they should be terminated.\n\t\t * flag attemptReconnect is used for ensuring this.\n\t\t */\n\t\tthis.stop = true;\n\t\tthis.userAgent?.stop();\n\t\tthis.registerer?.dispose();\n\t\tthis._connectionState = 'STOP';\n\n\t\tif (this.userAgent) {\n\t\t\tthis.userAgent.transport.onConnect = undefined;\n\t\t\tthis.userAgent.transport.onDisconnect = undefined;\n\t\t\twindow.removeEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.removeEventListener('offline', this.offlineNetworkHandler);\n\t\t}\n\t}\n\n\tonNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.on(event, handler);\n\t}\n\n\toffNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.off(event, handler);\n\t}\n\n\t/**\n\t * Connection is lost in 3 ways\n\t * 1. When local network is lost (Router is disconnected, switching networks, devtools->network->offline)\n\t * In this case, the SIP.js's transport layer does not detect the disconnection. Hence, it does not\n\t * call |onDisconnect|. To detect this kind of disconnection, window event listeners have been added.\n\t * These event listeners would be get called when the browser detects that network is offline or online.\n\t * When the network is restored, the code tries to reconnect. The useragent.transport \"does not\" generate the\n\t * onconnected event in this case as well. so onlineNetworkHandler calls attemptReconnection.\n\t * Which calls attemptRegistrationPostRecovery based on correct state. attemptRegistrationPostRecovery first tries to\n\t * unregister and then re-register.\n\t * Important note : We use the event listeners using bind function object offlineNetworkHandler and onlineNetworkHandler\n\t * It is done so because the same event handlers need to be used for removeEventListener, which becomes impossible\n\t * if done inline.\n\t *\n\t * 2. Computer goes to sleep. In this case onDisconnect is triggered. The code tries to reconnect but cant go ahead\n\t * as it goes to sleep. On waking up, The attemptReconnection gets executed, connection is completed.\n\t * In this case, it generates onConnected event. In this onConnected event it calls attemptRegistrationPostRecovery\n\t *\n\t * 3. When Asterisk disconnects all the endpoints either because it crashes or restarted,\n\t * As soon as the agent successfully connects to asterisk, it should re-register\n\t *\n\t * Retry count :\n\t * connectionRetryCount is the parameter called |Retry Count| in\n\t * Administration -> Call Center -> Server configuration -> Retry count.\n\t * The retry is implemented with backoff, maxbackoff = 8 seconds.\n\t * For continuous retries (In case Asterisk restart happens) Set this parameter to -1.\n\t *\n\t * Important to note is how attemptRegistrationPostRecovery is called. In case of\n\t * the router connection loss or while switching the networks,\n\t * there is no disconnect and connect event from the transport layer of the userAgent.\n\t * So in this case, when the connection is successful after reconnect, the code should try to re-register by calling\n\t * attemptRegistrationPostRecovery.\n\t * In case of computer waking from sleep or asterisk getting restored, connect and disconnect events are generated.\n\t * In this case, re-registration should be triggered (by calling) only when onConnected gets called and not otherwise.\n\t */\n\n\tasync attemptReconnection(reconnectionAttempt = 0, checkRegistration = false): Promise<void> {\n\t\tconst reconnectionAttempts = this.connectionRetryCount;\n\t\tthis._connectionState = 'SERVER_RECONNECTING';\n\t\tif (!this.userAgent) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.stop) {\n\t\t\treturn;\n\t\t}\n\t\t// reconnectionAttempts == -1 then keep continuously trying\n\t\tif (reconnectionAttempts !== -1 && reconnectionAttempt > reconnectionAttempts) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\treturn;\n\t\t}\n\n\t\tconst reconnectionDelay = Math.pow(2, reconnectionAttempt % 4);\n\n\t\tconsole.error(`Attempting to reconnect with backoff due to network loss. Backoff time [${reconnectionDelay}]`);\n\t\tsetTimeout(() => {\n\t\t\tif (this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState === 'SERVER_CONNECTED') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.userAgent\n\t\t\t\t?.reconnect()\n\t\t\t\t.then(() => {\n\t\t\t\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\t\t\t})\n\t\t\t\t.catch(() => {\n\t\t\t\t\tthis.attemptReconnection(++reconnectionAttempt, checkRegistration);\n\t\t\t\t});\n\t\t}, reconnectionDelay * 1000);\n\t}\n\n\tasync attemptPostRecoveryRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tthis.sendOptions({\n\t\t\tonAccept: (): void => {\n\t\t\t\tthis.attemptPostRecoveryRegistrationRoutine();\n\t\t\t},\n\t\t\tonReject: (error: unknown): void => {\n\t\t\t\tconsole.error(`[${error}] Failed to do options in attemptPostRecoveryRoutine()`);\n\t\t\t},\n\t\t});\n\t}\n\n\tasync sendKeepAliveAndWaitForResponse(withDebounce = false): Promise<boolean> {\n\t\tconst promise = new Promise<boolean>((resolve, reject) => {\n\t\t\tlet keepAliveAccepted = false;\n\t\t\tlet responseWaitTime = this.optionsKeepaliveInterval / 2;\n\t\t\tif (withDebounce) {\n\t\t\t\tresponseWaitTime += this.optionsKeepAliveDebounceTimeInSec;\n\t\t\t}\n\n\t\t\tthis.sendOptions({\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tkeepAliveAccepted = true;\n\t\t\t\t},\n\t\t\t\tonReject: (_error: unknown): void => {\n\t\t\t\t\tconsole.error('Failed to do options.');\n\t\t\t\t},\n\t\t\t});\n\t\t\tsetTimeout(async () => {\n\t\t\t\tif (!keepAliveAccepted) {\n\t\t\t\t\treject(false);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.attemptRegistration) {\n\t\t\t\t\t\tthis.attemptPostRecoveryRoutine();\n\t\t\t\t\t\tthis.attemptRegistration = false;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(true);\n\t\t\t\t}\n\t\t\t}, responseWaitTime * 1000);\n\t\t});\n\t\treturn promise;\n\t}\n\n\tasync startOptionsPingForUnstableNetworks(): Promise<void> {\n\t\tsetTimeout(async () => {\n\t\t\tif (!this.userAgent || this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState !== 'SERVER_RECONNECTING') {\n\t\t\t\tlet isConnected = false;\n\t\t\t\ttry {\n\t\t\t\t\tawait this.sendKeepAliveAndWaitForResponse();\n\t\t\t\t\tisConnected = true;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(`[${e}] Failed to do options ping.`);\n\t\t\t\t} finally {\n\t\t\t\t\t// Send event only if it's a \"change\" on the status (avoid unnecessary event flooding)\n\t\t\t\t\t!isConnected && this.networkEmitter.emit('disconnected');\n\t\t\t\t\tisConnected && this.networkEmitter.emit('connected');\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Each seconds check if the network can reach asterisk. If not, try to reconnect\n\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t}, this.optionsKeepaliveInterval * 1000);\n\t}\n\n\tasync attemptPostRecoveryRegistrationRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tconst promise = new Promise<void>((_resolve, _reject) => {\n\t\t\tthis.registerer?.unregister({\n\t\t\t\tall: true,\n\t\t\t\trequestDelegate: {\n\t\t\t\t\tonAccept: (): void => {\n\t\t\t\t\t\t_resolve();\n\t\t\t\t\t},\n\t\t\t\t\tonReject: (error): void => {\n\t\t\t\t\t\tconsole.error(`[${error}] While unregistering after recovery`);\n\t\t\t\t\t\tthis.emit('unregistrationerror', error);\n\t\t\t\t\t\t_reject('Error in Unregistering');\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t\ttry {\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\tconsole.error(`[${error}] While waiting for unregister promise`);\n\t\t}\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonReject: (error): void => {\n\t\t\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\t\t\tthis.emit('registrationerror', error);\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\tasync changeAudioInputDevice(constraints: MediaStreamConstraints): Promise<boolean> {\n\t\tif (!this.session) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No session. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst newStream = await LocalStream.requestNewStream(constraints, this.session);\n\t\tif (!newStream) {\n\t\t\tconsole.warn('changeAudioInputDevice() : Unable to get local stream. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No peer connection. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tLocalStream.replaceTrack(peerConnection, newStream, 'audio');\n\t\treturn true;\n\t}\n\n\t// Commenting this as Video Configuration is not part of the scope for now\n\t// async changeVideoInputDevice(selectedVideoDevices: IDevice): Promise<boolean> {\n\t// \tif (!this.session) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No session. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tif (!this.config.enableVideo || this.deviceManager.hasVideoInputDevice()) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable change video device. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tthis.deviceManager.changeVideoInputDevice(selectedVideoDevices);\n\t// \tconst newStream = await LocalStream.requestNewStream(this.deviceManager.getConstraints('video'), this.session);\n\t// \tif (!newStream) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable to get local stream. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t// \tif (!peerConnection) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No peer connection. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tLocalStream.replaceTrack(peerConnection, newStream, 'video');\n\t// \treturn true;\n\t// }\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\tasync makeCallURI(_callee: string, _mediaRenderer?: IMediaStreamRenderer): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\tasync makeCall(_calleeNumber: string): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n}\n"]},"targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/client/lib/voip/VoIPUser.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"client/lib/voip/VoIPUser.ts","inputSourceMap":{"version":3,"file":"client/lib/voip/VoIPUser.ts","sourceRoot":"","sources":["client/lib/voip/VoIPUser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Class representing SIP UserAgent\n * @remarks\n * This class encapsulates all the details of sip.js and exposes\n * a very simple functions and callback handlers to the outside world.\n * This class thus abstracts user from Browser specific media details as well as\n * SIP specific protocol details.\n */\nimport type {\n\tCallStates,\n\tConnectionState,\n\tICallerInfo,\n\tIQueueMembershipSubscription,\n\tSignalingSocketEvents,\n\tSocketEventKeys,\n\tIMediaStreamRenderer,\n\tVoIPUserConfiguration,\n\tVoIpCallerInfo,\n\tIState,\n\tVoipEvents,\n} from '@rocket.chat/core-typings';\nimport { Operation, UserState, WorkflowTypes } from '@rocket.chat/core-typings';\nimport { Emitter } from '@rocket.chat/emitter';\nimport type { UserAgentOptions, InvitationAcceptOptions, Session, SessionInviteOptions } from 'sip.js';\nimport { UserAgent, Invitation, SessionState, Registerer, RequestPendingError, Inviter } from 'sip.js';\nimport type { OutgoingByeRequest, OutgoingRequestDelegate } from 'sip.js/lib/core';\nimport { URI } from 'sip.js/lib/core';\nimport type { SessionDescriptionHandlerOptions } from 'sip.js/lib/platform/web';\nimport { SessionDescriptionHandler } from 'sip.js/lib/platform/web';\n\nimport { toggleMediaStreamTracks } from './Helper';\nimport LocalStream from './LocalStream';\nimport { QueueAggregator } from './QueueAggregator';\nimport RemoteStream from './RemoteStream';\n\nexport class VoIPUser extends Emitter<VoipEvents> {\n\tstate: IState = {\n\t\tisReady: false,\n\t\tenableVideo: false,\n\t};\n\n\tprivate remoteStream: RemoteStream | undefined;\n\n\tuserAgentOptions: UserAgentOptions = {};\n\n\tuserAgent: UserAgent | undefined;\n\n\tregisterer: Registerer | undefined;\n\n\tmediaStreamRendered?: IMediaStreamRenderer;\n\n\tprivate _connectionState: ConnectionState = 'INITIAL';\n\n\tprivate _held = false;\n\n\tprivate mode: WorkflowTypes;\n\n\tprivate queueInfo: QueueAggregator;\n\n\tprivate connectionRetryCount;\n\n\tprivate stop;\n\n\tprivate networkEmitter: Emitter<SignalingSocketEvents>;\n\n\tprivate offlineNetworkHandler: () => void;\n\n\tprivate onlineNetworkHandler: () => void;\n\n\tprivate optionsKeepaliveInterval = 5;\n\n\tprivate optionsKeepAliveDebounceTimeInSec = 5;\n\n\tprivate attemptRegistration = false;\n\n\tprotected session: Session | undefined;\n\n\tprotected _callState: CallStates = 'INITIAL';\n\n\tprotected _callerInfo: ICallerInfo | undefined;\n\n\tprotected _userState: UserState = UserState.IDLE;\n\n\tprotected _opInProgress: Operation = Operation.OP_NONE;\n\n\tget operationInProgress(): Operation {\n\t\treturn this._opInProgress;\n\t}\n\n\tget userState(): UserState | undefined {\n\t\treturn this._userState;\n\t}\n\n\tconstructor(\n\t\tprivate readonly config: VoIPUserConfiguration,\n\t\tmediaRenderer?: IMediaStreamRenderer,\n\t) {\n\t\tsuper();\n\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\tthis.networkEmitter = new Emitter<SignalingSocketEvents>();\n\t\tthis.connectionRetryCount = this.config.connectionRetryCount;\n\t\tthis.stop = false;\n\n\t\tthis.onlineNetworkHandler = this.onNetworkRestored.bind(this);\n\t\tthis.offlineNetworkHandler = this.onNetworkLost.bind(this);\n\t}\n\n\t/**\n\t * Configures and initializes sip.js UserAgent\n\t * call gets established.\n\t * @remarks\n\t * This class configures transport properties such as websocket url, passed down in config,\n\t * sets up ICE servers,\n\t * SIP UserAgent options such as userName, Password, URI.\n\t * Once initialized, it starts the userAgent.\n\t */\n\n\tasync init(): Promise<void> {\n\t\tconst sipUri = `sip:${this.config.authUserName}@${this.config.sipRegistrarHostnameOrIP}`;\n\t\tconst transportOptions = {\n\t\t\tserver: this.config.webSocketURI,\n\t\t\tconnectionTimeout: 100, // Replace this with config\n\t\t\tkeepAliveInterval: 20,\n\t\t\t// traceSip: true,\n\t\t};\n\t\tconst sdpFactoryOptions = {\n\t\t\ticeGatheringTimeout: 10,\n\t\t\tpeerConnectionConfiguration: {\n\t\t\t\ticeServers: this.config.iceServers,\n\t\t\t},\n\t\t};\n\t\tthis.userAgentOptions = {\n\t\t\tdelegate: {\n\t\t\t\tonInvite: async (invitation: Invitation): Promise<void> => {\n\t\t\t\t\tawait this.handleIncomingCall(invitation);\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthorizationPassword: this.config.authPassword,\n\t\t\tauthorizationUsername: this.config.authUserName,\n\t\t\turi: UserAgent.makeURI(sipUri),\n\t\t\ttransportOptions,\n\t\t\tsessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n\t\t\tlogConfiguration: false,\n\t\t\tlogLevel: 'error',\n\t\t};\n\n\t\tthis.userAgent = new UserAgent(this.userAgentOptions);\n\t\tthis.userAgent.transport.isConnected();\n\t\tthis._opInProgress = Operation.OP_CONNECT;\n\t\ttry {\n\t\t\tthis.registerer = new Registerer(this.userAgent);\n\n\t\t\tthis.userAgent.transport.onConnect = this.onConnected.bind(this);\n\t\t\tthis.userAgent.transport.onDisconnect = this.onDisconnected.bind(this);\n\t\t\twindow.addEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.addEventListener('offline', this.offlineNetworkHandler);\n\t\t\tawait this.userAgent.start();\n\t\t\tif (this.config.enableKeepAliveUsingOptionsForUnstableNetworks) {\n\t\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync onConnected(): Promise<void> {\n\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\tthis.state.isReady = true;\n\t\tthis.sendOptions();\n\t\tthis.networkEmitter.emit('connected');\n\t\t/**\n\t\t * Re-registration post network recovery should be attempted\n\t\t * if it was previously registered or incall/onhold\n\t\t */\n\n\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\tthis.attemptRegistration = true;\n\t\t}\n\t}\n\n\tonDisconnected(error: any): void {\n\t\tthis._connectionState = 'SERVER_DISCONNECTED';\n\t\tthis._opInProgress = Operation.OP_NONE;\n\t\tthis.networkEmitter.emit('disconnected');\n\t\tif (error) {\n\t\t\tthis.networkEmitter.emit('connectionerror', error);\n\t\t\tthis.state.isReady = false;\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted assuming\n\t\t\t * that the disconnect happened from the remote side or due to sleep\n\t\t\t * In case of remote side disconnection, if config.connectionRetryCount is -1,\n\t\t\t * attemptReconnection attempts continuously. Else stops after |config.connectionRetryCount|\n\t\t\t *\n\t\t\t */\n\t\t\t// this.attemptReconnection();\n\t\t\tthis.attemptReconnection(0, false);\n\t\t}\n\t}\n\n\tonNetworkRestored(): void {\n\t\tthis.networkEmitter.emit('localnetworkonline');\n\t\tif (this._connectionState === 'WAITING_FOR_NETWORK') {\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted when online event handler\n\t\t\t * gets notified.\n\t\t\t * Important thing to note is that the second parameter |checkRegistration| = true passed here\n\t\t\t * because after the network recovery and after reconnecting to the server,\n\t\t\t * the transport layer of SIPUA does not call onConnected. So by passing |checkRegistration = true |\n\t\t\t * the code will check if the endpoint was previously registered before the disconnection.\n\t\t\t * If such is the case, it will first unregister and then re-register.\n\t\t\t * */\n\t\t\tthis.attemptReconnection();\n\t\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\t\tthis.attemptRegistration = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tonNetworkLost(): void {\n\t\tthis.networkEmitter.emit('localnetworkoffline');\n\t\tthis._connectionState = 'WAITING_FOR_NETWORK';\n\t}\n\n\tget userConfig(): VoIPUserConfiguration {\n\t\treturn this.config;\n\t}\n\n\tget callState(): CallStates {\n\t\treturn this._callState;\n\t}\n\n\tget connectionState(): ConnectionState {\n\t\treturn this._connectionState;\n\t}\n\n\tget callerInfo(): VoIpCallerInfo {\n\t\tif (\n\t\t\tthis.callState === 'IN_CALL' ||\n\t\t\tthis.callState === 'OFFER_RECEIVED' ||\n\t\t\tthis.callState === 'ON_HOLD' ||\n\t\t\tthis.callState === 'OFFER_SENT'\n\t\t) {\n\t\t\tif (!this._callerInfo) {\n\t\t\t\tthrow new Error('[VoIPUser callerInfo] invalid state');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: this.callState,\n\t\t\t\tcaller: this._callerInfo,\n\t\t\t\tuserState: this._userState,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tstate: this.callState,\n\t\t\tuserState: this._userState,\n\t\t};\n\t}\n\n\t/* Media Stream functions begin */\n\t/** The local media stream. Undefined if call not answered. */\n\tget localMediaStream(): MediaStream | undefined {\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\t\treturn sdh.localMediaStream;\n\t}\n\n\t/* Media Stream functions end */\n\t/* OutgoingRequestDelegate methods begin */\n\tonRegistrationRequestAccept(): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis._callState = 'REGISTERED';\n\t\t\tthis.emit('registered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\tthis.emit('unregistered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t}\n\n\tonRegistrationRequestReject(error: any): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis.emit('registrationerror', error);\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis.emit('unregistrationerror', error);\n\t\t}\n\t}\n\t/* OutgoingRequestDelegate methods end */\n\n\tprivate async handleIncomingCall(invitation: Invitation): Promise<void> {\n\t\tif (this.callState === 'REGISTERED') {\n\t\t\tthis._opInProgress = Operation.OP_PROCESS_INVITE;\n\t\t\tthis._callState = 'OFFER_RECEIVED';\n\t\t\tthis._userState = UserState.UAS;\n\t\t\tthis.session = invitation;\n\t\t\tthis.setupSessionEventHandlers(invitation);\n\t\t\tconst callerInfo: ICallerInfo = {\n\t\t\t\tcallerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n\t\t\t\tcallerName: invitation.remoteIdentity.displayName,\n\t\t\t\thost: invitation.remoteIdentity.uri.host,\n\t\t\t};\n\t\t\tthis._callerInfo = callerInfo;\n\t\t\tthis.emit('incomingcall', callerInfo);\n\t\t\tthis.emit('stateChanged');\n\t\t\treturn;\n\t\t}\n\n\t\tawait invitation.reject();\n\t}\n\n\t/**\n\t * Sets up an listener handler for handling session's state change\n\t * @remarks\n\t * Called for setting up various state listeners. These listeners will\n\t * decide the next action to be taken when the session state changes.\n\t * e.g when session.state changes from |Establishing| to |Established|\n\t * one must set up local and remote media rendering.\n\t *\n\t * This class handles such session state changes and takes necessary actions.\n\t */\n\n\tprotected setupSessionEventHandlers(session: Session): void {\n\t\tthis.session?.stateChange.addListener((state: SessionState) => {\n\t\t\tif (this.session !== session) {\n\t\t\t\treturn; // if our session has changed, just return\n\t\t\t}\n\t\t\tswitch (state) {\n\t\t\t\tcase SessionState.Initial:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Establishing:\n\t\t\t\t\tthis.emit('ringing', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Established:\n\t\t\t\t\tif (this._userState === UserState.UAC) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * We need to decide about user-state ANSWER-RECEIVED for outbound.\n\t\t\t\t\t\t * This state is there for the symmetry of ANSWER-SENT.\n\t\t\t\t\t\t * ANSWER-SENT occurs when there is incoming invite. So then the UA\n\t\t\t\t\t\t * accepts a call, it sends the answer and state becomes ANSWER-SENT.\n\t\t\t\t\t\t * The call gets established only when the remote party sends ACK.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * But in case of UAC where the invite is sent out, there is no intermediate\n\t\t\t\t\t\t * state where the UA can be in ANSWER-RECEIVED. As soon this UA receives the answer,\n\t\t\t\t\t\t * it sends ack and changes the SessionState to established.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * So we do not have an actual state transitions from ANSWER-RECEIVED to IN-CALL.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Nevertheless, this state is just added to maintain the symmetry. This can be safely removed.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * */\n\t\t\t\t\t\tthis._callState = 'ANSWER_RECEIVED';\n\t\t\t\t\t}\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis.setupRemoteMedia();\n\t\t\t\t\tthis._callState = 'IN_CALL';\n\t\t\t\t\tthis.emit('callestablished', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Terminating:\n\t\t\t\t// fall through\n\t\t\t\tcase SessionState.Terminated:\n\t\t\t\t\tthis.session = undefined;\n\t\t\t\t\tthis._callState = 'REGISTERED';\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._userState = UserState.IDLE;\n\t\t\t\t\tthis.emit('callterminated');\n\t\t\t\t\tthis.remoteStream?.clear();\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown session state.');\n\t\t\t}\n\t\t});\n\t}\n\n\tonTrackAdded(_event: any): void {\n\t\tconsole.log('onTrackAdded');\n\t}\n\n\tonTrackRemoved(_event: any): void {\n\t\tconsole.log('onTrackRemoved');\n\t}\n\n\t/**\n\t * Carries out necessary steps for rendering remote media whe\n\t * call gets established.\n\t * @remarks\n\t * Sets up Stream class and plays the stream on given Media element/\n\t * Also sets up various event handlers.\n\t */\n\tprivate setupRemoteMedia(): any {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\n\t\tconst remoteStream = sdh.remoteMediaStream;\n\t\tif (!remoteStream) {\n\t\t\tthrow new Error('Remote media stream is undefined.');\n\t\t}\n\n\t\tthis.remoteStream = new RemoteStream(remoteStream);\n\t\tconst mediaElement = this.mediaStreamRendered?.remoteMediaElement;\n\t\tif (mediaElement) {\n\t\t\tthis.remoteStream.init(mediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\t/**\n\t * Handles call mute-unmute\n\t */\n\tprivate async handleMuteUnmute(muteState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === muteState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = muteState;\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\tthis.emit('muteerror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A mute request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('muteerror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles call hold-unhold\n\t */\n\tprivate async handleHoldUnhold(holdState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === holdState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = holdState;\n\t\t\t\t\tthis._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis.emit('holderror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Session properties used to pass options to the SessionDescriptionHandler:\n\t\t//\n\t\t// 1) Session.sessionDescriptionHandlerOptions\n\t\t//    SDH options for the initial INVITE transaction.\n\t\t//    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n\t\t//\n\t\t// 2) Session.sessionDescriptionHandlerOptionsReInvite\n\t\t//    SDH options for re-INVITE transactions.\n\t\t//    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Session.invite().\n\n\t\tconst sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite as SessionDescriptionHandlerOptions;\n\t\tsessionDescriptionHandlerOptions.hold = holdState;\n\t\tsession.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A hold request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('holderror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tstatic async create(config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer): Promise<VoIPUser> {\n\t\tconst voip = new VoIPUser(config, mediaRenderer);\n\t\tawait voip.init();\n\t\treturn voip;\n\t}\n\n\t/**\n\t * Sends SIP OPTIONS message to asterisk\n\t *\n\t * There is an interesting problem that happens with Asterisk.\n\t * After websocket connection succeeds and if there is no SIP\n\t * message goes in 30 seconds, asterisk disconnects the socket.\n\t *\n\t * If any SIP message goes before 30 seconds, asterisk holds the connection.\n\t * This problem could be solved in multiple ways. One is that\n\t * whenever disconnect happens make sure that the socket is connected back using\n\t * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n\t * every 30 seconds till we send register message.\n\t *\n\t * Another approach is to send SIP OPTIONS just to tell server that\n\t * there is a UA using this socket. This is implemented below\n\t */\n\n\tsendOptions(outgoingRequestDelegate?: OutgoingRequestDelegate): void {\n\t\tconst uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n\t\tconst outgoingMessage = this.userAgent?.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\t\tif (outgoingMessage) {\n\t\t\tthis.userAgent?.userAgentCore.request(outgoingMessage, outgoingRequestDelegate);\n\t\t}\n\t}\n\t/**\n\t * Public method called from outside to register the SIP UA with call server.\n\t * @remarks\n\t */\n\n\tregister(): void {\n\t\tthis._opInProgress = Operation.OP_REGISTER;\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Public method called from outside to unregister the SIP UA.\n\t * @remarks\n\t */\n\n\tunregister(): void {\n\t\tthis._opInProgress = Operation.OP_UNREGISTER;\n\t\tthis.registerer?.unregister({\n\t\t\tall: true,\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\t/**\n\t * Public method called from outside to accept incoming call.\n\t * @remarks\n\t */\n\n\tasync acceptCall(mediaRenderer: IMediaStreamRenderer): Promise<void> {\n\t\tif (mediaRenderer) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t}\n\t\t// Call state must be in offer_received.\n\t\tif (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n\t\t\tthis._callState = 'ANSWER_SENT';\n\t\t\t// Something is wrong, this session is not an instance of INVITE\n\t\t\tif (!(this.session instanceof Invitation)) {\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\t}\n\t\t\t/**\n\t\t\t * It is important to decide when to add video option to the outgoing offer.\n\t\t\t * This would matter when the reinvite goes out (In case of hold/unhold)\n\t\t\t * This was added because there were failures in hold-unhold.\n\t\t\t * The scenario was that if this client does hold-unhold first, and remote client does\n\t\t\t * later, remote client goes in inconsistent state and hold-unhold does not work\n\t\t\t * Where as if the remote client does hold-unhold first, this client can do it any number\n\t\t\t * of times.\n\t\t\t *\n\t\t\t * Logic below works as follows\n\t\t\t * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n\t\t\t * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n\t\t\t * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n\t\t\t * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n\t\t\t *\n\t\t\t */\n\t\t\tlet videoInvite = !!this.config.enableVideo;\n\n\t\t\tconst { body } = this.session;\n\t\t\tif (body && body.indexOf('m=video') === -1) {\n\t\t\t\tvideoInvite = false;\n\t\t\t}\n\n\t\t\tconst invitationAcceptOptions: InvitationAcceptOptions = {\n\t\t\t\tsessionDescriptionHandlerOptions: {\n\t\t\t\t\tconstraints: {\n\t\t\t\t\t\taudio: true,\n\t\t\t\t\t\tvideo: !!this.config.enableVideo && videoInvite,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\treturn this.session.accept(invitationAcceptOptions);\n\t\t}\n\t\tthrow new Error('Something went wrong');\n\t}\n\n\t/* Helper routines for checking call actions BEGIN */\n\n\tprivate canRejectCall(): boolean {\n\t\treturn ['OFFER_RECEIVED', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\tprivate canEndOrHoldCall(): boolean {\n\t\treturn ['ANSWER_SENT', 'ANSWER_RECEIVED', 'IN_CALL', 'ON_HOLD', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\t/* Helper routines for checking call actions END */\n\n\t/**\n\t * Public method called from outside to reject a call.\n\t * @remarks\n\t */\n\trejectCall(): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canRejectCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tif (!(this.session instanceof Invitation)) {\n\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t}\n\t\treturn this.session.reject();\n\t}\n\n\t/**\n\t * Public method called from outside to end a call.\n\t * @remarks\n\t */\n\tasync endCall(): Promise<OutgoingByeRequest | void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\n\t\t// When call ends, force state to be revisited\n\t\tthis.emit('stateChanged');\n\t\tswitch (this.session.state) {\n\t\t\tcase SessionState.Initial:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Establishing:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tif (this.session instanceof Inviter) {\n\t\t\t\t\treturn this.session.cancel();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Established:\n\t\t\t\treturn this.session.bye();\n\t\t\tcase SessionState.Terminating:\n\t\t\t\tbreak;\n\t\t\tcase SessionState.Terminated:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown state');\n\t\t}\n\t}\n\n\t/**\n\t * Public method called from outside to mute the call.\n\t * @remarks\n\t */\n\tasync muteCall(muteState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'IN_CALL') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleMuteUnmute(muteState);\n\t}\n\n\t/**\n\t * Public method called from outside to hold the call.\n\t * @remarks\n\t */\n\tasync holdCall(holdState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleHoldUnhold(holdState);\n\t}\n\n\t/* CallEventDelegate implementation end */\n\tisReady(): boolean {\n\t\treturn this.state.isReady;\n\t}\n\n\t/**\n\t * This function allows to change the media renderer media elements.\n\t */\n\tswitchMediaRenderer(mediaRenderer: IMediaStreamRenderer): void {\n\t\tif (this.remoteStream) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t\tthis.remoteStream.init(mediaRenderer.remoteMediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\tsetWorkflowMode(mode: WorkflowTypes): void {\n\t\tthis.mode = mode;\n\t\tif (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\tthis.queueInfo = new QueueAggregator();\n\t\t}\n\t}\n\n\tsetMembershipSubscription(subscription: IQueueMembershipSubscription): void {\n\t\tif (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\treturn;\n\t\t}\n\t\tthis.queueInfo?.setMembership(subscription);\n\t}\n\n\tgetAggregator(): QueueAggregator {\n\t\treturn this.queueInfo;\n\t}\n\n\tgetRegistrarState(): string | undefined {\n\t\treturn this.registerer?.state.toString().toLocaleLowerCase();\n\t}\n\n\tclear(): void {\n\t\tthis._opInProgress = Operation.OP_CLEANUP;\n\t\t/** Socket reconnection is attempted when the socket is disconnected with some error.\n\t\t * While disconnecting, if there is any socket error, there should be no reconnection attempt.\n\t\t * So when userAgent.stop() is called which closes the sockets, it should be made sure that\n\t\t * if the socket is disconnected with error, connection attempts are not started or\n\t\t * if there are any previously ongoing attempts, they should be terminated.\n\t\t * flag attemptReconnect is used for ensuring this.\n\t\t */\n\t\tthis.stop = true;\n\t\tthis.userAgent?.stop();\n\t\tthis.registerer?.dispose();\n\t\tthis._connectionState = 'STOP';\n\n\t\tif (this.userAgent) {\n\t\t\tthis.userAgent.transport.onConnect = undefined;\n\t\t\tthis.userAgent.transport.onDisconnect = undefined;\n\t\t\twindow.removeEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.removeEventListener('offline', this.offlineNetworkHandler);\n\t\t}\n\t}\n\n\tonNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.on(event, handler);\n\t}\n\n\toffNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.off(event, handler);\n\t}\n\n\t/**\n\t * Connection is lost in 3 ways\n\t * 1. When local network is lost (Router is disconnected, switching networks, devtools->network->offline)\n\t * In this case, the SIP.js's transport layer does not detect the disconnection. Hence, it does not\n\t * call |onDisconnect|. To detect this kind of disconnection, window event listeners have been added.\n\t * These event listeners would be get called when the browser detects that network is offline or online.\n\t * When the network is restored, the code tries to reconnect. The useragent.transport \"does not\" generate the\n\t * onconnected event in this case as well. so onlineNetworkHandler calls attemptReconnection.\n\t * Which calls attemptRegistrationPostRecovery based on correct state. attemptRegistrationPostRecovery first tries to\n\t * unregister and then re-register.\n\t * Important note : We use the event listeners using bind function object offlineNetworkHandler and onlineNetworkHandler\n\t * It is done so because the same event handlers need to be used for removeEventListener, which becomes impossible\n\t * if done inline.\n\t *\n\t * 2. Computer goes to sleep. In this case onDisconnect is triggered. The code tries to reconnect but cant go ahead\n\t * as it goes to sleep. On waking up, The attemptReconnection gets executed, connection is completed.\n\t * In this case, it generates onConnected event. In this onConnected event it calls attemptRegistrationPostRecovery\n\t *\n\t * 3. When Asterisk disconnects all the endpoints either because it crashes or restarted,\n\t * As soon as the agent successfully connects to asterisk, it should re-register\n\t *\n\t * Retry count :\n\t * connectionRetryCount is the parameter called |Retry Count| in\n\t * Administration -> Call Center -> Server configuration -> Retry count.\n\t * The retry is implemented with backoff, maxbackoff = 8 seconds.\n\t * For continuous retries (In case Asterisk restart happens) Set this parameter to -1.\n\t *\n\t * Important to note is how attemptRegistrationPostRecovery is called. In case of\n\t * the router connection loss or while switching the networks,\n\t * there is no disconnect and connect event from the transport layer of the userAgent.\n\t * So in this case, when the connection is successful after reconnect, the code should try to re-register by calling\n\t * attemptRegistrationPostRecovery.\n\t * In case of computer waking from sleep or asterisk getting restored, connect and disconnect events are generated.\n\t * In this case, re-registration should be triggered (by calling) only when onConnected gets called and not otherwise.\n\t */\n\n\tasync attemptReconnection(reconnectionAttempt = 0, checkRegistration = false): Promise<void> {\n\t\tconst reconnectionAttempts = this.connectionRetryCount;\n\t\tthis._connectionState = 'SERVER_RECONNECTING';\n\t\tif (!this.userAgent) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.stop) {\n\t\t\treturn;\n\t\t}\n\t\t// reconnectionAttempts == -1 then keep continuously trying\n\t\tif (reconnectionAttempts !== -1 && reconnectionAttempt > reconnectionAttempts) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\treturn;\n\t\t}\n\n\t\tconst reconnectionDelay = Math.pow(2, reconnectionAttempt % 4);\n\n\t\tconsole.error(`Attempting to reconnect with backoff due to network loss. Backoff time [${reconnectionDelay}]`);\n\t\tsetTimeout(() => {\n\t\t\tif (this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState === 'SERVER_CONNECTED') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.userAgent\n\t\t\t\t?.reconnect()\n\t\t\t\t.then(() => {\n\t\t\t\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\t\t\t})\n\t\t\t\t.catch(() => {\n\t\t\t\t\tthis.attemptReconnection(++reconnectionAttempt, checkRegistration);\n\t\t\t\t});\n\t\t}, reconnectionDelay * 1000);\n\t}\n\n\tasync attemptPostRecoveryRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tthis.sendOptions({\n\t\t\tonAccept: (): void => {\n\t\t\t\tthis.attemptPostRecoveryRegistrationRoutine();\n\t\t\t},\n\t\t\tonReject: (error: unknown): void => {\n\t\t\t\tconsole.error(`[${error}] Failed to do options in attemptPostRecoveryRoutine()`);\n\t\t\t},\n\t\t});\n\t}\n\n\tasync sendKeepAliveAndWaitForResponse(withDebounce = false): Promise<boolean> {\n\t\tconst promise = new Promise<boolean>((resolve, reject) => {\n\t\t\tlet keepAliveAccepted = false;\n\t\t\tlet responseWaitTime = this.optionsKeepaliveInterval / 2;\n\t\t\tif (withDebounce) {\n\t\t\t\tresponseWaitTime += this.optionsKeepAliveDebounceTimeInSec;\n\t\t\t}\n\n\t\t\tthis.sendOptions({\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tkeepAliveAccepted = true;\n\t\t\t\t},\n\t\t\t\tonReject: (_error: unknown): void => {\n\t\t\t\t\tconsole.error('Failed to do options.');\n\t\t\t\t},\n\t\t\t});\n\t\t\tsetTimeout(async () => {\n\t\t\t\tif (!keepAliveAccepted) {\n\t\t\t\t\treject(false);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.attemptRegistration) {\n\t\t\t\t\t\tthis.attemptPostRecoveryRoutine();\n\t\t\t\t\t\tthis.attemptRegistration = false;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(true);\n\t\t\t\t}\n\t\t\t}, responseWaitTime * 1000);\n\t\t});\n\t\treturn promise;\n\t}\n\n\tasync startOptionsPingForUnstableNetworks(): Promise<void> {\n\t\tsetTimeout(async () => {\n\t\t\tif (!this.userAgent || this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState !== 'SERVER_RECONNECTING') {\n\t\t\t\tlet isConnected = false;\n\t\t\t\ttry {\n\t\t\t\t\tawait this.sendKeepAliveAndWaitForResponse();\n\t\t\t\t\tisConnected = true;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(`[${e}] Failed to do options ping.`);\n\t\t\t\t} finally {\n\t\t\t\t\t// Send event only if it's a \"change\" on the status (avoid unnecessary event flooding)\n\t\t\t\t\t!isConnected && this.networkEmitter.emit('disconnected');\n\t\t\t\t\tisConnected && this.networkEmitter.emit('connected');\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Each seconds check if the network can reach asterisk. If not, try to reconnect\n\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t}, this.optionsKeepaliveInterval * 1000);\n\t}\n\n\tasync attemptPostRecoveryRegistrationRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tconst promise = new Promise<void>((_resolve, _reject) => {\n\t\t\tthis.registerer?.unregister({\n\t\t\t\tall: true,\n\t\t\t\trequestDelegate: {\n\t\t\t\t\tonAccept: (): void => {\n\t\t\t\t\t\t_resolve();\n\t\t\t\t\t},\n\t\t\t\t\tonReject: (error): void => {\n\t\t\t\t\t\tconsole.error(`[${error}] While unregistering after recovery`);\n\t\t\t\t\t\tthis.emit('unregistrationerror', error);\n\t\t\t\t\t\t_reject('Error in Unregistering');\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t\ttry {\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\tconsole.error(`[${error}] While waiting for unregister promise`);\n\t\t}\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonReject: (error): void => {\n\t\t\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\t\t\tthis.emit('registrationerror', error);\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\tasync changeAudioInputDevice(constraints: MediaStreamConstraints): Promise<boolean> {\n\t\tif (!this.session) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No session. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst newStream = await LocalStream.requestNewStream(constraints, this.session);\n\t\tif (!newStream) {\n\t\t\tconsole.warn('changeAudioInputDevice() : Unable to get local stream. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No peer connection. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tLocalStream.replaceTrack(peerConnection, newStream, 'audio');\n\t\treturn true;\n\t}\n\n\t// Commenting this as Video Configuration is not part of the scope for now\n\t// async changeVideoInputDevice(selectedVideoDevices: IDevice): Promise<boolean> {\n\t// \tif (!this.session) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No session. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tif (!this.config.enableVideo || this.deviceManager.hasVideoInputDevice()) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable change video device. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tthis.deviceManager.changeVideoInputDevice(selectedVideoDevices);\n\t// \tconst newStream = await LocalStream.requestNewStream(this.deviceManager.getConstraints('video'), this.session);\n\t// \tif (!newStream) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable to get local stream. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t// \tif (!peerConnection) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No peer connection. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tLocalStream.replaceTrack(peerConnection, newStream, 'video');\n\t// \treturn true;\n\t// }\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\tasync makeCallURI(_callee: string, _mediaRenderer?: IMediaStreamRenderer): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\tasync makeCall(_calleeNumber: string): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n}\n"]}}},"code":"module.export({\n  VoIPUser: () => VoIPUser\n});\nlet Operation, UserState, WorkflowTypes;\nmodule.link(\"@rocket.chat/core-typings\", {\n  Operation(v) {\n    Operation = v;\n  },\n  UserState(v) {\n    UserState = v;\n  },\n  WorkflowTypes(v) {\n    WorkflowTypes = v;\n  }\n}, 0);\nlet Emitter;\nmodule.link(\"@rocket.chat/emitter\", {\n  Emitter(v) {\n    Emitter = v;\n  }\n}, 1);\nlet UserAgent, Invitation, SessionState, Registerer, RequestPendingError, Inviter;\nmodule.link(\"sip.js\", {\n  UserAgent(v) {\n    UserAgent = v;\n  },\n  Invitation(v) {\n    Invitation = v;\n  },\n  SessionState(v) {\n    SessionState = v;\n  },\n  Registerer(v) {\n    Registerer = v;\n  },\n  RequestPendingError(v) {\n    RequestPendingError = v;\n  },\n  Inviter(v) {\n    Inviter = v;\n  }\n}, 2);\nlet URI;\nmodule.link(\"sip.js/lib/core\", {\n  URI(v) {\n    URI = v;\n  }\n}, 3);\nlet SessionDescriptionHandler;\nmodule.link(\"sip.js/lib/platform/web\", {\n  SessionDescriptionHandler(v) {\n    SessionDescriptionHandler = v;\n  }\n}, 4);\nlet toggleMediaStreamTracks;\nmodule.link(\"./Helper\", {\n  toggleMediaStreamTracks(v) {\n    toggleMediaStreamTracks = v;\n  }\n}, 5);\nlet LocalStream;\nmodule.link(\"./LocalStream\", {\n  default(v) {\n    LocalStream = v;\n  }\n}, 6);\nlet QueueAggregator;\nmodule.link(\"./QueueAggregator\", {\n  QueueAggregator(v) {\n    QueueAggregator = v;\n  }\n}, 7);\nlet RemoteStream;\nmodule.link(\"./RemoteStream\", {\n  default(v) {\n    RemoteStream = v;\n  }\n}, 8);\nclass VoIPUser extends Emitter {\n  get operationInProgress() {\n    return this._opInProgress;\n  }\n  get userState() {\n    return this._userState;\n  }\n  constructor(config, mediaRenderer) {\n    super();\n    this.config = void 0;\n    this.state = {\n      isReady: false,\n      enableVideo: false\n    };\n    this.remoteStream = void 0;\n    this.userAgentOptions = {};\n    this.userAgent = void 0;\n    this.registerer = void 0;\n    this.mediaStreamRendered = void 0;\n    this._connectionState = 'INITIAL';\n    this._held = false;\n    this.mode = void 0;\n    this.queueInfo = void 0;\n    this.connectionRetryCount = void 0;\n    this.stop = void 0;\n    this.networkEmitter = void 0;\n    this.offlineNetworkHandler = void 0;\n    this.onlineNetworkHandler = void 0;\n    this.optionsKeepaliveInterval = 5;\n    this.optionsKeepAliveDebounceTimeInSec = 5;\n    this.attemptRegistration = false;\n    this.session = void 0;\n    this._callState = 'INITIAL';\n    this._callerInfo = void 0;\n    this._userState = UserState.IDLE;\n    this._opInProgress = Operation.OP_NONE;\n    this.config = config;\n    this.mediaStreamRendered = mediaRenderer;\n    this.networkEmitter = new Emitter();\n    this.connectionRetryCount = this.config.connectionRetryCount;\n    this.stop = false;\n    this.onlineNetworkHandler = this.onNetworkRestored.bind(this);\n    this.offlineNetworkHandler = this.onNetworkLost.bind(this);\n  }\n  /**\n   * Configures and initializes sip.js UserAgent\n   * call gets established.\n   * @remarks\n   * This class configures transport properties such as websocket url, passed down in config,\n   * sets up ICE servers,\n   * SIP UserAgent options such as userName, Password, URI.\n   * Once initialized, it starts the userAgent.\n   */\n  async init() {\n    const sipUri = \"sip:\".concat(this.config.authUserName, \"@\").concat(this.config.sipRegistrarHostnameOrIP);\n    const transportOptions = {\n      server: this.config.webSocketURI,\n      connectionTimeout: 100,\n      // Replace this with config\n      keepAliveInterval: 20\n      // traceSip: true,\n    };\n    const sdpFactoryOptions = {\n      iceGatheringTimeout: 10,\n      peerConnectionConfiguration: {\n        iceServers: this.config.iceServers\n      }\n    };\n    this.userAgentOptions = {\n      delegate: {\n        onInvite: async invitation => {\n          await this.handleIncomingCall(invitation);\n        }\n      },\n      authorizationPassword: this.config.authPassword,\n      authorizationUsername: this.config.authUserName,\n      uri: UserAgent.makeURI(sipUri),\n      transportOptions,\n      sessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n      logConfiguration: false,\n      logLevel: 'error'\n    };\n    this.userAgent = new UserAgent(this.userAgentOptions);\n    this.userAgent.transport.isConnected();\n    this._opInProgress = Operation.OP_CONNECT;\n    try {\n      this.registerer = new Registerer(this.userAgent);\n      this.userAgent.transport.onConnect = this.onConnected.bind(this);\n      this.userAgent.transport.onDisconnect = this.onDisconnected.bind(this);\n      window.addEventListener('online', this.onlineNetworkHandler);\n      window.addEventListener('offline', this.offlineNetworkHandler);\n      await this.userAgent.start();\n      if (this.config.enableKeepAliveUsingOptionsForUnstableNetworks) {\n        this.startOptionsPingForUnstableNetworks();\n      }\n    } catch (error) {\n      this._connectionState = 'ERROR';\n      throw error;\n    }\n  }\n  async onConnected() {\n    this._connectionState = 'SERVER_CONNECTED';\n    this.state.isReady = true;\n    this.sendOptions();\n    this.networkEmitter.emit('connected');\n    /**\n     * Re-registration post network recovery should be attempted\n     * if it was previously registered or incall/onhold\n     */\n    if (this.registerer && this.callState !== 'INITIAL') {\n      this.attemptRegistration = true;\n    }\n  }\n  onDisconnected(error) {\n    this._connectionState = 'SERVER_DISCONNECTED';\n    this._opInProgress = Operation.OP_NONE;\n    this.networkEmitter.emit('disconnected');\n    if (error) {\n      this.networkEmitter.emit('connectionerror', error);\n      this.state.isReady = false;\n      /**\n       * Signalling socket reconnection should be attempted assuming\n       * that the disconnect happened from the remote side or due to sleep\n       * In case of remote side disconnection, if config.connectionRetryCount is -1,\n       * attemptReconnection attempts continuously. Else stops after |config.connectionRetryCount|\n       *\n       */\n      // this.attemptReconnection();\n      this.attemptReconnection(0, false);\n    }\n  }\n  onNetworkRestored() {\n    this.networkEmitter.emit('localnetworkonline');\n    if (this._connectionState === 'WAITING_FOR_NETWORK') {\n      /**\n       * Signalling socket reconnection should be attempted when online event handler\n       * gets notified.\n       * Important thing to note is that the second parameter |checkRegistration| = true passed here\n       * because after the network recovery and after reconnecting to the server,\n       * the transport layer of SIPUA does not call onConnected. So by passing |checkRegistration = true |\n       * the code will check if the endpoint was previously registered before the disconnection.\n       * If such is the case, it will first unregister and then re-register.\n       * */\n      this.attemptReconnection();\n      if (this.registerer && this.callState !== 'INITIAL') {\n        this.attemptRegistration = true;\n      }\n    }\n  }\n  onNetworkLost() {\n    this.networkEmitter.emit('localnetworkoffline');\n    this._connectionState = 'WAITING_FOR_NETWORK';\n  }\n  get userConfig() {\n    return this.config;\n  }\n  get callState() {\n    return this._callState;\n  }\n  get connectionState() {\n    return this._connectionState;\n  }\n  get callerInfo() {\n    if (this.callState === 'IN_CALL' || this.callState === 'OFFER_RECEIVED' || this.callState === 'ON_HOLD' || this.callState === 'OFFER_SENT') {\n      if (!this._callerInfo) {\n        throw new Error('[VoIPUser callerInfo] invalid state');\n      }\n      return {\n        state: this.callState,\n        caller: this._callerInfo,\n        userState: this._userState\n      };\n    }\n    return {\n      state: this.callState,\n      userState: this._userState\n    };\n  }\n  /* Media Stream functions begin */\n  /** The local media stream. Undefined if call not answered. */\n  get localMediaStream() {\n    var _this$session;\n    const sdh = (_this$session = this.session) === null || _this$session === void 0 ? void 0 : _this$session.sessionDescriptionHandler;\n    if (!sdh) {\n      return undefined;\n    }\n    if (!(sdh instanceof SessionDescriptionHandler)) {\n      throw new Error('Session description handler not instance of web SessionDescriptionHandler');\n    }\n    return sdh.localMediaStream;\n  }\n  /* Media Stream functions end */\n  /* OutgoingRequestDelegate methods begin */\n  onRegistrationRequestAccept() {\n    if (this._opInProgress === Operation.OP_REGISTER) {\n      this._callState = 'REGISTERED';\n      this.emit('registered');\n      this.emit('stateChanged');\n    }\n    if (this._opInProgress === Operation.OP_UNREGISTER) {\n      this._callState = 'UNREGISTERED';\n      this.emit('unregistered');\n      this.emit('stateChanged');\n    }\n  }\n  onRegistrationRequestReject(error) {\n    if (this._opInProgress === Operation.OP_REGISTER) {\n      this.emit('registrationerror', error);\n    }\n    if (this._opInProgress === Operation.OP_UNREGISTER) {\n      this.emit('unregistrationerror', error);\n    }\n  }\n  /* OutgoingRequestDelegate methods end */\n  async handleIncomingCall(invitation) {\n    if (this.callState === 'REGISTERED') {\n      this._opInProgress = Operation.OP_PROCESS_INVITE;\n      this._callState = 'OFFER_RECEIVED';\n      this._userState = UserState.UAS;\n      this.session = invitation;\n      this.setupSessionEventHandlers(invitation);\n      const callerInfo = {\n        callerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n        callerName: invitation.remoteIdentity.displayName,\n        host: invitation.remoteIdentity.uri.host\n      };\n      this._callerInfo = callerInfo;\n      this.emit('incomingcall', callerInfo);\n      this.emit('stateChanged');\n      return;\n    }\n    await invitation.reject();\n  }\n  /**\n   * Sets up an listener handler for handling session's state change\n   * @remarks\n   * Called for setting up various state listeners. These listeners will\n   * decide the next action to be taken when the session state changes.\n   * e.g when session.state changes from |Establishing| to |Established|\n   * one must set up local and remote media rendering.\n   *\n   * This class handles such session state changes and takes necessary actions.\n   */\n  setupSessionEventHandlers(session) {\n    var _this$session2;\n    (_this$session2 = this.session) === null || _this$session2 === void 0 ? void 0 : _this$session2.stateChange.addListener(state => {\n      var _this$remoteStream;\n      if (this.session !== session) {\n        return; // if our session has changed, just return\n      }\n      switch (state) {\n        case SessionState.Initial:\n          break;\n        case SessionState.Establishing:\n          this.emit('ringing', {\n            userState: this._userState,\n            callInfo: this._callerInfo\n          });\n          break;\n        case SessionState.Established:\n          if (this._userState === UserState.UAC) {\n            /**\n             * We need to decide about user-state ANSWER-RECEIVED for outbound.\n             * This state is there for the symmetry of ANSWER-SENT.\n             * ANSWER-SENT occurs when there is incoming invite. So then the UA\n             * accepts a call, it sends the answer and state becomes ANSWER-SENT.\n             * The call gets established only when the remote party sends ACK.\n             *\n             * But in case of UAC where the invite is sent out, there is no intermediate\n             * state where the UA can be in ANSWER-RECEIVED. As soon this UA receives the answer,\n             * it sends ack and changes the SessionState to established.\n             *\n             * So we do not have an actual state transitions from ANSWER-RECEIVED to IN-CALL.\n             *\n             * Nevertheless, this state is just added to maintain the symmetry. This can be safely removed.\n             *\n             * */\n            this._callState = 'ANSWER_RECEIVED';\n          }\n          this._opInProgress = Operation.OP_NONE;\n          this.setupRemoteMedia();\n          this._callState = 'IN_CALL';\n          this.emit('callestablished', {\n            userState: this._userState,\n            callInfo: this._callerInfo\n          });\n          this.emit('stateChanged');\n          break;\n        case SessionState.Terminating:\n        // fall through\n        case SessionState.Terminated:\n          this.session = undefined;\n          this._callState = 'REGISTERED';\n          this._opInProgress = Operation.OP_NONE;\n          this._userState = UserState.IDLE;\n          this.emit('callterminated');\n          (_this$remoteStream = this.remoteStream) === null || _this$remoteStream === void 0 ? void 0 : _this$remoteStream.clear();\n          this.emit('stateChanged');\n          break;\n        default:\n          throw new Error('Unknown session state.');\n      }\n    });\n  }\n  onTrackAdded(_event) {\n    console.log('onTrackAdded');\n  }\n  onTrackRemoved(_event) {\n    console.log('onTrackRemoved');\n  }\n  /**\n   * Carries out necessary steps for rendering remote media whe\n   * call gets established.\n   * @remarks\n   * Sets up Stream class and plays the stream on given Media element/\n   * Also sets up various event handlers.\n   */\n  setupRemoteMedia() {\n    var _this$session3, _this$mediaStreamRend;\n    if (!this.session) {\n      throw new Error('Session does not exist.');\n    }\n    const sdh = (_this$session3 = this.session) === null || _this$session3 === void 0 ? void 0 : _this$session3.sessionDescriptionHandler;\n    if (!sdh) {\n      return undefined;\n    }\n    if (!(sdh instanceof SessionDescriptionHandler)) {\n      throw new Error('Session description handler not instance of web SessionDescriptionHandler');\n    }\n    const remoteStream = sdh.remoteMediaStream;\n    if (!remoteStream) {\n      throw new Error('Remote media stream is undefined.');\n    }\n    this.remoteStream = new RemoteStream(remoteStream);\n    const mediaElement = (_this$mediaStreamRend = this.mediaStreamRendered) === null || _this$mediaStreamRend === void 0 ? void 0 : _this$mediaStreamRend.remoteMediaElement;\n    if (mediaElement) {\n      this.remoteStream.init(mediaElement);\n      this.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n      this.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n      this.remoteStream.play();\n    }\n  }\n  /**\n   * Handles call mute-unmute\n   */\n  async handleMuteUnmute(muteState) {\n    var _this$session4, _this$session5;\n    const {\n      session\n    } = this;\n    if (this._held === muteState) {\n      return Promise.resolve();\n    }\n    if (!session) {\n      throw new Error('Session not found');\n    }\n    const sessionDescriptionHandler = (_this$session4 = this.session) === null || _this$session4 === void 0 ? void 0 : _this$session4.sessionDescriptionHandler;\n    if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n    }\n    const options = {\n      requestDelegate: {\n        onAccept: () => {\n          this._held = muteState;\n          toggleMediaStreamTracks(!this._held, session, 'receiver');\n          toggleMediaStreamTracks(!this._held, session, 'sender');\n        },\n        onReject: () => {\n          this.emit('muteerror');\n        }\n      }\n    };\n    const {\n      peerConnection\n    } = sessionDescriptionHandler;\n    if (!peerConnection) {\n      throw new Error('Peer connection closed.');\n    }\n    return (_this$session5 = this.session) === null || _this$session5 === void 0 ? void 0 : _this$session5.invite(options).then(() => {\n      toggleMediaStreamTracks(!this._held, session, 'receiver');\n      toggleMediaStreamTracks(!this._held, session, 'sender');\n    }).catch(error => {\n      if (error instanceof RequestPendingError) {\n        var _this$session6;\n        console.error(\"[\".concat((_this$session6 = this.session) === null || _this$session6 === void 0 ? void 0 : _this$session6.id, \"] A mute request is already in progress.\"));\n      }\n      this.emit('muteerror');\n      throw error;\n    });\n  }\n  /**\n   * Handles call hold-unhold\n   */\n  async handleHoldUnhold(holdState) {\n    var _this$session7, _this$session8;\n    const {\n      session\n    } = this;\n    if (this._held === holdState) {\n      return Promise.resolve();\n    }\n    if (!session) {\n      throw new Error('Session not found');\n    }\n    const sessionDescriptionHandler = (_this$session7 = this.session) === null || _this$session7 === void 0 ? void 0 : _this$session7.sessionDescriptionHandler;\n    if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n    }\n    const options = {\n      requestDelegate: {\n        onAccept: () => {\n          this._held = holdState;\n          this._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n          toggleMediaStreamTracks(!this._held, session, 'receiver');\n          toggleMediaStreamTracks(!this._held, session, 'sender');\n          this._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n          this.emit('stateChanged');\n        },\n        onReject: () => {\n          toggleMediaStreamTracks(!this._held, session, 'receiver');\n          toggleMediaStreamTracks(!this._held, session, 'sender');\n          this.emit('holderror');\n        }\n      }\n    };\n    // Session properties used to pass options to the SessionDescriptionHandler:\n    //\n    // 1) Session.sessionDescriptionHandlerOptions\n    //    SDH options for the initial INVITE transaction.\n    //    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n    //    - May be set directly at anytime.\n    //    - May optionally be set via constructor option.\n    //    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n    //\n    // 2) Session.sessionDescriptionHandlerOptionsReInvite\n    //    SDH options for re-INVITE transactions.\n    //    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n    //    - May be set directly at anytime.\n    //    - May optionally be set via constructor option.\n    //    - May optionally be set via options passed to Session.invite().\n    const sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite;\n    sessionDescriptionHandlerOptions.hold = holdState;\n    session.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n    const {\n      peerConnection\n    } = sessionDescriptionHandler;\n    if (!peerConnection) {\n      throw new Error('Peer connection closed.');\n    }\n    return (_this$session8 = this.session) === null || _this$session8 === void 0 ? void 0 : _this$session8.invite(options).then(() => {\n      toggleMediaStreamTracks(!this._held, session, 'receiver');\n      toggleMediaStreamTracks(!this._held, session, 'sender');\n    }).catch(error => {\n      if (error instanceof RequestPendingError) {\n        var _this$session9;\n        console.error(\"[\".concat((_this$session9 = this.session) === null || _this$session9 === void 0 ? void 0 : _this$session9.id, \"] A hold request is already in progress.\"));\n      }\n      this.emit('holderror');\n      throw error;\n    });\n  }\n  static async create(config, mediaRenderer) {\n    const voip = new VoIPUser(config, mediaRenderer);\n    await voip.init();\n    return voip;\n  }\n  /**\n   * Sends SIP OPTIONS message to asterisk\n   *\n   * There is an interesting problem that happens with Asterisk.\n   * After websocket connection succeeds and if there is no SIP\n   * message goes in 30 seconds, asterisk disconnects the socket.\n   *\n   * If any SIP message goes before 30 seconds, asterisk holds the connection.\n   * This problem could be solved in multiple ways. One is that\n   * whenever disconnect happens make sure that the socket is connected back using\n   * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n   * every 30 seconds till we send register message.\n   *\n   * Another approach is to send SIP OPTIONS just to tell server that\n   * there is a UA using this socket. This is implemented below\n   */\n  sendOptions(outgoingRequestDelegate) {\n    var _this$userAgent;\n    const uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n    const outgoingMessage = (_this$userAgent = this.userAgent) === null || _this$userAgent === void 0 ? void 0 : _this$userAgent.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n    if (outgoingMessage) {\n      var _this$userAgent2;\n      (_this$userAgent2 = this.userAgent) === null || _this$userAgent2 === void 0 ? void 0 : _this$userAgent2.userAgentCore.request(outgoingMessage, outgoingRequestDelegate);\n    }\n  }\n  /**\n   * Public method called from outside to register the SIP UA with call server.\n   * @remarks\n   */\n  register() {\n    var _this$registerer;\n    this._opInProgress = Operation.OP_REGISTER;\n    (_this$registerer = this.registerer) === null || _this$registerer === void 0 ? void 0 : _this$registerer.register({\n      requestDelegate: {\n        onAccept: this.onRegistrationRequestAccept.bind(this),\n        onReject: this.onRegistrationRequestReject.bind(this)\n      }\n    });\n  }\n  /**\n   * Public method called from outside to unregister the SIP UA.\n   * @remarks\n   */\n  unregister() {\n    var _this$registerer2;\n    this._opInProgress = Operation.OP_UNREGISTER;\n    (_this$registerer2 = this.registerer) === null || _this$registerer2 === void 0 ? void 0 : _this$registerer2.unregister({\n      all: true,\n      requestDelegate: {\n        onAccept: this.onRegistrationRequestAccept.bind(this),\n        onReject: this.onRegistrationRequestReject.bind(this)\n      }\n    });\n  }\n  /**\n   * Public method called from outside to accept incoming call.\n   * @remarks\n   */\n  async acceptCall(mediaRenderer) {\n    if (mediaRenderer) {\n      this.mediaStreamRendered = mediaRenderer;\n    }\n    // Call state must be in offer_received.\n    if (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n      this._callState = 'ANSWER_SENT';\n      // Something is wrong, this session is not an instance of INVITE\n      if (!(this.session instanceof Invitation)) {\n        throw new Error('Session not instance of Invitation.');\n      }\n      /**\n       * It is important to decide when to add video option to the outgoing offer.\n       * This would matter when the reinvite goes out (In case of hold/unhold)\n       * This was added because there were failures in hold-unhold.\n       * The scenario was that if this client does hold-unhold first, and remote client does\n       * later, remote client goes in inconsistent state and hold-unhold does not work\n       * Where as if the remote client does hold-unhold first, this client can do it any number\n       * of times.\n       *\n       * Logic below works as follows\n       * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n       * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n       * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n       * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n       *\n       */\n      let videoInvite = !!this.config.enableVideo;\n      const {\n        body\n      } = this.session;\n      if (body && body.indexOf('m=video') === -1) {\n        videoInvite = false;\n      }\n      const invitationAcceptOptions = {\n        sessionDescriptionHandlerOptions: {\n          constraints: {\n            audio: true,\n            video: !!this.config.enableVideo && videoInvite\n          }\n        }\n      };\n      return this.session.accept(invitationAcceptOptions);\n    }\n    throw new Error('Something went wrong');\n  }\n  /* Helper routines for checking call actions BEGIN */\n  canRejectCall() {\n    return ['OFFER_RECEIVED', 'OFFER_SENT'].includes(this._callState);\n  }\n  canEndOrHoldCall() {\n    return ['ANSWER_SENT', 'ANSWER_RECEIVED', 'IN_CALL', 'ON_HOLD', 'OFFER_SENT'].includes(this._callState);\n  }\n  /* Helper routines for checking call actions END */\n  /**\n   * Public method called from outside to reject a call.\n   * @remarks\n   */\n  rejectCall() {\n    if (!this.session) {\n      throw new Error('Session does not exist.');\n    }\n    if (!this.canRejectCall()) {\n      throw new Error(\"Incorrect call State = \".concat(this.callState));\n    }\n    if (!(this.session instanceof Invitation)) {\n      throw new Error('Session not instance of Invitation.');\n    }\n    return this.session.reject();\n  }\n  /**\n   * Public method called from outside to end a call.\n   * @remarks\n   */\n  async endCall() {\n    if (!this.session) {\n      throw new Error('Session does not exist.');\n    }\n    if (!this.canEndOrHoldCall()) {\n      throw new Error(\"Incorrect call State = \".concat(this.callState));\n    }\n    // When call ends, force state to be revisited\n    this.emit('stateChanged');\n    switch (this.session.state) {\n      case SessionState.Initial:\n        if (this.session instanceof Invitation) {\n          return this.session.reject();\n        }\n        throw new Error('Session not instance of Invitation.');\n      case SessionState.Establishing:\n        if (this.session instanceof Invitation) {\n          return this.session.reject();\n        }\n        if (this.session instanceof Inviter) {\n          return this.session.cancel();\n        }\n        throw new Error('Session not instance of Invitation.');\n      case SessionState.Established:\n        return this.session.bye();\n      case SessionState.Terminating:\n        break;\n      case SessionState.Terminated:\n        break;\n      default:\n        throw new Error('Unknown state');\n    }\n  }\n  /**\n   * Public method called from outside to mute the call.\n   * @remarks\n   */\n  async muteCall(muteState) {\n    if (!this.session) {\n      throw new Error('Session does not exist.');\n    }\n    if (this._callState !== 'IN_CALL') {\n      throw new Error(\"Incorrect call State = \".concat(this.callState));\n    }\n    this.handleMuteUnmute(muteState);\n  }\n  /**\n   * Public method called from outside to hold the call.\n   * @remarks\n   */\n  async holdCall(holdState) {\n    if (!this.session) {\n      throw new Error('Session does not exist.');\n    }\n    if (!this.canEndOrHoldCall()) {\n      throw new Error(\"Incorrect call State = \".concat(this.callState));\n    }\n    this.handleHoldUnhold(holdState);\n  }\n  /* CallEventDelegate implementation end */\n  isReady() {\n    return this.state.isReady;\n  }\n  /**\n   * This function allows to change the media renderer media elements.\n   */\n  switchMediaRenderer(mediaRenderer) {\n    if (this.remoteStream) {\n      this.mediaStreamRendered = mediaRenderer;\n      this.remoteStream.init(mediaRenderer.remoteMediaElement);\n      this.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n      this.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n      this.remoteStream.play();\n    }\n  }\n  setWorkflowMode(mode) {\n    this.mode = mode;\n    if (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n      this.queueInfo = new QueueAggregator();\n    }\n  }\n  setMembershipSubscription(subscription) {\n    var _this$queueInfo;\n    if (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n      return;\n    }\n    (_this$queueInfo = this.queueInfo) === null || _this$queueInfo === void 0 ? void 0 : _this$queueInfo.setMembership(subscription);\n  }\n  getAggregator() {\n    return this.queueInfo;\n  }\n  getRegistrarState() {\n    var _this$registerer3;\n    return (_this$registerer3 = this.registerer) === null || _this$registerer3 === void 0 ? void 0 : _this$registerer3.state.toString().toLocaleLowerCase();\n  }\n  clear() {\n    var _this$userAgent3, _this$registerer4;\n    this._opInProgress = Operation.OP_CLEANUP;\n    /** Socket reconnection is attempted when the socket is disconnected with some error.\n     * While disconnecting, if there is any socket error, there should be no reconnection attempt.\n     * So when userAgent.stop() is called which closes the sockets, it should be made sure that\n     * if the socket is disconnected with error, connection attempts are not started or\n     * if there are any previously ongoing attempts, they should be terminated.\n     * flag attemptReconnect is used for ensuring this.\n     */\n    this.stop = true;\n    (_this$userAgent3 = this.userAgent) === null || _this$userAgent3 === void 0 ? void 0 : _this$userAgent3.stop();\n    (_this$registerer4 = this.registerer) === null || _this$registerer4 === void 0 ? void 0 : _this$registerer4.dispose();\n    this._connectionState = 'STOP';\n    if (this.userAgent) {\n      this.userAgent.transport.onConnect = undefined;\n      this.userAgent.transport.onDisconnect = undefined;\n      window.removeEventListener('online', this.onlineNetworkHandler);\n      window.removeEventListener('offline', this.offlineNetworkHandler);\n    }\n  }\n  onNetworkEvent(event, handler) {\n    this.networkEmitter.on(event, handler);\n  }\n  offNetworkEvent(event, handler) {\n    this.networkEmitter.off(event, handler);\n  }\n  /**\n   * Connection is lost in 3 ways\n   * 1. When local network is lost (Router is disconnected, switching networks, devtools->network->offline)\n   * In this case, the SIP.js's transport layer does not detect the disconnection. Hence, it does not\n   * call |onDisconnect|. To detect this kind of disconnection, window event listeners have been added.\n   * These event listeners would be get called when the browser detects that network is offline or online.\n   * When the network is restored, the code tries to reconnect. The useragent.transport \"does not\" generate the\n   * onconnected event in this case as well. so onlineNetworkHandler calls attemptReconnection.\n   * Which calls attemptRegistrationPostRecovery based on correct state. attemptRegistrationPostRecovery first tries to\n   * unregister and then re-register.\n   * Important note : We use the event listeners using bind function object offlineNetworkHandler and onlineNetworkHandler\n   * It is done so because the same event handlers need to be used for removeEventListener, which becomes impossible\n   * if done inline.\n   *\n   * 2. Computer goes to sleep. In this case onDisconnect is triggered. The code tries to reconnect but cant go ahead\n   * as it goes to sleep. On waking up, The attemptReconnection gets executed, connection is completed.\n   * In this case, it generates onConnected event. In this onConnected event it calls attemptRegistrationPostRecovery\n   *\n   * 3. When Asterisk disconnects all the endpoints either because it crashes or restarted,\n   * As soon as the agent successfully connects to asterisk, it should re-register\n   *\n   * Retry count :\n   * connectionRetryCount is the parameter called |Retry Count| in\n   * Administration -> Call Center -> Server configuration -> Retry count.\n   * The retry is implemented with backoff, maxbackoff = 8 seconds.\n   * For continuous retries (In case Asterisk restart happens) Set this parameter to -1.\n   *\n   * Important to note is how attemptRegistrationPostRecovery is called. In case of\n   * the router connection loss or while switching the networks,\n   * there is no disconnect and connect event from the transport layer of the userAgent.\n   * So in this case, when the connection is successful after reconnect, the code should try to re-register by calling\n   * attemptRegistrationPostRecovery.\n   * In case of computer waking from sleep or asterisk getting restored, connect and disconnect events are generated.\n   * In this case, re-registration should be triggered (by calling) only when onConnected gets called and not otherwise.\n   */\n  async attemptReconnection() {\n    let reconnectionAttempt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let checkRegistration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const reconnectionAttempts = this.connectionRetryCount;\n    this._connectionState = 'SERVER_RECONNECTING';\n    if (!this.userAgent) {\n      return;\n    }\n    if (this.stop) {\n      return;\n    }\n    // reconnectionAttempts == -1 then keep continuously trying\n    if (reconnectionAttempts !== -1 && reconnectionAttempt > reconnectionAttempts) {\n      this._connectionState = 'ERROR';\n      return;\n    }\n    const reconnectionDelay = Math.pow(2, reconnectionAttempt % 4);\n    console.error(\"Attempting to reconnect with backoff due to network loss. Backoff time [\".concat(reconnectionDelay, \"]\"));\n    setTimeout(() => {\n      var _this$userAgent4;\n      if (this.stop) {\n        return;\n      }\n      if (this._connectionState === 'SERVER_CONNECTED') {\n        return;\n      }\n      (_this$userAgent4 = this.userAgent) === null || _this$userAgent4 === void 0 ? void 0 : _this$userAgent4.reconnect().then(() => {\n        this._connectionState = 'SERVER_CONNECTED';\n      }).catch(() => {\n        this.attemptReconnection(++reconnectionAttempt, checkRegistration);\n      });\n    }, reconnectionDelay * 1000);\n  }\n  async attemptPostRecoveryRoutine() {\n    /**\n     * It might happen that the whole network loss can happen\n     * while there is ongoing call. In that case, we want to maintain\n     * the call.\n     *\n     * So after re-registration, it should remain in the same state.\n     * */\n    this.sendOptions({\n      onAccept: () => {\n        this.attemptPostRecoveryRegistrationRoutine();\n      },\n      onReject: error => {\n        console.error(\"[\".concat(error, \"] Failed to do options in attemptPostRecoveryRoutine()\"));\n      }\n    });\n  }\n  async sendKeepAliveAndWaitForResponse() {\n    let withDebounce = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const promise = new Promise((resolve, reject) => {\n      let keepAliveAccepted = false;\n      let responseWaitTime = this.optionsKeepaliveInterval / 2;\n      if (withDebounce) {\n        responseWaitTime += this.optionsKeepAliveDebounceTimeInSec;\n      }\n      this.sendOptions({\n        onAccept: () => {\n          keepAliveAccepted = true;\n        },\n        onReject: _error => {\n          console.error('Failed to do options.');\n        }\n      });\n      setTimeout(async () => {\n        if (!keepAliveAccepted) {\n          reject(false);\n        } else {\n          if (this.attemptRegistration) {\n            this.attemptPostRecoveryRoutine();\n            this.attemptRegistration = false;\n          }\n          resolve(true);\n        }\n      }, responseWaitTime * 1000);\n    });\n    return promise;\n  }\n  async startOptionsPingForUnstableNetworks() {\n    setTimeout(async () => {\n      if (!this.userAgent || this.stop) {\n        return;\n      }\n      if (this._connectionState !== 'SERVER_RECONNECTING') {\n        let isConnected = false;\n        try {\n          await this.sendKeepAliveAndWaitForResponse();\n          isConnected = true;\n        } catch (e) {\n          console.error(\"[\".concat(e, \"] Failed to do options ping.\"));\n        } finally {\n          // Send event only if it's a \"change\" on the status (avoid unnecessary event flooding)\n          !isConnected && this.networkEmitter.emit('disconnected');\n          isConnected && this.networkEmitter.emit('connected');\n        }\n      }\n      // Each seconds check if the network can reach asterisk. If not, try to reconnect\n      this.startOptionsPingForUnstableNetworks();\n    }, this.optionsKeepaliveInterval * 1000);\n  }\n  async attemptPostRecoveryRegistrationRoutine() {\n    var _this$registerer6;\n    /**\n     * It might happen that the whole network loss can happen\n     * while there is ongoing call. In that case, we want to maintain\n     * the call.\n     *\n     * So after re-registration, it should remain in the same state.\n     * */\n    const promise = new Promise((_resolve, _reject) => {\n      var _this$registerer5;\n      (_this$registerer5 = this.registerer) === null || _this$registerer5 === void 0 ? void 0 : _this$registerer5.unregister({\n        all: true,\n        requestDelegate: {\n          onAccept: () => {\n            _resolve();\n          },\n          onReject: error => {\n            console.error(\"[\".concat(error, \"] While unregistering after recovery\"));\n            this.emit('unregistrationerror', error);\n            _reject('Error in Unregistering');\n          }\n        }\n      });\n    });\n    try {\n      await promise;\n    } catch (error) {\n      console.error(\"[\".concat(error, \"] While waiting for unregister promise\"));\n    }\n    (_this$registerer6 = this.registerer) === null || _this$registerer6 === void 0 ? void 0 : _this$registerer6.register({\n      requestDelegate: {\n        onReject: error => {\n          this._callState = 'UNREGISTERED';\n          this.emit('registrationerror', error);\n          this.emit('stateChanged');\n        }\n      }\n    });\n  }\n  async changeAudioInputDevice(constraints) {\n    var _this$session10;\n    if (!this.session) {\n      console.warn('changeAudioInputDevice() : No session. Returning');\n      return false;\n    }\n    const newStream = await LocalStream.requestNewStream(constraints, this.session);\n    if (!newStream) {\n      console.warn('changeAudioInputDevice() : Unable to get local stream. Returning');\n      return false;\n    }\n    const {\n      peerConnection\n    } = (_this$session10 = this.session) === null || _this$session10 === void 0 ? void 0 : _this$session10.sessionDescriptionHandler;\n    if (!peerConnection) {\n      console.warn('changeAudioInputDevice() : No peer connection. Returning');\n      return false;\n    }\n    LocalStream.replaceTrack(peerConnection, newStream, 'audio');\n    return true;\n  }\n  // Commenting this as Video Configuration is not part of the scope for now\n  // async changeVideoInputDevice(selectedVideoDevices: IDevice): Promise<boolean> {\n  // \tif (!this.session) {\n  // \t\tconsole.warn('changeVideoInputDevice() : No session. Returning');\n  // \t\treturn false;\n  // \t}\n  // \tif (!this.config.enableVideo || this.deviceManager.hasVideoInputDevice()) {\n  // \t\tconsole.warn('changeVideoInputDevice() : Unable change video device. Returning');\n  // \t\treturn false;\n  // \t}\n  // \tthis.deviceManager.changeVideoInputDevice(selectedVideoDevices);\n  // \tconst newStream = await LocalStream.requestNewStream(this.deviceManager.getConstraints('video'), this.session);\n  // \tif (!newStream) {\n  // \t\tconsole.warn('changeVideoInputDevice() : Unable to get local stream. Returning');\n  // \t\treturn false;\n  // \t}\n  // \tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n  // \tif (!peerConnection) {\n  // \t\tconsole.warn('changeVideoInputDevice() : No peer connection. Returning');\n  // \t\treturn false;\n  // \t}\n  // \tLocalStream.replaceTrack(peerConnection, newStream, 'video');\n  // \treturn true;\n  // }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async makeCallURI(_callee, _mediaRenderer) {\n    throw new Error('Not implemented');\n  }\n  async makeCall(_calleeNumber) {\n    throw new Error('Not implemented');\n  }\n}","map":{"version":3,"names":["module","export","VoIPUser","Operation","UserState","WorkflowTypes","link","v","Emitter","UserAgent","Invitation","SessionState","Registerer","RequestPendingError","Inviter","URI","SessionDescriptionHandler","toggleMediaStreamTracks","LocalStream","default","QueueAggregator","RemoteStream","operationInProgress","_opInProgress","userState","_userState","constructor","config","mediaRenderer","state","isReady","enableVideo","remoteStream","userAgentOptions","userAgent","registerer","mediaStreamRendered","_connectionState","_held","mode","queueInfo","connectionRetryCount","stop","networkEmitter","offlineNetworkHandler","onlineNetworkHandler","optionsKeepaliveInterval","optionsKeepAliveDebounceTimeInSec","attemptRegistration","session","_callState","_callerInfo","IDLE","OP_NONE","onNetworkRestored","bind","onNetworkLost","init","sipUri","concat","authUserName","sipRegistrarHostnameOrIP","transportOptions","server","webSocketURI","connectionTimeout","keepAliveInterval","sdpFactoryOptions","iceGatheringTimeout","peerConnectionConfiguration","iceServers","delegate","onInvite","invitation","handleIncomingCall","authorizationPassword","authPassword","authorizationUsername","uri","makeURI","sessionDescriptionHandlerFactoryOptions","logConfiguration","logLevel","transport","isConnected","OP_CONNECT","onConnect","onConnected","onDisconnect","onDisconnected","window","addEventListener","start","enableKeepAliveUsingOptionsForUnstableNetworks","startOptionsPingForUnstableNetworks","error","sendOptions","emit","callState","attemptReconnection","userConfig","connectionState","callerInfo","Error","caller","localMediaStream","_this$session","sdh","sessionDescriptionHandler","undefined","onRegistrationRequestAccept","OP_REGISTER","OP_UNREGISTER","onRegistrationRequestReject","OP_PROCESS_INVITE","UAS","setupSessionEventHandlers","callerId","remoteIdentity","user","callerName","displayName","host","reject","_this$session2","stateChange","addListener","_this$remoteStream","Initial","Establishing","callInfo","Established","UAC","setupRemoteMedia","Terminating","Terminated","clear","onTrackAdded","_event","console","log","onTrackRemoved","_this$session3","_this$mediaStreamRend","remoteMediaStream","mediaElement","remoteMediaElement","play","handleMuteUnmute","muteState","_this$session4","_this$session5","Promise","resolve","options","requestDelegate","onAccept","onReject","peerConnection","invite","then","catch","_this$session6","id","handleHoldUnhold","holdState","_this$session7","_this$session8","sessionDescriptionHandlerOptions","sessionDescriptionHandlerOptionsReInvite","hold","_this$session9","create","voip","outgoingRequestDelegate","_this$userAgent","outgoingMessage","userAgentCore","makeOutgoingRequestMessage","_this$userAgent2","request","register","_this$registerer","unregister","_this$registerer2","all","acceptCall","videoInvite","body","indexOf","invitationAcceptOptions","constraints","audio","video","accept","canRejectCall","includes","canEndOrHoldCall","rejectCall","endCall","cancel","bye","muteCall","holdCall","switchMediaRenderer","setWorkflowMode","CONTACT_CENTER_USER","setMembershipSubscription","subscription","_this$queueInfo","setMembership","getAggregator","getRegistrarState","_this$registerer3","toString","toLocaleLowerCase","_this$userAgent3","_this$registerer4","OP_CLEANUP","dispose","removeEventListener","onNetworkEvent","event","handler","on","offNetworkEvent","off","reconnectionAttempt","arguments","length","checkRegistration","reconnectionAttempts","reconnectionDelay","Math","pow","setTimeout","_this$userAgent4","reconnect","attemptPostRecoveryRoutine","attemptPostRecoveryRegistrationRoutine","sendKeepAliveAndWaitForResponse","withDebounce","promise","keepAliveAccepted","responseWaitTime","_error","e","_this$registerer6","_resolve","_reject","_this$registerer5","changeAudioInputDevice","_this$session10","warn","newStream","requestNewStream","replaceTrack","makeCallURI","_callee","_mediaRenderer","makeCall","_calleeNumber"],"sources":["client/lib/voip/VoIPUser.ts"],"sourcesContent":["/**\n * Class representing SIP UserAgent\n * @remarks\n * This class encapsulates all the details of sip.js and exposes\n * a very simple functions and callback handlers to the outside world.\n * This class thus abstracts user from Browser specific media details as well as\n * SIP specific protocol details.\n */\nimport type {\n\tCallStates,\n\tConnectionState,\n\tICallerInfo,\n\tIQueueMembershipSubscription,\n\tSignalingSocketEvents,\n\tSocketEventKeys,\n\tIMediaStreamRenderer,\n\tVoIPUserConfiguration,\n\tVoIpCallerInfo,\n\tIState,\n\tVoipEvents,\n} from '@rocket.chat/core-typings';\nimport { Operation, UserState, WorkflowTypes } from '@rocket.chat/core-typings';\nimport { Emitter } from '@rocket.chat/emitter';\nimport type { UserAgentOptions, InvitationAcceptOptions, Session, SessionInviteOptions } from 'sip.js';\nimport { UserAgent, Invitation, SessionState, Registerer, RequestPendingError, Inviter } from 'sip.js';\nimport type { OutgoingByeRequest, OutgoingRequestDelegate } from 'sip.js/lib/core';\nimport { URI } from 'sip.js/lib/core';\nimport type { SessionDescriptionHandlerOptions } from 'sip.js/lib/platform/web';\nimport { SessionDescriptionHandler } from 'sip.js/lib/platform/web';\n\nimport { toggleMediaStreamTracks } from './Helper';\nimport LocalStream from './LocalStream';\nimport { QueueAggregator } from './QueueAggregator';\nimport RemoteStream from './RemoteStream';\n\nexport class VoIPUser extends Emitter<VoipEvents> {\n\tstate: IState = {\n\t\tisReady: false,\n\t\tenableVideo: false,\n\t};\n\n\tprivate remoteStream: RemoteStream | undefined;\n\n\tuserAgentOptions: UserAgentOptions = {};\n\n\tuserAgent: UserAgent | undefined;\n\n\tregisterer: Registerer | undefined;\n\n\tmediaStreamRendered?: IMediaStreamRenderer;\n\n\tprivate _connectionState: ConnectionState = 'INITIAL';\n\n\tprivate _held = false;\n\n\tprivate mode: WorkflowTypes;\n\n\tprivate queueInfo: QueueAggregator;\n\n\tprivate connectionRetryCount;\n\n\tprivate stop;\n\n\tprivate networkEmitter: Emitter<SignalingSocketEvents>;\n\n\tprivate offlineNetworkHandler: () => void;\n\n\tprivate onlineNetworkHandler: () => void;\n\n\tprivate optionsKeepaliveInterval = 5;\n\n\tprivate optionsKeepAliveDebounceTimeInSec = 5;\n\n\tprivate attemptRegistration = false;\n\n\tprotected session: Session | undefined;\n\n\tprotected _callState: CallStates = 'INITIAL';\n\n\tprotected _callerInfo: ICallerInfo | undefined;\n\n\tprotected _userState: UserState = UserState.IDLE;\n\n\tprotected _opInProgress: Operation = Operation.OP_NONE;\n\n\tget operationInProgress(): Operation {\n\t\treturn this._opInProgress;\n\t}\n\n\tget userState(): UserState | undefined {\n\t\treturn this._userState;\n\t}\n\n\tconstructor(\n\t\tprivate readonly config: VoIPUserConfiguration,\n\t\tmediaRenderer?: IMediaStreamRenderer,\n\t) {\n\t\tsuper();\n\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\tthis.networkEmitter = new Emitter<SignalingSocketEvents>();\n\t\tthis.connectionRetryCount = this.config.connectionRetryCount;\n\t\tthis.stop = false;\n\n\t\tthis.onlineNetworkHandler = this.onNetworkRestored.bind(this);\n\t\tthis.offlineNetworkHandler = this.onNetworkLost.bind(this);\n\t}\n\n\t/**\n\t * Configures and initializes sip.js UserAgent\n\t * call gets established.\n\t * @remarks\n\t * This class configures transport properties such as websocket url, passed down in config,\n\t * sets up ICE servers,\n\t * SIP UserAgent options such as userName, Password, URI.\n\t * Once initialized, it starts the userAgent.\n\t */\n\n\tasync init(): Promise<void> {\n\t\tconst sipUri = `sip:${this.config.authUserName}@${this.config.sipRegistrarHostnameOrIP}`;\n\t\tconst transportOptions = {\n\t\t\tserver: this.config.webSocketURI,\n\t\t\tconnectionTimeout: 100, // Replace this with config\n\t\t\tkeepAliveInterval: 20,\n\t\t\t// traceSip: true,\n\t\t};\n\t\tconst sdpFactoryOptions = {\n\t\t\ticeGatheringTimeout: 10,\n\t\t\tpeerConnectionConfiguration: {\n\t\t\t\ticeServers: this.config.iceServers,\n\t\t\t},\n\t\t};\n\t\tthis.userAgentOptions = {\n\t\t\tdelegate: {\n\t\t\t\tonInvite: async (invitation: Invitation): Promise<void> => {\n\t\t\t\t\tawait this.handleIncomingCall(invitation);\n\t\t\t\t},\n\t\t\t},\n\t\t\tauthorizationPassword: this.config.authPassword,\n\t\t\tauthorizationUsername: this.config.authUserName,\n\t\t\turi: UserAgent.makeURI(sipUri),\n\t\t\ttransportOptions,\n\t\t\tsessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\n\t\t\tlogConfiguration: false,\n\t\t\tlogLevel: 'error',\n\t\t};\n\n\t\tthis.userAgent = new UserAgent(this.userAgentOptions);\n\t\tthis.userAgent.transport.isConnected();\n\t\tthis._opInProgress = Operation.OP_CONNECT;\n\t\ttry {\n\t\t\tthis.registerer = new Registerer(this.userAgent);\n\n\t\t\tthis.userAgent.transport.onConnect = this.onConnected.bind(this);\n\t\t\tthis.userAgent.transport.onDisconnect = this.onDisconnected.bind(this);\n\t\t\twindow.addEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.addEventListener('offline', this.offlineNetworkHandler);\n\t\t\tawait this.userAgent.start();\n\t\t\tif (this.config.enableKeepAliveUsingOptionsForUnstableNetworks) {\n\t\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tasync onConnected(): Promise<void> {\n\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\tthis.state.isReady = true;\n\t\tthis.sendOptions();\n\t\tthis.networkEmitter.emit('connected');\n\t\t/**\n\t\t * Re-registration post network recovery should be attempted\n\t\t * if it was previously registered or incall/onhold\n\t\t */\n\n\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\tthis.attemptRegistration = true;\n\t\t}\n\t}\n\n\tonDisconnected(error: any): void {\n\t\tthis._connectionState = 'SERVER_DISCONNECTED';\n\t\tthis._opInProgress = Operation.OP_NONE;\n\t\tthis.networkEmitter.emit('disconnected');\n\t\tif (error) {\n\t\t\tthis.networkEmitter.emit('connectionerror', error);\n\t\t\tthis.state.isReady = false;\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted assuming\n\t\t\t * that the disconnect happened from the remote side or due to sleep\n\t\t\t * In case of remote side disconnection, if config.connectionRetryCount is -1,\n\t\t\t * attemptReconnection attempts continuously. Else stops after |config.connectionRetryCount|\n\t\t\t *\n\t\t\t */\n\t\t\t// this.attemptReconnection();\n\t\t\tthis.attemptReconnection(0, false);\n\t\t}\n\t}\n\n\tonNetworkRestored(): void {\n\t\tthis.networkEmitter.emit('localnetworkonline');\n\t\tif (this._connectionState === 'WAITING_FOR_NETWORK') {\n\t\t\t/**\n\t\t\t * Signalling socket reconnection should be attempted when online event handler\n\t\t\t * gets notified.\n\t\t\t * Important thing to note is that the second parameter |checkRegistration| = true passed here\n\t\t\t * because after the network recovery and after reconnecting to the server,\n\t\t\t * the transport layer of SIPUA does not call onConnected. So by passing |checkRegistration = true |\n\t\t\t * the code will check if the endpoint was previously registered before the disconnection.\n\t\t\t * If such is the case, it will first unregister and then re-register.\n\t\t\t * */\n\t\t\tthis.attemptReconnection();\n\t\t\tif (this.registerer && this.callState !== 'INITIAL') {\n\t\t\t\tthis.attemptRegistration = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tonNetworkLost(): void {\n\t\tthis.networkEmitter.emit('localnetworkoffline');\n\t\tthis._connectionState = 'WAITING_FOR_NETWORK';\n\t}\n\n\tget userConfig(): VoIPUserConfiguration {\n\t\treturn this.config;\n\t}\n\n\tget callState(): CallStates {\n\t\treturn this._callState;\n\t}\n\n\tget connectionState(): ConnectionState {\n\t\treturn this._connectionState;\n\t}\n\n\tget callerInfo(): VoIpCallerInfo {\n\t\tif (\n\t\t\tthis.callState === 'IN_CALL' ||\n\t\t\tthis.callState === 'OFFER_RECEIVED' ||\n\t\t\tthis.callState === 'ON_HOLD' ||\n\t\t\tthis.callState === 'OFFER_SENT'\n\t\t) {\n\t\t\tif (!this._callerInfo) {\n\t\t\t\tthrow new Error('[VoIPUser callerInfo] invalid state');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tstate: this.callState,\n\t\t\t\tcaller: this._callerInfo,\n\t\t\t\tuserState: this._userState,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tstate: this.callState,\n\t\t\tuserState: this._userState,\n\t\t};\n\t}\n\n\t/* Media Stream functions begin */\n\t/** The local media stream. Undefined if call not answered. */\n\tget localMediaStream(): MediaStream | undefined {\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\t\treturn sdh.localMediaStream;\n\t}\n\n\t/* Media Stream functions end */\n\t/* OutgoingRequestDelegate methods begin */\n\tonRegistrationRequestAccept(): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis._callState = 'REGISTERED';\n\t\t\tthis.emit('registered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\tthis.emit('unregistered');\n\t\t\tthis.emit('stateChanged');\n\t\t}\n\t}\n\n\tonRegistrationRequestReject(error: any): void {\n\t\tif (this._opInProgress === Operation.OP_REGISTER) {\n\t\t\tthis.emit('registrationerror', error);\n\t\t}\n\t\tif (this._opInProgress === Operation.OP_UNREGISTER) {\n\t\t\tthis.emit('unregistrationerror', error);\n\t\t}\n\t}\n\t/* OutgoingRequestDelegate methods end */\n\n\tprivate async handleIncomingCall(invitation: Invitation): Promise<void> {\n\t\tif (this.callState === 'REGISTERED') {\n\t\t\tthis._opInProgress = Operation.OP_PROCESS_INVITE;\n\t\t\tthis._callState = 'OFFER_RECEIVED';\n\t\t\tthis._userState = UserState.UAS;\n\t\t\tthis.session = invitation;\n\t\t\tthis.setupSessionEventHandlers(invitation);\n\t\t\tconst callerInfo: ICallerInfo = {\n\t\t\t\tcallerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\n\t\t\t\tcallerName: invitation.remoteIdentity.displayName,\n\t\t\t\thost: invitation.remoteIdentity.uri.host,\n\t\t\t};\n\t\t\tthis._callerInfo = callerInfo;\n\t\t\tthis.emit('incomingcall', callerInfo);\n\t\t\tthis.emit('stateChanged');\n\t\t\treturn;\n\t\t}\n\n\t\tawait invitation.reject();\n\t}\n\n\t/**\n\t * Sets up an listener handler for handling session's state change\n\t * @remarks\n\t * Called for setting up various state listeners. These listeners will\n\t * decide the next action to be taken when the session state changes.\n\t * e.g when session.state changes from |Establishing| to |Established|\n\t * one must set up local and remote media rendering.\n\t *\n\t * This class handles such session state changes and takes necessary actions.\n\t */\n\n\tprotected setupSessionEventHandlers(session: Session): void {\n\t\tthis.session?.stateChange.addListener((state: SessionState) => {\n\t\t\tif (this.session !== session) {\n\t\t\t\treturn; // if our session has changed, just return\n\t\t\t}\n\t\t\tswitch (state) {\n\t\t\t\tcase SessionState.Initial:\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Establishing:\n\t\t\t\t\tthis.emit('ringing', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Established:\n\t\t\t\t\tif (this._userState === UserState.UAC) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * We need to decide about user-state ANSWER-RECEIVED for outbound.\n\t\t\t\t\t\t * This state is there for the symmetry of ANSWER-SENT.\n\t\t\t\t\t\t * ANSWER-SENT occurs when there is incoming invite. So then the UA\n\t\t\t\t\t\t * accepts a call, it sends the answer and state becomes ANSWER-SENT.\n\t\t\t\t\t\t * The call gets established only when the remote party sends ACK.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * But in case of UAC where the invite is sent out, there is no intermediate\n\t\t\t\t\t\t * state where the UA can be in ANSWER-RECEIVED. As soon this UA receives the answer,\n\t\t\t\t\t\t * it sends ack and changes the SessionState to established.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * So we do not have an actual state transitions from ANSWER-RECEIVED to IN-CALL.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Nevertheless, this state is just added to maintain the symmetry. This can be safely removed.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * */\n\t\t\t\t\t\tthis._callState = 'ANSWER_RECEIVED';\n\t\t\t\t\t}\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis.setupRemoteMedia();\n\t\t\t\t\tthis._callState = 'IN_CALL';\n\t\t\t\t\tthis.emit('callestablished', { userState: this._userState, callInfo: this._callerInfo });\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tcase SessionState.Terminating:\n\t\t\t\t// fall through\n\t\t\t\tcase SessionState.Terminated:\n\t\t\t\t\tthis.session = undefined;\n\t\t\t\t\tthis._callState = 'REGISTERED';\n\t\t\t\t\tthis._opInProgress = Operation.OP_NONE;\n\t\t\t\t\tthis._userState = UserState.IDLE;\n\t\t\t\t\tthis.emit('callterminated');\n\t\t\t\t\tthis.remoteStream?.clear();\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown session state.');\n\t\t\t}\n\t\t});\n\t}\n\n\tonTrackAdded(_event: any): void {\n\t\tconsole.log('onTrackAdded');\n\t}\n\n\tonTrackRemoved(_event: any): void {\n\t\tconsole.log('onTrackRemoved');\n\t}\n\n\t/**\n\t * Carries out necessary steps for rendering remote media whe\n\t * call gets established.\n\t * @remarks\n\t * Sets up Stream class and plays the stream on given Media element/\n\t * Also sets up various event handlers.\n\t */\n\tprivate setupRemoteMedia(): any {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tconst sdh = this.session?.sessionDescriptionHandler;\n\t\tif (!sdh) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!(sdh instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\n\t\t}\n\n\t\tconst remoteStream = sdh.remoteMediaStream;\n\t\tif (!remoteStream) {\n\t\t\tthrow new Error('Remote media stream is undefined.');\n\t\t}\n\n\t\tthis.remoteStream = new RemoteStream(remoteStream);\n\t\tconst mediaElement = this.mediaStreamRendered?.remoteMediaElement;\n\t\tif (mediaElement) {\n\t\t\tthis.remoteStream.init(mediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\t/**\n\t * Handles call mute-unmute\n\t */\n\tprivate async handleMuteUnmute(muteState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === muteState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = muteState;\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\tthis.emit('muteerror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A mute request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('muteerror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles call hold-unhold\n\t */\n\tprivate async handleHoldUnhold(holdState: boolean): Promise<void> {\n\t\tconst { session } = this;\n\t\tif (this._held === holdState) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (!session) {\n\t\t\tthrow new Error('Session not found');\n\t\t}\n\n\t\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\n\t\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n\t\t\tthrow new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n\t\t}\n\t\tconst options: SessionInviteOptions = {\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tthis._held = holdState;\n\t\t\t\t\tthis._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t\tonReject: (): void => {\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t\t\tthis.emit('holderror');\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Session properties used to pass options to the SessionDescriptionHandler:\n\t\t//\n\t\t// 1) Session.sessionDescriptionHandlerOptions\n\t\t//    SDH options for the initial INVITE transaction.\n\t\t//    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n\t\t//\n\t\t// 2) Session.sessionDescriptionHandlerOptionsReInvite\n\t\t//    SDH options for re-INVITE transactions.\n\t\t//    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n\t\t//    - May be set directly at anytime.\n\t\t//    - May optionally be set via constructor option.\n\t\t//    - May optionally be set via options passed to Session.invite().\n\n\t\tconst sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite as SessionDescriptionHandlerOptions;\n\t\tsessionDescriptionHandlerOptions.hold = holdState;\n\t\tsession.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\n\n\t\tconst { peerConnection } = sessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tthrow new Error('Peer connection closed.');\n\t\t}\n\t\treturn this.session\n\t\t\t?.invite(options)\n\t\t\t.then(() => {\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\n\t\t\t\ttoggleMediaStreamTracks(!this._held, session, 'sender');\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tif (error instanceof RequestPendingError) {\n\t\t\t\t\tconsole.error(`[${this.session?.id}] A hold request is already in progress.`);\n\t\t\t\t}\n\t\t\t\tthis.emit('holderror');\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tstatic async create(config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer): Promise<VoIPUser> {\n\t\tconst voip = new VoIPUser(config, mediaRenderer);\n\t\tawait voip.init();\n\t\treturn voip;\n\t}\n\n\t/**\n\t * Sends SIP OPTIONS message to asterisk\n\t *\n\t * There is an interesting problem that happens with Asterisk.\n\t * After websocket connection succeeds and if there is no SIP\n\t * message goes in 30 seconds, asterisk disconnects the socket.\n\t *\n\t * If any SIP message goes before 30 seconds, asterisk holds the connection.\n\t * This problem could be solved in multiple ways. One is that\n\t * whenever disconnect happens make sure that the socket is connected back using\n\t * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\n\t * every 30 seconds till we send register message.\n\t *\n\t * Another approach is to send SIP OPTIONS just to tell server that\n\t * there is a UA using this socket. This is implemented below\n\t */\n\n\tsendOptions(outgoingRequestDelegate?: OutgoingRequestDelegate): void {\n\t\tconst uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\n\t\tconst outgoingMessage = this.userAgent?.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\n\t\tif (outgoingMessage) {\n\t\t\tthis.userAgent?.userAgentCore.request(outgoingMessage, outgoingRequestDelegate);\n\t\t}\n\t}\n\t/**\n\t * Public method called from outside to register the SIP UA with call server.\n\t * @remarks\n\t */\n\n\tregister(): void {\n\t\tthis._opInProgress = Operation.OP_REGISTER;\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Public method called from outside to unregister the SIP UA.\n\t * @remarks\n\t */\n\n\tunregister(): void {\n\t\tthis._opInProgress = Operation.OP_UNREGISTER;\n\t\tthis.registerer?.unregister({\n\t\t\tall: true,\n\t\t\trequestDelegate: {\n\t\t\t\tonAccept: this.onRegistrationRequestAccept.bind(this),\n\t\t\t\tonReject: this.onRegistrationRequestReject.bind(this),\n\t\t\t},\n\t\t});\n\t}\n\t/**\n\t * Public method called from outside to accept incoming call.\n\t * @remarks\n\t */\n\n\tasync acceptCall(mediaRenderer: IMediaStreamRenderer): Promise<void> {\n\t\tif (mediaRenderer) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t}\n\t\t// Call state must be in offer_received.\n\t\tif (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\n\t\t\tthis._callState = 'ANSWER_SENT';\n\t\t\t// Something is wrong, this session is not an instance of INVITE\n\t\t\tif (!(this.session instanceof Invitation)) {\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\t}\n\t\t\t/**\n\t\t\t * It is important to decide when to add video option to the outgoing offer.\n\t\t\t * This would matter when the reinvite goes out (In case of hold/unhold)\n\t\t\t * This was added because there were failures in hold-unhold.\n\t\t\t * The scenario was that if this client does hold-unhold first, and remote client does\n\t\t\t * later, remote client goes in inconsistent state and hold-unhold does not work\n\t\t\t * Where as if the remote client does hold-unhold first, this client can do it any number\n\t\t\t * of times.\n\t\t\t *\n\t\t\t * Logic below works as follows\n\t\t\t * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\n\t\t\t * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\n\t\t\t * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\n\t\t\t * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\n\t\t\t *\n\t\t\t */\n\t\t\tlet videoInvite = !!this.config.enableVideo;\n\n\t\t\tconst { body } = this.session;\n\t\t\tif (body && body.indexOf('m=video') === -1) {\n\t\t\t\tvideoInvite = false;\n\t\t\t}\n\n\t\t\tconst invitationAcceptOptions: InvitationAcceptOptions = {\n\t\t\t\tsessionDescriptionHandlerOptions: {\n\t\t\t\t\tconstraints: {\n\t\t\t\t\t\taudio: true,\n\t\t\t\t\t\tvideo: !!this.config.enableVideo && videoInvite,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\treturn this.session.accept(invitationAcceptOptions);\n\t\t}\n\t\tthrow new Error('Something went wrong');\n\t}\n\n\t/* Helper routines for checking call actions BEGIN */\n\n\tprivate canRejectCall(): boolean {\n\t\treturn ['OFFER_RECEIVED', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\tprivate canEndOrHoldCall(): boolean {\n\t\treturn ['ANSWER_SENT', 'ANSWER_RECEIVED', 'IN_CALL', 'ON_HOLD', 'OFFER_SENT'].includes(this._callState);\n\t}\n\n\t/* Helper routines for checking call actions END */\n\n\t/**\n\t * Public method called from outside to reject a call.\n\t * @remarks\n\t */\n\trejectCall(): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canRejectCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tif (!(this.session instanceof Invitation)) {\n\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t}\n\t\treturn this.session.reject();\n\t}\n\n\t/**\n\t * Public method called from outside to end a call.\n\t * @remarks\n\t */\n\tasync endCall(): Promise<OutgoingByeRequest | void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\n\t\t// When call ends, force state to be revisited\n\t\tthis.emit('stateChanged');\n\t\tswitch (this.session.state) {\n\t\t\tcase SessionState.Initial:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Establishing:\n\t\t\t\tif (this.session instanceof Invitation) {\n\t\t\t\t\treturn this.session.reject();\n\t\t\t\t}\n\t\t\t\tif (this.session instanceof Inviter) {\n\t\t\t\t\treturn this.session.cancel();\n\t\t\t\t}\n\t\t\t\tthrow new Error('Session not instance of Invitation.');\n\t\t\tcase SessionState.Established:\n\t\t\t\treturn this.session.bye();\n\t\t\tcase SessionState.Terminating:\n\t\t\t\tbreak;\n\t\t\tcase SessionState.Terminated:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown state');\n\t\t}\n\t}\n\n\t/**\n\t * Public method called from outside to mute the call.\n\t * @remarks\n\t */\n\tasync muteCall(muteState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (this._callState !== 'IN_CALL') {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleMuteUnmute(muteState);\n\t}\n\n\t/**\n\t * Public method called from outside to hold the call.\n\t * @remarks\n\t */\n\tasync holdCall(holdState: boolean): Promise<void> {\n\t\tif (!this.session) {\n\t\t\tthrow new Error('Session does not exist.');\n\t\t}\n\t\tif (!this.canEndOrHoldCall()) {\n\t\t\tthrow new Error(`Incorrect call State = ${this.callState}`);\n\t\t}\n\t\tthis.handleHoldUnhold(holdState);\n\t}\n\n\t/* CallEventDelegate implementation end */\n\tisReady(): boolean {\n\t\treturn this.state.isReady;\n\t}\n\n\t/**\n\t * This function allows to change the media renderer media elements.\n\t */\n\tswitchMediaRenderer(mediaRenderer: IMediaStreamRenderer): void {\n\t\tif (this.remoteStream) {\n\t\t\tthis.mediaStreamRendered = mediaRenderer;\n\t\t\tthis.remoteStream.init(mediaRenderer.remoteMediaElement);\n\t\t\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\n\t\t\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\n\t\t\tthis.remoteStream.play();\n\t\t}\n\t}\n\n\tsetWorkflowMode(mode: WorkflowTypes): void {\n\t\tthis.mode = mode;\n\t\tif (mode === WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\tthis.queueInfo = new QueueAggregator();\n\t\t}\n\t}\n\n\tsetMembershipSubscription(subscription: IQueueMembershipSubscription): void {\n\t\tif (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\n\t\t\treturn;\n\t\t}\n\t\tthis.queueInfo?.setMembership(subscription);\n\t}\n\n\tgetAggregator(): QueueAggregator {\n\t\treturn this.queueInfo;\n\t}\n\n\tgetRegistrarState(): string | undefined {\n\t\treturn this.registerer?.state.toString().toLocaleLowerCase();\n\t}\n\n\tclear(): void {\n\t\tthis._opInProgress = Operation.OP_CLEANUP;\n\t\t/** Socket reconnection is attempted when the socket is disconnected with some error.\n\t\t * While disconnecting, if there is any socket error, there should be no reconnection attempt.\n\t\t * So when userAgent.stop() is called which closes the sockets, it should be made sure that\n\t\t * if the socket is disconnected with error, connection attempts are not started or\n\t\t * if there are any previously ongoing attempts, they should be terminated.\n\t\t * flag attemptReconnect is used for ensuring this.\n\t\t */\n\t\tthis.stop = true;\n\t\tthis.userAgent?.stop();\n\t\tthis.registerer?.dispose();\n\t\tthis._connectionState = 'STOP';\n\n\t\tif (this.userAgent) {\n\t\t\tthis.userAgent.transport.onConnect = undefined;\n\t\t\tthis.userAgent.transport.onDisconnect = undefined;\n\t\t\twindow.removeEventListener('online', this.onlineNetworkHandler);\n\t\t\twindow.removeEventListener('offline', this.offlineNetworkHandler);\n\t\t}\n\t}\n\n\tonNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.on(event, handler);\n\t}\n\n\toffNetworkEvent(event: SocketEventKeys, handler: () => void): void {\n\t\tthis.networkEmitter.off(event, handler);\n\t}\n\n\t/**\n\t * Connection is lost in 3 ways\n\t * 1. When local network is lost (Router is disconnected, switching networks, devtools->network->offline)\n\t * In this case, the SIP.js's transport layer does not detect the disconnection. Hence, it does not\n\t * call |onDisconnect|. To detect this kind of disconnection, window event listeners have been added.\n\t * These event listeners would be get called when the browser detects that network is offline or online.\n\t * When the network is restored, the code tries to reconnect. The useragent.transport \"does not\" generate the\n\t * onconnected event in this case as well. so onlineNetworkHandler calls attemptReconnection.\n\t * Which calls attemptRegistrationPostRecovery based on correct state. attemptRegistrationPostRecovery first tries to\n\t * unregister and then re-register.\n\t * Important note : We use the event listeners using bind function object offlineNetworkHandler and onlineNetworkHandler\n\t * It is done so because the same event handlers need to be used for removeEventListener, which becomes impossible\n\t * if done inline.\n\t *\n\t * 2. Computer goes to sleep. In this case onDisconnect is triggered. The code tries to reconnect but cant go ahead\n\t * as it goes to sleep. On waking up, The attemptReconnection gets executed, connection is completed.\n\t * In this case, it generates onConnected event. In this onConnected event it calls attemptRegistrationPostRecovery\n\t *\n\t * 3. When Asterisk disconnects all the endpoints either because it crashes or restarted,\n\t * As soon as the agent successfully connects to asterisk, it should re-register\n\t *\n\t * Retry count :\n\t * connectionRetryCount is the parameter called |Retry Count| in\n\t * Administration -> Call Center -> Server configuration -> Retry count.\n\t * The retry is implemented with backoff, maxbackoff = 8 seconds.\n\t * For continuous retries (In case Asterisk restart happens) Set this parameter to -1.\n\t *\n\t * Important to note is how attemptRegistrationPostRecovery is called. In case of\n\t * the router connection loss or while switching the networks,\n\t * there is no disconnect and connect event from the transport layer of the userAgent.\n\t * So in this case, when the connection is successful after reconnect, the code should try to re-register by calling\n\t * attemptRegistrationPostRecovery.\n\t * In case of computer waking from sleep or asterisk getting restored, connect and disconnect events are generated.\n\t * In this case, re-registration should be triggered (by calling) only when onConnected gets called and not otherwise.\n\t */\n\n\tasync attemptReconnection(reconnectionAttempt = 0, checkRegistration = false): Promise<void> {\n\t\tconst reconnectionAttempts = this.connectionRetryCount;\n\t\tthis._connectionState = 'SERVER_RECONNECTING';\n\t\tif (!this.userAgent) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.stop) {\n\t\t\treturn;\n\t\t}\n\t\t// reconnectionAttempts == -1 then keep continuously trying\n\t\tif (reconnectionAttempts !== -1 && reconnectionAttempt > reconnectionAttempts) {\n\t\t\tthis._connectionState = 'ERROR';\n\t\t\treturn;\n\t\t}\n\n\t\tconst reconnectionDelay = Math.pow(2, reconnectionAttempt % 4);\n\n\t\tconsole.error(`Attempting to reconnect with backoff due to network loss. Backoff time [${reconnectionDelay}]`);\n\t\tsetTimeout(() => {\n\t\t\tif (this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState === 'SERVER_CONNECTED') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.userAgent\n\t\t\t\t?.reconnect()\n\t\t\t\t.then(() => {\n\t\t\t\t\tthis._connectionState = 'SERVER_CONNECTED';\n\t\t\t\t})\n\t\t\t\t.catch(() => {\n\t\t\t\t\tthis.attemptReconnection(++reconnectionAttempt, checkRegistration);\n\t\t\t\t});\n\t\t}, reconnectionDelay * 1000);\n\t}\n\n\tasync attemptPostRecoveryRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tthis.sendOptions({\n\t\t\tonAccept: (): void => {\n\t\t\t\tthis.attemptPostRecoveryRegistrationRoutine();\n\t\t\t},\n\t\t\tonReject: (error: unknown): void => {\n\t\t\t\tconsole.error(`[${error}] Failed to do options in attemptPostRecoveryRoutine()`);\n\t\t\t},\n\t\t});\n\t}\n\n\tasync sendKeepAliveAndWaitForResponse(withDebounce = false): Promise<boolean> {\n\t\tconst promise = new Promise<boolean>((resolve, reject) => {\n\t\t\tlet keepAliveAccepted = false;\n\t\t\tlet responseWaitTime = this.optionsKeepaliveInterval / 2;\n\t\t\tif (withDebounce) {\n\t\t\t\tresponseWaitTime += this.optionsKeepAliveDebounceTimeInSec;\n\t\t\t}\n\n\t\t\tthis.sendOptions({\n\t\t\t\tonAccept: (): void => {\n\t\t\t\t\tkeepAliveAccepted = true;\n\t\t\t\t},\n\t\t\t\tonReject: (_error: unknown): void => {\n\t\t\t\t\tconsole.error('Failed to do options.');\n\t\t\t\t},\n\t\t\t});\n\t\t\tsetTimeout(async () => {\n\t\t\t\tif (!keepAliveAccepted) {\n\t\t\t\t\treject(false);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.attemptRegistration) {\n\t\t\t\t\t\tthis.attemptPostRecoveryRoutine();\n\t\t\t\t\t\tthis.attemptRegistration = false;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(true);\n\t\t\t\t}\n\t\t\t}, responseWaitTime * 1000);\n\t\t});\n\t\treturn promise;\n\t}\n\n\tasync startOptionsPingForUnstableNetworks(): Promise<void> {\n\t\tsetTimeout(async () => {\n\t\t\tif (!this.userAgent || this.stop) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._connectionState !== 'SERVER_RECONNECTING') {\n\t\t\t\tlet isConnected = false;\n\t\t\t\ttry {\n\t\t\t\t\tawait this.sendKeepAliveAndWaitForResponse();\n\t\t\t\t\tisConnected = true;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(`[${e}] Failed to do options ping.`);\n\t\t\t\t} finally {\n\t\t\t\t\t// Send event only if it's a \"change\" on the status (avoid unnecessary event flooding)\n\t\t\t\t\t!isConnected && this.networkEmitter.emit('disconnected');\n\t\t\t\t\tisConnected && this.networkEmitter.emit('connected');\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Each seconds check if the network can reach asterisk. If not, try to reconnect\n\t\t\tthis.startOptionsPingForUnstableNetworks();\n\t\t}, this.optionsKeepaliveInterval * 1000);\n\t}\n\n\tasync attemptPostRecoveryRegistrationRoutine(): Promise<void> {\n\t\t/**\n\t\t * It might happen that the whole network loss can happen\n\t\t * while there is ongoing call. In that case, we want to maintain\n\t\t * the call.\n\t\t *\n\t\t * So after re-registration, it should remain in the same state.\n\t\t * */\n\t\tconst promise = new Promise<void>((_resolve, _reject) => {\n\t\t\tthis.registerer?.unregister({\n\t\t\t\tall: true,\n\t\t\t\trequestDelegate: {\n\t\t\t\t\tonAccept: (): void => {\n\t\t\t\t\t\t_resolve();\n\t\t\t\t\t},\n\t\t\t\t\tonReject: (error): void => {\n\t\t\t\t\t\tconsole.error(`[${error}] While unregistering after recovery`);\n\t\t\t\t\t\tthis.emit('unregistrationerror', error);\n\t\t\t\t\t\t_reject('Error in Unregistering');\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t\ttry {\n\t\t\tawait promise;\n\t\t} catch (error) {\n\t\t\tconsole.error(`[${error}] While waiting for unregister promise`);\n\t\t}\n\t\tthis.registerer?.register({\n\t\t\trequestDelegate: {\n\t\t\t\tonReject: (error): void => {\n\t\t\t\t\tthis._callState = 'UNREGISTERED';\n\t\t\t\t\tthis.emit('registrationerror', error);\n\t\t\t\t\tthis.emit('stateChanged');\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\tasync changeAudioInputDevice(constraints: MediaStreamConstraints): Promise<boolean> {\n\t\tif (!this.session) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No session. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst newStream = await LocalStream.requestNewStream(constraints, this.session);\n\t\tif (!newStream) {\n\t\t\tconsole.warn('changeAudioInputDevice() : Unable to get local stream. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t\tif (!peerConnection) {\n\t\t\tconsole.warn('changeAudioInputDevice() : No peer connection. Returning');\n\t\t\treturn false;\n\t\t}\n\t\tLocalStream.replaceTrack(peerConnection, newStream, 'audio');\n\t\treturn true;\n\t}\n\n\t// Commenting this as Video Configuration is not part of the scope for now\n\t// async changeVideoInputDevice(selectedVideoDevices: IDevice): Promise<boolean> {\n\t// \tif (!this.session) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No session. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tif (!this.config.enableVideo || this.deviceManager.hasVideoInputDevice()) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable change video device. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tthis.deviceManager.changeVideoInputDevice(selectedVideoDevices);\n\t// \tconst newStream = await LocalStream.requestNewStream(this.deviceManager.getConstraints('video'), this.session);\n\t// \tif (!newStream) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : Unable to get local stream. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\n\t// \tif (!peerConnection) {\n\t// \t\tconsole.warn('changeVideoInputDevice() : No peer connection. Returning');\n\t// \t\treturn false;\n\t// \t}\n\t// \tLocalStream.replaceTrack(peerConnection, newStream, 'video');\n\t// \treturn true;\n\t// }\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\tasync makeCallURI(_callee: string, _mediaRenderer?: IMediaStreamRenderer): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n\n\tasync makeCall(_calleeNumber: string): Promise<void> {\n\t\tthrow new Error('Not implemented');\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"0112c84312b4f8c5b7da12b68a8c23d2e9b23ce8"}
