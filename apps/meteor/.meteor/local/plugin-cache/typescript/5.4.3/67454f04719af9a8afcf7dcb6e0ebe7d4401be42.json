{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/client/lib/voip/LocalStream.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"client/lib/voip/LocalStream.ts","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/client/lib/voip/LocalStream.ts","inputSourceMap":{"version":3,"file":"client/lib/voip/LocalStream.ts","sourceRoot":"","sources":["client/lib/voip/LocalStream.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;GAaG;AAIH,OAAO,EAAE,yBAAyB,EAAE,MAAM,yBAAyB,CAAC;AAEpE,OAAO,MAAM,MAAM,UAAU,CAAC;AAE9B,MAAM,CAAC,OAAO,OAAO,WAAY,SAAQ,MAAM;IAC9C,MAAM,CAAC,KAAK,CAAC,gBAAgB,CAAC,WAAmC,EAAE,OAAgB;QAClF,MAAM,OAAO,GAAuB,yBAAyB,EAAE,CAAC;QAChE,IAAI,OAAO,EAAE,yBAAyB,EAAE,CAAC;YACxC,OAAO,OAAO,CAAC,WAAW,EAAE,OAAO,CAAC,yBAAsD,CAAC,CAAC;QAC7F,CAAC;IACF,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,YAAY,CAAC,cAAiC,EAAE,SAAsB,EAAE,SAA6B;QACjH,MAAM,OAAO,GAAG,cAAc,CAAC,UAAU,EAAE,CAAC;QAC5C,IAAI,CAAC,OAAO,EAAE,CAAC;YACd,OAAO,KAAK,CAAC;QACd,CAAC;QACD;;;;;;;;;;;;;;;;aAgBK;QAEL,QAAQ,SAAS,EAAE,CAAC;YACnB,KAAK,OAAO,CAAC,CAAC,CAAC;gBACd,IAAI,QAAQ,GAAG,KAAK,CAAC;gBACrB,MAAM,SAAS,GAAG,SAAS,CAAC,cAAc,EAAE,CAAC;gBAC7C,IAAI,CAAC,SAAS,EAAE,CAAC;oBAChB,OAAO,CAAC,IAAI,CAAC,2DAA2D,CAAC,CAAC;oBAC1E,OAAO,KAAK,CAAC;gBACd,CAAC;gBACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC1C,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,KAAK,OAAO,EAAE,CAAC;wBACxC,OAAO,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;wBACtC,QAAQ,GAAG,IAAI,CAAC;wBAChB,MAAM;oBACP,CAAC;gBACF,CAAC;gBACD,OAAO,QAAQ,CAAC;YACjB,CAAC;YACD,KAAK,OAAO,CAAC,CAAC,CAAC;gBACd,IAAI,QAAQ,GAAG,KAAK,CAAC;gBACrB,MAAM,SAAS,GAAG,SAAS,CAAC,cAAc,EAAE,CAAC;gBAC7C,IAAI,CAAC,SAAS,EAAE,CAAC;oBAChB,OAAO,CAAC,IAAI,CAAC,2DAA2D,CAAC,CAAC;oBAC1E,OAAO,KAAK,CAAC;gBACd,CAAC;gBACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC1C,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,KAAK,OAAO,EAAE,CAAC;wBACxC,OAAO,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;wBACtC,QAAQ,GAAG,IAAI,CAAC;wBAChB,MAAM;oBACP,CAAC;gBACF,CAAC;gBACD,OAAO,QAAQ,CAAC;YACjB,CAAC;YACD,OAAO,CAAC,CAAC,CAAC;gBACT,IAAI,QAAQ,GAAG,KAAK,CAAC;gBACrB,MAAM,SAAS,GAAG,SAAS,CAAC,cAAc,EAAE,CAAC;gBAC7C,IAAI,CAAC,SAAS,EAAE,CAAC;oBAChB,OAAO,CAAC,IAAI,CAAC,qDAAqD,CAAC,CAAC;oBACpE,OAAO,KAAK,CAAC;gBACd,CAAC;gBACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;wBAC3C,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;4BAClD,OAAO,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;4BACtC,QAAQ,GAAG,IAAI,CAAC;4BAChB,MAAM;wBACP,CAAC;oBACF,CAAC;gBACF,CAAC;gBACD,OAAO,QAAQ,CAAC;YACjB,CAAC;QACF,CAAC;IACF,CAAC;CACD","sourcesContent":["/**\n * This class is used for local stream manipulation.\n * @remarks\n * This class does not really store any local stream for the reason\n * that the local stream tracks are stored in the peer connection.\n *\n * This simply provides necessary methods for stream manipulation.\n *\n * Currently it does not use any of its base functionality. Nevertheless\n * there might be a need that we may want to do some stream operations\n * such as closing of tracks, in future. For that purpose, it is written\n * this way.\n *\n */\n\nimport type { Session } from 'sip.js';\nimport type { MediaStreamFactory, SessionDescriptionHandler } from 'sip.js/lib/platform/web';\nimport { defaultMediaStreamFactory } from 'sip.js/lib/platform/web';\n\nimport Stream from './Stream';\n\nexport default class LocalStream extends Stream {\n\tstatic async requestNewStream(constraints: MediaStreamConstraints, session: Session): Promise<MediaStream | undefined> {\n\t\tconst factory: MediaStreamFactory = defaultMediaStreamFactory();\n\t\tif (session?.sessionDescriptionHandler) {\n\t\t\treturn factory(constraints, session.sessionDescriptionHandler as SessionDescriptionHandler);\n\t\t}\n\t}\n\n\tstatic async replaceTrack(peerConnection: RTCPeerConnection, newStream: MediaStream, mediaType?: 'audio' | 'video'): Promise<boolean> {\n\t\tconst senders = peerConnection.getSenders();\n\t\tif (!senders) {\n\t\t\treturn false;\n\t\t}\n\t\t/**\n\t\t * This will be called when media device change happens.\n\t\t * This needs to be called externally when the device change occurs.\n\t\t * This function first acquires the new stream based on device selection\n\t\t * and then replaces the track in the sender of existing stream by track acquired\n\t\t * by caputuring new stream.\n\t\t *\n\t\t * Notes:\n\t\t * Each sender represents a track in the RTCPeerConnection.\n\t\t * Peer connection will contain single track for\n\t\t * each, audio, video and data.\n\t\t * Furthermore, We are assuming that\n\t\t * newly captured stream will have a single track for each media type. i.e\n\t\t * audio video and data. But this assumption may not be true atleast in theory. One may see multiple\n\t\t * audio track in the captured stream or multiple senders for same kind in the peer connection\n\t\t * If/When such situation arrives in future, we may need to revisit the track replacement logic.\n\t\t * */\n\n\t\tswitch (mediaType) {\n\t\t\tcase 'audio': {\n\t\t\t\tlet replaced = false;\n\t\t\t\tconst newTracks = newStream.getAudioTracks();\n\t\t\t\tif (!newTracks) {\n\t\t\t\t\tconsole.warn('replaceTrack() : No audio tracks in the stream. Returning');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < senders?.length; i++) {\n\t\t\t\t\tif (senders[i].track?.kind === 'audio') {\n\t\t\t\t\t\tsenders[i].replaceTrack(newTracks[0]);\n\t\t\t\t\t\treplaced = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn replaced;\n\t\t\t}\n\t\t\tcase 'video': {\n\t\t\t\tlet replaced = false;\n\t\t\t\tconst newTracks = newStream.getVideoTracks();\n\t\t\t\tif (!newTracks) {\n\t\t\t\t\tconsole.warn('replaceTrack() : No video tracks in the stream. Returning');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < senders?.length; i++) {\n\t\t\t\t\tif (senders[i].track?.kind === 'video') {\n\t\t\t\t\t\tsenders[i].replaceTrack(newTracks[0]);\n\t\t\t\t\t\treplaced = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn replaced;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tlet replaced = false;\n\t\t\t\tconst newTracks = newStream.getVideoTracks();\n\t\t\t\tif (!newTracks) {\n\t\t\t\t\tconsole.warn('replaceTrack() : No tracks in the stream. Returning');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < senders?.length; i++) {\n\t\t\t\t\tfor (let j = 0; j < newTracks.length; j++) {\n\t\t\t\t\t\tif (senders[i].track?.kind === newTracks[j].kind) {\n\t\t\t\t\t\t\tsenders[i].replaceTrack(newTracks[j]);\n\t\t\t\t\t\t\treplaced = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn replaced;\n\t\t\t}\n\t\t}\n\t}\n}\n"]},"targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/client/lib/voip/LocalStream.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"client/lib/voip/LocalStream.ts","inputSourceMap":{"version":3,"file":"client/lib/voip/LocalStream.ts","sourceRoot":"","sources":["client/lib/voip/LocalStream.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * This class is used for local stream manipulation.\n * @remarks\n * This class does not really store any local stream for the reason\n * that the local stream tracks are stored in the peer connection.\n *\n * This simply provides necessary methods for stream manipulation.\n *\n * Currently it does not use any of its base functionality. Nevertheless\n * there might be a need that we may want to do some stream operations\n * such as closing of tracks, in future. For that purpose, it is written\n * this way.\n *\n */\n\nimport type { Session } from 'sip.js';\nimport type { MediaStreamFactory, SessionDescriptionHandler } from 'sip.js/lib/platform/web';\nimport { defaultMediaStreamFactory } from 'sip.js/lib/platform/web';\n\nimport Stream from './Stream';\n\nexport default class LocalStream extends Stream {\n\tstatic async requestNewStream(constraints: MediaStreamConstraints, session: Session): Promise<MediaStream | undefined> {\n\t\tconst factory: MediaStreamFactory = defaultMediaStreamFactory();\n\t\tif (session?.sessionDescriptionHandler) {\n\t\t\treturn factory(constraints, session.sessionDescriptionHandler as SessionDescriptionHandler);\n\t\t}\n\t}\n\n\tstatic async replaceTrack(peerConnection: RTCPeerConnection, newStream: MediaStream, mediaType?: 'audio' | 'video'): Promise<boolean> {\n\t\tconst senders = peerConnection.getSenders();\n\t\tif (!senders) {\n\t\t\treturn false;\n\t\t}\n\t\t/**\n\t\t * This will be called when media device change happens.\n\t\t * This needs to be called externally when the device change occurs.\n\t\t * This function first acquires the new stream based on device selection\n\t\t * and then replaces the track in the sender of existing stream by track acquired\n\t\t * by caputuring new stream.\n\t\t *\n\t\t * Notes:\n\t\t * Each sender represents a track in the RTCPeerConnection.\n\t\t * Peer connection will contain single track for\n\t\t * each, audio, video and data.\n\t\t * Furthermore, We are assuming that\n\t\t * newly captured stream will have a single track for each media type. i.e\n\t\t * audio video and data. But this assumption may not be true atleast in theory. One may see multiple\n\t\t * audio track in the captured stream or multiple senders for same kind in the peer connection\n\t\t * If/When such situation arrives in future, we may need to revisit the track replacement logic.\n\t\t * */\n\n\t\tswitch (mediaType) {\n\t\t\tcase 'audio': {\n\t\t\t\tlet replaced = false;\n\t\t\t\tconst newTracks = newStream.getAudioTracks();\n\t\t\t\tif (!newTracks) {\n\t\t\t\t\tconsole.warn('replaceTrack() : No audio tracks in the stream. Returning');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < senders?.length; i++) {\n\t\t\t\t\tif (senders[i].track?.kind === 'audio') {\n\t\t\t\t\t\tsenders[i].replaceTrack(newTracks[0]);\n\t\t\t\t\t\treplaced = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn replaced;\n\t\t\t}\n\t\t\tcase 'video': {\n\t\t\t\tlet replaced = false;\n\t\t\t\tconst newTracks = newStream.getVideoTracks();\n\t\t\t\tif (!newTracks) {\n\t\t\t\t\tconsole.warn('replaceTrack() : No video tracks in the stream. Returning');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < senders?.length; i++) {\n\t\t\t\t\tif (senders[i].track?.kind === 'video') {\n\t\t\t\t\t\tsenders[i].replaceTrack(newTracks[0]);\n\t\t\t\t\t\treplaced = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn replaced;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tlet replaced = false;\n\t\t\t\tconst newTracks = newStream.getVideoTracks();\n\t\t\t\tif (!newTracks) {\n\t\t\t\t\tconsole.warn('replaceTrack() : No tracks in the stream. Returning');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < senders?.length; i++) {\n\t\t\t\t\tfor (let j = 0; j < newTracks.length; j++) {\n\t\t\t\t\t\tif (senders[i].track?.kind === newTracks[j].kind) {\n\t\t\t\t\t\t\tsenders[i].replaceTrack(newTracks[j]);\n\t\t\t\t\t\t\treplaced = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn replaced;\n\t\t\t}\n\t\t}\n\t}\n}\n"]}}},"code":"module.export({\n  default: () => LocalStream\n});\nlet defaultMediaStreamFactory;\nmodule.link(\"sip.js/lib/platform/web\", {\n  defaultMediaStreamFactory(v) {\n    defaultMediaStreamFactory = v;\n  }\n}, 0);\nlet Stream;\nmodule.link(\"./Stream\", {\n  default(v) {\n    Stream = v;\n  }\n}, 1);\nclass LocalStream extends Stream {\n  static async requestNewStream(constraints, session) {\n    const factory = defaultMediaStreamFactory();\n    if (session !== null && session !== void 0 && session.sessionDescriptionHandler) {\n      return factory(constraints, session.sessionDescriptionHandler);\n    }\n  }\n  static async replaceTrack(peerConnection, newStream, mediaType) {\n    const senders = peerConnection.getSenders();\n    if (!senders) {\n      return false;\n    }\n    /**\n     * This will be called when media device change happens.\n     * This needs to be called externally when the device change occurs.\n     * This function first acquires the new stream based on device selection\n     * and then replaces the track in the sender of existing stream by track acquired\n     * by caputuring new stream.\n     *\n     * Notes:\n     * Each sender represents a track in the RTCPeerConnection.\n     * Peer connection will contain single track for\n     * each, audio, video and data.\n     * Furthermore, We are assuming that\n     * newly captured stream will have a single track for each media type. i.e\n     * audio video and data. But this assumption may not be true atleast in theory. One may see multiple\n     * audio track in the captured stream or multiple senders for same kind in the peer connection\n     * If/When such situation arrives in future, we may need to revisit the track replacement logic.\n     * */\n    switch (mediaType) {\n      case 'audio':\n        {\n          let replaced = false;\n          const newTracks = newStream.getAudioTracks();\n          if (!newTracks) {\n            console.warn('replaceTrack() : No audio tracks in the stream. Returning');\n            return false;\n          }\n          for (let i = 0; i < (senders === null || senders === void 0 ? void 0 : senders.length); i++) {\n            var _senders$i$track;\n            if (((_senders$i$track = senders[i].track) === null || _senders$i$track === void 0 ? void 0 : _senders$i$track.kind) === 'audio') {\n              senders[i].replaceTrack(newTracks[0]);\n              replaced = true;\n              break;\n            }\n          }\n          return replaced;\n        }\n      case 'video':\n        {\n          let replaced = false;\n          const newTracks = newStream.getVideoTracks();\n          if (!newTracks) {\n            console.warn('replaceTrack() : No video tracks in the stream. Returning');\n            return false;\n          }\n          for (let i = 0; i < (senders === null || senders === void 0 ? void 0 : senders.length); i++) {\n            var _senders$i$track2;\n            if (((_senders$i$track2 = senders[i].track) === null || _senders$i$track2 === void 0 ? void 0 : _senders$i$track2.kind) === 'video') {\n              senders[i].replaceTrack(newTracks[0]);\n              replaced = true;\n              break;\n            }\n          }\n          return replaced;\n        }\n      default:\n        {\n          let replaced = false;\n          const newTracks = newStream.getVideoTracks();\n          if (!newTracks) {\n            console.warn('replaceTrack() : No tracks in the stream. Returning');\n            return false;\n          }\n          for (let i = 0; i < (senders === null || senders === void 0 ? void 0 : senders.length); i++) {\n            for (let j = 0; j < newTracks.length; j++) {\n              var _senders$i$track3;\n              if (((_senders$i$track3 = senders[i].track) === null || _senders$i$track3 === void 0 ? void 0 : _senders$i$track3.kind) === newTracks[j].kind) {\n                senders[i].replaceTrack(newTracks[j]);\n                replaced = true;\n                break;\n              }\n            }\n          }\n          return replaced;\n        }\n    }\n  }\n}","map":{"version":3,"names":["module","export","default","LocalStream","defaultMediaStreamFactory","link","v","Stream","requestNewStream","constraints","session","factory","sessionDescriptionHandler","replaceTrack","peerConnection","newStream","mediaType","senders","getSenders","replaced","newTracks","getAudioTracks","console","warn","i","length","_senders$i$track","track","kind","getVideoTracks","_senders$i$track2","j","_senders$i$track3"],"sources":["client/lib/voip/LocalStream.ts"],"sourcesContent":["/**\n * This class is used for local stream manipulation.\n * @remarks\n * This class does not really store any local stream for the reason\n * that the local stream tracks are stored in the peer connection.\n *\n * This simply provides necessary methods for stream manipulation.\n *\n * Currently it does not use any of its base functionality. Nevertheless\n * there might be a need that we may want to do some stream operations\n * such as closing of tracks, in future. For that purpose, it is written\n * this way.\n *\n */\n\nimport type { Session } from 'sip.js';\nimport type { MediaStreamFactory, SessionDescriptionHandler } from 'sip.js/lib/platform/web';\nimport { defaultMediaStreamFactory } from 'sip.js/lib/platform/web';\n\nimport Stream from './Stream';\n\nexport default class LocalStream extends Stream {\n\tstatic async requestNewStream(constraints: MediaStreamConstraints, session: Session): Promise<MediaStream | undefined> {\n\t\tconst factory: MediaStreamFactory = defaultMediaStreamFactory();\n\t\tif (session?.sessionDescriptionHandler) {\n\t\t\treturn factory(constraints, session.sessionDescriptionHandler as SessionDescriptionHandler);\n\t\t}\n\t}\n\n\tstatic async replaceTrack(peerConnection: RTCPeerConnection, newStream: MediaStream, mediaType?: 'audio' | 'video'): Promise<boolean> {\n\t\tconst senders = peerConnection.getSenders();\n\t\tif (!senders) {\n\t\t\treturn false;\n\t\t}\n\t\t/**\n\t\t * This will be called when media device change happens.\n\t\t * This needs to be called externally when the device change occurs.\n\t\t * This function first acquires the new stream based on device selection\n\t\t * and then replaces the track in the sender of existing stream by track acquired\n\t\t * by caputuring new stream.\n\t\t *\n\t\t * Notes:\n\t\t * Each sender represents a track in the RTCPeerConnection.\n\t\t * Peer connection will contain single track for\n\t\t * each, audio, video and data.\n\t\t * Furthermore, We are assuming that\n\t\t * newly captured stream will have a single track for each media type. i.e\n\t\t * audio video and data. But this assumption may not be true atleast in theory. One may see multiple\n\t\t * audio track in the captured stream or multiple senders for same kind in the peer connection\n\t\t * If/When such situation arrives in future, we may need to revisit the track replacement logic.\n\t\t * */\n\n\t\tswitch (mediaType) {\n\t\t\tcase 'audio': {\n\t\t\t\tlet replaced = false;\n\t\t\t\tconst newTracks = newStream.getAudioTracks();\n\t\t\t\tif (!newTracks) {\n\t\t\t\t\tconsole.warn('replaceTrack() : No audio tracks in the stream. Returning');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < senders?.length; i++) {\n\t\t\t\t\tif (senders[i].track?.kind === 'audio') {\n\t\t\t\t\t\tsenders[i].replaceTrack(newTracks[0]);\n\t\t\t\t\t\treplaced = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn replaced;\n\t\t\t}\n\t\t\tcase 'video': {\n\t\t\t\tlet replaced = false;\n\t\t\t\tconst newTracks = newStream.getVideoTracks();\n\t\t\t\tif (!newTracks) {\n\t\t\t\t\tconsole.warn('replaceTrack() : No video tracks in the stream. Returning');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < senders?.length; i++) {\n\t\t\t\t\tif (senders[i].track?.kind === 'video') {\n\t\t\t\t\t\tsenders[i].replaceTrack(newTracks[0]);\n\t\t\t\t\t\treplaced = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn replaced;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tlet replaced = false;\n\t\t\t\tconst newTracks = newStream.getVideoTracks();\n\t\t\t\tif (!newTracks) {\n\t\t\t\t\tconsole.warn('replaceTrack() : No tracks in the stream. Returning');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < senders?.length; i++) {\n\t\t\t\t\tfor (let j = 0; j < newTracks.length; j++) {\n\t\t\t\t\t\tif (senders[i].track?.kind === newTracks[j].kind) {\n\t\t\t\t\t\t\tsenders[i].replaceTrack(newTracks[j]);\n\t\t\t\t\t\t\treplaced = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn replaced;\n\t\t\t}\n\t\t}\n\t}\n}\n"],"mappings":"AAAAA,MAAA,CAAAC,MAAA;EAAAC,OAAA,EAAAA,CAAA,KAAAC;AAAA;AAAA,IAAAC,yBAAA;AAAAJ,MAAA,CAAAK,IAAA;EAAAD,0BAAAE,CAAA;IAAAF,yBAAA,GAAAE,CAAA;EAAA;AAAA;AAAA,IAAAC,MAAA;AAAAP,MAAA,CAAAK,IAAA;EAAAH,QAAAI,CAAA;IAAAC,MAAA,GAAAD,CAAA;EAAA;AAAA;AAqBc,MAAOH,WAAY,SAAQI,MAAM;EAC9C,aAAaC,gBAAgBA,CAACC,WAAmC,EAAEC,OAAgB;IAClF,MAAMC,OAAO,GAAuBP,yBAAyB,EAAE;IAC/D,IAAIM,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEE,yBAAyB,EAAE;MACvC,OAAOD,OAAO,CAACF,WAAW,EAAEC,OAAO,CAACE,yBAAsD,CAAC;IAC5F;EACD;EAEA,aAAaC,YAAYA,CAACC,cAAiC,EAAEC,SAAsB,EAAEC,SAA6B;IACjH,MAAMC,OAAO,GAAGH,cAAc,CAACI,UAAU,EAAE;IAC3C,IAAI,CAACD,OAAO,EAAE;MACb,OAAO,KAAK;IACb;IACA;;;;;;;;;;;;;;;;;IAkBA,QAAQD,SAAS;MAChB,KAAK,OAAO;QAAE;UACb,IAAIG,QAAQ,GAAG,KAAK;UACpB,MAAMC,SAAS,GAAGL,SAAS,CAACM,cAAc,EAAE;UAC5C,IAAI,CAACD,SAAS,EAAE;YACfE,OAAO,CAACC,IAAI,CAAC,2DAA2D,CAAC;YACzE,OAAO,KAAK;UACb;UACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAGP,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEQ,MAAM,GAAED,CAAC,EAAE,EAAE;YAAA,IAAAE,gBAAA;YACzC,IAAI,EAAAA,gBAAA,GAAAT,OAAO,CAACO,CAAC,CAAC,CAACG,KAAK,cAAAD,gBAAA,uBAAhBA,gBAAA,CAAkBE,IAAI,MAAK,OAAO,EAAE;cACvCX,OAAO,CAACO,CAAC,CAAC,CAACX,YAAY,CAACO,SAAS,CAAC,CAAC,CAAC,CAAC;cACrCD,QAAQ,GAAG,IAAI;cACf;YACD;UACD;UACA,OAAOA,QAAQ;QAChB;MACA,KAAK,OAAO;QAAE;UACb,IAAIA,QAAQ,GAAG,KAAK;UACpB,MAAMC,SAAS,GAAGL,SAAS,CAACc,cAAc,EAAE;UAC5C,IAAI,CAACT,SAAS,EAAE;YACfE,OAAO,CAACC,IAAI,CAAC,2DAA2D,CAAC;YACzE,OAAO,KAAK;UACb;UACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAGP,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEQ,MAAM,GAAED,CAAC,EAAE,EAAE;YAAA,IAAAM,iBAAA;YACzC,IAAI,EAAAA,iBAAA,GAAAb,OAAO,CAACO,CAAC,CAAC,CAACG,KAAK,cAAAG,iBAAA,uBAAhBA,iBAAA,CAAkBF,IAAI,MAAK,OAAO,EAAE;cACvCX,OAAO,CAACO,CAAC,CAAC,CAACX,YAAY,CAACO,SAAS,CAAC,CAAC,CAAC,CAAC;cACrCD,QAAQ,GAAG,IAAI;cACf;YACD;UACD;UACA,OAAOA,QAAQ;QAChB;MACA;QAAS;UACR,IAAIA,QAAQ,GAAG,KAAK;UACpB,MAAMC,SAAS,GAAGL,SAAS,CAACc,cAAc,EAAE;UAC5C,IAAI,CAACT,SAAS,EAAE;YACfE,OAAO,CAACC,IAAI,CAAC,qDAAqD,CAAC;YACnE,OAAO,KAAK;UACb;UACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAGP,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEQ,MAAM,GAAED,CAAC,EAAE,EAAE;YACzC,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,SAAS,CAACK,MAAM,EAAEM,CAAC,EAAE,EAAE;cAAA,IAAAC,iBAAA;cAC1C,IAAI,EAAAA,iBAAA,GAAAf,OAAO,CAACO,CAAC,CAAC,CAACG,KAAK,cAAAK,iBAAA,uBAAhBA,iBAAA,CAAkBJ,IAAI,MAAKR,SAAS,CAACW,CAAC,CAAC,CAACH,IAAI,EAAE;gBACjDX,OAAO,CAACO,CAAC,CAAC,CAACX,YAAY,CAACO,SAAS,CAACW,CAAC,CAAC,CAAC;gBACrCZ,QAAQ,GAAG,IAAI;gBACf;cACD;YACD;UACD;UACA,OAAOA,QAAQ;QAChB;IACD;EACD","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"67454f04719af9a8afcf7dcb6e0ebe7d4401be42"}
