{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/imports/client/sodium-plus/lib/sodiumplus.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"imports/client/sodium-plus/lib/sodiumplus.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/imports/client/sodium-plus/lib/sodiumplus.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/imports/client/sodium-plus/lib/sodiumplus.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/client/sodium-plus/lib/sodiumplus.js"}},"code":"!function (module1) {\n  const Backend = require('./backend');\n  const CryptographyKey = require('./cryptography-key');\n  const Ed25519SecretKey = require('./keytypes/ed25519sk');\n  const Ed25519PublicKey = require('./keytypes/ed25519pk');\n  const LibsodiumWrappersBackend = require('./backend/libsodium-wrappers');\n  const SodiumError = require('./sodium-error');\n  const SodiumNativeBackend = require('./backend/sodiumnative');\n  const X25519PublicKey = require('./keytypes/x25519pk');\n  const X25519SecretKey = require('./keytypes/x25519sk');\n  const Util = require('./util');\n\n  /* istanbul ignore if */\n  if (typeof Buffer === 'undefined') {\n    let Buffer = require('buffer/').Buffer;\n  }\n  class SodiumPlus {\n    constructor(backend) {\n      /* istanbul ignore if */\n      if (!(backend instanceof Backend)) {\n        throw new TypeError('Backend object must implement the backend function');\n      }\n      this.backend = backend;\n      Util.populateConstants(this);\n    }\n\n    /**\n     * Returns the name of the current active backend.\n     * This method is NOT async.\n     *\n     * @return {string}\n     */\n    getBackendName() {\n      return this.backend.backendName;\n    }\n\n    /**\n     * Is this powered by sodium-native?\n     * This method is NOT async.\n     *\n     * @return {boolean}\n     */\n    isSodiumNative() {\n      return this.backend instanceof SodiumNativeBackend;\n    }\n\n    /**\n     * Is this powered by libsodium-wrappers?\n     * This method is NOT async.\n     *\n     * @return {boolean}\n     */\n    isLibsodiumWrappers() {\n      return this.backend instanceof LibsodiumWrappersBackend;\n    }\n\n    /**\n     * Automatically select a backend.\n     *\n     * @return {Promise<SodiumPlus>}\n     */\n    static async auto() {\n      let backend;\n      try {\n        backend = await SodiumNativeBackend.init();\n      } catch (e) {\n        backend = await LibsodiumWrappersBackend.init();\n      }\n      /* istanbul ignore if */\n      if (!backend) {\n        backend = await LibsodiumWrappersBackend.init();\n      }\n      Util.populateConstants(backend);\n      return new SodiumPlus(backend);\n    }\n\n    /**\n     * If our backend isn't defined, it will trigger an autoload.\n     *\n     * Mostly used internally. `await SodiumPlus.auto()` provides the same\n     * exact guarantee as this method.\n     *\n     * @return {Promise<void>}\n     */\n    async ensureLoaded() {\n      /* istanbul ignore if */\n      if (typeof this.backend === 'undefined') {\n        try {\n          await SodiumPlus.auto();\n        } catch (e) {\n          this.backend = await LibsodiumWrappersBackend.init();\n        }\n      }\n    }\n\n    /**\n     * Decrypt a message (and optional associated data) with XChaCha20-Poly1305\n     *\n     * @param {String|Buffer} ciphertext\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @param {String|Buffer} assocData\n     * @return {Promise<Buffer>}\n     * @throws {SodiumError}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_decrypt(ciphertext, nonce, key) {\n      let assocData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n      await this.ensureLoaded();\n      if (nonce.length !== 24) {\n        throw new SodiumError('Argument 2 must be 24 bytes');\n      }\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Argument 3 must be an instance of CryptographyKey');\n      }\n      return await this.backend.crypto_aead_xchacha20poly1305_ietf_decrypt(await Util.toBuffer(ciphertext), assocData.length > 0 ? await Util.toBuffer(assocData) : null, await Util.toBuffer(nonce), key);\n    }\n\n    /**\n     * Encrypt a message (and optional associated data) with XChaCha20-Poly1305.\n     *\n     * Throws a SodiumError if an invalid ciphertext/AAD is provided for this\n     * nonce and key.\n     *\n     * @param {String|Buffer} plaintext\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @param {String|Buffer} assocData\n     * @return {Promise<Buffer>}\n     * @throws {SodiumError}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, nonce, key) {\n      let assocData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n      await this.ensureLoaded();\n      if (nonce.length !== 24) {\n        throw new SodiumError('Argument 2 must be 24 bytes');\n      }\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Argument 3 must be an instance of CryptographyKey');\n      }\n      return await this.backend.crypto_aead_xchacha20poly1305_ietf_encrypt(await Util.toBuffer(plaintext), assocData.length > 0 ? await Util.toBuffer(assocData) : null, await Util.toBuffer(nonce), key);\n    }\n\n    /**\n     * Generate an XChaCha20-Poly1305 key.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(32));\n    }\n\n    /**\n     * Get an authenticator for a message for a given key.\n     *\n     * Algorithm: HMAC-SHA512 truncated to 32 bytes.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_auth(message, key) {\n      await this.ensureLoaded();\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n      }\n      await this.ensureLoaded();\n      return await this.backend.crypto_auth(await Util.toBuffer(message), key);\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_auth_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(32));\n    }\n\n    /**\n     * Verify an authenticator for a message for a given key.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} mac\n     * @return {Promise<boolean>}\n     */\n    async crypto_auth_verify(message, key, mac) {\n      await this.ensureLoaded();\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n      }\n      await this.ensureLoaded();\n      return await this.backend.crypto_auth_verify(await Util.toBuffer(mac), await Util.toBuffer(message), key);\n    }\n\n    /**\n     * Public-key authenticated encryption.\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {X25519SecretKey} myPrivateKey\n     * @param {X25519PublicKey} theirPublicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box(plaintext, nonce, myPrivateKey, theirPublicKey) {\n      await this.ensureLoaded();\n      if (!(myPrivateKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n      }\n      if (!(theirPublicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 4 must be an instance of X25519PublicKey');\n      }\n      nonce = await Util.toBuffer(nonce);\n      if (nonce.length !== 24) {\n        throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n      }\n      return this.backend.crypto_box(await Util.toBuffer(plaintext), await Util.toBuffer(nonce), myPrivateKey, theirPublicKey);\n    }\n\n    /**\n     * Public-key authenticated decryption.\n     *\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {X25519SecretKey} myPrivateKey\n     * @param {X25519PublicKey} theirPublicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_open(ciphertext, nonce, myPrivateKey, theirPublicKey) {\n      await this.ensureLoaded();\n      if (!(myPrivateKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n      }\n      if (!(theirPublicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 4 must be an instance of X25519PublicKey');\n      }\n      ciphertext = await Util.toBuffer(ciphertext);\n      if (ciphertext.length < 16) {\n        throw new SodiumError('Ciphertext must be a buffer of at least 16 bytes');\n      }\n      nonce = await Util.toBuffer(nonce);\n      if (nonce.length !== 24) {\n        throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n      }\n      return this.backend.crypto_box_open(ciphertext, nonce, myPrivateKey, theirPublicKey);\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_box_keypair() {\n      await this.ensureLoaded();\n      return this.backend.crypto_box_keypair();\n    }\n\n    /**\n     * Combine two X25519 keys (secret, public) into a keypair object.\n     *\n     * @param {X25519SecretKey} sKey\n     * @param {X25519PublicKey} pKey\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_box_keypair_from_secretkey_and_publickey(sKey, pKey) {\n      await this.ensureLoaded();\n      if (!(sKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n      }\n      if (!(pKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n      }\n      return await this.backend.crypto_box_keypair_from_secretkey_and_publickey(sKey, pKey);\n    }\n\n    /**\n     * Extract the secret key from an X25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<X25519SecretKey>}\n     */\n    async crypto_box_secretkey(keypair) {\n      if (keypair.getLength() !== 64) {\n        throw new SodiumError('Keypair must be 64 bytes');\n      }\n      return new X25519SecretKey(Buffer.from(keypair.getBuffer().slice(0, 32)));\n    }\n\n    /**\n     * Extract the public key from an X25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_box_publickey(keypair) {\n      if (keypair.getLength() !== 64) {\n        throw new SodiumError('Keypair must be 64 bytes');\n      }\n      return new X25519PublicKey(Buffer.from(keypair.getBuffer().slice(32, 64)));\n    }\n\n    /**\n     * Derive the public key from a given X25519 secret key.\n     *\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_box_publickey_from_secretkey(secretKey) {\n      await this.ensureLoaded();\n      if (!(secretKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n      }\n      return new X25519PublicKey(await this.backend.crypto_scalarmult_base(secretKey));\n    }\n\n    /**\n     * Anonymous public-key encryption. (Message integrity is still assured.)\n     *\n     * @param {string|Buffer} plaintext\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_seal(plaintext, publicKey) {\n      await this.ensureLoaded();\n      if (!(publicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n      }\n      return await this.backend.crypto_box_seal(plaintext, publicKey);\n    }\n\n    /**\n     * Anonymous public-key decryption. (Message integrity is still assured.)\n     *\n     * @param {Buffer} ciphertext\n     * @param {X25519PublicKey} publicKey\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_seal_open(ciphertext, publicKey, secretKey) {\n      await this.ensureLoaded();\n      if (!(publicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n      }\n      if (!(secretKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n      }\n      return await this.backend.crypto_box_seal_open(await Util.toBuffer(ciphertext), publicKey, secretKey);\n    }\n\n    /**\n     * Generic-purpose cryptographic hash.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash(message) {\n      let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let outputLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;\n      await this.ensureLoaded();\n      return await this.backend.crypto_generichash(message, key, outputLength);\n    }\n\n    /**\n     * Initialize a BLAKE2 hash context for stream hashing.\n     *\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash_init() {\n      let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      let outputLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n      await this.ensureLoaded();\n      return await this.backend.crypto_generichash_init(key, outputLength);\n    }\n\n    /**\n     * Update the BLAKE2 hash state with a block of data.\n     *\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @return {Promise<*>}\n     */\n    async crypto_generichash_update(state, message) {\n      await this.ensureLoaded();\n      return await this.backend.crypto_generichash_update(state, message);\n    }\n\n    /**\n     * Obtain the final BLAKE2 hash output.\n     *\n     * @param {*} state\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash_final(state) {\n      let outputLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n      await this.ensureLoaded();\n      return await this.backend.crypto_generichash_final(state, outputLength);\n    }\n\n    /**\n     * Generate a 256-bit random key for BLAKE2.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_generichash_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(this.CRYPTO_GENERICHASH_KEYBYTES));\n    }\n\n    /**\n     * Derive a subkey from a master key.\n     *\n     * @param {number} length\n     * @param {number} subKeyId\n     * @param {string|Buffer} context\n     * @param {CryptographyKey} key\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kdf_derive_from_key(length, subKeyId, context, key) {\n      await this.ensureLoaded();\n      if (length < 1) {\n        throw new SodiumError('Length must be a positive integer.');\n      }\n      if (subKeyId < 0) {\n        throw new SodiumError('Key ID must be an unsigned integer');\n      }\n      return await this.backend.crypto_kdf_derive_from_key(length, subKeyId, context, key);\n    }\n\n    /**\n     * Generate a 256-bit random key for our KDF.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kdf_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(this.CRYPTO_KDF_KEYBYTES));\n    }\n\n    /**\n     * This is functionally identical to crypto_box_keypair().\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kx_keypair() {\n      return this.crypto_box_keypair();\n    }\n\n    /**\n     * Generate an X25519 keypair from a seed.\n     *\n     * @param {string|Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kx_seed_keypair(seed) {\n      await this.ensureLoaded();\n      const sk = await this.backend.crypto_generichash(seed, null, this.CRYPTO_KX_SECRETKEYBYTES);\n      const pk = await this.backend.crypto_scalarmult_base(new CryptographyKey(sk));\n      return new CryptographyKey(Buffer.concat([sk, pk]));\n    }\n\n    /**\n     * Perform a key exchange from the client's perspective.\n     *\n     * Returns an array of two CryptographyKey objects.\n     *\n     * The first is meant for data sent from the server to the client (incoming decryption).\n     * The second is meant for data sent from the client to the server (outgoing encryption).\n     *\n     * @param {X25519PublicKey} clientPublicKey\n     * @param {X25519SecretKey} clientSecretKey\n     * @param {X25519PublicKey} serverPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    async crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey) {\n      await this.ensureLoaded();\n      if (!(clientPublicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 1 must be an instance of X25519PublicKey');\n      }\n      if (!(clientSecretKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 2 must be an instance of X25519SecretKey');\n      }\n      if (!(serverPublicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 3 must be an instance of X25519PublicKey');\n      }\n      return this.backend.crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey);\n    }\n\n    /**\n     * Perform a key exchange from the server's perspective.\n     *\n     * Returns an array of two CryptographyKey objects.\n     *\n     * The first is meant for data sent from the client to the server (incoming decryption).\n     * The second is meant for data sent from the server to the client (outgoing encryption).\n     *\n     * @param {X25519PublicKey} serverPublicKey\n     * @param {X25519SecretKey} serverSecretKey\n     * @param {X25519PublicKey} clientPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    async crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey) {\n      await this.ensureLoaded();\n      if (!(serverPublicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 1 must be an instance of X25519PublicKey');\n      }\n      if (!(serverSecretKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 2 must be an instance of X25519SecretKey');\n      }\n      if (!(clientPublicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 3 must be an instance of X25519PublicKey');\n      }\n      return this.backend.crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey);\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_onetimeauth(message, key) {\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n      }\n      return await this.backend.crypto_onetimeauth(await Util.toBuffer(message), key);\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} tag\n     * @return {Promise<boolean>}\n     */\n    async crypto_onetimeauth_verify(message, key, tag) {\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n      }\n      return await this.backend.crypto_onetimeauth_verify(await Util.toBuffer(message), key, await Util.toBuffer(tag));\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_onetimeauth_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(32));\n    }\n\n    /**\n     * Derive a cryptography key from a password and salt.\n     *\n     * @param {number} length\n     * @param {string|Buffer} password\n     * @param {Buffer} salt\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @param {number|null} algorithm\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_pwhash(length, password, salt, opslimit, memlimit) {\n      let algorithm = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      await this.ensureLoaded();\n      /* istanbul ignore if */\n      if (!algorithm) {\n        algorithm = this.CRYPTO_PWHASH_ALG_DEFAULT;\n      }\n      return new CryptographyKey(await this.backend.crypto_pwhash(length, await Util.toBuffer(password), await Util.toBuffer(salt), opslimit, memlimit, algorithm));\n    }\n\n    /**\n     * Get a password hash (in a safe-for-storage format)\n     *\n     * @param {string|Buffer} password\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<string>}\n     */\n    async crypto_pwhash_str(password, opslimit, memlimit) {\n      await this.ensureLoaded();\n      return await this.backend.crypto_pwhash_str(password, opslimit, memlimit);\n    }\n\n    /**\n     * Verify a password against a known password hash\n     *\n     * @param {string|Buffer} password\n     * @param {string|Buffer} hash\n     * @return {Promise<boolean>}\n     */\n    async crypto_pwhash_str_verify(password, hash) {\n      await this.ensureLoaded();\n      return await this.backend.crypto_pwhash_str_verify(password, hash);\n    }\n\n    /**\n     * Does this password need to be rehashed?\n     *\n     * @param {string|Buffer} hash\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<boolean>}\n     */\n    async crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit) {\n      await this.ensureLoaded();\n      return await this.backend.crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit);\n    }\n\n    /**\n     * Elliptic Curve Diffie-Hellman key exchange\n     *\n     * @param {X25519SecretKey} secretKey\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_scalarmult(secretKey, publicKey) {\n      await this.ensureLoaded();\n      if (!(secretKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n      }\n      if (!(publicKey instanceof X25519PublicKey)) {\n        throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n      }\n      return await this.backend.crypto_scalarmult(secretKey, publicKey);\n    }\n\n    /**\n     * Generate an X25519PublicKey from an X25519SecretKey\n     *\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_scalarmult_base(secretKey) {\n      await this.ensureLoaded();\n      if (!(secretKey instanceof X25519SecretKey)) {\n        throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n      }\n      return new X25519PublicKey(await this.backend.crypto_scalarmult_base(secretKey));\n    }\n\n    /**\n     * Shared-key authenticated encryption\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretbox(plaintext, nonce, key) {\n      await this.ensureLoaded();\n      if (key.isEd25519Key() || key.isX25519Key()) {\n        throw new TypeError('Argument 3 must not be an asymmetric key');\n      }\n      nonce = await Util.toBuffer(nonce);\n      if (nonce.length !== 24) {\n        throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n      }\n      return await this.backend.crypto_secretbox(plaintext, nonce, key);\n    }\n\n    /**\n     * Shared-key authenticated decryption\n     *\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretbox_open(ciphertext, nonce, key) {\n      await this.ensureLoaded();\n      if (key.isEd25519Key() || key.isX25519Key()) {\n        throw new TypeError('Argument 3 must not be an asymmetric key');\n      }\n      ciphertext = await Util.toBuffer(ciphertext);\n      if (ciphertext.length < 16) {\n        throw new SodiumError('Ciphertext must be a buffer of at least 16 bytes');\n      }\n      nonce = await Util.toBuffer(nonce);\n      if (nonce.length !== 24) {\n        throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n      }\n      return await this.backend.crypto_secretbox_open(ciphertext, nonce, key);\n    }\n\n    /**\n     * Generate a key for shared-key authenticated encryption.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_secretbox_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(this.CRYPTO_SECRETBOX_KEYBYTES));\n    }\n\n    /**\n     * Internalize the internal state and a random header for stream encryption.\n     *\n     * @param {CryptographyKey} key\n     * @return {Promise<array>}\n     */\n    async crypto_secretstream_xchacha20poly1305_init_push(key) {\n      await this.ensureLoaded();\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Key must be an instance of CryptographyKey');\n      }\n      if (key.getLength() !== 32) {\n        throw new SodiumError('crypto_secretstream keys must be 32 bytes long');\n      }\n      const [state, header] = await this.backend.crypto_secretstream_xchacha20poly1305_init_push(key);\n      return Object.freeze({\n        header: header,\n        push: this.crypto_secretstream_xchacha20poly1305_push.bind(this, state),\n        rekey: this.crypto_secretstream_xchacha20poly1305_rekey.bind(this, state)\n      });\n    }\n\n    /**\n     * Initialize the internal state for stream decryption.\n     *\n     * @param {Buffer} header\n     * @param {CryptographyKey} key\n     * @return {Promise<*>}\n     */\n    async crypto_secretstream_xchacha20poly1305_init_pull(key, header) {\n      await this.ensureLoaded();\n      header = await Util.toBuffer(header);\n      if (header.length !== 24) {\n        throw new SodiumError('crypto_secretstream headers must be 24 bytes long');\n      }\n      if (!(key instanceof CryptographyKey)) {\n        throw new TypeError('Key must be an instance of CryptographyKey');\n      }\n      if (key.getLength() !== 32) {\n        throw new SodiumError('crypto_secretstream keys must be 32 bytes long');\n      }\n      const state = await this.backend.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n      return Object.freeze({\n        pull: this.crypto_secretstream_xchacha20poly1305_pull.bind(this, state)\n      });\n    }\n\n    /**\n     * Stream encryption.\n     *\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretstream_xchacha20poly1305_push(state, message) {\n      let ad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      let tag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      await this.ensureLoaded();\n      return this.backend.crypto_secretstream_xchacha20poly1305_push(state, message, ad, tag);\n    }\n\n    /**\n     * Stream decryption.\n     *\n     * @param {*} state\n     * @param {Buffer} ciphertext\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretstream_xchacha20poly1305_pull(state, ciphertext) {\n      let ad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      let tag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      await this.ensureLoaded();\n      return this.backend.crypto_secretstream_xchacha20poly1305_pull(state, ciphertext, ad, tag);\n    }\n\n    /**\n     * Deterministic rekeying.\n     *\n     * @param {*} state\n     * @return {Promise<void>}\n     */\n    async crypto_secretstream_xchacha20poly1305_rekey(state) {\n      await this.ensureLoaded();\n      await this.backend.crypto_secretstream_xchacha20poly1305_rekey(state);\n    }\n\n    /**\n     * Generate a key for shared-key authenticated encryption.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_secretstream_xchacha20poly1305_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_KEYBYTES));\n    }\n\n    /**\n     * Calculate a fast hash for short inputs.\n     *\n     * Algorithm: SipHash-2-4\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_shorthash(message, key) {\n      await this.ensureLoaded();\n      return await this.backend.crypto_shorthash(await Util.toBuffer(message), key);\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_shorthash_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(this.CRYPTO_SHORTHASH_KEYBYTES));\n    }\n\n    /**\n     * Returns a signed message.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign(message, secretKey) {\n      await this.ensureLoaded();\n      if (!(secretKey instanceof Ed25519SecretKey)) {\n        throw new TypeError('Argument 2 must be an instance of Ed25519SecretKey');\n      }\n      return this.backend.crypto_sign(message, secretKey);\n    }\n\n    /**\n     * Given a signed message, verify the Ed25519 signature. If it matches, return the\n     * bare message (no signature).\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_open(message, publicKey) {\n      await this.ensureLoaded();\n      if (!(publicKey instanceof Ed25519PublicKey)) {\n        throw new TypeError('Argument 2 must be an instance of Ed25519PublicKey');\n      }\n      return this.backend.crypto_sign_open(message, publicKey);\n    }\n\n    /**\n     * Returns the Ed25519 signature of the message, for the given secret key.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_detached(message, secretKey) {\n      await this.ensureLoaded();\n      if (!(secretKey instanceof Ed25519SecretKey)) {\n        throw new TypeError('Argument 2 must be an instance of Ed25519SecretKey');\n      }\n      return this.backend.crypto_sign_detached(message, secretKey);\n    }\n\n    /**\n     * Returns true if the Ed25519 signature is valid for a given message and public key.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @param {Buffer} signature\n     * @return {Promise<boolean>}\n     */\n    async crypto_sign_verify_detached(message, publicKey, signature) {\n      await this.ensureLoaded();\n      if (!(publicKey instanceof Ed25519PublicKey)) {\n        throw new TypeError('Argument 2 must be an instance of Ed25519PublicKey');\n      }\n      return this.backend.crypto_sign_verify_detached(message, publicKey, signature);\n    }\n\n    /**\n     * Extract the secret key from an Ed25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<Ed25519SecretKey>}\n     */\n    async crypto_sign_secretkey(keypair) {\n      if (keypair.getLength() !== 96) {\n        throw new SodiumError('Keypair must be 96 bytes');\n      }\n      return new Ed25519SecretKey(await Util.toBuffer(keypair.getBuffer().slice(0, 64)));\n    }\n\n    /**\n     * Extract the public key from an Ed25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<Ed25519PublicKey>}\n     */\n    async crypto_sign_publickey(keypair) {\n      if (keypair.getLength() !== 96) {\n        throw new SodiumError('Keypair must be 96 bytes');\n      }\n      return new Ed25519PublicKey(keypair.getBuffer().slice(64, 96));\n    }\n\n    /**\n     * Generate an Ed25519 keypair object.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_sign_keypair() {\n      await this.ensureLoaded();\n      return this.backend.crypto_sign_keypair();\n    }\n\n    /**\n     * Generate an Ed25519 keypair object from a seed.\n     *\n     * @param {Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_sign_seed_keypair(seed) {\n      await this.ensureLoaded();\n      if (seed instanceof CryptographyKey) {\n        seed = seed.getBuffer();\n      }\n      seed = await Util.toBuffer(seed);\n      if (seed.length !== 32) {\n        throw new SodiumError(\"Seed must be 32 bytes long; got \".concat(seed.length));\n      }\n      return this.backend.crypto_sign_seed_keypair(seed);\n    }\n\n    /**\n     * Obtain a birationally equivalent X25519 secret key,\n     * given an Ed25519 secret key.\n     *\n     * @param {Ed25519SecretKey} sk\n     * @return {Promise<X25519SecretKey>}\n     */\n    async crypto_sign_ed25519_sk_to_curve25519(sk) {\n      await this.ensureLoaded();\n      return new X25519SecretKey(await this.backend.crypto_sign_ed25519_sk_to_curve25519(sk));\n    }\n\n    /**\n     * Obtain a birationally equivalent X25519 public key,\n     * given an Ed25519 public key.\n     *\n     * @param {Ed25519PublicKey} pk\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_sign_ed25519_pk_to_curve25519(pk) {\n      await this.ensureLoaded();\n      return new X25519PublicKey(await this.backend.crypto_sign_ed25519_pk_to_curve25519(pk));\n    }\n\n    /**\n     * Generate an arbitrary number of pseudorandom bytes from a given\n     * nonce and key.\n     *\n     * @param {number} length\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_stream(length, nonce, key) {\n      await this.ensureLoaded();\n      return this.backend.crypto_stream(length, nonce, key);\n    }\n\n    /**\n     * Encrypts a string (without authentication).\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_stream_xor(plaintext, nonce, key) {\n      await this.ensureLoaded();\n      return this.backend.crypto_stream_xor(plaintext, nonce, key);\n    }\n    /**\n     * Generate a key for stream ciphers.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_stream_keygen() {\n      return new CryptographyKey(await this.backend.randombytes_buf(this.CRYPTO_STREAM_KEYBYTES));\n    }\n\n    /**\n     * Returns a buffer filled with random bytes.\n     *\n     * @param {number} num\n     * @return {Promise<Buffer>}\n     */\n    async randombytes_buf(num) {\n      await this.ensureLoaded();\n      return await this.backend.randombytes_buf(num);\n    }\n\n    /**\n     * Generate an integer between 0 and upperBound (non-inclusive).\n     *\n     * For example, randombytes_uniform(10) returns an integer between 0 and 9.\n     *\n     * @param {number} upperBound\n     * @return {Promise<number>}\n     */\n    async randombytes_uniform(upperBound) {\n      await this.ensureLoaded();\n      return this.backend.randombytes_uniform(upperBound);\n    }\n\n    /**\n     * Add two buffers (little-endian). Returns the value.\n     *\n     * @param {Buffer} val\n     * @param {Buffer} addv\n     * @return {Promise<Buffer>}\n     */\n    async sodium_add(val, addv) {\n      await this.ensureLoaded();\n      return await this.backend.sodium_add(await Util.toBuffer(val), await Util.toBuffer(addv));\n    }\n\n    /**\n     * Convert to hex.\n     *\n     * @param {Buffer} decoded\n     * @return {Promise<Buffer>}\n     */\n    async sodium_bin2hex(decoded) {\n      await this.ensureLoaded();\n      return this.backend.sodium_bin2hex(decoded);\n    }\n\n    /**\n     * Compare two buffers in constant time.\n     *\n     * Returns -1 if b1 is less than b2.\n     * Returns  1 if b1 is greater than b2.\n     * Returns  0 if b1 is equal to b2.\n     *\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<number>}\n     */\n    async sodium_compare(b1, b2) {\n      await this.ensureLoaded();\n      return this.backend.sodium_compare(b1, b2);\n    }\n    /**\n     * Convert to hex.\n     *\n     * @param {Buffer|string} encoded\n     * @return {Promise<string>}\n     */\n    async sodium_hex2bin(encoded) {\n      await this.ensureLoaded();\n      return this.backend.sodium_hex2bin(encoded);\n    }\n\n    /**\n     * Increment a buffer (little endian). Overwrites the buffer in-place.\n     *\n     * @param {Buffer} buf\n     * @return {Promise<Buffer>}\n     */\n    async sodium_increment(buf) {\n      await this.ensureLoaded();\n      return this.backend.sodium_increment(buf);\n    }\n\n    /**\n     * Returns true if the buffer is zero.\n     *\n     * @param {Buffer} buf\n     * @param {number} len\n     * @return {Promise<Buffer>}\n     */\n    async sodium_is_zero(buf, len) {\n      await this.ensureLoaded();\n      return this.backend.sodium_is_zero(buf, len);\n    }\n\n    /**\n     * Timing-safe buffer comparison.\n     *\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<boolean>}\n     */\n    async sodium_memcmp(b1, b2) {\n      await this.ensureLoaded();\n      return this.backend.sodium_memcmp(b1, b2);\n    }\n\n    /**\n     * Zero out a buffer. Overwrites the buffer in-place.\n     *\n     * @param {Buffer} buf\n     * @return {Promise<void>}\n     */\n    async sodium_memzero(buf) {\n      await this.ensureLoaded();\n      await this.backend.sodium_memzero(buf);\n    }\n\n    /**\n     * Pad a string.\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    async sodium_pad(buf, blockSize) {\n      await this.ensureLoaded();\n      return this.backend.sodium_pad(buf, blockSize);\n    }\n\n    /**\n     * Unpad a string.\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    async sodium_unpad(buf, blockSize) {\n      await this.ensureLoaded();\n      return this.backend.sodium_unpad(buf, blockSize);\n    }\n  }\n  module.exports = SodiumPlus;\n}.call(this, module);","map":{"version":3,"names":["Backend","require","CryptographyKey","Ed25519SecretKey","Ed25519PublicKey","LibsodiumWrappersBackend","SodiumError","SodiumNativeBackend","X25519PublicKey","X25519SecretKey","Util","Buffer","SodiumPlus","constructor","backend","TypeError","populateConstants","getBackendName","backendName","isSodiumNative","isLibsodiumWrappers","auto","init","e","ensureLoaded","crypto_aead_xchacha20poly1305_ietf_decrypt","ciphertext","nonce","key","assocData","arguments","length","undefined","toBuffer","crypto_aead_xchacha20poly1305_ietf_encrypt","plaintext","crypto_aead_xchacha20poly1305_ietf_keygen","randombytes_buf","crypto_auth","message","crypto_auth_keygen","crypto_auth_verify","mac","crypto_box","myPrivateKey","theirPublicKey","crypto_box_open","crypto_box_keypair","crypto_box_keypair_from_secretkey_and_publickey","sKey","pKey","crypto_box_secretkey","keypair","getLength","from","getBuffer","slice","crypto_box_publickey","crypto_box_publickey_from_secretkey","secretKey","crypto_scalarmult_base","crypto_box_seal","publicKey","crypto_box_seal_open","crypto_generichash","outputLength","crypto_generichash_init","crypto_generichash_update","state","crypto_generichash_final","crypto_generichash_keygen","CRYPTO_GENERICHASH_KEYBYTES","crypto_kdf_derive_from_key","subKeyId","context","crypto_kdf_keygen","CRYPTO_KDF_KEYBYTES","crypto_kx_keypair","crypto_kx_seed_keypair","seed","sk","CRYPTO_KX_SECRETKEYBYTES","pk","concat","crypto_kx_client_session_keys","clientPublicKey","clientSecretKey","serverPublicKey","crypto_kx_server_session_keys","serverSecretKey","crypto_onetimeauth","crypto_onetimeauth_verify","tag","crypto_onetimeauth_keygen","crypto_pwhash","password","salt","opslimit","memlimit","algorithm","CRYPTO_PWHASH_ALG_DEFAULT","crypto_pwhash_str","crypto_pwhash_str_verify","hash","crypto_pwhash_str_needs_rehash","crypto_scalarmult","crypto_secretbox","isEd25519Key","isX25519Key","crypto_secretbox_open","crypto_secretbox_keygen","CRYPTO_SECRETBOX_KEYBYTES","crypto_secretstream_xchacha20poly1305_init_push","header","Object","freeze","push","crypto_secretstream_xchacha20poly1305_push","bind","rekey","crypto_secretstream_xchacha20poly1305_rekey","crypto_secretstream_xchacha20poly1305_init_pull","pull","crypto_secretstream_xchacha20poly1305_pull","ad","crypto_secretstream_xchacha20poly1305_keygen","CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_KEYBYTES","crypto_shorthash","crypto_shorthash_keygen","CRYPTO_SHORTHASH_KEYBYTES","crypto_sign","crypto_sign_open","crypto_sign_detached","crypto_sign_verify_detached","signature","crypto_sign_secretkey","crypto_sign_publickey","crypto_sign_keypair","crypto_sign_seed_keypair","crypto_sign_ed25519_sk_to_curve25519","crypto_sign_ed25519_pk_to_curve25519","crypto_stream","crypto_stream_xor","crypto_stream_keygen","CRYPTO_STREAM_KEYBYTES","num","randombytes_uniform","upperBound","sodium_add","val","addv","sodium_bin2hex","decoded","sodium_compare","b1","b2","sodium_hex2bin","encoded","sodium_increment","buf","sodium_is_zero","len","sodium_memcmp","sodium_memzero","sodium_pad","blockSize","sodium_unpad","module","exports","call"],"sources":["imports/client/sodium-plus/lib/sodiumplus.js"],"sourcesContent":["const Backend = require('./backend');\nconst CryptographyKey = require('./cryptography-key');\nconst Ed25519SecretKey = require('./keytypes/ed25519sk');\nconst Ed25519PublicKey = require('./keytypes/ed25519pk');\nconst LibsodiumWrappersBackend = require('./backend/libsodium-wrappers');\nconst SodiumError = require('./sodium-error');\nconst SodiumNativeBackend = require('./backend/sodiumnative');\nconst X25519PublicKey = require('./keytypes/x25519pk');\nconst X25519SecretKey = require('./keytypes/x25519sk');\nconst Util = require('./util');\n\n/* istanbul ignore if */\nif (typeof (Buffer) === 'undefined') {\n    let Buffer = require('buffer/').Buffer;\n}\n\nclass SodiumPlus {\n    constructor(backend) {\n        /* istanbul ignore if */\n        if (!(backend instanceof Backend)) {\n            throw new TypeError('Backend object must implement the backend function');\n        }\n        this.backend = backend;\n        Util.populateConstants(this);\n    }\n\n    /**\n     * Returns the name of the current active backend.\n     * This method is NOT async.\n     *\n     * @return {string}\n     */\n    getBackendName() {\n        return this.backend.backendName;\n    }\n\n    /**\n     * Is this powered by sodium-native?\n     * This method is NOT async.\n     *\n     * @return {boolean}\n     */\n    isSodiumNative() {\n        return (this.backend instanceof SodiumNativeBackend);\n    }\n\n    /**\n     * Is this powered by libsodium-wrappers?\n     * This method is NOT async.\n     *\n     * @return {boolean}\n     */\n    isLibsodiumWrappers() {\n        return (this.backend instanceof LibsodiumWrappersBackend);\n    }\n\n    /**\n     * Automatically select a backend.\n     *\n     * @return {Promise<SodiumPlus>}\n     */\n    static async auto() {\n        let backend;\n        try {\n            backend = await SodiumNativeBackend.init();\n        } catch (e) {\n            backend = await LibsodiumWrappersBackend.init();\n        }\n        /* istanbul ignore if */\n        if (!backend) {\n            backend = await LibsodiumWrappersBackend.init();\n        }\n        Util.populateConstants(backend);\n        return new SodiumPlus(backend);\n    }\n\n    /**\n     * If our backend isn't defined, it will trigger an autoload.\n     *\n     * Mostly used internally. `await SodiumPlus.auto()` provides the same\n     * exact guarantee as this method.\n     *\n     * @return {Promise<void>}\n     */\n    async ensureLoaded() {\n        /* istanbul ignore if */\n        if (typeof (this.backend) === 'undefined') {\n            try {\n                await SodiumPlus.auto();\n            } catch (e) {\n                this.backend = await LibsodiumWrappersBackend.init();\n            }\n        }\n    }\n\n    /**\n     * Decrypt a message (and optional associated data) with XChaCha20-Poly1305\n     *\n     * @param {String|Buffer} ciphertext\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @param {String|Buffer} assocData\n     * @return {Promise<Buffer>}\n     * @throws {SodiumError}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_decrypt(ciphertext, nonce, key, assocData = '') {\n        await this.ensureLoaded();\n        if (nonce.length !== 24) {\n            throw new SodiumError('Argument 2 must be 24 bytes');\n        }\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 3 must be an instance of CryptographyKey');\n        }\n        return await this.backend.crypto_aead_xchacha20poly1305_ietf_decrypt(\n            await Util.toBuffer(ciphertext),\n            assocData.length > 0 ? await Util.toBuffer(assocData) : null,\n            await Util.toBuffer(nonce),\n            key\n        );\n    }\n\n    /**\n     * Encrypt a message (and optional associated data) with XChaCha20-Poly1305.\n     *\n     * Throws a SodiumError if an invalid ciphertext/AAD is provided for this\n     * nonce and key.\n     *\n     * @param {String|Buffer} plaintext\n     * @param {String|Buffer} nonce\n     * @param {CryptographyKey} key\n     * @param {String|Buffer} assocData\n     * @return {Promise<Buffer>}\n     * @throws {SodiumError}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, nonce, key, assocData = '') {\n        await this.ensureLoaded();\n        if (nonce.length !== 24) {\n            throw new SodiumError('Argument 2 must be 24 bytes');\n        }\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 3 must be an instance of CryptographyKey');\n        }\n\n        return await this.backend.crypto_aead_xchacha20poly1305_ietf_encrypt(\n            await Util.toBuffer(plaintext),\n            assocData.length > 0 ? await Util.toBuffer(assocData) : null,\n            await Util.toBuffer(nonce),\n            key\n        );\n    }\n\n    /**\n     * Generate an XChaCha20-Poly1305 key.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_aead_xchacha20poly1305_ietf_keygen() {\n        return new CryptographyKey(await this.backend.randombytes_buf(32));\n    }\n\n    /**\n     * Get an authenticator for a message for a given key.\n     *\n     * Algorithm: HMAC-SHA512 truncated to 32 bytes.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_auth(message, key) {\n        await this.ensureLoaded();\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n        }\n        await this.ensureLoaded();\n        return await this.backend.crypto_auth(\n            await Util.toBuffer(message),\n            key\n        );\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_auth_keygen() {\n        return new CryptographyKey(await this.backend.randombytes_buf(32));\n    }\n\n    /**\n     * Verify an authenticator for a message for a given key.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} mac\n     * @return {Promise<boolean>}\n     */\n    async crypto_auth_verify(message, key, mac) {\n        await this.ensureLoaded();\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n        }\n        await this.ensureLoaded();\n        return await this.backend.crypto_auth_verify(\n            await Util.toBuffer(mac),\n            await Util.toBuffer(message),\n            key\n        );\n    }\n\n    /**\n     * Public-key authenticated encryption.\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {X25519SecretKey} myPrivateKey\n     * @param {X25519PublicKey} theirPublicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box(plaintext, nonce, myPrivateKey, theirPublicKey) {\n        await this.ensureLoaded();\n        if (!(myPrivateKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n        }\n        if (!(theirPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 4 must be an instance of X25519PublicKey');\n        }\n        nonce = await Util.toBuffer(nonce);\n        if (nonce.length !== 24) {\n            throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n        }\n        return this.backend.crypto_box(\n            await Util.toBuffer(plaintext),\n            await Util.toBuffer(nonce),\n            myPrivateKey,\n            theirPublicKey\n        );\n    }\n\n    /**\n     * Public-key authenticated decryption.\n     *\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {X25519SecretKey} myPrivateKey\n     * @param {X25519PublicKey} theirPublicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_open(ciphertext, nonce, myPrivateKey, theirPublicKey) {\n        await this.ensureLoaded();\n        if (!(myPrivateKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n        }\n        if (!(theirPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 4 must be an instance of X25519PublicKey');\n        }\n        ciphertext = await Util.toBuffer(ciphertext);\n        if (ciphertext.length < 16) {\n            throw new SodiumError('Ciphertext must be a buffer of at least 16 bytes');\n        }\n        nonce = await Util.toBuffer(nonce);\n        if (nonce.length !== 24) {\n            throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n        }\n        return this.backend.crypto_box_open(\n            ciphertext,\n            nonce,\n            myPrivateKey,\n            theirPublicKey\n        );\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_box_keypair() {\n        await this.ensureLoaded();\n        return this.backend.crypto_box_keypair();\n    }\n\n    /**\n     * Combine two X25519 keys (secret, public) into a keypair object.\n     *\n     * @param {X25519SecretKey} sKey\n     * @param {X25519PublicKey} pKey\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_box_keypair_from_secretkey_and_publickey(sKey, pKey) {\n        await this.ensureLoaded();\n        if (!(sKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n        }\n        if (!(pKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n        }\n        return await this.backend.crypto_box_keypair_from_secretkey_and_publickey(sKey, pKey);\n    }\n\n    /**\n     * Extract the secret key from an X25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<X25519SecretKey>}\n     */\n    async crypto_box_secretkey(keypair) {\n        if (keypair.getLength()!== 64) {\n            throw new SodiumError('Keypair must be 64 bytes');\n        }\n        return new X25519SecretKey(\n            Buffer.from(keypair.getBuffer().slice(0, 32))\n        );\n    }\n\n    /**\n     * Extract the public key from an X25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_box_publickey(keypair) {\n        if (keypair.getLength() !== 64) {\n            throw new SodiumError('Keypair must be 64 bytes');\n        }\n        return new X25519PublicKey(\n            Buffer.from(keypair.getBuffer().slice(32, 64))\n        );\n    }\n\n    /**\n     * Derive the public key from a given X25519 secret key.\n     *\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_box_publickey_from_secretkey(secretKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n        }\n        return new X25519PublicKey(\n            await this.backend.crypto_scalarmult_base(secretKey)\n        );\n    }\n\n    /**\n     * Anonymous public-key encryption. (Message integrity is still assured.)\n     *\n     * @param {string|Buffer} plaintext\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_seal(plaintext, publicKey) {\n        await this.ensureLoaded();\n        if (!(publicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n        }\n        return await this.backend.crypto_box_seal(plaintext, publicKey);\n    }\n\n    /**\n     * Anonymous public-key decryption. (Message integrity is still assured.)\n     *\n     * @param {Buffer} ciphertext\n     * @param {X25519PublicKey} publicKey\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_box_seal_open(ciphertext, publicKey, secretKey) {\n        await this.ensureLoaded();\n        if (!(publicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n        }\n        if (!(secretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519SecretKey');\n        }\n        return await this.backend.crypto_box_seal_open(\n            await Util.toBuffer(ciphertext),\n            publicKey,\n            secretKey\n        );\n    }\n\n    /**\n     * Generic-purpose cryptographic hash.\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash(message, key = null, outputLength = 32) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_generichash(message, key, outputLength);\n    }\n\n    /**\n     * Initialize a BLAKE2 hash context for stream hashing.\n     *\n     * @param {CryptographyKey|null} key\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash_init(key = null, outputLength = 32) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_generichash_init(key, outputLength);\n    }\n\n\n    /**\n     * Update the BLAKE2 hash state with a block of data.\n     *\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @return {Promise<*>}\n     */\n    async crypto_generichash_update(state, message) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_generichash_update(state, message);\n    }\n\n    /**\n     * Obtain the final BLAKE2 hash output.\n     *\n     * @param {*} state\n     * @param {number} outputLength\n     * @return {Promise<Buffer>}\n     */\n    async crypto_generichash_final(state, outputLength = 32) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_generichash_final(state, outputLength);\n    }\n\n    /**\n     * Generate a 256-bit random key for BLAKE2.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_generichash_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_GENERICHASH_KEYBYTES)\n        );\n    }\n\n    /**\n     * Derive a subkey from a master key.\n     *\n     * @param {number} length\n     * @param {number} subKeyId\n     * @param {string|Buffer} context\n     * @param {CryptographyKey} key\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kdf_derive_from_key(length, subKeyId, context, key) {\n        await this.ensureLoaded();\n        if (length < 1) {\n            throw new SodiumError('Length must be a positive integer.');\n        }\n        if (subKeyId < 0) {\n            throw new SodiumError('Key ID must be an unsigned integer');\n        }\n        return await this.backend.crypto_kdf_derive_from_key(\n            length,\n            subKeyId,\n            context,\n            key\n        );\n    }\n\n    /**\n     * Generate a 256-bit random key for our KDF.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kdf_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_KDF_KEYBYTES)\n        );\n    }\n\n    /**\n     * This is functionally identical to crypto_box_keypair().\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kx_keypair() {\n        return this.crypto_box_keypair();\n    }\n\n    /**\n     * Generate an X25519 keypair from a seed.\n     *\n     * @param {string|Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_kx_seed_keypair(seed) {\n        await this.ensureLoaded();\n        const sk = await this.backend.crypto_generichash(seed, null, this.CRYPTO_KX_SECRETKEYBYTES);\n        const pk = await this.backend.crypto_scalarmult_base(new CryptographyKey(sk));\n        return new CryptographyKey(Buffer.concat([sk, pk]));\n    }\n\n    /**\n     * Perform a key exchange from the client's perspective.\n     *\n     * Returns an array of two CryptographyKey objects.\n     *\n     * The first is meant for data sent from the server to the client (incoming decryption).\n     * The second is meant for data sent from the client to the server (outgoing encryption).\n     *\n     * @param {X25519PublicKey} clientPublicKey\n     * @param {X25519SecretKey} clientSecretKey\n     * @param {X25519PublicKey} serverPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    async crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey) {\n        await this.ensureLoaded();\n        if (!(clientPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519PublicKey');\n        }\n        if (!(clientSecretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519SecretKey');\n        }\n        if (!(serverPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519PublicKey');\n        }\n        return this.backend.crypto_kx_client_session_keys(clientPublicKey, clientSecretKey, serverPublicKey);\n    }\n\n    /**\n     * Perform a key exchange from the server's perspective.\n     *\n     * Returns an array of two CryptographyKey objects.\n     *\n     * The first is meant for data sent from the client to the server (incoming decryption).\n     * The second is meant for data sent from the server to the client (outgoing encryption).\n     *\n     * @param {X25519PublicKey} serverPublicKey\n     * @param {X25519SecretKey} serverSecretKey\n     * @param {X25519PublicKey} clientPublicKey\n     * @return {Promise<CryptographyKey[]>}\n     */\n    async crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey) {\n        await this.ensureLoaded();\n        if (!(serverPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519PublicKey');\n        }\n        if (!(serverSecretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519SecretKey');\n        }\n        if (!(clientPublicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 3 must be an instance of X25519PublicKey');\n        }\n        return this.backend.crypto_kx_server_session_keys(serverPublicKey, serverSecretKey, clientPublicKey);\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_onetimeauth(message, key) {\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n        }\n        return await this.backend.crypto_onetimeauth(await Util.toBuffer(message), key);\n    }\n\n    /**\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @param {Buffer} tag\n     * @return {Promise<boolean>}\n     */\n    async crypto_onetimeauth_verify(message, key, tag) {\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Argument 2 must be an instance of CryptographyKey');\n        }\n        return await this.backend.crypto_onetimeauth_verify(\n            await Util.toBuffer(message),\n            key,\n            await Util.toBuffer(tag)\n        );\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_onetimeauth_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(32)\n        );\n    }\n\n    /**\n     * Derive a cryptography key from a password and salt.\n     *\n     * @param {number} length\n     * @param {string|Buffer} password\n     * @param {Buffer} salt\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @param {number|null} algorithm\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_pwhash(length, password, salt, opslimit, memlimit, algorithm = null) {\n        await this.ensureLoaded();\n        /* istanbul ignore if */\n        if (!algorithm) {\n            algorithm = this.CRYPTO_PWHASH_ALG_DEFAULT;\n        }\n        return new CryptographyKey(\n            await this.backend.crypto_pwhash(\n                length,\n                await Util.toBuffer(password),\n                await Util.toBuffer(salt),\n                opslimit,\n                memlimit,\n                algorithm\n            )\n        );\n    }\n\n    /**\n     * Get a password hash (in a safe-for-storage format)\n     *\n     * @param {string|Buffer} password\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<string>}\n     */\n    async crypto_pwhash_str(password, opslimit, memlimit) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_pwhash_str(password, opslimit, memlimit);\n    }\n\n    /**\n     * Verify a password against a known password hash\n     *\n     * @param {string|Buffer} password\n     * @param {string|Buffer} hash\n     * @return {Promise<boolean>}\n     */\n    async crypto_pwhash_str_verify(password, hash) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_pwhash_str_verify(password, hash);\n    }\n\n    /**\n     * Does this password need to be rehashed?\n     *\n     * @param {string|Buffer} hash\n     * @param {number} opslimit\n     * @param {number} memlimit\n     * @return {Promise<boolean>}\n     */\n    async crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_pwhash_str_needs_rehash(hash, opslimit, memlimit);\n    }\n\n    /**\n     * Elliptic Curve Diffie-Hellman key exchange\n     *\n     * @param {X25519SecretKey} secretKey\n     * @param {X25519PublicKey} publicKey\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_scalarmult(secretKey, publicKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n        }\n        if (!(publicKey instanceof X25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of X25519PublicKey');\n        }\n        return await this.backend.crypto_scalarmult(secretKey, publicKey);\n    }\n\n    /**\n     * Generate an X25519PublicKey from an X25519SecretKey\n     *\n     * @param {X25519SecretKey} secretKey\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_scalarmult_base(secretKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof X25519SecretKey)) {\n            throw new TypeError('Argument 1 must be an instance of X25519SecretKey');\n        }\n        return new X25519PublicKey(\n            await this.backend.crypto_scalarmult_base(secretKey)\n        );\n    }\n\n    /**\n     * Shared-key authenticated encryption\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretbox(plaintext, nonce, key) {\n        await this.ensureLoaded();\n        if (key.isEd25519Key() || key.isX25519Key()) {\n            throw new TypeError('Argument 3 must not be an asymmetric key');\n        }\n        nonce = await Util.toBuffer(nonce);\n        if (nonce.length !== 24) {\n            throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n        }\n\n        return await this.backend.crypto_secretbox(\n            plaintext,\n            nonce,\n            key\n        );\n    }\n\n    /**\n     * Shared-key authenticated decryption\n     *\n     * @param {Buffer} ciphertext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretbox_open(ciphertext, nonce, key) {\n        await this.ensureLoaded();\n        if (key.isEd25519Key() || key.isX25519Key()) {\n            throw new TypeError('Argument 3 must not be an asymmetric key');\n        }\n        ciphertext = await Util.toBuffer(ciphertext);\n        if (ciphertext.length < 16) {\n            throw new SodiumError('Ciphertext must be a buffer of at least 16 bytes');\n        }\n        nonce = await Util.toBuffer(nonce);\n        if (nonce.length !== 24) {\n            throw new SodiumError('Nonce must be a buffer of exactly 24 bytes');\n        }\n        return await this.backend.crypto_secretbox_open(\n            ciphertext,\n            nonce,\n            key\n        );\n    }\n\n    /**\n     * Generate a key for shared-key authenticated encryption.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_secretbox_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_SECRETBOX_KEYBYTES)\n        );\n    }\n\n    /**\n     * Internalize the internal state and a random header for stream encryption.\n     *\n     * @param {CryptographyKey} key\n     * @return {Promise<array>}\n     */\n    async crypto_secretstream_xchacha20poly1305_init_push(key) {\n        await this.ensureLoaded();\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Key must be an instance of CryptographyKey');\n        }\n        if (key.getLength() !== 32) {\n            throw new SodiumError('crypto_secretstream keys must be 32 bytes long');\n        }\n        const [state, header] = await this.backend.crypto_secretstream_xchacha20poly1305_init_push(key);\n        return Object.freeze({\n            header: header,\n            push: this.crypto_secretstream_xchacha20poly1305_push.bind(this, state),\n            rekey: this.crypto_secretstream_xchacha20poly1305_rekey.bind(this, state)\n        });\n    }\n\n    /**\n     * Initialize the internal state for stream decryption.\n     *\n     * @param {Buffer} header\n     * @param {CryptographyKey} key\n     * @return {Promise<*>}\n     */\n    async crypto_secretstream_xchacha20poly1305_init_pull(key, header) {\n        await this.ensureLoaded();\n        header = await Util.toBuffer(header);\n        if (header.length !== 24) {\n            throw new SodiumError('crypto_secretstream headers must be 24 bytes long');\n        }\n        if (!(key instanceof CryptographyKey)) {\n            throw new TypeError('Key must be an instance of CryptographyKey');\n        }\n        if (key.getLength() !== 32) {\n            throw new SodiumError('crypto_secretstream keys must be 32 bytes long');\n        }\n        const state = await this.backend.crypto_secretstream_xchacha20poly1305_init_pull(header, key);\n        return Object.freeze({\n            pull: this.crypto_secretstream_xchacha20poly1305_pull.bind(this, state)\n        });\n    }\n\n    /**\n     * Stream encryption.\n     *\n     * @param {*} state\n     * @param {string|Buffer} message\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretstream_xchacha20poly1305_push(state, message, ad = '', tag = 0) {\n        await this.ensureLoaded();\n        return this.backend.crypto_secretstream_xchacha20poly1305_push(state, message, ad, tag);\n    }\n\n    /**\n     * Stream decryption.\n     *\n     * @param {*} state\n     * @param {Buffer} ciphertext\n     * @param {string|Buffer} ad\n     * @param {number} tag\n     * @return {Promise<Buffer>}\n     */\n    async crypto_secretstream_xchacha20poly1305_pull(state, ciphertext, ad = '', tag = 0) {\n        await this.ensureLoaded();\n        return this.backend.crypto_secretstream_xchacha20poly1305_pull(state, ciphertext, ad, tag);\n    }\n\n    /**\n     * Deterministic rekeying.\n     *\n     * @param {*} state\n     * @return {Promise<void>}\n     */\n    async crypto_secretstream_xchacha20poly1305_rekey(state) {\n        await this.ensureLoaded();\n        await this.backend.crypto_secretstream_xchacha20poly1305_rekey(state);\n    }\n\n    /**\n     * Generate a key for shared-key authenticated encryption.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_secretstream_xchacha20poly1305_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_SECRETSTREAM_XCHACHA20POLY1305_KEYBYTES)\n        );\n    }\n\n    /**\n     * Calculate a fast hash for short inputs.\n     *\n     * Algorithm: SipHash-2-4\n     *\n     * @param {string|Buffer} message\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_shorthash(message, key) {\n        await this.ensureLoaded();\n        return await this.backend.crypto_shorthash(await Util.toBuffer(message), key);\n    }\n\n    /**\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_shorthash_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_SHORTHASH_KEYBYTES)\n        );\n    }\n\n    /**\n     * Returns a signed message.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign(message, secretKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof Ed25519SecretKey)) {\n            throw new TypeError('Argument 2 must be an instance of Ed25519SecretKey');\n        }\n        return this.backend.crypto_sign(message, secretKey);\n    }\n\n    /**\n     * Given a signed message, verify the Ed25519 signature. If it matches, return the\n     * bare message (no signature).\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_open(message, publicKey) {\n        await this.ensureLoaded();\n        if (!(publicKey instanceof Ed25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of Ed25519PublicKey');\n        }\n        return this.backend.crypto_sign_open(message, publicKey);\n    }\n\n    /**\n     * Returns the Ed25519 signature of the message, for the given secret key.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519SecretKey} secretKey\n     * @return {Promise<Buffer>}\n     */\n    async crypto_sign_detached(message, secretKey) {\n        await this.ensureLoaded();\n        if (!(secretKey instanceof Ed25519SecretKey)) {\n            throw new TypeError('Argument 2 must be an instance of Ed25519SecretKey');\n        }\n        return this.backend.crypto_sign_detached(message, secretKey);\n    }\n\n    /**\n     * Returns true if the Ed25519 signature is valid for a given message and public key.\n     *\n     * @param {string|Buffer} message,\n     * @param {Ed25519PublicKey} publicKey\n     * @param {Buffer} signature\n     * @return {Promise<boolean>}\n     */\n    async crypto_sign_verify_detached(message, publicKey, signature) {\n        await this.ensureLoaded();\n        if (!(publicKey instanceof Ed25519PublicKey)) {\n            throw new TypeError('Argument 2 must be an instance of Ed25519PublicKey');\n        }\n        return this.backend.crypto_sign_verify_detached(message, publicKey, signature);\n    }\n\n    /**\n     * Extract the secret key from an Ed25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<Ed25519SecretKey>}\n     */\n    async crypto_sign_secretkey(keypair) {\n        if (keypair.getLength() !== 96) {\n            throw new SodiumError('Keypair must be 96 bytes');\n        }\n        return new Ed25519SecretKey(\n            await Util.toBuffer(\n                keypair.getBuffer().slice(0, 64)\n            )\n        );\n    }\n\n    /**\n     * Extract the public key from an Ed25519 keypair object.\n     *\n     * @param {CryptographyKey} keypair\n     * @return {Promise<Ed25519PublicKey>}\n     */\n    async crypto_sign_publickey(keypair) {\n        if (keypair.getLength() !== 96) {\n            throw new SodiumError('Keypair must be 96 bytes');\n        }\n        return new Ed25519PublicKey(\n            keypair.getBuffer().slice(64, 96)\n        );\n    }\n\n    /**\n     * Generate an Ed25519 keypair object.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_sign_keypair() {\n        await this.ensureLoaded();\n        return this.backend.crypto_sign_keypair();\n    }\n\n    /**\n     * Generate an Ed25519 keypair object from a seed.\n     *\n     * @param {Buffer} seed\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_sign_seed_keypair(seed) {\n        await this.ensureLoaded();\n        if (seed instanceof CryptographyKey) {\n            seed = seed.getBuffer();\n        }\n        seed = await Util.toBuffer(seed);\n        if (seed.length !== 32) {\n            throw new SodiumError(`Seed must be 32 bytes long; got ${seed.length}`);\n        }\n        return this.backend.crypto_sign_seed_keypair(seed);\n    }\n\n    /**\n     * Obtain a birationally equivalent X25519 secret key,\n     * given an Ed25519 secret key.\n     *\n     * @param {Ed25519SecretKey} sk\n     * @return {Promise<X25519SecretKey>}\n     */\n    async crypto_sign_ed25519_sk_to_curve25519(sk) {\n        await this.ensureLoaded();\n        return new X25519SecretKey(\n            await this.backend.crypto_sign_ed25519_sk_to_curve25519(sk)\n        );\n    }\n\n    /**\n     * Obtain a birationally equivalent X25519 public key,\n     * given an Ed25519 public key.\n     *\n     * @param {Ed25519PublicKey} pk\n     * @return {Promise<X25519PublicKey>}\n     */\n    async crypto_sign_ed25519_pk_to_curve25519(pk) {\n        await this.ensureLoaded();\n        return new X25519PublicKey(\n            await this.backend.crypto_sign_ed25519_pk_to_curve25519(pk)\n        );\n    }\n\n    /**\n     * Generate an arbitrary number of pseudorandom bytes from a given\n     * nonce and key.\n     *\n     * @param {number} length\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_stream(length, nonce, key) {\n        await this.ensureLoaded();\n        return this.backend.crypto_stream(length, nonce, key);\n    }\n\n    /**\n     * Encrypts a string (without authentication).\n     *\n     * @param {string|Buffer} plaintext\n     * @param {Buffer} nonce\n     * @param {CryptographyKey} key\n     * @return {Promise<Buffer>}\n     */\n    async crypto_stream_xor(plaintext, nonce, key) {\n        await this.ensureLoaded();\n        return this.backend.crypto_stream_xor(plaintext, nonce, key);\n    }\n    /**\n     * Generate a key for stream ciphers.\n     *\n     * @return {Promise<CryptographyKey>}\n     */\n    async crypto_stream_keygen() {\n        return new CryptographyKey(\n            await this.backend.randombytes_buf(this.CRYPTO_STREAM_KEYBYTES)\n        );\n    }\n\n    /**\n     * Returns a buffer filled with random bytes.\n     *\n     * @param {number} num\n     * @return {Promise<Buffer>}\n     */\n    async randombytes_buf(num) {\n        await this.ensureLoaded();\n        return await this.backend.randombytes_buf(num);\n    }\n\n    /**\n     * Generate an integer between 0 and upperBound (non-inclusive).\n     *\n     * For example, randombytes_uniform(10) returns an integer between 0 and 9.\n     *\n     * @param {number} upperBound\n     * @return {Promise<number>}\n     */\n    async randombytes_uniform(upperBound) {\n        await this.ensureLoaded();\n        return this.backend.randombytes_uniform(upperBound);\n    }\n\n    /**\n     * Add two buffers (little-endian). Returns the value.\n     *\n     * @param {Buffer} val\n     * @param {Buffer} addv\n     * @return {Promise<Buffer>}\n     */\n    async sodium_add(val, addv) {\n        await this.ensureLoaded();\n        return await this.backend.sodium_add(\n            await Util.toBuffer(val),\n            await Util.toBuffer(addv)\n        );\n    }\n\n    /**\n     * Convert to hex.\n     *\n     * @param {Buffer} decoded\n     * @return {Promise<Buffer>}\n     */\n    async sodium_bin2hex(decoded) {\n        await this.ensureLoaded();\n        return this.backend.sodium_bin2hex(decoded);\n    }\n\n    /**\n     * Compare two buffers in constant time.\n     *\n     * Returns -1 if b1 is less than b2.\n     * Returns  1 if b1 is greater than b2.\n     * Returns  0 if b1 is equal to b2.\n     *\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<number>}\n     */\n    async sodium_compare(b1, b2) {\n        await this.ensureLoaded();\n        return this.backend.sodium_compare(b1, b2);\n    }\n    /**\n     * Convert to hex.\n     *\n     * @param {Buffer|string} encoded\n     * @return {Promise<string>}\n     */\n    async sodium_hex2bin(encoded) {\n        await this.ensureLoaded();\n        return this.backend.sodium_hex2bin(encoded);\n    }\n\n    /**\n     * Increment a buffer (little endian). Overwrites the buffer in-place.\n     *\n     * @param {Buffer} buf\n     * @return {Promise<Buffer>}\n     */\n    async sodium_increment(buf) {\n        await this.ensureLoaded();\n        return this.backend.sodium_increment(buf);\n    }\n\n    /**\n     * Returns true if the buffer is zero.\n     *\n     * @param {Buffer} buf\n     * @param {number} len\n     * @return {Promise<Buffer>}\n     */\n    async sodium_is_zero(buf, len) {\n        await this.ensureLoaded();\n        return this.backend.sodium_is_zero(buf, len);\n    }\n\n    /**\n     * Timing-safe buffer comparison.\n     *\n     * @param {Buffer} b1\n     * @param {Buffer} b2\n     * @return {Promise<boolean>}\n     */\n    async sodium_memcmp(b1, b2) {\n        await this.ensureLoaded();\n        return this.backend.sodium_memcmp(b1, b2);\n    }\n\n    /**\n     * Zero out a buffer. Overwrites the buffer in-place.\n     *\n     * @param {Buffer} buf\n     * @return {Promise<void>}\n     */\n    async sodium_memzero(buf) {\n        await this.ensureLoaded();\n        await this.backend.sodium_memzero(buf);\n    }\n\n    /**\n     * Pad a string.\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    async sodium_pad(buf, blockSize) {\n        await this.ensureLoaded();\n        return this.backend.sodium_pad(buf, blockSize);\n    }\n\n    /**\n     * Unpad a string.\n     *\n     * @param {string|Buffer} buf\n     * @param {number} blockSize\n     * @return {Promise<Buffer>}\n     */\n    async sodium_unpad(buf, blockSize) {\n        await this.ensureLoaded();\n        return this.backend.sodium_unpad(buf, blockSize);\n    }\n}\n\nmodule.exports = SodiumPlus;\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"6466e5940ac0f824d15b723f1f2fdccfdcd930bd"}
