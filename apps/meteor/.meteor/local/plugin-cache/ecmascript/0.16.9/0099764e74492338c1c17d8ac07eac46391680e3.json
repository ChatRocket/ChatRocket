{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/oauth/pending_credentials.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/oauth/pending_credentials.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/oauth/pending_credentials.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/oauth/pending_credentials.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/oauth/pending_credentials.js"}},"code":"//\n// When an oauth request is made, Meteor receives oauth credentials\n// in one browser tab, and temporarily persists them while that\n// tab is closed, then retrieves them in the browser tab that\n// initiated the credential request.\n//\n// _pendingCredentials is the storage mechanism used to share the\n// credential between the 2 tabs\n//\n\n// Collection containing pending credentials of oauth credential requests\n// Has key, credential, and createdAt fields.\nOAuth._pendingCredentials = new Mongo.Collection(\"meteor_oauth_pendingCredentials\", {\n  _preventAutopublish: true\n});\n\n// TODO[FIBERS]: I Need TLA\nasync function init() {\n  await OAuth._pendingCredentials.createIndexAsync('key', {\n    unique: true\n  });\n  await OAuth._pendingCredentials.createIndexAsync('credentialSecret');\n  await OAuth._pendingCredentials.createIndexAsync('createdAt');\n}\ninit();\n\n// Periodically clear old entries that were never retrieved\nconst _cleanStaleResults = async () => {\n  // Remove credentials older than 1 minute\n  const timeCutoff = new Date();\n  timeCutoff.setMinutes(timeCutoff.getMinutes() - 1);\n  await OAuth._pendingCredentials.removeAsync({\n    createdAt: {\n      $lt: timeCutoff\n    }\n  });\n};\nconst _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000);\n\n// Stores the key and credential in the _pendingCredentials collection.\n// Will throw an exception if `key` is not a string.\n//\n// @param key {string}\n// @param credential {Object}   The credential to store\n// @param credentialSecret {string} A secret that must be presented in\n//   addition to the `key` to retrieve the credential\n//\nOAuth._storePendingCredential = async function (key, credential) {\n  let credentialSecret = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  check(key, String);\n  check(credentialSecret, Match.Maybe(String));\n  if (credential instanceof Error) {\n    credential = storableError(credential);\n  } else {\n    credential = OAuth.sealSecret(credential);\n  }\n\n  // We do an upsert here instead of an insert in case the user happens\n  // to somehow send the same `state` parameter twice during an OAuth\n  // login; we don't want a duplicate key error.\n  await OAuth._pendingCredentials.upsertAsync({\n    key\n  }, {\n    key,\n    credential,\n    credentialSecret,\n    createdAt: new Date()\n  });\n};\n\n// Retrieves and removes a credential from the _pendingCredentials collection\n//\n// @param key {string}\n// @param credentialSecret {string}\n//\nOAuth._retrievePendingCredential = async function (key) {\n  let credentialSecret = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  check(key, String);\n  const pendingCredential = await OAuth._pendingCredentials.findOneAsync({\n    key,\n    credentialSecret\n  });\n  if (pendingCredential) {\n    await OAuth._pendingCredentials.removeAsync({\n      _id: pendingCredential._id\n    });\n    if (pendingCredential.credential.error) return recreateError(pendingCredential.credential.error);else return OAuth.openSecret(pendingCredential.credential);\n  } else {\n    return undefined;\n  }\n};\n\n// Convert an Error into an object that can be stored in mongo\n// Note: A Meteor.Error is reconstructed as a Meteor.Error\n// All other error classes are reconstructed as a plain Error.\n// TODO: Can we do this more simply with EJSON?\nconst storableError = error => {\n  const plainObject = {};\n  Object.getOwnPropertyNames(error).forEach(key => plainObject[key] = error[key]);\n\n  // Keep track of whether it's a Meteor.Error\n  if (error instanceof Meteor.Error) {\n    plainObject['meteorError'] = true;\n  }\n  return {\n    error: plainObject\n  };\n};\n\n// Create an error from the error format stored in mongo\nconst recreateError = errorDoc => {\n  let error;\n  if (errorDoc.meteorError) {\n    error = new Meteor.Error();\n    delete errorDoc.meteorError;\n  } else {\n    error = new Error();\n  }\n  Object.getOwnPropertyNames(errorDoc).forEach(key => error[key] = errorDoc[key]);\n  return error;\n};","map":{"version":3,"names":["OAuth","_pendingCredentials","Mongo","Collection","_preventAutopublish","init","createIndexAsync","unique","_cleanStaleResults","timeCutoff","Date","setMinutes","getMinutes","removeAsync","createdAt","$lt","_cleanupHandle","Meteor","setInterval","_storePendingCredential","key","credential","credentialSecret","arguments","length","undefined","check","String","Match","Maybe","Error","storableError","sealSecret","upsertAsync","_retrievePendingCredential","pendingCredential","findOneAsync","_id","error","recreateError","openSecret","plainObject","Object","getOwnPropertyNames","forEach","errorDoc","meteorError"],"sources":["packages/oauth/pending_credentials.js"],"sourcesContent":["//\n// When an oauth request is made, Meteor receives oauth credentials\n// in one browser tab, and temporarily persists them while that\n// tab is closed, then retrieves them in the browser tab that\n// initiated the credential request.\n//\n// _pendingCredentials is the storage mechanism used to share the\n// credential between the 2 tabs\n//\n\n\n// Collection containing pending credentials of oauth credential requests\n// Has key, credential, and createdAt fields.\nOAuth._pendingCredentials = new Mongo.Collection(\n  \"meteor_oauth_pendingCredentials\", {\n    _preventAutopublish: true\n  });\n\n// TODO[FIBERS]: I Need TLA\nasync function init() {\n  await OAuth._pendingCredentials.createIndexAsync('key', { unique: true });\n  await OAuth._pendingCredentials.createIndexAsync('credentialSecret');\n  await OAuth._pendingCredentials.createIndexAsync('createdAt');\n}\ninit()\n\n\n\n// Periodically clear old entries that were never retrieved\nconst _cleanStaleResults = async () => {\n  // Remove credentials older than 1 minute\n  const timeCutoff = new Date();\n  timeCutoff.setMinutes(timeCutoff.getMinutes() - 1);\n  await OAuth._pendingCredentials.removeAsync({ createdAt: { $lt: timeCutoff } });\n};\nconst _cleanupHandle = Meteor.setInterval(_cleanStaleResults, 60 * 1000);\n\n\n// Stores the key and credential in the _pendingCredentials collection.\n// Will throw an exception if `key` is not a string.\n//\n// @param key {string}\n// @param credential {Object}   The credential to store\n// @param credentialSecret {string} A secret that must be presented in\n//   addition to the `key` to retrieve the credential\n//\nOAuth._storePendingCredential =\n  async (key, credential, credentialSecret = null) => {\n    check(key, String);\n    check(credentialSecret, Match.Maybe(String));\n\n    if (credential instanceof Error) {\n      credential = storableError(credential);\n    } else {\n      credential = OAuth.sealSecret(credential);\n    }\n\n    // We do an upsert here instead of an insert in case the user happens\n    // to somehow send the same `state` parameter twice during an OAuth\n    // login; we don't want a duplicate key error.\n    await OAuth._pendingCredentials.upsertAsync({\n      key,\n    }, {\n      key,\n      credential,\n      credentialSecret,\n      createdAt: new Date()\n    });\n  };\n\n\n// Retrieves and removes a credential from the _pendingCredentials collection\n//\n// @param key {string}\n// @param credentialSecret {string}\n//\nOAuth._retrievePendingCredential =\n  async (key, credentialSecret = null) => {\n    check(key, String);\n\n    const pendingCredential = await OAuth._pendingCredentials.findOneAsync({\n      key,\n      credentialSecret,\n    });\n    if (pendingCredential) {\n      await OAuth._pendingCredentials.removeAsync({ _id: pendingCredential._id });\n      if (pendingCredential.credential.error)\n        return recreateError(pendingCredential.credential.error);\n      else\n        return OAuth.openSecret(pendingCredential.credential);\n    } else {\n      return undefined;\n    }\n  };\n\n\n// Convert an Error into an object that can be stored in mongo\n// Note: A Meteor.Error is reconstructed as a Meteor.Error\n// All other error classes are reconstructed as a plain Error.\n// TODO: Can we do this more simply with EJSON?\nconst storableError = error => {\n  const plainObject = {};\n  Object.getOwnPropertyNames(error).forEach(\n    key => plainObject[key] = error[key]\n  );\n\n  // Keep track of whether it's a Meteor.Error\n  if(error instanceof Meteor.Error) {\n    plainObject['meteorError'] = true;\n  }\n\n  return { error: plainObject };\n};\n\n// Create an error from the error format stored in mongo\nconst recreateError = errorDoc => {\n  let error;\n\n  if (errorDoc.meteorError) {\n    error = new Meteor.Error();\n    delete errorDoc.meteorError;\n  } else {\n    error = new Error();\n  }\n\n  Object.getOwnPropertyNames(errorDoc).forEach(key =>\n    error[key] = errorDoc[key]\n  );\n\n  return error;\n};\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"0099764e74492338c1c17d8ac07eac46391680e3"}
