{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/federation/server/endpoints/dispatch.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"app/federation/server/endpoints/dispatch.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/federation/server/endpoints/dispatch.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/federation/server/endpoints/dispatch.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/federation/server/endpoints/dispatch.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    let api;\n    module.link(\"@rocket.chat/core-services\", {\n      api(v) {\n        api = v;\n      }\n    }, 0);\n    let eventTypes;\n    module.link(\"@rocket.chat/core-typings\", {\n      eventTypes(v) {\n        eventTypes = v;\n      }\n    }, 1);\n    let FederationServers, FederationRoomEvents, Rooms, Messages, Subscriptions, Users, ReadReceipts;\n    module.link(\"@rocket.chat/models\", {\n      FederationServers(v) {\n        FederationServers = v;\n      },\n      FederationRoomEvents(v) {\n        FederationRoomEvents = v;\n      },\n      Rooms(v) {\n        Rooms = v;\n      },\n      Messages(v) {\n        Messages = v;\n      },\n      Subscriptions(v) {\n        Subscriptions = v;\n      },\n      Users(v) {\n        Users = v;\n      },\n      ReadReceipts(v) {\n        ReadReceipts = v;\n      }\n    }, 2);\n    let EJSON;\n    module.link(\"ejson\", {\n      default(v) {\n        EJSON = v;\n      }\n    }, 3);\n    let API;\n    module.link(\"../../../api/server\", {\n      API(v) {\n        API = v;\n      }\n    }, 4);\n    let FileUpload;\n    module.link(\"../../../file-upload/server\", {\n      FileUpload(v) {\n        FileUpload = v;\n      }\n    }, 5);\n    let deleteRoom;\n    module.link(\"../../../lib/server/functions/deleteRoom\", {\n      deleteRoom(v) {\n        deleteRoom = v;\n      }\n    }, 6);\n    let notifyOnMessageChange, notifyOnRoomChanged, notifyOnRoomChangedById, notifyOnSubscriptionChanged, notifyOnSubscriptionChangedById;\n    module.link(\"../../../lib/server/lib/notifyListener\", {\n      notifyOnMessageChange(v) {\n        notifyOnMessageChange = v;\n      },\n      notifyOnRoomChanged(v) {\n        notifyOnRoomChanged = v;\n      },\n      notifyOnRoomChangedById(v) {\n        notifyOnRoomChangedById = v;\n      },\n      notifyOnSubscriptionChanged(v) {\n        notifyOnSubscriptionChanged = v;\n      },\n      notifyOnSubscriptionChangedById(v) {\n        notifyOnSubscriptionChangedById = v;\n      }\n    }, 7);\n    let notifyUsersOnMessage;\n    module.link(\"../../../lib/server/lib/notifyUsersOnMessage\", {\n      notifyUsersOnMessage(v) {\n        notifyUsersOnMessage = v;\n      }\n    }, 8);\n    let sendAllNotifications;\n    module.link(\"../../../lib/server/lib/sendNotificationsOnMessage\", {\n      sendAllNotifications(v) {\n        sendAllNotifications = v;\n      }\n    }, 9);\n    let processThreads;\n    module.link(\"../../../threads/server/hooks/aftersavemessage\", {\n      processThreads(v) {\n        processThreads = v;\n      }\n    }, 10);\n    let getUpload, requestEventsFromLatest;\n    module.link(\"../handler\", {\n      getUpload(v) {\n        getUpload = v;\n      },\n      requestEventsFromLatest(v) {\n        requestEventsFromLatest = v;\n      }\n    }, 11);\n    let contextDefinitions;\n    module.link(\"../lib/context\", {\n      contextDefinitions(v) {\n        contextDefinitions = v;\n      }\n    }, 12);\n    let decryptIfNeeded;\n    module.link(\"../lib/crypt\", {\n      decryptIfNeeded(v) {\n        decryptIfNeeded = v;\n      }\n    }, 13);\n    let getFederationDomain;\n    module.link(\"../lib/getFederationDomain\", {\n      getFederationDomain(v) {\n        getFederationDomain = v;\n      }\n    }, 14);\n    let isFederationEnabled;\n    module.link(\"../lib/isFederationEnabled\", {\n      isFederationEnabled(v) {\n        isFederationEnabled = v;\n      }\n    }, 15);\n    let serverLogger;\n    module.link(\"../lib/logger\", {\n      serverLogger(v) {\n        serverLogger = v;\n      }\n    }, 16);\n    let normalizers;\n    module.link(\"../normalizers\", {\n      normalizers(v) {\n        normalizers = v;\n      }\n    }, 17);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    const eventHandlers = {\n      //\n      // PING\n      //\n      async [eventTypes.PING]() {\n        return {\n          success: true\n        };\n      },\n      //\n      // GENESIS\n      //\n      async [eventTypes.GENESIS](event) {\n        switch (event.data.contextType) {\n          case contextDefinitions.ROOM.type:\n            const eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n            // If the event was successfully added, handle the event locally\n            if (eventResult.success) {\n              const {\n                data: {\n                  room\n                }\n              } = event;\n\n              // Check if room exists\n              const persistedRoom = await Rooms.findOne({\n                _id: room._id\n              });\n              if (persistedRoom) {\n                // Update the federation\n                await Rooms.updateOne({\n                  _id: persistedRoom._id\n                }, {\n                  $set: {\n                    federation: room.federation\n                  }\n                });\n\n                // Notify watch.rooms listener\n                void notifyOnRoomChangedById(room._id);\n              } else {\n                // Denormalize room\n                const denormalizedRoom = normalizers.denormalizeRoom(room);\n\n                // Create the room\n                const insertedRoom = await Rooms.insertOne(denormalizedRoom);\n\n                // Notify watch.rooms listener\n                void notifyOnRoomChangedById(insertedRoom.insertedId);\n              }\n            }\n            return eventResult;\n        }\n      },\n      //\n      // ROOM_DELETE\n      //\n      async [eventTypes.ROOM_DELETE](event) {\n        const {\n          data: {\n            roomId\n          }\n        } = event;\n\n        // Check if room exists\n        const persistedRoom = await Rooms.findOne({\n          _id: roomId\n        });\n        if (persistedRoom) {\n          // Delete the room\n          await deleteRoom(roomId);\n\n          // Notify watch.rooms listener\n          void notifyOnRoomChanged(persistedRoom, 'removed');\n        }\n\n        // Remove all room events\n        await FederationRoomEvents.removeRoomEvents(roomId);\n        return {\n          success: true\n        };\n      },\n      //\n      // ROOM_ADD_USER\n      //\n      async [eventTypes.ROOM_ADD_USER](event) {\n        const eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n        // We only want to refresh the server list and update the room federation array if something changed\n        let federationAltered = false;\n\n        // If the event was successfully added, handle the event locally\n        if (eventResult.success) {\n          const {\n            data: {\n              roomId,\n              user,\n              subscription,\n              domainsAfterAdd\n            }\n          } = event;\n\n          // Check if user exists\n          const persistedUser = await Users.findOne({\n            _id: user._id\n          });\n          if (persistedUser) {\n            // Update the federation, if its not already set (if it's set, this is likely an event being reprocessed)\n            if (!persistedUser.federation) {\n              await Users.updateOne({\n                _id: persistedUser._id\n              }, {\n                $set: {\n                  federation: user.federation\n                }\n              });\n              federationAltered = true;\n            }\n          } else {\n            // Denormalize user\n            const denormalizedUser = normalizers.denormalizeUser(user);\n\n            // Create the user\n            await Users.insertOne(denormalizedUser);\n            federationAltered = true;\n          }\n\n          // Check if subscription exists\n          const persistedSubscription = await Subscriptions.findOne({\n            _id: subscription._id\n          });\n          try {\n            if (persistedSubscription) {\n              // Update the federation, if its not already set (if it's set, this is likely an event being reprocessed\n              if (!persistedSubscription.federation) {\n                await Subscriptions.updateOne({\n                  _id: persistedSubscription._id\n                }, {\n                  $set: {\n                    federation: subscription.federation\n                  }\n                });\n                federationAltered = true;\n              }\n            } else {\n              // Denormalize subscription\n              const denormalizedSubscription = normalizers.denormalizeSubscription(subscription);\n\n              // Create the subscription\n              const {\n                insertedId\n              } = await Subscriptions.insertOne(denormalizedSubscription);\n              if (insertedId) {\n                void notifyOnSubscriptionChangedById(insertedId);\n              }\n              federationAltered = true;\n            }\n          } catch (ex) {\n            serverLogger.debug(\"unable to create subscription for user ( \".concat(user._id, \" ) in room (\").concat(roomId, \")\"));\n          }\n\n          // Refresh the servers list\n          if (federationAltered) {\n            await FederationServers.refreshServers();\n\n            // Update the room's federation property\n            await Rooms.updateOne({\n              _id: roomId\n            }, {\n              $set: {\n                'federation.domains': domainsAfterAdd\n              }\n            });\n\n            // Notify watch.rooms listener\n            void notifyOnRoomChangedById(roomId);\n          }\n        }\n        return eventResult;\n      },\n      //\n      // ROOM_REMOVE_USER\n      //\n      async [eventTypes.ROOM_REMOVE_USER](event) {\n        const eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n        // If the event was successfully added, handle the event locally\n        if (eventResult.success) {\n          const {\n            data: {\n              roomId,\n              user,\n              domainsAfterRemoval\n            }\n          } = event;\n\n          // Remove the user's subscription\n          const deletedSubscription = await Subscriptions.removeByRoomIdAndUserId(roomId, user._id);\n          if (deletedSubscription) {\n            void notifyOnSubscriptionChanged(deletedSubscription, 'removed');\n          }\n\n          // Refresh the servers list\n          await FederationServers.refreshServers();\n\n          // Update the room's federation property\n          await Rooms.updateOne({\n            _id: roomId\n          }, {\n            $set: {\n              'federation.domains': domainsAfterRemoval\n            }\n          });\n\n          // Notify watch.rooms listener\n          void notifyOnRoomChangedById(roomId);\n        }\n        return eventResult;\n      },\n      //\n      // ROOM_USER_LEFT\n      //\n      async [eventTypes.ROOM_USER_LEFT](event) {\n        const eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n        // If the event was successfully added, handle the event locally\n        if (eventResult.success) {\n          const {\n            data: {\n              roomId,\n              user,\n              domainsAfterRemoval\n            }\n          } = event;\n\n          // Remove the user's subscription\n          const deletedSubscription = await Subscriptions.removeByRoomIdAndUserId(roomId, user._id);\n          if (deletedSubscription) {\n            void notifyOnSubscriptionChanged(deletedSubscription, 'removed');\n          }\n\n          // Refresh the servers list\n          await FederationServers.refreshServers();\n\n          // Update the room's federation property\n          await Rooms.updateOne({\n            _id: roomId\n          }, {\n            $set: {\n              'federation.domains': domainsAfterRemoval\n            }\n          });\n\n          // Notify watch.rooms listener\n          void notifyOnRoomChangedById(roomId);\n        }\n        return eventResult;\n      },\n      //\n      // ROOM_MESSAGE\n      //\n      async [eventTypes.ROOM_MESSAGE](event) {\n        const eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n        // If the event was successfully added, handle the event locally\n        if (eventResult.success) {\n          const {\n            data: {\n              message\n            }\n          } = event;\n\n          // Check if message exists\n          const persistedMessage = await Messages.findOne({\n            _id: message._id\n          });\n          let messageForNotification;\n          if (persistedMessage) {\n            // Update the federation\n            if (!persistedMessage.federation) {\n              await Messages.updateOne({\n                _id: persistedMessage._id\n              }, {\n                $set: {\n                  federation: message.federation\n                }\n              });\n              messageForNotification = _objectSpread(_objectSpread({}, persistedMessage), {}, {\n                federation: message.federation\n              });\n            }\n          } else {\n            // Load the room\n            const room = await Rooms.findOneById(message.rid);\n\n            // Denormalize message\n            const denormalizedMessage = normalizers.denormalizeMessage(message);\n\n            // Is there a file?\n            if (denormalizedMessage.file) {\n              const fileStore = FileUpload.getStore('Uploads');\n              const {\n                federation: {\n                  origin\n                }\n              } = denormalizedMessage;\n              const {\n                upload,\n                buffer\n              } = await getUpload(origin, denormalizedMessage.file._id);\n              const oldUploadId = upload._id;\n\n              // Normalize upload\n              delete upload._id;\n              upload.rid = denormalizedMessage.rid;\n              upload.userId = denormalizedMessage.u._id;\n              upload.federation = {\n                _id: denormalizedMessage.file._id,\n                origin\n              };\n              await fileStore.insert(upload, buffer);\n\n              // Update the message's file\n              denormalizedMessage.file._id = upload._id;\n\n              // Update the message's attachments dependent on type\n              for (const attachment of denormalizedMessage.attachments) {\n                attachment.title_link = attachment.title_link.replace(oldUploadId, upload._id);\n                if (/^image\\/.+/.test(denormalizedMessage.file.type)) {\n                  attachment.image_url = attachment.image_url.replace(oldUploadId, upload._id);\n                } else if (/^audio\\/.+/.test(denormalizedMessage.file.type)) {\n                  attachment.audio_url = attachment.audio_url.replace(oldUploadId, upload._id);\n                } else if (/^video\\/.+/.test(denormalizedMessage.file.type)) {\n                  attachment.video_url = attachment.video_url.replace(oldUploadId, upload._id);\n                }\n              }\n            }\n\n            // Create the message\n            try {\n              await Messages.insertOne(denormalizedMessage);\n              await processThreads(denormalizedMessage, room);\n              const roomUpdater = Rooms.getUpdater();\n              await notifyUsersOnMessage(denormalizedMessage, room, roomUpdater);\n              if (roomUpdater.hasChanges()) {\n                await Rooms.updateFromUpdater({\n                  _id: room._id\n                }, roomUpdater);\n              }\n              sendAllNotifications(denormalizedMessage, room);\n              messageForNotification = denormalizedMessage;\n            } catch (err) {\n              serverLogger.debug(\"Error on creating message: \".concat(message._id));\n            }\n          }\n          if (messageForNotification) {\n            void notifyOnMessageChange({\n              id: messageForNotification._id,\n              data: messageForNotification\n            });\n          }\n        }\n        return eventResult;\n      },\n      //\n      // ROOM_EDIT_MESSAGE\n      //\n      async [eventTypes.ROOM_EDIT_MESSAGE](event) {\n        const eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n        // If the event was successfully added, handle the event locally\n        if (eventResult.success) {\n          const {\n            data: {\n              message\n            }\n          } = event;\n\n          // Check if message exists\n          const persistedMessage = await Messages.findOne({\n            _id: message._id\n          });\n          if (!persistedMessage) {\n            eventResult.success = false;\n            eventResult.reason = 'missingMessageToEdit';\n          } else {\n            // Update the message\n            await Messages.updateOne({\n              _id: persistedMessage._id\n            }, {\n              $set: {\n                msg: message.msg,\n                federation: message.federation\n              }\n            });\n            void notifyOnMessageChange({\n              id: persistedMessage._id,\n              data: _objectSpread(_objectSpread({}, persistedMessage), {}, {\n                msg: message.msg,\n                federation: message.federation\n              })\n            });\n          }\n        }\n        return eventResult;\n      },\n      //\n      // ROOM_DELETE_MESSAGE\n      //\n      async [eventTypes.ROOM_DELETE_MESSAGE](event) {\n        const eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n        // If the event was successfully added, handle the event locally\n        if (eventResult.success) {\n          const {\n            data: {\n              roomId,\n              messageId\n            }\n          } = event;\n\n          // Remove the message\n          await Messages.removeById(messageId);\n          await ReadReceipts.removeByMessageId(messageId);\n\n          // Notify the room\n          void api.broadcast('notify.deleteMessage', roomId, {\n            _id: messageId\n          });\n        }\n        return eventResult;\n      },\n      //\n      // ROOM_SET_MESSAGE_REACTION\n      //\n      async [eventTypes.ROOM_SET_MESSAGE_REACTION](event) {\n        const eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n        // If the event was successfully added, handle the event locally\n        if (eventResult.success) {\n          const {\n            data: {\n              messageId,\n              username,\n              reaction\n            }\n          } = event;\n\n          // Get persisted message\n          const persistedMessage = await Messages.findOne({\n            _id: messageId\n          });\n\n          // Make sure reactions exist\n          persistedMessage.reactions = persistedMessage.reactions || {};\n          let reactionObj = persistedMessage.reactions[reaction];\n\n          // If there are no reactions of that type, add it\n          if (!reactionObj) {\n            reactionObj = {\n              usernames: [username]\n            };\n          } else {\n            // Otherwise, add the username\n            reactionObj.usernames.push(username);\n            reactionObj.usernames = [...new Set(reactionObj.usernames)];\n          }\n\n          // Update the property\n          await Messages.updateOne({\n            _id: messageId\n          }, {\n            $set: {\n              [\"reactions.\".concat(reaction)]: reactionObj\n            }\n          });\n          void notifyOnMessageChange({\n            id: persistedMessage._id,\n            data: _objectSpread(_objectSpread({}, persistedMessage), {}, {\n              reactions: _objectSpread(_objectSpread({}, persistedMessage.reactions), {}, {\n                [reaction]: reactionObj\n              })\n            })\n          });\n        }\n        return eventResult;\n      },\n      //\n      // ROOM_UNSET_MESSAGE_REACTION\n      //\n      async [eventTypes.ROOM_UNSET_MESSAGE_REACTION](event) {\n        const eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n        // If the event was successfully added, handle the event locally\n        if (eventResult.success) {\n          const {\n            data: {\n              messageId,\n              username,\n              reaction\n            }\n          } = event;\n\n          // Get persisted message\n          const persistedMessage = await Messages.findOne({\n            _id: messageId\n          });\n\n          // Make sure reactions exist\n          persistedMessage.reactions = persistedMessage.reactions || {};\n\n          // If there are no reactions of that type, ignore\n          if (!persistedMessage.reactions[reaction]) {\n            return eventResult;\n          }\n          const reactionObj = persistedMessage.reactions[reaction];\n\n          // Get the username index on the list\n          const usernameIdx = reactionObj.usernames.indexOf(username);\n\n          // If the index is not found, ignore\n          if (usernameIdx === -1) {\n            return eventResult;\n          }\n\n          // Remove the username from the given reaction\n          reactionObj.usernames.splice(usernameIdx, 1);\n\n          // If there are no more users for that reaction, remove the property\n          if (reactionObj.usernames.length === 0) {\n            await Messages.updateOne({\n              _id: messageId\n            }, {\n              $unset: {\n                [\"reactions.\".concat(reaction)]: 1\n              }\n            });\n          } else {\n            // Otherwise, update the property\n            await Messages.updateOne({\n              _id: messageId\n            }, {\n              $set: {\n                [\"reactions.\".concat(reaction)]: reactionObj\n              }\n            });\n          }\n          void notifyOnMessageChange({\n            id: persistedMessage._id,\n            data: _objectSpread(_objectSpread({}, persistedMessage), {}, {\n              reactions: _objectSpread(_objectSpread({}, persistedMessage.reactions), {}, {\n                [reaction]: reactionObj\n              })\n            })\n          });\n        }\n        return eventResult;\n      },\n      //\n      // ROOM_MUTE_USER\n      //\n      async [eventTypes.ROOM_MUTE_USER](event) {\n        const eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n        // If the event was successfully added, handle the event locally\n        if (eventResult.success) {\n          const {\n            data: {\n              roomId,\n              user\n            }\n          } = event;\n\n          // Denormalize user\n          const denormalizedUser = normalizers.denormalizeUser(user);\n\n          // Mute user\n          await Rooms.muteUsernameByRoomId(roomId, denormalizedUser.username);\n\n          // Broadcast the unmute event\n          void notifyOnRoomChangedById(roomId);\n        }\n        return eventResult;\n      },\n      //\n      // ROOM_UNMUTE_USER\n      //\n      async [eventTypes.ROOM_UNMUTE_USER](event) {\n        const eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n        // If the event was successfully added, handle the event locally\n        if (eventResult.success) {\n          const {\n            data: {\n              roomId,\n              user\n            }\n          } = event;\n\n          // Denormalize user\n          const denormalizedUser = normalizers.denormalizeUser(user);\n\n          // Unmute user\n          await Rooms.unmuteMutedUsernameByRoomId(roomId, denormalizedUser.username);\n\n          // Broadcast the unmute event\n          void notifyOnRoomChangedById(roomId);\n        }\n        return eventResult;\n      }\n    };\n    API.v1.addRoute('federation.events.dispatch', {\n      authRequired: false,\n      rateLimiterOptions: {\n        numRequestsAllowed: 30,\n        intervalTimeInMS: 1000\n      }\n    }, {\n      async post() {\n        if (!isFederationEnabled()) {\n          return API.v1.failure('Federation not enabled');\n        }\n\n        //\n        // Decrypt the payload if needed\n        let payload;\n        try {\n          payload = await decryptIfNeeded(this.request, this.bodyParams);\n        } catch (err) {\n          return API.v1.failure('Could not decrypt payload');\n        }\n\n        //\n        // Convert from EJSON\n        const {\n          events\n        } = EJSON.fromJSONValue(payload);\n        serverLogger.debug({\n          msg: 'federation.events.dispatch',\n          events\n        });\n\n        // Loop over received events\n        for (const event of events) {\n          /* eslint-disable no-await-in-loop */\n\n          let eventResult;\n          if (eventHandlers[event.type]) {\n            eventResult = await eventHandlers[event.type](event);\n          }\n\n          // If there was an error handling the event, take action\n          if (!eventResult || !eventResult.success) {\n            try {\n              serverLogger.debug({\n                msg: 'federation.events.dispatch => Event has missing parents',\n                event\n              });\n              await requestEventsFromLatest(event.origin, getFederationDomain(), contextDefinitions.defineType(event), event.context, eventResult.latestEventIds);\n\n              // And stop handling the events\n              break;\n            } catch (err) {\n              serverLogger.error({\n                msg: 'dispatch',\n                event,\n                eventResult,\n                err\n              });\n              throw err;\n            }\n          }\n\n          /* eslint-enable no-await-in-loop */\n        }\n\n        // Respond\n        return API.v1.success();\n      }\n    });\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_objectSpread","module","link","default","v","api","eventTypes","FederationServers","FederationRoomEvents","Rooms","Messages","Subscriptions","Users","ReadReceipts","EJSON","API","FileUpload","deleteRoom","notifyOnMessageChange","notifyOnRoomChanged","notifyOnRoomChangedById","notifyOnSubscriptionChanged","notifyOnSubscriptionChangedById","notifyUsersOnMessage","sendAllNotifications","processThreads","getUpload","requestEventsFromLatest","contextDefinitions","decryptIfNeeded","getFederationDomain","isFederationEnabled","serverLogger","normalizers","__reifyWaitForDeps__","eventHandlers","PING","success","GENESIS","event","data","contextType","ROOM","type","eventResult","addEvent","context","room","persistedRoom","findOne","_id","updateOne","$set","federation","denormalizedRoom","denormalizeRoom","insertedRoom","insertOne","insertedId","ROOM_DELETE","roomId","removeRoomEvents","ROOM_ADD_USER","federationAltered","user","subscription","domainsAfterAdd","persistedUser","denormalizedUser","denormalizeUser","persistedSubscription","denormalizedSubscription","denormalizeSubscription","ex","debug","concat","refreshServers","ROOM_REMOVE_USER","domainsAfterRemoval","deletedSubscription","removeByRoomIdAndUserId","ROOM_USER_LEFT","ROOM_MESSAGE","message","persistedMessage","messageForNotification","findOneById","rid","denormalizedMessage","denormalizeMessage","file","fileStore","getStore","origin","upload","buffer","oldUploadId","userId","u","insert","attachment","attachments","title_link","replace","test","image_url","audio_url","video_url","roomUpdater","getUpdater","hasChanges","updateFromUpdater","err","id","ROOM_EDIT_MESSAGE","reason","msg","ROOM_DELETE_MESSAGE","messageId","removeById","removeByMessageId","broadcast","ROOM_SET_MESSAGE_REACTION","username","reaction","reactions","reactionObj","usernames","push","Set","ROOM_UNSET_MESSAGE_REACTION","usernameIdx","indexOf","splice","length","$unset","ROOM_MUTE_USER","muteUsernameByRoomId","ROOM_UNMUTE_USER","unmuteMutedUsernameByRoomId","v1","addRoute","authRequired","rateLimiterOptions","numRequestsAllowed","intervalTimeInMS","post","failure","payload","request","bodyParams","events","fromJSONValue","defineType","latestEventIds","error","__reify_async_result__","_reifyError","self","async"],"sources":["app/federation/server/endpoints/dispatch.js"],"sourcesContent":["import { api } from '@rocket.chat/core-services';\nimport { eventTypes } from '@rocket.chat/core-typings';\nimport { FederationServers, FederationRoomEvents, Rooms, Messages, Subscriptions, Users, ReadReceipts } from '@rocket.chat/models';\nimport EJSON from 'ejson';\n\nimport { API } from '../../../api/server';\nimport { FileUpload } from '../../../file-upload/server';\nimport { deleteRoom } from '../../../lib/server/functions/deleteRoom';\nimport {\n\tnotifyOnMessageChange,\n\tnotifyOnRoomChanged,\n\tnotifyOnRoomChangedById,\n\tnotifyOnSubscriptionChanged,\n\tnotifyOnSubscriptionChangedById,\n} from '../../../lib/server/lib/notifyListener';\nimport { notifyUsersOnMessage } from '../../../lib/server/lib/notifyUsersOnMessage';\nimport { sendAllNotifications } from '../../../lib/server/lib/sendNotificationsOnMessage';\nimport { processThreads } from '../../../threads/server/hooks/aftersavemessage';\nimport { getUpload, requestEventsFromLatest } from '../handler';\nimport { contextDefinitions } from '../lib/context';\nimport { decryptIfNeeded } from '../lib/crypt';\nimport { getFederationDomain } from '../lib/getFederationDomain';\nimport { isFederationEnabled } from '../lib/isFederationEnabled';\nimport { serverLogger } from '../lib/logger';\nimport { normalizers } from '../normalizers';\n\nconst eventHandlers = {\n\t//\n\t// PING\n\t//\n\tasync [eventTypes.PING]() {\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t};\n\t},\n\n\t//\n\t// GENESIS\n\t//\n\tasync [eventTypes.GENESIS](event) {\n\t\tswitch (event.data.contextType) {\n\t\t\tcase contextDefinitions.ROOM.type:\n\t\t\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t\t\t// If the event was successfully added, handle the event locally\n\t\t\t\tif (eventResult.success) {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tdata: { room },\n\t\t\t\t\t} = event;\n\n\t\t\t\t\t// Check if room exists\n\t\t\t\t\tconst persistedRoom = await Rooms.findOne({ _id: room._id });\n\n\t\t\t\t\tif (persistedRoom) {\n\t\t\t\t\t\t// Update the federation\n\t\t\t\t\t\tawait Rooms.updateOne({ _id: persistedRoom._id }, { $set: { federation: room.federation } });\n\n\t\t\t\t\t\t// Notify watch.rooms listener\n\t\t\t\t\t\tvoid notifyOnRoomChangedById(room._id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Denormalize room\n\t\t\t\t\t\tconst denormalizedRoom = normalizers.denormalizeRoom(room);\n\n\t\t\t\t\t\t// Create the room\n\t\t\t\t\t\tconst insertedRoom = await Rooms.insertOne(denormalizedRoom);\n\n\t\t\t\t\t\t// Notify watch.rooms listener\n\t\t\t\t\t\tvoid notifyOnRoomChangedById(insertedRoom.insertedId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn eventResult;\n\t\t}\n\t},\n\n\t//\n\t// ROOM_DELETE\n\t//\n\tasync [eventTypes.ROOM_DELETE](event) {\n\t\tconst {\n\t\t\tdata: { roomId },\n\t\t} = event;\n\n\t\t// Check if room exists\n\t\tconst persistedRoom = await Rooms.findOne({ _id: roomId });\n\n\t\tif (persistedRoom) {\n\t\t\t// Delete the room\n\t\t\tawait deleteRoom(roomId);\n\n\t\t\t// Notify watch.rooms listener\n\t\t\tvoid notifyOnRoomChanged(persistedRoom, 'removed');\n\t\t}\n\n\t\t// Remove all room events\n\t\tawait FederationRoomEvents.removeRoomEvents(roomId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t};\n\t},\n\n\t//\n\t// ROOM_ADD_USER\n\t//\n\tasync [eventTypes.ROOM_ADD_USER](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// We only want to refresh the server list and update the room federation array if something changed\n\t\tlet federationAltered = false;\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { roomId, user, subscription, domainsAfterAdd },\n\t\t\t} = event;\n\n\t\t\t// Check if user exists\n\t\t\tconst persistedUser = await Users.findOne({ _id: user._id });\n\n\t\t\tif (persistedUser) {\n\t\t\t\t// Update the federation, if its not already set (if it's set, this is likely an event being reprocessed)\n\t\t\t\tif (!persistedUser.federation) {\n\t\t\t\t\tawait Users.updateOne({ _id: persistedUser._id }, { $set: { federation: user.federation } });\n\t\t\t\t\tfederationAltered = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Denormalize user\n\t\t\t\tconst denormalizedUser = normalizers.denormalizeUser(user);\n\n\t\t\t\t// Create the user\n\t\t\t\tawait Users.insertOne(denormalizedUser);\n\t\t\t\tfederationAltered = true;\n\t\t\t}\n\n\t\t\t// Check if subscription exists\n\t\t\tconst persistedSubscription = await Subscriptions.findOne({ _id: subscription._id });\n\n\t\t\ttry {\n\t\t\t\tif (persistedSubscription) {\n\t\t\t\t\t// Update the federation, if its not already set (if it's set, this is likely an event being reprocessed\n\t\t\t\t\tif (!persistedSubscription.federation) {\n\t\t\t\t\t\tawait Subscriptions.updateOne({ _id: persistedSubscription._id }, { $set: { federation: subscription.federation } });\n\t\t\t\t\t\tfederationAltered = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Denormalize subscription\n\t\t\t\t\tconst denormalizedSubscription = normalizers.denormalizeSubscription(subscription);\n\n\t\t\t\t\t// Create the subscription\n\t\t\t\t\tconst { insertedId } = await Subscriptions.insertOne(denormalizedSubscription);\n\t\t\t\t\tif (insertedId) {\n\t\t\t\t\t\tvoid notifyOnSubscriptionChangedById(insertedId);\n\t\t\t\t\t}\n\t\t\t\t\tfederationAltered = true;\n\t\t\t\t}\n\t\t\t} catch (ex) {\n\t\t\t\tserverLogger.debug(`unable to create subscription for user ( ${user._id} ) in room (${roomId})`);\n\t\t\t}\n\n\t\t\t// Refresh the servers list\n\t\t\tif (federationAltered) {\n\t\t\t\tawait FederationServers.refreshServers();\n\n\t\t\t\t// Update the room's federation property\n\t\t\t\tawait Rooms.updateOne({ _id: roomId }, { $set: { 'federation.domains': domainsAfterAdd } });\n\n\t\t\t\t// Notify watch.rooms listener\n\t\t\t\tvoid notifyOnRoomChangedById(roomId);\n\t\t\t}\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_REMOVE_USER\n\t//\n\tasync [eventTypes.ROOM_REMOVE_USER](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { roomId, user, domainsAfterRemoval },\n\t\t\t} = event;\n\n\t\t\t// Remove the user's subscription\n\t\t\tconst deletedSubscription = await Subscriptions.removeByRoomIdAndUserId(roomId, user._id);\n\t\t\tif (deletedSubscription) {\n\t\t\t\tvoid notifyOnSubscriptionChanged(deletedSubscription, 'removed');\n\t\t\t}\n\n\t\t\t// Refresh the servers list\n\t\t\tawait FederationServers.refreshServers();\n\n\t\t\t// Update the room's federation property\n\t\t\tawait Rooms.updateOne({ _id: roomId }, { $set: { 'federation.domains': domainsAfterRemoval } });\n\n\t\t\t// Notify watch.rooms listener\n\t\t\tvoid notifyOnRoomChangedById(roomId);\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_USER_LEFT\n\t//\n\tasync [eventTypes.ROOM_USER_LEFT](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { roomId, user, domainsAfterRemoval },\n\t\t\t} = event;\n\n\t\t\t// Remove the user's subscription\n\t\t\tconst deletedSubscription = await Subscriptions.removeByRoomIdAndUserId(roomId, user._id);\n\t\t\tif (deletedSubscription) {\n\t\t\t\tvoid notifyOnSubscriptionChanged(deletedSubscription, 'removed');\n\t\t\t}\n\n\t\t\t// Refresh the servers list\n\t\t\tawait FederationServers.refreshServers();\n\n\t\t\t// Update the room's federation property\n\t\t\tawait Rooms.updateOne({ _id: roomId }, { $set: { 'federation.domains': domainsAfterRemoval } });\n\n\t\t\t// Notify watch.rooms listener\n\t\t\tvoid notifyOnRoomChangedById(roomId);\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_MESSAGE\n\t//\n\tasync [eventTypes.ROOM_MESSAGE](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { message },\n\t\t\t} = event;\n\n\t\t\t// Check if message exists\n\t\t\tconst persistedMessage = await Messages.findOne({ _id: message._id });\n\t\t\tlet messageForNotification;\n\n\t\t\tif (persistedMessage) {\n\t\t\t\t// Update the federation\n\t\t\t\tif (!persistedMessage.federation) {\n\t\t\t\t\tawait Messages.updateOne({ _id: persistedMessage._id }, { $set: { federation: message.federation } });\n\t\t\t\t\tmessageForNotification = { ...persistedMessage, federation: message.federation };\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Load the room\n\t\t\t\tconst room = await Rooms.findOneById(message.rid);\n\n\t\t\t\t// Denormalize message\n\t\t\t\tconst denormalizedMessage = normalizers.denormalizeMessage(message);\n\n\t\t\t\t// Is there a file?\n\t\t\t\tif (denormalizedMessage.file) {\n\t\t\t\t\tconst fileStore = FileUpload.getStore('Uploads');\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tfederation: { origin },\n\t\t\t\t\t} = denormalizedMessage;\n\n\t\t\t\t\tconst { upload, buffer } = await getUpload(origin, denormalizedMessage.file._id);\n\n\t\t\t\t\tconst oldUploadId = upload._id;\n\n\t\t\t\t\t// Normalize upload\n\t\t\t\t\tdelete upload._id;\n\t\t\t\t\tupload.rid = denormalizedMessage.rid;\n\t\t\t\t\tupload.userId = denormalizedMessage.u._id;\n\t\t\t\t\tupload.federation = {\n\t\t\t\t\t\t_id: denormalizedMessage.file._id,\n\t\t\t\t\t\torigin,\n\t\t\t\t\t};\n\n\t\t\t\t\tawait fileStore.insert(upload, buffer);\n\n\t\t\t\t\t// Update the message's file\n\t\t\t\t\tdenormalizedMessage.file._id = upload._id;\n\n\t\t\t\t\t// Update the message's attachments dependent on type\n\t\t\t\t\tfor (const attachment of denormalizedMessage.attachments) {\n\t\t\t\t\t\tattachment.title_link = attachment.title_link.replace(oldUploadId, upload._id);\n\t\t\t\t\t\tif (/^image\\/.+/.test(denormalizedMessage.file.type)) {\n\t\t\t\t\t\t\tattachment.image_url = attachment.image_url.replace(oldUploadId, upload._id);\n\t\t\t\t\t\t} else if (/^audio\\/.+/.test(denormalizedMessage.file.type)) {\n\t\t\t\t\t\t\tattachment.audio_url = attachment.audio_url.replace(oldUploadId, upload._id);\n\t\t\t\t\t\t} else if (/^video\\/.+/.test(denormalizedMessage.file.type)) {\n\t\t\t\t\t\t\tattachment.video_url = attachment.video_url.replace(oldUploadId, upload._id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create the message\n\t\t\t\ttry {\n\t\t\t\t\tawait Messages.insertOne(denormalizedMessage);\n\n\t\t\t\t\tawait processThreads(denormalizedMessage, room);\n\n\t\t\t\t\tconst roomUpdater = Rooms.getUpdater();\n\t\t\t\t\tawait notifyUsersOnMessage(denormalizedMessage, room, roomUpdater);\n\t\t\t\t\tif (roomUpdater.hasChanges()) {\n\t\t\t\t\t\tawait Rooms.updateFromUpdater({ _id: room._id }, roomUpdater);\n\t\t\t\t\t}\n\n\t\t\t\t\tsendAllNotifications(denormalizedMessage, room);\n\t\t\t\t\tmessageForNotification = denormalizedMessage;\n\t\t\t\t} catch (err) {\n\t\t\t\t\tserverLogger.debug(`Error on creating message: ${message._id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (messageForNotification) {\n\t\t\t\tvoid notifyOnMessageChange({\n\t\t\t\t\tid: messageForNotification._id,\n\t\t\t\t\tdata: messageForNotification,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_EDIT_MESSAGE\n\t//\n\tasync [eventTypes.ROOM_EDIT_MESSAGE](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { message },\n\t\t\t} = event;\n\n\t\t\t// Check if message exists\n\t\t\tconst persistedMessage = await Messages.findOne({ _id: message._id });\n\n\t\t\tif (!persistedMessage) {\n\t\t\t\teventResult.success = false;\n\t\t\t\teventResult.reason = 'missingMessageToEdit';\n\t\t\t} else {\n\t\t\t\t// Update the message\n\t\t\t\tawait Messages.updateOne({ _id: persistedMessage._id }, { $set: { msg: message.msg, federation: message.federation } });\n\t\t\t\tvoid notifyOnMessageChange({\n\t\t\t\t\tid: persistedMessage._id,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\t...persistedMessage,\n\t\t\t\t\t\tmsg: message.msg,\n\t\t\t\t\t\tfederation: message.federation,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_DELETE_MESSAGE\n\t//\n\tasync [eventTypes.ROOM_DELETE_MESSAGE](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { roomId, messageId },\n\t\t\t} = event;\n\n\t\t\t// Remove the message\n\t\t\tawait Messages.removeById(messageId);\n\t\t\tawait ReadReceipts.removeByMessageId(messageId);\n\n\t\t\t// Notify the room\n\t\t\tvoid api.broadcast('notify.deleteMessage', roomId, { _id: messageId });\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_SET_MESSAGE_REACTION\n\t//\n\tasync [eventTypes.ROOM_SET_MESSAGE_REACTION](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { messageId, username, reaction },\n\t\t\t} = event;\n\n\t\t\t// Get persisted message\n\t\t\tconst persistedMessage = await Messages.findOne({ _id: messageId });\n\n\t\t\t// Make sure reactions exist\n\t\t\tpersistedMessage.reactions = persistedMessage.reactions || {};\n\n\t\t\tlet reactionObj = persistedMessage.reactions[reaction];\n\n\t\t\t// If there are no reactions of that type, add it\n\t\t\tif (!reactionObj) {\n\t\t\t\treactionObj = {\n\t\t\t\t\tusernames: [username],\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// Otherwise, add the username\n\t\t\t\treactionObj.usernames.push(username);\n\t\t\t\treactionObj.usernames = [...new Set(reactionObj.usernames)];\n\t\t\t}\n\n\t\t\t// Update the property\n\t\t\tawait Messages.updateOne({ _id: messageId }, { $set: { [`reactions.${reaction}`]: reactionObj } });\n\t\t\tvoid notifyOnMessageChange({\n\t\t\t\tid: persistedMessage._id,\n\t\t\t\tdata: {\n\t\t\t\t\t...persistedMessage,\n\t\t\t\t\treactions: {\n\t\t\t\t\t\t...persistedMessage.reactions,\n\t\t\t\t\t\t[reaction]: reactionObj,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_UNSET_MESSAGE_REACTION\n\t//\n\tasync [eventTypes.ROOM_UNSET_MESSAGE_REACTION](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { messageId, username, reaction },\n\t\t\t} = event;\n\n\t\t\t// Get persisted message\n\t\t\tconst persistedMessage = await Messages.findOne({ _id: messageId });\n\n\t\t\t// Make sure reactions exist\n\t\t\tpersistedMessage.reactions = persistedMessage.reactions || {};\n\n\t\t\t// If there are no reactions of that type, ignore\n\t\t\tif (!persistedMessage.reactions[reaction]) {\n\t\t\t\treturn eventResult;\n\t\t\t}\n\n\t\t\tconst reactionObj = persistedMessage.reactions[reaction];\n\n\t\t\t// Get the username index on the list\n\t\t\tconst usernameIdx = reactionObj.usernames.indexOf(username);\n\n\t\t\t// If the index is not found, ignore\n\t\t\tif (usernameIdx === -1) {\n\t\t\t\treturn eventResult;\n\t\t\t}\n\n\t\t\t// Remove the username from the given reaction\n\t\t\treactionObj.usernames.splice(usernameIdx, 1);\n\n\t\t\t// If there are no more users for that reaction, remove the property\n\t\t\tif (reactionObj.usernames.length === 0) {\n\t\t\t\tawait Messages.updateOne({ _id: messageId }, { $unset: { [`reactions.${reaction}`]: 1 } });\n\t\t\t} else {\n\t\t\t\t// Otherwise, update the property\n\t\t\t\tawait Messages.updateOne({ _id: messageId }, { $set: { [`reactions.${reaction}`]: reactionObj } });\n\t\t\t}\n\t\t\tvoid notifyOnMessageChange({\n\t\t\t\tid: persistedMessage._id,\n\t\t\t\tdata: {\n\t\t\t\t\t...persistedMessage,\n\t\t\t\t\treactions: {\n\t\t\t\t\t\t...persistedMessage.reactions,\n\t\t\t\t\t\t[reaction]: reactionObj,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_MUTE_USER\n\t//\n\tasync [eventTypes.ROOM_MUTE_USER](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { roomId, user },\n\t\t\t} = event;\n\n\t\t\t// Denormalize user\n\t\t\tconst denormalizedUser = normalizers.denormalizeUser(user);\n\n\t\t\t// Mute user\n\t\t\tawait Rooms.muteUsernameByRoomId(roomId, denormalizedUser.username);\n\n\t\t\t// Broadcast the unmute event\n\t\t\tvoid notifyOnRoomChangedById(roomId);\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_UNMUTE_USER\n\t//\n\tasync [eventTypes.ROOM_UNMUTE_USER](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { roomId, user },\n\t\t\t} = event;\n\n\t\t\t// Denormalize user\n\t\t\tconst denormalizedUser = normalizers.denormalizeUser(user);\n\n\t\t\t// Unmute user\n\t\t\tawait Rooms.unmuteMutedUsernameByRoomId(roomId, denormalizedUser.username);\n\n\t\t\t// Broadcast the unmute event\n\t\t\tvoid notifyOnRoomChangedById(roomId);\n\t\t}\n\n\t\treturn eventResult;\n\t},\n};\n\nAPI.v1.addRoute(\n\t'federation.events.dispatch',\n\t{ authRequired: false, rateLimiterOptions: { numRequestsAllowed: 30, intervalTimeInMS: 1000 } },\n\t{\n\t\tasync post() {\n\t\t\tif (!isFederationEnabled()) {\n\t\t\t\treturn API.v1.failure('Federation not enabled');\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Decrypt the payload if needed\n\t\t\tlet payload;\n\n\t\t\ttry {\n\t\t\t\tpayload = await decryptIfNeeded(this.request, this.bodyParams);\n\t\t\t} catch (err) {\n\t\t\t\treturn API.v1.failure('Could not decrypt payload');\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Convert from EJSON\n\t\t\tconst { events } = EJSON.fromJSONValue(payload);\n\n\t\t\tserverLogger.debug({ msg: 'federation.events.dispatch', events });\n\n\t\t\t// Loop over received events\n\t\t\tfor (const event of events) {\n\t\t\t\t/* eslint-disable no-await-in-loop */\n\n\t\t\t\tlet eventResult;\n\n\t\t\t\tif (eventHandlers[event.type]) {\n\t\t\t\t\teventResult = await eventHandlers[event.type](event);\n\t\t\t\t}\n\n\t\t\t\t// If there was an error handling the event, take action\n\t\t\t\tif (!eventResult || !eventResult.success) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tserverLogger.debug({\n\t\t\t\t\t\t\tmsg: 'federation.events.dispatch => Event has missing parents',\n\t\t\t\t\t\t\tevent,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tawait requestEventsFromLatest(\n\t\t\t\t\t\t\tevent.origin,\n\t\t\t\t\t\t\tgetFederationDomain(),\n\t\t\t\t\t\t\tcontextDefinitions.defineType(event),\n\t\t\t\t\t\t\tevent.context,\n\t\t\t\t\t\t\teventResult.latestEventIds,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// And stop handling the events\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tserverLogger.error({ msg: 'dispatch', event, eventResult, err });\n\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* eslint-enable no-await-in-loop */\n\t\t\t}\n\n\t\t\t// Respond\n\t\t\treturn API.v1.success();\n\t\t},\n\t},\n);\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"916ddf080f626ee22aa88fc75e3f24194002a509"}
