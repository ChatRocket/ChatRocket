{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/oauth/oauth_server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/oauth/oauth_server.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/oauth/oauth_server.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/oauth/oauth_server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/oauth/oauth_server.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    let _objectWithoutProperties;\n    module.link(\"@babel/runtime/helpers/objectWithoutProperties\", {\n      default(v) {\n        _objectWithoutProperties = v;\n      }\n    }, 1);\n    const _excluded = [\"headers\", \"queryParams\", \"body\"];\n    let bodyParser;\n    module.link(\"body-parser\", {\n      default(v) {\n        bodyParser = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    OAuth = {};\n    OAuthTest = {};\n    RoutePolicy.declare('/_oauth/', 'network');\n    const registeredServices = {};\n\n    // Internal: Maps from service version to handler function. The\n    // 'oauth1' and 'oauth2' packages manipulate this directly to register\n    // for callbacks.\n    OAuth._requestHandlers = {};\n\n    /**\n    /* Register a handler for an OAuth service. The handler will be called\n    /* when we get an incoming http request on /_oauth/{serviceName}. This\n    /* handler should use that information to fetch data about the user\n    /* logging in.\n    /*\n    /* @param name {String} e.g. \"google\", \"facebook\"\n    /* @param version {Number} OAuth version (1 or 2)\n    /* @param urls   For OAuth1 only, specify the service's urls\n    /* @param handleOauthRequest {Function(oauthBinding|query)}\n    /*   - (For OAuth1 only) oauthBinding {OAuth1Binding} bound to the appropriate provider\n    /*   - (For OAuth2 only) query {Object} parameters passed in query string\n    /*   - return value is:\n    /*     - {serviceData:, (optional options:)} where serviceData should end\n    /*       up in the user's services[name] field\n    /*     - `null` if the user declined to give permissions\n    */\n    OAuth.registerService = (name, version, urls, handleOauthRequest) => {\n      if (registeredServices[name]) throw new Error(\"Already registered the \".concat(name, \" OAuth service\"));\n      registeredServices[name] = {\n        serviceName: name,\n        version,\n        urls,\n        handleOauthRequest\n      };\n    };\n\n    // For test cleanup.\n    OAuthTest.unregisterService = name => {\n      delete registeredServices[name];\n    };\n    OAuth.retrieveCredential = (credentialToken, credentialSecret) => OAuth._retrievePendingCredential(credentialToken, credentialSecret);\n\n    // The state parameter is normally generated on the client using\n    // `btoa`, but for tests we need a version that runs on the server.\n    //\n    OAuth._generateState = (loginStyle, credentialToken, redirectUrl) => {\n      return Buffer.from(JSON.stringify({\n        loginStyle: loginStyle,\n        credentialToken: credentialToken,\n        redirectUrl: redirectUrl\n      })).toString('base64');\n    };\n    OAuth._stateFromQuery = query => {\n      let string;\n      try {\n        string = Buffer.from(query.state, 'base64').toString('binary');\n      } catch (e) {\n        Log.warn(\"Unable to base64 decode state from OAuth query: \".concat(query.state));\n        throw e;\n      }\n      try {\n        return JSON.parse(string);\n      } catch (e) {\n        Log.warn(\"Unable to parse state from OAuth query: \".concat(string));\n        throw e;\n      }\n    };\n    OAuth._loginStyleFromQuery = query => {\n      let style;\n      // For backwards-compatibility for older clients, catch any errors\n      // that result from parsing the state parameter. If we can't parse it,\n      // set login style to popup by default.\n      try {\n        style = OAuth._stateFromQuery(query).loginStyle;\n      } catch (err) {\n        style = \"popup\";\n      }\n      if (style !== \"popup\" && style !== \"redirect\") {\n        throw new Error(\"Unrecognized login style: \".concat(style));\n      }\n      return style;\n    };\n    OAuth._credentialTokenFromQuery = query => {\n      let state;\n      // For backwards-compatibility for older clients, catch any errors\n      // that result from parsing the state parameter. If we can't parse it,\n      // assume that the state parameter's value is the credential token, as\n      // it used to be for older clients.\n      try {\n        state = OAuth._stateFromQuery(query);\n      } catch (err) {\n        return query.state;\n      }\n      return state.credentialToken;\n    };\n    OAuth._isCordovaFromQuery = query => {\n      try {\n        return !!OAuth._stateFromQuery(query).isCordova;\n      } catch (err) {\n        // For backwards-compatibility for older clients, catch any errors\n        // that result from parsing the state parameter. If we can't parse\n        // it, assume that we are not on Cordova, since older Meteor didn't\n        // do Cordova.\n        return false;\n      }\n    };\n\n    // Checks if the `redirectUrl` matches the app host.\n    // We export this function so that developers can override this\n    // behavior to allow apps from external domains to login using the\n    // redirect OAuth flow.\n    OAuth._checkRedirectUrlOrigin = redirectUrl => {\n      const appHost = Meteor.absoluteUrl();\n      const appHostReplacedLocalhost = Meteor.absoluteUrl(undefined, {\n        replaceLocalhost: true\n      });\n      return redirectUrl.substr(0, appHost.length) !== appHost && redirectUrl.substr(0, appHostReplacedLocalhost.length) !== appHostReplacedLocalhost;\n    };\n    const middleware = async (req, res, next) => {\n      let requestData;\n\n      // Make sure to catch any exceptions because otherwise we'd crash\n      // the runner\n      try {\n        const serviceName = oauthServiceName(req);\n        if (!serviceName) {\n          // not an oauth request. pass to next middleware.\n          next();\n          return;\n        }\n        const service = registeredServices[serviceName];\n\n        // Skip everything if there's no service set by the oauth middleware\n        if (!service) throw new Error(\"Unexpected OAuth service \".concat(serviceName));\n\n        // Make sure we're configured\n        await ensureConfigured(serviceName);\n        const handler = OAuth._requestHandlers[service.version];\n        if (!handler) throw new Error(\"Unexpected OAuth version \".concat(service.version));\n        if (req.method === 'GET') {\n          requestData = req.query;\n        } else {\n          requestData = req.body;\n        }\n        await handler(service, requestData, res);\n      } catch (err) {\n        var _requestData;\n        // if we got thrown an error, save it off, it will get passed to\n        // the appropriate login call (if any) and reported there.\n        //\n        // The other option would be to display it in the popup tab that\n        // is still open at this point, ignoring the 'close' or 'redirect'\n        // we were passed. But then the developer wouldn't be able to\n        // style the error or react to it in any way.\n        if ((_requestData = requestData) !== null && _requestData !== void 0 && _requestData.state && err instanceof Error) {\n          try {\n            // catch any exceptions to avoid crashing runner\n            await OAuth._storePendingCredential(OAuth._credentialTokenFromQuery(requestData), err);\n          } catch (err) {\n            // Ignore the error and just give up. If we failed to store the\n            // error, then the login will just fail with a generic error.\n            Log.warn(\"Error in OAuth Server while storing pending login result.\\n\" + err.stack || err.message);\n          }\n        }\n\n        // close the popup. because nobody likes them just hanging\n        // there.  when someone sees this multiple times they might\n        // think to check server logs (we hope?)\n        // Catch errors because any exception here will crash the runner.\n        try {\n          await OAuth._endOfLoginResponse(res, {\n            query: requestData,\n            loginStyle: OAuth._loginStyleFromQuery(requestData),\n            error: err\n          });\n        } catch (err) {\n          Log.warn(\"Error generating end of login response\\n\" + (err && (err.stack || err.message)));\n        }\n      }\n    };\n\n    // Listen to incoming OAuth http requests\n    WebApp.handlers.use('/_oauth', bodyParser.json());\n    WebApp.handlers.use('/_oauth', bodyParser.urlencoded({\n      extended: false\n    }));\n    WebApp.handlers.use(middleware);\n    OAuthTest.middleware = middleware;\n    OAuthTest.registeredServices = registeredServices;\n\n    // Handle /_oauth/* paths and extract the service name.\n    //\n    // @returns {String|null} e.g. \"facebook\", or null if this isn't an\n    // oauth request\n    const oauthServiceName = req => {\n      // req.url will be \"/_oauth/<service name>\" with an optional \"?close\".\n      const i = req.url.indexOf('?');\n      let barePath;\n      if (i === -1) barePath = req.url;else barePath = req.url.substring(0, i);\n      const splitPath = barePath.split('/');\n\n      // Any non-oauth request will continue down the default\n      // middlewares.\n      if (splitPath[1] !== '_oauth') return null;\n\n      // Find service based on url\n      const serviceName = splitPath[2];\n      return serviceName;\n    };\n\n    // Make sure we're configured\n    const ensureConfigured = async serviceName => {\n      const config = await ServiceConfiguration.configurations.findOneAsync({\n        service: serviceName\n      });\n      if (!config) {\n        throw new ServiceConfiguration.ConfigError();\n      }\n    };\n    const isSafe = value => {\n      // This matches strings generated by `Random.secret` and\n      // `Random.id`.\n      return typeof value === \"string\" && /^[a-zA-Z0-9\\-_]+$/.test(value);\n    };\n\n    // Internal: used by the oauth1 and oauth2 packages\n    OAuth._renderOauthResults = async (res, query, credentialSecret) => {\n      // For tests, we support the `only_credential_secret_for_test`\n      // parameter, which just returns the credential secret without any\n      // surrounding HTML. (The test needs to be able to easily grab the\n      // secret and use it to log in.)\n      //\n      // XXX only_credential_secret_for_test could be useful for other\n      // things beside tests, like command-line clients. We should give it a\n      // real name and serve the credential secret in JSON.\n\n      if (query.only_credential_secret_for_test) {\n        res.writeHead(200, {\n          'Content-Type': 'text/html'\n        });\n        res.end(credentialSecret, 'utf-8');\n      } else {\n        const details = {\n          query,\n          loginStyle: OAuth._loginStyleFromQuery(query)\n        };\n        if (query.error) {\n          details.error = query.error;\n        } else {\n          const token = OAuth._credentialTokenFromQuery(query);\n          const secret = credentialSecret;\n          if (token && secret && isSafe(token) && isSafe(secret)) {\n            details.credentials = {\n              token: token,\n              secret: secret\n            };\n          } else {\n            details.error = \"invalid_credential_token_or_secret\";\n          }\n        }\n        await OAuth._endOfLoginResponse(res, details);\n      }\n    };\n    const getAsset = name => {\n      return new Promise((resolve, reject) => Assets.getTextAsync(\"\".concat(name, \".html\"), (err, data) => err ? reject(err) : resolve(data)));\n    };\n    // This \"template\" (not a real Spacebars template, just an HTML file\n    // with some ##PLACEHOLDER##s) communicates the credential secret back\n    // to the main window and then closes the popup.\n    OAuth._endOfPopupResponseTemplate = async () => await getAsset('end_of_popup_response');\n    OAuth._endOfRedirectResponseTemplate = async () => await getAsset('end_of_redirect_response');\n\n    // Renders the end of login response template into some HTML and JavaScript\n    // that closes the popup or redirects at the end of the OAuth flow.\n    //\n    // options are:\n    //   - loginStyle (\"popup\" or \"redirect\")\n    //   - setCredentialToken (boolean)\n    //   - credentialToken\n    //   - credentialSecret\n    //   - redirectUrl\n    //   - isCordova (boolean)\n    //\n    const renderEndOfLoginResponse = async options => {\n      // It would be nice to use Blaze here, but it's a little tricky\n      // because our mustaches would be inside a <script> tag, and Blaze\n      // would treat the <script> tag contents as text (e.g. encode '&' as\n      // '&amp;'). So we just do a simple replace.\n\n      const escape = s => {\n        if (s) {\n          return s.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\\\"/g, \"&quot;\").replace(/\\'/g, \"&#x27;\").replace(/\\//g, \"&#x2F;\");\n        } else {\n          return s;\n        }\n      };\n\n      // Escape everything just to be safe (we've already checked that some\n      // of this data -- the token and secret -- are safe).\n      const config = {\n        setCredentialToken: !!options.setCredentialToken,\n        credentialToken: escape(options.credentialToken),\n        credentialSecret: escape(options.credentialSecret),\n        storagePrefix: escape(OAuth._storageTokenPrefix),\n        redirectUrl: escape(options.redirectUrl),\n        isCordova: !!options.isCordova\n      };\n      let template;\n      if (options.loginStyle === 'popup') {\n        template = await OAuth._endOfPopupResponseTemplate();\n      } else if (options.loginStyle === 'redirect') {\n        template = await OAuth._endOfRedirectResponseTemplate();\n      } else {\n        throw new Error(\"invalid loginStyle: \".concat(options.loginStyle));\n      }\n      const result = template.replace(/##CONFIG##/, JSON.stringify(config)).replace(/##ROOT_URL_PATH_PREFIX##/, __meteor_runtime_config__.ROOT_URL_PATH_PREFIX);\n      return \"<!DOCTYPE html>\\n\".concat(result);\n    };\n\n    // Writes an HTTP response to the popup window at the end of an OAuth\n    // login flow. At this point, if the user has successfully authenticated\n    // to the OAuth server and authorized this app, we communicate the\n    // credentialToken and credentialSecret to the main window. The main\n    // window must provide both these values to the DDP `login` method to\n    // authenticate its DDP connection. After communicating these values to\n    // the main window, we close the popup.\n    //\n    // We export this function so that developers can override this\n    // behavior, which is particularly useful in, for example, some mobile\n    // environments where popups and/or `window.opener` don't work. For\n    // example, an app could override `OAuth._endOfPopupResponse` to put the\n    // credential token and credential secret in the popup URL for the main\n    // window to read them there instead of using `window.opener`. If you\n    // override this function, you take responsibility for writing to the\n    // request and calling `res.end()` to complete the request.\n    //\n    // Arguments:\n    //   - res: the HTTP response object\n    //   - details:\n    //      - query: the query string on the HTTP request\n    //      - credentials: { token: *, secret: * }. If present, this field\n    //        indicates that the login was successful. Return these values\n    //        to the client, who can use them to log in over DDP. If\n    //        present, the values have been checked against a limited\n    //        character set and are safe to include in HTML.\n    //      - error: if present, a string or Error indicating an error that\n    //        occurred during the login. This can come from the client and\n    //        so shouldn't be trusted for security decisions or included in\n    //        the response without sanitizing it first. Only one of `error`\n    //        or `credentials` should be set.\n    OAuth._endOfLoginResponse = async (res, details) => {\n      res.writeHead(200, {\n        'Content-Type': 'text/html'\n      });\n      let redirectUrl;\n      if (details.loginStyle === 'redirect') {\n        var _Meteor$settings, _Meteor$settings$pack, _Meteor$settings$pack2;\n        redirectUrl = OAuth._stateFromQuery(details.query).redirectUrl;\n        const appHost = Meteor.absoluteUrl();\n        if (!((_Meteor$settings = Meteor.settings) !== null && _Meteor$settings !== void 0 && (_Meteor$settings$pack = _Meteor$settings.packages) !== null && _Meteor$settings$pack !== void 0 && (_Meteor$settings$pack2 = _Meteor$settings$pack.oauth) !== null && _Meteor$settings$pack2 !== void 0 && _Meteor$settings$pack2.disableCheckRedirectUrlOrigin) && OAuth._checkRedirectUrlOrigin(redirectUrl)) {\n          details.error = \"redirectUrl (\".concat(redirectUrl) + \") is not on the same host as the app (\".concat(appHost, \")\");\n          redirectUrl = appHost;\n        }\n      }\n      const isCordova = OAuth._isCordovaFromQuery(details.query);\n      if (details.error) {\n        Log.warn(\"Error in OAuth Server: \" + (details.error instanceof Error ? details.error.message : details.error));\n        res.end(await renderEndOfLoginResponse({\n          loginStyle: details.loginStyle,\n          setCredentialToken: false,\n          redirectUrl,\n          isCordova\n        }), \"utf-8\");\n        return;\n      }\n\n      // If we have a credentialSecret, report it back to the parent\n      // window, with the corresponding credentialToken. The parent window\n      // uses the credentialToken and credentialSecret to log in over DDP.\n      res.end(await renderEndOfLoginResponse({\n        loginStyle: details.loginStyle,\n        setCredentialToken: true,\n        credentialToken: details.credentials.token,\n        credentialSecret: details.credentials.secret,\n        redirectUrl,\n        isCordova\n      }), \"utf-8\");\n    };\n    const OAuthEncryption = Package[\"oauth-encryption\"] && Package[\"oauth-encryption\"].OAuthEncryption;\n    const usingOAuthEncryption = () => OAuthEncryption && OAuthEncryption.keyIsLoaded();\n\n    // Encrypt sensitive service data such as access tokens if the\n    // \"oauth-encryption\" package is loaded and the oauth secret key has\n    // been specified.  Returns the unencrypted plaintext otherwise.\n    //\n    // The user id is not specified because the user isn't known yet at\n    // this point in the oauth authentication process.  After the oauth\n    // authentication process completes the encrypted service data fields\n    // will be re-encrypted with the user id included before inserting the\n    // service data into the user document.\n    //\n    OAuth.sealSecret = plaintext => {\n      if (usingOAuthEncryption()) return OAuthEncryption.seal(plaintext);else return plaintext;\n    };\n\n    // Unencrypt a service data field, if the \"oauth-encryption\"\n    // package is loaded and the field is encrypted.\n    //\n    // Throws an error if the \"oauth-encryption\" package is loaded and the\n    // field is encrypted, but the oauth secret key hasn't been specified.\n    //\n    OAuth.openSecret = (maybeSecret, userId) => {\n      if (!Package[\"oauth-encryption\"] || !OAuthEncryption.isSealed(maybeSecret)) return maybeSecret;\n      return OAuthEncryption.open(maybeSecret, userId);\n    };\n\n    // Unencrypt fields in the service data object.\n    //\n    OAuth.openSecrets = (serviceData, userId) => {\n      const result = {};\n      Object.keys(serviceData).forEach(key => result[key] = OAuth.openSecret(serviceData[key], userId));\n      return result;\n    };\n    OAuth._addValuesToQueryParams = function () {\n      let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new URLSearchParams();\n      Object.entries(values).forEach(_ref => {\n        let [key, value] = _ref;\n        queryParams.set(key, \"\".concat(value));\n      });\n      return queryParams;\n    };\n    OAuth._fetch = async function (url) {\n      let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GET';\n      let _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      let {\n          headers = {},\n          queryParams = {},\n          body\n        } = _ref2,\n        options = _objectWithoutProperties(_ref2, _excluded);\n      const urlWithParams = new URL(url);\n      OAuth._addValuesToQueryParams(queryParams, urlWithParams.searchParams);\n      const requestOptions = _objectSpread(_objectSpread({\n        method: method.toUpperCase(),\n        headers\n      }, body ? {\n        body\n      } : {}), options);\n      return fetch(urlWithParams.toString(), requestOptions);\n    };\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_objectSpread","module","link","default","v","_objectWithoutProperties","_excluded","bodyParser","__reifyWaitForDeps__","OAuth","OAuthTest","RoutePolicy","declare","registeredServices","_requestHandlers","registerService","name","version","urls","handleOauthRequest","Error","concat","serviceName","unregisterService","retrieveCredential","credentialToken","credentialSecret","_retrievePendingCredential","_generateState","loginStyle","redirectUrl","Buffer","from","JSON","stringify","toString","_stateFromQuery","query","string","state","e","Log","warn","parse","_loginStyleFromQuery","style","err","_credentialTokenFromQuery","_isCordovaFromQuery","isCordova","_checkRedirectUrlOrigin","appHost","Meteor","absoluteUrl","appHostReplacedLocalhost","undefined","replaceLocalhost","substr","length","middleware","req","res","next","requestData","oauthServiceName","service","ensureConfigured","handler","method","body","_requestData","_storePendingCredential","stack","message","_endOfLoginResponse","error","WebApp","handlers","use","json","urlencoded","extended","i","url","indexOf","barePath","substring","splitPath","split","config","ServiceConfiguration","configurations","findOneAsync","ConfigError","isSafe","value","test","_renderOauthResults","only_credential_secret_for_test","writeHead","end","details","token","secret","credentials","getAsset","Promise","resolve","reject","Assets","getTextAsync","data","_endOfPopupResponseTemplate","_endOfRedirectResponseTemplate","renderEndOfLoginResponse","options","escape","s","replace","setCredentialToken","storagePrefix","_storageTokenPrefix","template","result","__meteor_runtime_config__","ROOT_URL_PATH_PREFIX","_Meteor$settings","_Meteor$settings$pack","_Meteor$settings$pack2","settings","packages","oauth","disableCheckRedirectUrlOrigin","OAuthEncryption","Package","usingOAuthEncryption","keyIsLoaded","sealSecret","plaintext","seal","openSecret","maybeSecret","userId","isSealed","open","openSecrets","serviceData","Object","keys","forEach","key","_addValuesToQueryParams","values","arguments","queryParams","URLSearchParams","entries","_ref","set","_fetch","_ref2","headers","urlWithParams","URL","searchParams","requestOptions","toUpperCase","fetch","__reify_async_result__","_reifyError","self","async"],"sources":["packages/oauth/oauth_server.js"],"sourcesContent":["import bodyParser from 'body-parser';\n\nOAuth = {};\nOAuthTest = {};\n\nRoutePolicy.declare('/_oauth/', 'network');\n\nconst registeredServices = {};\n\n// Internal: Maps from service version to handler function. The\n// 'oauth1' and 'oauth2' packages manipulate this directly to register\n// for callbacks.\nOAuth._requestHandlers = {};\n\n\n/**\n/* Register a handler for an OAuth service. The handler will be called\n/* when we get an incoming http request on /_oauth/{serviceName}. This\n/* handler should use that information to fetch data about the user\n/* logging in.\n/*\n/* @param name {String} e.g. \"google\", \"facebook\"\n/* @param version {Number} OAuth version (1 or 2)\n/* @param urls   For OAuth1 only, specify the service's urls\n/* @param handleOauthRequest {Function(oauthBinding|query)}\n/*   - (For OAuth1 only) oauthBinding {OAuth1Binding} bound to the appropriate provider\n/*   - (For OAuth2 only) query {Object} parameters passed in query string\n/*   - return value is:\n/*     - {serviceData:, (optional options:)} where serviceData should end\n/*       up in the user's services[name] field\n/*     - `null` if the user declined to give permissions\n*/\nOAuth.registerService = (name, version, urls, handleOauthRequest) => {\n  if (registeredServices[name])\n    throw new Error(`Already registered the ${name} OAuth service`);\n\n  registeredServices[name] = {\n    serviceName: name,\n    version,\n    urls,\n    handleOauthRequest,\n  };\n};\n\n// For test cleanup.\nOAuthTest.unregisterService = name => {\n  delete registeredServices[name];\n};\n\n\nOAuth.retrieveCredential = (credentialToken, credentialSecret) =>\n  OAuth._retrievePendingCredential(credentialToken, credentialSecret);\n\n\n// The state parameter is normally generated on the client using\n// `btoa`, but for tests we need a version that runs on the server.\n//\nOAuth._generateState = (loginStyle, credentialToken, redirectUrl) => {\n  return Buffer.from(JSON.stringify({\n    loginStyle: loginStyle,\n    credentialToken: credentialToken,\n    redirectUrl: redirectUrl})).toString('base64');\n};\n\nOAuth._stateFromQuery = query => {\n  let string;\n  try {\n    string = Buffer.from(query.state, 'base64').toString('binary');\n  } catch (e) {\n    Log.warn(`Unable to base64 decode state from OAuth query: ${query.state}`);\n    throw e;\n  }\n\n  try {\n    return JSON.parse(string);\n  } catch (e) {\n    Log.warn(`Unable to parse state from OAuth query: ${string}`);\n    throw e;\n  }\n};\n\nOAuth._loginStyleFromQuery = query => {\n  let style;\n  // For backwards-compatibility for older clients, catch any errors\n  // that result from parsing the state parameter. If we can't parse it,\n  // set login style to popup by default.\n  try {\n    style = OAuth._stateFromQuery(query).loginStyle;\n  } catch (err) {\n    style = \"popup\";\n  }\n  if (style !== \"popup\" && style !== \"redirect\") {\n    throw new Error(`Unrecognized login style: ${style}`);\n  }\n  return style;\n};\n\nOAuth._credentialTokenFromQuery = query => {\n  let state;\n  // For backwards-compatibility for older clients, catch any errors\n  // that result from parsing the state parameter. If we can't parse it,\n  // assume that the state parameter's value is the credential token, as\n  // it used to be for older clients.\n  try {\n    state = OAuth._stateFromQuery(query);\n  } catch (err) {\n    return query.state;\n  }\n  return state.credentialToken;\n};\n\nOAuth._isCordovaFromQuery = query => {\n  try {\n    return !! OAuth._stateFromQuery(query).isCordova;\n  } catch (err) {\n    // For backwards-compatibility for older clients, catch any errors\n    // that result from parsing the state parameter. If we can't parse\n    // it, assume that we are not on Cordova, since older Meteor didn't\n    // do Cordova.\n    return false;\n  }\n};\n\n// Checks if the `redirectUrl` matches the app host.\n// We export this function so that developers can override this\n// behavior to allow apps from external domains to login using the\n// redirect OAuth flow.\nOAuth._checkRedirectUrlOrigin = redirectUrl => {\n  const appHost = Meteor.absoluteUrl();\n  const appHostReplacedLocalhost = Meteor.absoluteUrl(undefined, {\n    replaceLocalhost: true\n  });\n  return (\n    redirectUrl.substr(0, appHost.length) !== appHost &&\n    redirectUrl.substr(0, appHostReplacedLocalhost.length) !== appHostReplacedLocalhost\n  );\n};\n\nconst middleware = async (req, res, next) => {\n  let requestData;\n\n  // Make sure to catch any exceptions because otherwise we'd crash\n  // the runner\n  try {\n    const serviceName = oauthServiceName(req);\n    if (!serviceName) {\n      // not an oauth request. pass to next middleware.\n      next();\n      return;\n    }\n\n    const service = registeredServices[serviceName];\n\n    // Skip everything if there's no service set by the oauth middleware\n    if (!service)\n      throw new Error(`Unexpected OAuth service ${serviceName}`);\n\n    // Make sure we're configured\n    await ensureConfigured(serviceName);\n\n    const handler = OAuth._requestHandlers[service.version];\n    if (!handler)\n      throw new Error(`Unexpected OAuth version ${service.version}`);\n\n    if (req.method === 'GET') {\n      requestData = req.query;\n    } else {\n      requestData = req.body;\n    }\n    await handler(service, requestData, res);\n  } catch (err) {\n    // if we got thrown an error, save it off, it will get passed to\n    // the appropriate login call (if any) and reported there.\n    //\n    // The other option would be to display it in the popup tab that\n    // is still open at this point, ignoring the 'close' or 'redirect'\n    // we were passed. But then the developer wouldn't be able to\n    // style the error or react to it in any way.\n    if (requestData?.state && err instanceof Error) {\n      try { // catch any exceptions to avoid crashing runner\n        await OAuth._storePendingCredential(OAuth._credentialTokenFromQuery(requestData), err);\n      } catch (err) {\n        // Ignore the error and just give up. If we failed to store the\n        // error, then the login will just fail with a generic error.\n        Log.warn(\"Error in OAuth Server while storing pending login result.\\n\" +\n                 err.stack || err.message);\n      }\n    }\n\n    // close the popup. because nobody likes them just hanging\n    // there.  when someone sees this multiple times they might\n    // think to check server logs (we hope?)\n    // Catch errors because any exception here will crash the runner.\n    try {\n      await OAuth._endOfLoginResponse(res, {\n        query: requestData,\n        loginStyle: OAuth._loginStyleFromQuery(requestData),\n        error: err\n      });\n    } catch (err) {\n      Log.warn(\"Error generating end of login response\\n\" +\n               (err && (err.stack || err.message)));\n    }\n  }\n};\n\n// Listen to incoming OAuth http requests\nWebApp.handlers.use('/_oauth', bodyParser.json());\nWebApp.handlers.use('/_oauth', bodyParser.urlencoded({ extended: false }));\nWebApp.handlers.use(middleware);\n\nOAuthTest.middleware = middleware;\n\nOAuthTest.registeredServices = registeredServices;\n\n// Handle /_oauth/* paths and extract the service name.\n//\n// @returns {String|null} e.g. \"facebook\", or null if this isn't an\n// oauth request\nconst oauthServiceName = req => {\n  // req.url will be \"/_oauth/<service name>\" with an optional \"?close\".\n  const i = req.url.indexOf('?');\n  let barePath;\n  if (i === -1)\n    barePath = req.url;\n  else\n    barePath = req.url.substring(0, i);\n  const splitPath = barePath.split('/');\n\n  // Any non-oauth request will continue down the default\n  // middlewares.\n  if (splitPath[1] !== '_oauth')\n    return null;\n\n  // Find service based on url\n  const serviceName = splitPath[2];\n  return serviceName;\n};\n\n// Make sure we're configured\nconst ensureConfigured =\n  async serviceName => {\n    const config =\n      await ServiceConfiguration.configurations.findOneAsync({ service: serviceName });\n    if (!config) {\n      throw new ServiceConfiguration.ConfigError();\n    }\n  };\n\nconst isSafe = value => {\n  // This matches strings generated by `Random.secret` and\n  // `Random.id`.\n  return typeof value === \"string\" &&\n    /^[a-zA-Z0-9\\-_]+$/.test(value);\n};\n\n// Internal: used by the oauth1 and oauth2 packages\nOAuth._renderOauthResults = async (res, query, credentialSecret) => {\n  // For tests, we support the `only_credential_secret_for_test`\n  // parameter, which just returns the credential secret without any\n  // surrounding HTML. (The test needs to be able to easily grab the\n  // secret and use it to log in.)\n  //\n  // XXX only_credential_secret_for_test could be useful for other\n  // things beside tests, like command-line clients. We should give it a\n  // real name and serve the credential secret in JSON.\n\n  if (query.only_credential_secret_for_test) {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(credentialSecret, 'utf-8');\n  } else {\n    const details = {\n      query,\n      loginStyle: OAuth._loginStyleFromQuery(query)\n    };\n    if (query.error) {\n      details.error = query.error;\n    } else {\n      const token = OAuth._credentialTokenFromQuery(query);\n      const secret = credentialSecret;\n      if (token && secret &&\n          isSafe(token) && isSafe(secret)) {\n        details.credentials = { token: token, secret: secret};\n      } else {\n        details.error = \"invalid_credential_token_or_secret\";\n      }\n    }\n\n    await OAuth._endOfLoginResponse(res, details);\n  }\n};\n\nconst getAsset = (name) => {\n  return new Promise((resolve, reject) => Assets.getTextAsync(\n    `${name}.html`,\n    (err, data) => err ? reject(err) : resolve(data)))\n}\n// This \"template\" (not a real Spacebars template, just an HTML file\n// with some ##PLACEHOLDER##s) communicates the credential secret back\n// to the main window and then closes the popup.\nOAuth._endOfPopupResponseTemplate =\n  async () => await getAsset('end_of_popup_response')\n\nOAuth._endOfRedirectResponseTemplate =\n  async () => await getAsset('end_of_redirect_response')\n\n// Renders the end of login response template into some HTML and JavaScript\n// that closes the popup or redirects at the end of the OAuth flow.\n//\n// options are:\n//   - loginStyle (\"popup\" or \"redirect\")\n//   - setCredentialToken (boolean)\n//   - credentialToken\n//   - credentialSecret\n//   - redirectUrl\n//   - isCordova (boolean)\n//\nconst renderEndOfLoginResponse = async options => {\n  // It would be nice to use Blaze here, but it's a little tricky\n  // because our mustaches would be inside a <script> tag, and Blaze\n  // would treat the <script> tag contents as text (e.g. encode '&' as\n  // '&amp;'). So we just do a simple replace.\n\n  const escape = s => {\n    if (s) {\n      return s.replace(/&/g, \"&amp;\").\n        replace(/</g, \"&lt;\").\n        replace(/>/g, \"&gt;\").\n        replace(/\\\"/g, \"&quot;\").\n        replace(/\\'/g, \"&#x27;\").\n        replace(/\\//g, \"&#x2F;\");\n    } else {\n      return s;\n    }\n  };\n\n  // Escape everything just to be safe (we've already checked that some\n  // of this data -- the token and secret -- are safe).\n  const config = {\n    setCredentialToken: !! options.setCredentialToken,\n    credentialToken: escape(options.credentialToken),\n    credentialSecret: escape(options.credentialSecret),\n    storagePrefix: escape(OAuth._storageTokenPrefix),\n    redirectUrl: escape(options.redirectUrl),\n    isCordova: !! options.isCordova\n  };\n\n  let template;\n  if (options.loginStyle === 'popup') {\n    template = await OAuth._endOfPopupResponseTemplate();\n  } else if (options.loginStyle === 'redirect') {\n    template = await OAuth._endOfRedirectResponseTemplate();\n  } else {\n    throw new Error(`invalid loginStyle: ${options.loginStyle}`);\n  }\n  const result = template.replace(/##CONFIG##/, JSON.stringify(config))\n    .replace(\n      /##ROOT_URL_PATH_PREFIX##/, __meteor_runtime_config__.ROOT_URL_PATH_PREFIX\n    );\n\n  return `<!DOCTYPE html>\\n${result}`;\n};\n\n// Writes an HTTP response to the popup window at the end of an OAuth\n// login flow. At this point, if the user has successfully authenticated\n// to the OAuth server and authorized this app, we communicate the\n// credentialToken and credentialSecret to the main window. The main\n// window must provide both these values to the DDP `login` method to\n// authenticate its DDP connection. After communicating these values to\n// the main window, we close the popup.\n//\n// We export this function so that developers can override this\n// behavior, which is particularly useful in, for example, some mobile\n// environments where popups and/or `window.opener` don't work. For\n// example, an app could override `OAuth._endOfPopupResponse` to put the\n// credential token and credential secret in the popup URL for the main\n// window to read them there instead of using `window.opener`. If you\n// override this function, you take responsibility for writing to the\n// request and calling `res.end()` to complete the request.\n//\n// Arguments:\n//   - res: the HTTP response object\n//   - details:\n//      - query: the query string on the HTTP request\n//      - credentials: { token: *, secret: * }. If present, this field\n//        indicates that the login was successful. Return these values\n//        to the client, who can use them to log in over DDP. If\n//        present, the values have been checked against a limited\n//        character set and are safe to include in HTML.\n//      - error: if present, a string or Error indicating an error that\n//        occurred during the login. This can come from the client and\n//        so shouldn't be trusted for security decisions or included in\n//        the response without sanitizing it first. Only one of `error`\n//        or `credentials` should be set.\nOAuth._endOfLoginResponse = async (res, details) => {\n  res.writeHead(200, {'Content-Type': 'text/html'});\n\n  let redirectUrl;\n  if (details.loginStyle === 'redirect') {\n    redirectUrl = OAuth._stateFromQuery(details.query).redirectUrl;\n    const appHost = Meteor.absoluteUrl();\n    if (\n      !Meteor.settings?.packages?.oauth?.disableCheckRedirectUrlOrigin &&\n      OAuth._checkRedirectUrlOrigin(redirectUrl)) {\n      details.error = `redirectUrl (${redirectUrl}` +\n        `) is not on the same host as the app (${appHost})`;\n      redirectUrl = appHost;\n    }\n  }\n\n  const isCordova = OAuth._isCordovaFromQuery(details.query);\n\n  if (details.error) {\n    Log.warn(\"Error in OAuth Server: \" +\n             (details.error instanceof Error ?\n              details.error.message : details.error));\n    res.end(await renderEndOfLoginResponse({\n      loginStyle: details.loginStyle,\n      setCredentialToken: false,\n      redirectUrl,\n      isCordova,\n    }), \"utf-8\");\n    return;\n  }\n\n  // If we have a credentialSecret, report it back to the parent\n  // window, with the corresponding credentialToken. The parent window\n  // uses the credentialToken and credentialSecret to log in over DDP.\n  res.end(await renderEndOfLoginResponse({\n    loginStyle: details.loginStyle,\n    setCredentialToken: true,\n    credentialToken: details.credentials.token,\n    credentialSecret: details.credentials.secret,\n    redirectUrl,\n    isCordova,\n  }), \"utf-8\");\n};\n\n\nconst OAuthEncryption = Package[\"oauth-encryption\"] && Package[\"oauth-encryption\"].OAuthEncryption;\n\nconst usingOAuthEncryption = () =>\n  OAuthEncryption && OAuthEncryption.keyIsLoaded();\n\n// Encrypt sensitive service data such as access tokens if the\n// \"oauth-encryption\" package is loaded and the oauth secret key has\n// been specified.  Returns the unencrypted plaintext otherwise.\n//\n// The user id is not specified because the user isn't known yet at\n// this point in the oauth authentication process.  After the oauth\n// authentication process completes the encrypted service data fields\n// will be re-encrypted with the user id included before inserting the\n// service data into the user document.\n//\nOAuth.sealSecret = plaintext => {\n  if (usingOAuthEncryption())\n    return OAuthEncryption.seal(plaintext);\n  else\n    return plaintext;\n};\n\n// Unencrypt a service data field, if the \"oauth-encryption\"\n// package is loaded and the field is encrypted.\n//\n// Throws an error if the \"oauth-encryption\" package is loaded and the\n// field is encrypted, but the oauth secret key hasn't been specified.\n//\nOAuth.openSecret = (maybeSecret, userId) => {\n  if (!Package[\"oauth-encryption\"] || !OAuthEncryption.isSealed(maybeSecret))\n    return maybeSecret;\n\n  return OAuthEncryption.open(maybeSecret, userId);\n};\n\n// Unencrypt fields in the service data object.\n//\nOAuth.openSecrets = (serviceData, userId) => {\n  const result = {};\n  Object.keys(serviceData).forEach(key =>\n    result[key] = OAuth.openSecret(serviceData[key], userId)\n  );\n  return result;\n};\n\nOAuth._addValuesToQueryParams = (\n  values = {},\n  queryParams = new URLSearchParams()\n) => {\n  Object.entries(values).forEach(([key, value]) => {\n    queryParams.set(key, `${value}`);\n  });\n  return queryParams;\n};\n\nOAuth._fetch = async (\n  url,\n  method = 'GET',\n  { headers = {}, queryParams = {}, body, ...options } = {}\n) => {\n  const urlWithParams = new URL(url);\n\n  OAuth._addValuesToQueryParams(queryParams, urlWithParams.searchParams);\n\n  const requestOptions = {\n    method: method.toUpperCase(),\n    headers,\n    ...(body ? { body } : {}),\n    ...options,\n  };\n  return fetch(urlWithParams.toString(), requestOptions);\n};\n"],"mappings":";;;IAAA,IAAIA,aAAa;IAACC,MAAM,CAACC,IAAI,CAAC,sCAAsC,EAAC;MAACC,OAAOA,CAACC,CAAC,EAAC;QAACJ,aAAa,GAACI,CAAC;MAAA;IAAC,CAAC,EAAC,CAAC,CAAC;IAAC,IAAIC,wBAAwB;IAACJ,MAAM,CAACC,IAAI,CAAC,gDAAgD,EAAC;MAACC,OAAOA,CAACC,CAAC,EAAC;QAACC,wBAAwB,GAACD,CAAC;MAAA;IAAC,CAAC,EAAC,CAAC,CAAC;IAAC,MAAAE,SAAA;IAA5O,IAAIC,UAAU;IAACN,MAAM,CAACC,IAAI,CAAC,aAAa,EAAC;MAACC,OAAOA,CAACC,CAAC,EAAC;QAACG,UAAU,GAACH,CAAC;MAAA;IAAC,CAAC,EAAC,CAAC,CAAC;IAAC,IAAII,oBAAoB,CAAC,CAAC,EAAE,CAAC,MAAMA,oBAAoB,CAAC,CAAC,EAAE,CAAC;IAEnIC,KAAK,GAAG,CAAC,CAAC;IACVC,SAAS,GAAG,CAAC,CAAC;IAEdC,WAAW,CAACC,OAAO,CAAC,UAAU,EAAE,SAAS,CAAC;IAE1C,MAAMC,kBAAkB,GAAG,CAAC,CAAC;;IAE7B;IACA;IACA;IACAJ,KAAK,CAACK,gBAAgB,GAAG,CAAC,CAAC;;IAG3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACAL,KAAK,CAACM,eAAe,GAAG,CAACC,IAAI,EAAEC,OAAO,EAAEC,IAAI,EAAEC,kBAAkB,KAAK;MACnE,IAAIN,kBAAkB,CAACG,IAAI,CAAC,EAC1B,MAAM,IAAII,KAAK,2BAAAC,MAAA,CAA2BL,IAAI,mBAAgB,CAAC;MAEjEH,kBAAkB,CAACG,IAAI,CAAC,GAAG;QACzBM,WAAW,EAAEN,IAAI;QACjBC,OAAO;QACPC,IAAI;QACJC;MACF,CAAC;IACH,CAAC;;IAED;IACAT,SAAS,CAACa,iBAAiB,GAAGP,IAAI,IAAI;MACpC,OAAOH,kBAAkB,CAACG,IAAI,CAAC;IACjC,CAAC;IAGDP,KAAK,CAACe,kBAAkB,GAAG,CAACC,eAAe,EAAEC,gBAAgB,KAC3DjB,KAAK,CAACkB,0BAA0B,CAACF,eAAe,EAAEC,gBAAgB,CAAC;;IAGrE;IACA;IACA;IACAjB,KAAK,CAACmB,cAAc,GAAG,CAACC,UAAU,EAAEJ,eAAe,EAAEK,WAAW,KAAK;MACnE,OAAOC,MAAM,CAACC,IAAI,CAACC,IAAI,CAACC,SAAS,CAAC;QAChCL,UAAU,EAAEA,UAAU;QACtBJ,eAAe,EAAEA,eAAe;QAChCK,WAAW,EAAEA;MAAW,CAAC,CAAC,CAAC,CAACK,QAAQ,CAAC,QAAQ,CAAC;IAClD,CAAC;IAED1B,KAAK,CAAC2B,eAAe,GAAGC,KAAK,IAAI;MAC/B,IAAIC,MAAM;MACV,IAAI;QACFA,MAAM,GAAGP,MAAM,CAACC,IAAI,CAACK,KAAK,CAACE,KAAK,EAAE,QAAQ,CAAC,CAACJ,QAAQ,CAAC,QAAQ,CAAC;MAChE,CAAC,CAAC,OAAOK,CAAC,EAAE;QACVC,GAAG,CAACC,IAAI,oDAAArB,MAAA,CAAoDgB,KAAK,CAACE,KAAK,CAAE,CAAC;QAC1E,MAAMC,CAAC;MACT;MAEA,IAAI;QACF,OAAOP,IAAI,CAACU,KAAK,CAACL,MAAM,CAAC;MAC3B,CAAC,CAAC,OAAOE,CAAC,EAAE;QACVC,GAAG,CAACC,IAAI,4CAAArB,MAAA,CAA4CiB,MAAM,CAAE,CAAC;QAC7D,MAAME,CAAC;MACT;IACF,CAAC;IAED/B,KAAK,CAACmC,oBAAoB,GAAGP,KAAK,IAAI;MACpC,IAAIQ,KAAK;MACT;MACA;MACA;MACA,IAAI;QACFA,KAAK,GAAGpC,KAAK,CAAC2B,eAAe,CAACC,KAAK,CAAC,CAACR,UAAU;MACjD,CAAC,CAAC,OAAOiB,GAAG,EAAE;QACZD,KAAK,GAAG,OAAO;MACjB;MACA,IAAIA,KAAK,KAAK,OAAO,IAAIA,KAAK,KAAK,UAAU,EAAE;QAC7C,MAAM,IAAIzB,KAAK,8BAAAC,MAAA,CAA8BwB,KAAK,CAAE,CAAC;MACvD;MACA,OAAOA,KAAK;IACd,CAAC;IAEDpC,KAAK,CAACsC,yBAAyB,GAAGV,KAAK,IAAI;MACzC,IAAIE,KAAK;MACT;MACA;MACA;MACA;MACA,IAAI;QACFA,KAAK,GAAG9B,KAAK,CAAC2B,eAAe,CAACC,KAAK,CAAC;MACtC,CAAC,CAAC,OAAOS,GAAG,EAAE;QACZ,OAAOT,KAAK,CAACE,KAAK;MACpB;MACA,OAAOA,KAAK,CAACd,eAAe;IAC9B,CAAC;IAEDhB,KAAK,CAACuC,mBAAmB,GAAGX,KAAK,IAAI;MACnC,IAAI;QACF,OAAO,CAAC,CAAE5B,KAAK,CAAC2B,eAAe,CAACC,KAAK,CAAC,CAACY,SAAS;MAClD,CAAC,CAAC,OAAOH,GAAG,EAAE;QACZ;QACA;QACA;QACA;QACA,OAAO,KAAK;MACd;IACF,CAAC;;IAED;IACA;IACA;IACA;IACArC,KAAK,CAACyC,uBAAuB,GAAGpB,WAAW,IAAI;MAC7C,MAAMqB,OAAO,GAAGC,MAAM,CAACC,WAAW,CAAC,CAAC;MACpC,MAAMC,wBAAwB,GAAGF,MAAM,CAACC,WAAW,CAACE,SAAS,EAAE;QAC7DC,gBAAgB,EAAE;MACpB,CAAC,CAAC;MACF,OACE1B,WAAW,CAAC2B,MAAM,CAAC,CAAC,EAAEN,OAAO,CAACO,MAAM,CAAC,KAAKP,OAAO,IACjDrB,WAAW,CAAC2B,MAAM,CAAC,CAAC,EAAEH,wBAAwB,CAACI,MAAM,CAAC,KAAKJ,wBAAwB;IAEvF,CAAC;IAED,MAAMK,UAAU,GAAG,MAAAA,CAAOC,GAAG,EAAEC,GAAG,EAAEC,IAAI,KAAK;MAC3C,IAAIC,WAAW;;MAEf;MACA;MACA,IAAI;QACF,MAAMzC,WAAW,GAAG0C,gBAAgB,CAACJ,GAAG,CAAC;QACzC,IAAI,CAACtC,WAAW,EAAE;UAChB;UACAwC,IAAI,CAAC,CAAC;UACN;QACF;QAEA,MAAMG,OAAO,GAAGpD,kBAAkB,CAACS,WAAW,CAAC;;QAE/C;QACA,IAAI,CAAC2C,OAAO,EACV,MAAM,IAAI7C,KAAK,6BAAAC,MAAA,CAA6BC,WAAW,CAAE,CAAC;;QAE5D;QACA,MAAM4C,gBAAgB,CAAC5C,WAAW,CAAC;QAEnC,MAAM6C,OAAO,GAAG1D,KAAK,CAACK,gBAAgB,CAACmD,OAAO,CAAChD,OAAO,CAAC;QACvD,IAAI,CAACkD,OAAO,EACV,MAAM,IAAI/C,KAAK,6BAAAC,MAAA,CAA6B4C,OAAO,CAAChD,OAAO,CAAE,CAAC;QAEhE,IAAI2C,GAAG,CAACQ,MAAM,KAAK,KAAK,EAAE;UACxBL,WAAW,GAAGH,GAAG,CAACvB,KAAK;QACzB,CAAC,MAAM;UACL0B,WAAW,GAAGH,GAAG,CAACS,IAAI;QACxB;QACA,MAAMF,OAAO,CAACF,OAAO,EAAEF,WAAW,EAAEF,GAAG,CAAC;MAC1C,CAAC,CAAC,OAAOf,GAAG,EAAE;QAAA,IAAAwB,YAAA;QACZ;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAI,CAAAA,YAAA,GAAAP,WAAW,cAAAO,YAAA,eAAXA,YAAA,CAAa/B,KAAK,IAAIO,GAAG,YAAY1B,KAAK,EAAE;UAC9C,IAAI;YAAE;YACJ,MAAMX,KAAK,CAAC8D,uBAAuB,CAAC9D,KAAK,CAACsC,yBAAyB,CAACgB,WAAW,CAAC,EAAEjB,GAAG,CAAC;UACxF,CAAC,CAAC,OAAOA,GAAG,EAAE;YACZ;YACA;YACAL,GAAG,CAACC,IAAI,CAAC,6DAA6D,GAC7DI,GAAG,CAAC0B,KAAK,IAAI1B,GAAG,CAAC2B,OAAO,CAAC;UACpC;QACF;;QAEA;QACA;QACA;QACA;QACA,IAAI;UACF,MAAMhE,KAAK,CAACiE,mBAAmB,CAACb,GAAG,EAAE;YACnCxB,KAAK,EAAE0B,WAAW;YAClBlC,UAAU,EAAEpB,KAAK,CAACmC,oBAAoB,CAACmB,WAAW,CAAC;YACnDY,KAAK,EAAE7B;UACT,CAAC,CAAC;QACJ,CAAC,CAAC,OAAOA,GAAG,EAAE;UACZL,GAAG,CAACC,IAAI,CAAC,0CAA0C,IACzCI,GAAG,KAAKA,GAAG,CAAC0B,KAAK,IAAI1B,GAAG,CAAC2B,OAAO,CAAC,CAAC,CAAC;QAC/C;MACF;IACF,CAAC;;IAED;IACAG,MAAM,CAACC,QAAQ,CAACC,GAAG,CAAC,SAAS,EAAEvE,UAAU,CAACwE,IAAI,CAAC,CAAC,CAAC;IACjDH,MAAM,CAACC,QAAQ,CAACC,GAAG,CAAC,SAAS,EAAEvE,UAAU,CAACyE,UAAU,CAAC;MAAEC,QAAQ,EAAE;IAAM,CAAC,CAAC,CAAC;IAC1EL,MAAM,CAACC,QAAQ,CAACC,GAAG,CAACnB,UAAU,CAAC;IAE/BjD,SAAS,CAACiD,UAAU,GAAGA,UAAU;IAEjCjD,SAAS,CAACG,kBAAkB,GAAGA,kBAAkB;;IAEjD;IACA;IACA;IACA;IACA,MAAMmD,gBAAgB,GAAGJ,GAAG,IAAI;MAC9B;MACA,MAAMsB,CAAC,GAAGtB,GAAG,CAACuB,GAAG,CAACC,OAAO,CAAC,GAAG,CAAC;MAC9B,IAAIC,QAAQ;MACZ,IAAIH,CAAC,KAAK,CAAC,CAAC,EACVG,QAAQ,GAAGzB,GAAG,CAACuB,GAAG,CAAC,KAEnBE,QAAQ,GAAGzB,GAAG,CAACuB,GAAG,CAACG,SAAS,CAAC,CAAC,EAAEJ,CAAC,CAAC;MACpC,MAAMK,SAAS,GAAGF,QAAQ,CAACG,KAAK,CAAC,GAAG,CAAC;;MAErC;MACA;MACA,IAAID,SAAS,CAAC,CAAC,CAAC,KAAK,QAAQ,EAC3B,OAAO,IAAI;;MAEb;MACA,MAAMjE,WAAW,GAAGiE,SAAS,CAAC,CAAC,CAAC;MAChC,OAAOjE,WAAW;IACpB,CAAC;;IAED;IACA,MAAM4C,gBAAgB,GACpB,MAAM5C,WAAW,IAAI;MACnB,MAAMmE,MAAM,GACV,MAAMC,oBAAoB,CAACC,cAAc,CAACC,YAAY,CAAC;QAAE3B,OAAO,EAAE3C;MAAY,CAAC,CAAC;MAClF,IAAI,CAACmE,MAAM,EAAE;QACX,MAAM,IAAIC,oBAAoB,CAACG,WAAW,CAAC,CAAC;MAC9C;IACF,CAAC;IAEH,MAAMC,MAAM,GAAGC,KAAK,IAAI;MACtB;MACA;MACA,OAAO,OAAOA,KAAK,KAAK,QAAQ,IAC9B,mBAAmB,CAACC,IAAI,CAACD,KAAK,CAAC;IACnC,CAAC;;IAED;IACAtF,KAAK,CAACwF,mBAAmB,GAAG,OAAOpC,GAAG,EAAExB,KAAK,EAAEX,gBAAgB,KAAK;MAClE;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MAEA,IAAIW,KAAK,CAAC6D,+BAA+B,EAAE;QACzCrC,GAAG,CAACsC,SAAS,CAAC,GAAG,EAAE;UAAC,cAAc,EAAE;QAAW,CAAC,CAAC;QACjDtC,GAAG,CAACuC,GAAG,CAAC1E,gBAAgB,EAAE,OAAO,CAAC;MACpC,CAAC,MAAM;QACL,MAAM2E,OAAO,GAAG;UACdhE,KAAK;UACLR,UAAU,EAAEpB,KAAK,CAACmC,oBAAoB,CAACP,KAAK;QAC9C,CAAC;QACD,IAAIA,KAAK,CAACsC,KAAK,EAAE;UACf0B,OAAO,CAAC1B,KAAK,GAAGtC,KAAK,CAACsC,KAAK;QAC7B,CAAC,MAAM;UACL,MAAM2B,KAAK,GAAG7F,KAAK,CAACsC,yBAAyB,CAACV,KAAK,CAAC;UACpD,MAAMkE,MAAM,GAAG7E,gBAAgB;UAC/B,IAAI4E,KAAK,IAAIC,MAAM,IACfT,MAAM,CAACQ,KAAK,CAAC,IAAIR,MAAM,CAACS,MAAM,CAAC,EAAE;YACnCF,OAAO,CAACG,WAAW,GAAG;cAAEF,KAAK,EAAEA,KAAK;cAAEC,MAAM,EAAEA;YAAM,CAAC;UACvD,CAAC,MAAM;YACLF,OAAO,CAAC1B,KAAK,GAAG,oCAAoC;UACtD;QACF;QAEA,MAAMlE,KAAK,CAACiE,mBAAmB,CAACb,GAAG,EAAEwC,OAAO,CAAC;MAC/C;IACF,CAAC;IAED,MAAMI,QAAQ,GAAIzF,IAAI,IAAK;MACzB,OAAO,IAAI0F,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAKC,MAAM,CAACC,YAAY,IAAAzF,MAAA,CACtDL,IAAI,YACP,CAAC8B,GAAG,EAAEiE,IAAI,KAAKjE,GAAG,GAAG8D,MAAM,CAAC9D,GAAG,CAAC,GAAG6D,OAAO,CAACI,IAAI,CAAC,CAAC,CAAC;IACtD,CAAC;IACD;IACA;IACA;IACAtG,KAAK,CAACuG,2BAA2B,GAC/B,YAAY,MAAMP,QAAQ,CAAC,uBAAuB,CAAC;IAErDhG,KAAK,CAACwG,8BAA8B,GAClC,YAAY,MAAMR,QAAQ,CAAC,0BAA0B,CAAC;;IAExD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMS,wBAAwB,GAAG,MAAMC,OAAO,IAAI;MAChD;MACA;MACA;MACA;;MAEA,MAAMC,MAAM,GAAGC,CAAC,IAAI;QAClB,IAAIA,CAAC,EAAE;UACL,OAAOA,CAAC,CAACC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAC7BA,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CACrBA,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CACrBA,OAAO,CAAC,KAAK,EAAE,QAAQ,CAAC,CACxBA,OAAO,CAAC,KAAK,EAAE,QAAQ,CAAC,CACxBA,OAAO,CAAC,KAAK,EAAE,QAAQ,CAAC;QAC5B,CAAC,MAAM;UACL,OAAOD,CAAC;QACV;MACF,CAAC;;MAED;MACA;MACA,MAAM5B,MAAM,GAAG;QACb8B,kBAAkB,EAAE,CAAC,CAAEJ,OAAO,CAACI,kBAAkB;QACjD9F,eAAe,EAAE2F,MAAM,CAACD,OAAO,CAAC1F,eAAe,CAAC;QAChDC,gBAAgB,EAAE0F,MAAM,CAACD,OAAO,CAACzF,gBAAgB,CAAC;QAClD8F,aAAa,EAAEJ,MAAM,CAAC3G,KAAK,CAACgH,mBAAmB,CAAC;QAChD3F,WAAW,EAAEsF,MAAM,CAACD,OAAO,CAACrF,WAAW,CAAC;QACxCmB,SAAS,EAAE,CAAC,CAAEkE,OAAO,CAAClE;MACxB,CAAC;MAED,IAAIyE,QAAQ;MACZ,IAAIP,OAAO,CAACtF,UAAU,KAAK,OAAO,EAAE;QAClC6F,QAAQ,GAAG,MAAMjH,KAAK,CAACuG,2BAA2B,CAAC,CAAC;MACtD,CAAC,MAAM,IAAIG,OAAO,CAACtF,UAAU,KAAK,UAAU,EAAE;QAC5C6F,QAAQ,GAAG,MAAMjH,KAAK,CAACwG,8BAA8B,CAAC,CAAC;MACzD,CAAC,MAAM;QACL,MAAM,IAAI7F,KAAK,wBAAAC,MAAA,CAAwB8F,OAAO,CAACtF,UAAU,CAAE,CAAC;MAC9D;MACA,MAAM8F,MAAM,GAAGD,QAAQ,CAACJ,OAAO,CAAC,YAAY,EAAErF,IAAI,CAACC,SAAS,CAACuD,MAAM,CAAC,CAAC,CAClE6B,OAAO,CACN,0BAA0B,EAAEM,yBAAyB,CAACC,oBACxD,CAAC;MAEH,2BAAAxG,MAAA,CAA2BsG,MAAM;IACnC,CAAC;;IAED;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAlH,KAAK,CAACiE,mBAAmB,GAAG,OAAOb,GAAG,EAAEwC,OAAO,KAAK;MAClDxC,GAAG,CAACsC,SAAS,CAAC,GAAG,EAAE;QAAC,cAAc,EAAE;MAAW,CAAC,CAAC;MAEjD,IAAIrE,WAAW;MACf,IAAIuE,OAAO,CAACxE,UAAU,KAAK,UAAU,EAAE;QAAA,IAAAiG,gBAAA,EAAAC,qBAAA,EAAAC,sBAAA;QACrClG,WAAW,GAAGrB,KAAK,CAAC2B,eAAe,CAACiE,OAAO,CAAChE,KAAK,CAAC,CAACP,WAAW;QAC9D,MAAMqB,OAAO,GAAGC,MAAM,CAACC,WAAW,CAAC,CAAC;QACpC,IACE,GAAAyE,gBAAA,GAAC1E,MAAM,CAAC6E,QAAQ,cAAAH,gBAAA,gBAAAC,qBAAA,GAAfD,gBAAA,CAAiBI,QAAQ,cAAAH,qBAAA,gBAAAC,sBAAA,GAAzBD,qBAAA,CAA2BI,KAAK,cAAAH,sBAAA,eAAhCA,sBAAA,CAAkCI,6BAA6B,KAChE3H,KAAK,CAACyC,uBAAuB,CAACpB,WAAW,CAAC,EAAE;UAC5CuE,OAAO,CAAC1B,KAAK,GAAG,gBAAAtD,MAAA,CAAgBS,WAAW,6CAAAT,MAAA,CACA8B,OAAO,MAAG;UACrDrB,WAAW,GAAGqB,OAAO;QACvB;MACF;MAEA,MAAMF,SAAS,GAAGxC,KAAK,CAACuC,mBAAmB,CAACqD,OAAO,CAAChE,KAAK,CAAC;MAE1D,IAAIgE,OAAO,CAAC1B,KAAK,EAAE;QACjBlC,GAAG,CAACC,IAAI,CAAC,yBAAyB,IACxB2D,OAAO,CAAC1B,KAAK,YAAYvD,KAAK,GAC9BiF,OAAO,CAAC1B,KAAK,CAACF,OAAO,GAAG4B,OAAO,CAAC1B,KAAK,CAAC,CAAC;QACjDd,GAAG,CAACuC,GAAG,CAAC,MAAMc,wBAAwB,CAAC;UACrCrF,UAAU,EAAEwE,OAAO,CAACxE,UAAU;UAC9B0F,kBAAkB,EAAE,KAAK;UACzBzF,WAAW;UACXmB;QACF,CAAC,CAAC,EAAE,OAAO,CAAC;QACZ;MACF;;MAEA;MACA;MACA;MACAY,GAAG,CAACuC,GAAG,CAAC,MAAMc,wBAAwB,CAAC;QACrCrF,UAAU,EAAEwE,OAAO,CAACxE,UAAU;QAC9B0F,kBAAkB,EAAE,IAAI;QACxB9F,eAAe,EAAE4E,OAAO,CAACG,WAAW,CAACF,KAAK;QAC1C5E,gBAAgB,EAAE2E,OAAO,CAACG,WAAW,CAACD,MAAM;QAC5CzE,WAAW;QACXmB;MACF,CAAC,CAAC,EAAE,OAAO,CAAC;IACd,CAAC;IAGD,MAAMoF,eAAe,GAAGC,OAAO,CAAC,kBAAkB,CAAC,IAAIA,OAAO,CAAC,kBAAkB,CAAC,CAACD,eAAe;IAElG,MAAME,oBAAoB,GAAGA,CAAA,KAC3BF,eAAe,IAAIA,eAAe,CAACG,WAAW,CAAC,CAAC;;IAElD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA/H,KAAK,CAACgI,UAAU,GAAGC,SAAS,IAAI;MAC9B,IAAIH,oBAAoB,CAAC,CAAC,EACxB,OAAOF,eAAe,CAACM,IAAI,CAACD,SAAS,CAAC,CAAC,KAEvC,OAAOA,SAAS;IACpB,CAAC;;IAED;IACA;IACA;IACA;IACA;IACA;IACAjI,KAAK,CAACmI,UAAU,GAAG,CAACC,WAAW,EAAEC,MAAM,KAAK;MAC1C,IAAI,CAACR,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAACD,eAAe,CAACU,QAAQ,CAACF,WAAW,CAAC,EACxE,OAAOA,WAAW;MAEpB,OAAOR,eAAe,CAACW,IAAI,CAACH,WAAW,EAAEC,MAAM,CAAC;IAClD,CAAC;;IAED;IACA;IACArI,KAAK,CAACwI,WAAW,GAAG,CAACC,WAAW,EAAEJ,MAAM,KAAK;MAC3C,MAAMnB,MAAM,GAAG,CAAC,CAAC;MACjBwB,MAAM,CAACC,IAAI,CAACF,WAAW,CAAC,CAACG,OAAO,CAACC,GAAG,IAClC3B,MAAM,CAAC2B,GAAG,CAAC,GAAG7I,KAAK,CAACmI,UAAU,CAACM,WAAW,CAACI,GAAG,CAAC,EAAER,MAAM,CACzD,CAAC;MACD,OAAOnB,MAAM;IACf,CAAC;IAEDlH,KAAK,CAAC8I,uBAAuB,GAAG,YAG3B;MAAA,IAFHC,MAAM,GAAAC,SAAA,CAAA/F,MAAA,QAAA+F,SAAA,QAAAlG,SAAA,GAAAkG,SAAA,MAAG,CAAC,CAAC;MAAA,IACXC,WAAW,GAAAD,SAAA,CAAA/F,MAAA,QAAA+F,SAAA,QAAAlG,SAAA,GAAAkG,SAAA,MAAG,IAAIE,eAAe,CAAC,CAAC;MAEnCR,MAAM,CAACS,OAAO,CAACJ,MAAM,CAAC,CAACH,OAAO,CAACQ,IAAA,IAAkB;QAAA,IAAjB,CAACP,GAAG,EAAEvD,KAAK,CAAC,GAAA8D,IAAA;QAC1CH,WAAW,CAACI,GAAG,CAACR,GAAG,KAAAjI,MAAA,CAAK0E,KAAK,CAAE,CAAC;MAClC,CAAC,CAAC;MACF,OAAO2D,WAAW;IACpB,CAAC;IAEDjJ,KAAK,CAACsJ,MAAM,GAAG,gBACb5E,GAAG,EAGA;MAAA,IAFHf,MAAM,GAAAqF,SAAA,CAAA/F,MAAA,QAAA+F,SAAA,QAAAlG,SAAA,GAAAkG,SAAA,MAAG,KAAK;MAAA,IAAAO,KAAA,GAAAP,SAAA,CAAA/F,MAAA,QAAA+F,SAAA,QAAAlG,SAAA,GAAAkG,SAAA,MACyC,CAAC,CAAC;MAAA,IAAzD;UAAEQ,OAAO,GAAG,CAAC,CAAC;UAAEP,WAAW,GAAG,CAAC,CAAC;UAAErF;QAAiB,CAAC,GAAA2F,KAAA;QAAT7C,OAAO,GAAA9G,wBAAA,CAAA2J,KAAA,EAAA1J,SAAA;MAElD,MAAM4J,aAAa,GAAG,IAAIC,GAAG,CAAChF,GAAG,CAAC;MAElC1E,KAAK,CAAC8I,uBAAuB,CAACG,WAAW,EAAEQ,aAAa,CAACE,YAAY,CAAC;MAEtE,MAAMC,cAAc,GAAArK,aAAA,CAAAA,aAAA;QAClBoE,MAAM,EAAEA,MAAM,CAACkG,WAAW,CAAC,CAAC;QAC5BL;MAAO,GACH5F,IAAI,GAAG;QAAEA;MAAK,CAAC,GAAG,CAAC,CAAC,GACrB8C,OAAO,CACX;MACD,OAAOoD,KAAK,CAACL,aAAa,CAAC/H,QAAQ,CAAC,CAAC,EAAEkI,cAAc,CAAC;IACxD,CAAC;IAACG,sBAAA;EAAA,SAAAC,WAAA;IAAA,OAAAD,sBAAA,CAAAC,WAAA;EAAA;EAAAD,sBAAA;AAAA;EAAAE,IAAA;EAAAC,KAAA;AAAA","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"6191471a12e50938cf4cdda1847822a7218c8173"}
