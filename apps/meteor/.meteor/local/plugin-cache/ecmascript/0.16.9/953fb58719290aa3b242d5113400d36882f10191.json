{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/oauth/oauth_client.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/oauth/oauth_client.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/oauth/oauth_client.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/packages/oauth/oauth_client.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/oauth/oauth_client.js"}},"code":"// credentialToken -> credentialSecret. You must provide both the\n// credentialToken and the credentialSecret to retrieve an access token from\n// the _pendingCredentials collection.\nconst credentialSecrets = {};\nOAuth = {};\nOAuth.showPopup = (url, callback, dimensions) => {\n  throw new Error(\"OAuth.showPopup must be implemented on this arch.\");\n};\n\n// Determine the login style (popup or redirect) for this login flow.\n//\n//\nOAuth._loginStyle = (service, config, options) => {\n  if (Meteor.isCordova) {\n    return \"popup\";\n  }\n  let loginStyle = options && options.loginStyle || config.loginStyle || 'popup';\n  if (![\"popup\", \"redirect\"].includes(loginStyle)) throw new Error(\"Invalid login style: \".concat(loginStyle));\n\n  // If we don't have session storage (for example, Safari in private\n  // mode), the redirect login flow won't work, so fallback to the\n  // popup style.\n  if (loginStyle === 'redirect') {\n    try {\n      sessionStorage.setItem('Meteor.oauth.test', 'test');\n      sessionStorage.removeItem('Meteor.oauth.test');\n    } catch (e) {\n      loginStyle = 'popup';\n    }\n  }\n  return loginStyle;\n};\nOAuth._stateParam = (loginStyle, credentialToken, redirectUrl) => {\n  var _Meteor$settings, _Meteor$settings$publ, _Meteor$settings$publ2, _Meteor$settings$publ3;\n  const state = {\n    loginStyle,\n    credentialToken,\n    isCordova: Meteor.isCordova\n  };\n  if (loginStyle === 'redirect' || (_Meteor$settings = Meteor.settings) !== null && _Meteor$settings !== void 0 && (_Meteor$settings$publ = _Meteor$settings.public) !== null && _Meteor$settings$publ !== void 0 && (_Meteor$settings$publ2 = _Meteor$settings$publ.packages) !== null && _Meteor$settings$publ2 !== void 0 && (_Meteor$settings$publ3 = _Meteor$settings$publ2.oauth) !== null && _Meteor$settings$publ3 !== void 0 && _Meteor$settings$publ3.setRedirectUrlWhenLoginStyleIsPopup && loginStyle === 'popup') {\n    state.redirectUrl = redirectUrl || '' + window.location;\n  }\n\n  // Encode base64 as not all login services URI-encode the state\n  // parameter when they pass it back to us.\n  // Use the 'base64' package here because 'btoa' isn't supported in IE8/9.\n  return Base64.encode(JSON.stringify(state));\n};\n\n// At the beginning of the redirect login flow, before we redirect to\n// the login service, save the credential token for this login attempt\n// in the reload migration data.\n//\nOAuth.saveDataForRedirect = (loginService, credentialToken) => {\n  Reload._onMigrate('oauth', () => [true, {\n    loginService,\n    credentialToken\n  }]);\n  Reload._migrate(null, {\n    immediateMigration: true\n  });\n};\n\n// At the end of the redirect login flow, when we've redirected back\n// to the application, retrieve the credentialToken and (if the login\n// was successful) the credentialSecret.\n//\n// Called at application startup.  Returns null if this is normal\n// application startup and we weren't just redirected at the end of\n// the login flow.\n//\nOAuth.getDataAfterRedirect = () => {\n  const migrationData = Reload._migrationData('oauth');\n  if (!(migrationData && migrationData.credentialToken)) return null;\n  const {\n    credentialToken\n  } = migrationData;\n  const key = OAuth._storageTokenPrefix + credentialToken;\n  let credentialSecret;\n  try {\n    credentialSecret = sessionStorage.getItem(key);\n    sessionStorage.removeItem(key);\n  } catch (e) {\n    Meteor._debug('error retrieving credentialSecret', e);\n  }\n  return {\n    loginService: migrationData.loginService,\n    credentialToken,\n    credentialSecret\n  };\n};\n\n/**\n * Launch an OAuth login flow.  For the popup login style, show the\n * popup.  For the redirect login style, save the credential token for\n * this login attempt in the reload migration data, and redirect to\n * the service for the login.\n *\n * @param {Object} options\n * @param {string} options.loginService \"facebook\", \"google\", etc.\n * @param {string} options.loginStyle \"popup\" or \"redirect\"\n * @param {string} options.loginUrl The URL at the login service provider to start the OAuth flow.\n *  credentialRequestCompleteCallback: for the popup flow, call when the popup\n *    is closed and we have the credential from the login service.\n * @param {string} options.credentialToken our identifier for this login flow.\n **/\nOAuth.launchLogin = options => {\n  if (!options.loginService) throw new Error('loginService required');\n  if (options.loginStyle === 'popup') {\n    OAuth.showPopup(options.loginUrl, options.credentialRequestCompleteCallback.bind(null, options.credentialToken), options.popupOptions);\n  } else if (options.loginStyle === 'redirect') {\n    OAuth.saveDataForRedirect(options.loginService, options.credentialToken);\n    window.location = options.loginUrl;\n  } else {\n    throw new Error('invalid login style');\n  }\n};\n\n// Called by the popup when the OAuth flow is completed, right before\n// the popup closes.\nOAuth._handleCredentialSecret = (credentialToken, secret) => {\n  check(credentialToken, String);\n  check(secret, String);\n  if (!Object.prototype.hasOwnProperty.call(credentialSecrets, credentialToken)) {\n    credentialSecrets[credentialToken] = secret;\n  } else {\n    throw new Error(\"Duplicate credential token from OAuth login\");\n  }\n};\n\n// Used by accounts-oauth, which needs both a credentialToken and the\n// corresponding to credential secret to call the `login` method over DDP.\nOAuth._retrieveCredentialSecret = credentialToken => {\n  // First check the secrets collected by OAuth._handleCredentialSecret,\n  // then check localStorage. This matches what we do in\n  // end_of_login_response.html.\n  let secret = credentialSecrets[credentialToken];\n  if (!secret) {\n    const localStorageKey = OAuth._storageTokenPrefix + credentialToken;\n    secret = Meteor._localStorage.getItem(localStorageKey);\n    Meteor._localStorage.removeItem(localStorageKey);\n  } else {\n    delete credentialSecrets[credentialToken];\n  }\n  return secret;\n};","map":{"version":3,"names":["credentialSecrets","OAuth","showPopup","url","callback","dimensions","Error","_loginStyle","service","config","options","Meteor","isCordova","loginStyle","includes","concat","sessionStorage","setItem","removeItem","e","_stateParam","credentialToken","redirectUrl","_Meteor$settings","_Meteor$settings$publ","_Meteor$settings$publ2","_Meteor$settings$publ3","state","settings","public","packages","oauth","setRedirectUrlWhenLoginStyleIsPopup","window","location","Base64","encode","JSON","stringify","saveDataForRedirect","loginService","Reload","_onMigrate","_migrate","immediateMigration","getDataAfterRedirect","migrationData","_migrationData","key","_storageTokenPrefix","credentialSecret","getItem","_debug","launchLogin","loginUrl","credentialRequestCompleteCallback","bind","popupOptions","_handleCredentialSecret","secret","check","String","Object","prototype","hasOwnProperty","call","_retrieveCredentialSecret","localStorageKey","_localStorage"],"sources":["packages/oauth/oauth_client.js"],"sourcesContent":["// credentialToken -> credentialSecret. You must provide both the\n// credentialToken and the credentialSecret to retrieve an access token from\n// the _pendingCredentials collection.\nconst credentialSecrets = {};\n\nOAuth = {};\n\nOAuth.showPopup = (url, callback, dimensions) => {\n  throw new Error(\"OAuth.showPopup must be implemented on this arch.\");\n};\n\n// Determine the login style (popup or redirect) for this login flow.\n//\n//\nOAuth._loginStyle = (service, config, options) => {\n\n  if (Meteor.isCordova) {\n    return \"popup\";\n  }\n\n  let loginStyle = (options && options.loginStyle) || config.loginStyle || 'popup';\n\n  if (! [\"popup\", \"redirect\"].includes(loginStyle))\n    throw new Error(`Invalid login style: ${loginStyle}`);\n\n  // If we don't have session storage (for example, Safari in private\n  // mode), the redirect login flow won't work, so fallback to the\n  // popup style.\n  if (loginStyle === 'redirect') {\n    try {\n      sessionStorage.setItem('Meteor.oauth.test', 'test');\n      sessionStorage.removeItem('Meteor.oauth.test');\n    } catch (e) {\n      loginStyle = 'popup';\n    }\n  }\n\n  return loginStyle;\n};\n\nOAuth._stateParam = (loginStyle, credentialToken, redirectUrl) => {\n  const state = {\n    loginStyle,\n    credentialToken,\n    isCordova: Meteor.isCordova\n  };\n\n  if (loginStyle === 'redirect' ||\n    (Meteor.settings?.public?.packages?.oauth?.setRedirectUrlWhenLoginStyleIsPopup && loginStyle === 'popup')\n  ) {\n    state.redirectUrl = redirectUrl || ('' + window.location);\n  }\n\n  // Encode base64 as not all login services URI-encode the state\n  // parameter when they pass it back to us.\n  // Use the 'base64' package here because 'btoa' isn't supported in IE8/9.\n  return Base64.encode(JSON.stringify(state));\n};\n\n\n// At the beginning of the redirect login flow, before we redirect to\n// the login service, save the credential token for this login attempt\n// in the reload migration data.\n//\nOAuth.saveDataForRedirect = (loginService, credentialToken) => {\n  Reload._onMigrate('oauth', () => [true, { loginService, credentialToken }]);\n  Reload._migrate(null, {immediateMigration: true});\n};\n\n// At the end of the redirect login flow, when we've redirected back\n// to the application, retrieve the credentialToken and (if the login\n// was successful) the credentialSecret.\n//\n// Called at application startup.  Returns null if this is normal\n// application startup and we weren't just redirected at the end of\n// the login flow.\n//\nOAuth.getDataAfterRedirect = () => {\n  const migrationData = Reload._migrationData('oauth');\n\n  if (! (migrationData && migrationData.credentialToken))\n    return null;\n\n  const { credentialToken } = migrationData;\n  const key = OAuth._storageTokenPrefix + credentialToken;\n  let credentialSecret;\n  try {\n    credentialSecret = sessionStorage.getItem(key);\n    sessionStorage.removeItem(key);\n  } catch (e) {\n    Meteor._debug('error retrieving credentialSecret', e);\n  }\n  return {\n    loginService: migrationData.loginService,\n    credentialToken,\n    credentialSecret,\n  };\n};\n\n/**\n * Launch an OAuth login flow.  For the popup login style, show the\n * popup.  For the redirect login style, save the credential token for\n * this login attempt in the reload migration data, and redirect to\n * the service for the login.\n *\n * @param {Object} options\n * @param {string} options.loginService \"facebook\", \"google\", etc.\n * @param {string} options.loginStyle \"popup\" or \"redirect\"\n * @param {string} options.loginUrl The URL at the login service provider to start the OAuth flow.\n *  credentialRequestCompleteCallback: for the popup flow, call when the popup\n *    is closed and we have the credential from the login service.\n * @param {string} options.credentialToken our identifier for this login flow.\n **/\nOAuth.launchLogin = options => {\n  if (! options.loginService)\n    throw new Error('loginService required');\n  if (options.loginStyle === 'popup') {\n    OAuth.showPopup(\n      options.loginUrl,\n      options.credentialRequestCompleteCallback.bind(null, options.credentialToken),\n      options.popupOptions);\n  } else if (options.loginStyle === 'redirect') {\n    OAuth.saveDataForRedirect(options.loginService, options.credentialToken);\n    window.location = options.loginUrl;\n  } else {\n    throw new Error('invalid login style');\n  }\n};\n\n// Called by the popup when the OAuth flow is completed, right before\n// the popup closes.\nOAuth._handleCredentialSecret = (credentialToken, secret) => {\n  check(credentialToken, String);\n  check(secret, String);\n  if (! Object.prototype.hasOwnProperty.call(credentialSecrets, credentialToken)) {\n    credentialSecrets[credentialToken] = secret;\n  } else {\n    throw new Error(\"Duplicate credential token from OAuth login\");\n  }\n};\n\n// Used by accounts-oauth, which needs both a credentialToken and the\n// corresponding to credential secret to call the `login` method over DDP.\nOAuth._retrieveCredentialSecret = credentialToken => {\n  // First check the secrets collected by OAuth._handleCredentialSecret,\n  // then check localStorage. This matches what we do in\n  // end_of_login_response.html.\n  let secret = credentialSecrets[credentialToken];\n  if (! secret) {\n    const localStorageKey = OAuth._storageTokenPrefix + credentialToken;\n    secret = Meteor._localStorage.getItem(localStorageKey);\n    Meteor._localStorage.removeItem(localStorageKey);\n  } else {\n    delete credentialSecrets[credentialToken];\n  }\n  return secret;\n};\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"953fb58719290aa3b242d5113400d36882f10191"}
