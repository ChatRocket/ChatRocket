{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/integrations/server/lib/triggerHandler.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"app/integrations/server/lib/triggerHandler.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/integrations/server/lib/triggerHandler.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/integrations/server/lib/triggerHandler.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/integrations/server/lib/triggerHandler.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let _objectSpread;\n    module.link(\"@babel/runtime/helpers/objectSpread2\", {\n      default(v) {\n        _objectSpread = v;\n      }\n    }, 0);\n    let _objectWithoutProperties;\n    module.link(\"@babel/runtime/helpers/objectWithoutProperties\", {\n      default(v) {\n        _objectWithoutProperties = v;\n      }\n    }, 1);\n    let _asyncIterator;\n    module.link(\"@babel/runtime/helpers/asyncIterator\", {\n      default(v) {\n        _asyncIterator = v;\n      }\n    }, 2);\n    const _excluded = [\"services\"];\n    module.export({\n      triggerHandler: () => triggerHandler\n    });\n    let Integrations, Users, Rooms, Messages;\n    module.link(\"@rocket.chat/models\", {\n      Integrations(v) {\n        Integrations = v;\n      },\n      Users(v) {\n        Users = v;\n      },\n      Rooms(v) {\n        Rooms = v;\n      },\n      Messages(v) {\n        Messages = v;\n      }\n    }, 0);\n    let fetch;\n    module.link(\"@rocket.chat/server-fetch\", {\n      serverFetch(v) {\n        fetch = v;\n      }\n    }, 1);\n    let wrapExceptions;\n    module.link(\"@rocket.chat/tools\", {\n      wrapExceptions(v) {\n        wrapExceptions = v;\n      }\n    }, 2);\n    let Meteor;\n    module.link(\"meteor/meteor\", {\n      Meteor(v) {\n        Meteor = v;\n      }\n    }, 3);\n    let _;\n    module.link(\"underscore\", {\n      default(v) {\n        _ = v;\n      }\n    }, 4);\n    let getRoomByNameOrIdWithOptionToJoin;\n    module.link(\"../../../lib/server/functions/getRoomByNameOrIdWithOptionToJoin\", {\n      getRoomByNameOrIdWithOptionToJoin(v) {\n        getRoomByNameOrIdWithOptionToJoin = v;\n      }\n    }, 5);\n    let processWebhookMessage;\n    module.link(\"../../../lib/server/functions/processWebhookMessage\", {\n      processWebhookMessage(v) {\n        processWebhookMessage = v;\n      }\n    }, 6);\n    let notifyOnIntegrationChangedById;\n    module.link(\"../../../lib/server/lib/notifyListener\", {\n      notifyOnIntegrationChangedById(v) {\n        notifyOnIntegrationChangedById = v;\n      }\n    }, 7);\n    let settings;\n    module.link(\"../../../settings/server\", {\n      settings(v) {\n        settings = v;\n      }\n    }, 8);\n    let outgoingEvents;\n    module.link(\"../../lib/outgoingEvents\", {\n      outgoingEvents(v) {\n        outgoingEvents = v;\n      }\n    }, 9);\n    let outgoingLogger;\n    module.link(\"../logger\", {\n      outgoingLogger(v) {\n        outgoingLogger = v;\n      }\n    }, 10);\n    let IsolatedVMScriptEngine;\n    module.link(\"./isolated-vm/isolated-vm\", {\n      IsolatedVMScriptEngine(v) {\n        IsolatedVMScriptEngine = v;\n      }\n    }, 11);\n    let updateHistory;\n    module.link(\"./updateHistory\", {\n      updateHistory(v) {\n        updateHistory = v;\n      }\n    }, 12);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    class RocketChatIntegrationHandler {\n      constructor() {\n        this.successResults = [200, 201, 202];\n        this.compiledScripts = {};\n        this.triggers = {};\n        this.ivmEngine = new IsolatedVMScriptEngine(false);\n      }\n      addIntegration(record) {\n        outgoingLogger.debug(\"Adding the integration \".concat(record.name, \" of the event \").concat(record.event, \"!\"));\n        let channels;\n        if (record.event && !outgoingEvents[record.event].use.channel) {\n          outgoingLogger.debug('The integration doesnt rely on channels.');\n          // We don't use any channels, so it's special ;)\n          channels = ['__any'];\n        } else if (_.isEmpty(record.channel)) {\n          outgoingLogger.debug('The integration had an empty channel property, so it is going on all the public channels.');\n          channels = ['all_public_channels'];\n        } else {\n          outgoingLogger.debug('The integration is going on these channels:', record.channel);\n          channels = [].concat(record.channel);\n        }\n        for (const channel of channels) {\n          if (!this.triggers[channel]) {\n            this.triggers[channel] = {};\n          }\n          this.triggers[channel][record._id] = record;\n        }\n      }\n\n      // eslint-disable-next-line no-unused-vars\n      getEngine(_integration) {\n        return this.ivmEngine;\n      }\n      removeIntegration(record) {\n        for (const trigger of Object.values(this.triggers)) {\n          delete trigger[record._id];\n        }\n      }\n      isTriggerEnabled(trigger) {\n        for (const trig of Object.values(this.triggers)) {\n          if (trig[trigger._id]) {\n            return trig[trigger._id].enabled;\n          }\n        }\n        return false;\n      }\n\n      // Trigger is the trigger, nameOrId is a string which is used to try and find a room, room is a room, message is a message, and data contains \"user_name\" if trigger.impersonateUser is truthful.\n      async sendMessage(_ref) {\n        let {\n          trigger,\n          nameOrId = '',\n          room,\n          message,\n          data\n        } = _ref;\n        let user;\n        // Try to find the user who we are impersonating\n        if (trigger.impersonateUser) {\n          user = await Users.findOneByUsernameIgnoringCase(data.user_name);\n        }\n\n        // If they don't exist (aka the trigger didn't contain a user) then we set the user based upon the\n        // configured username for the integration since this is required at all times.\n        if (!user) {\n          user = await Users.findOneByUsernameIgnoringCase(trigger.username);\n        }\n        let tmpRoom;\n        if (nameOrId || trigger.targetRoom || message.channel) {\n          tmpRoom = (await getRoomByNameOrIdWithOptionToJoin({\n            user,\n            nameOrId: nameOrId || message.channel || trigger.targetRoom,\n            errorOnEmpty: false\n          })) || room;\n        } else {\n          tmpRoom = room;\n        }\n\n        // If no room could be found, we won't be sending any messages but we'll warn in the logs\n        if (!tmpRoom) {\n          outgoingLogger.warn(\"The Integration \\\"\".concat(trigger.name, \"\\\" doesn't have a room configured nor did it provide a room to send the message to.\"));\n          return;\n        }\n        outgoingLogger.debug(\"Found a room for \".concat(trigger.name, \" which is: \").concat(tmpRoom.name, \" with a type of \").concat(tmpRoom.t));\n        message.bot = {\n          i: trigger._id\n        };\n        const defaultValues = {\n          alias: trigger.alias,\n          avatar: trigger.avatar,\n          emoji: trigger.emoji\n        };\n        if (tmpRoom.t === 'd') {\n          message.channel = \"@\".concat(tmpRoom._id);\n        } else {\n          message.channel = \"#\".concat(tmpRoom._id);\n        }\n        message = await processWebhookMessage(message, user, defaultValues);\n        return message;\n      }\n      eventNameArgumentsToObject() {\n        const argObject = {\n          event: arguments.length <= 0 ? undefined : arguments[0]\n        };\n        switch (argObject.event) {\n          case 'sendMessage':\n            if (arguments.length >= 3) {\n              argObject.message = arguments.length <= 1 ? undefined : arguments[1];\n              argObject.room = arguments.length <= 2 ? undefined : arguments[2];\n            }\n            break;\n          case 'fileUploaded':\n            if (arguments.length >= 2) {\n              const arghhh = arguments.length <= 1 ? undefined : arguments[1];\n              argObject.user = arghhh.user;\n              argObject.room = arghhh.room;\n              argObject.message = arghhh.message;\n            }\n            break;\n          case 'roomArchived':\n            if (arguments.length >= 3) {\n              argObject.room = arguments.length <= 1 ? undefined : arguments[1];\n              argObject.user = arguments.length <= 2 ? undefined : arguments[2];\n            }\n            break;\n          case 'roomCreated':\n            if (arguments.length >= 3) {\n              argObject.owner = arguments.length <= 1 ? undefined : arguments[1];\n              argObject.room = arguments.length <= 2 ? undefined : arguments[2];\n            }\n            break;\n          case 'roomJoined':\n          case 'roomLeft':\n            if (arguments.length >= 3) {\n              argObject.user = arguments.length <= 1 ? undefined : arguments[1];\n              argObject.room = arguments.length <= 2 ? undefined : arguments[2];\n            }\n            break;\n          case 'userCreated':\n            if (arguments.length >= 2) {\n              argObject.user = arguments.length <= 1 ? undefined : arguments[1];\n            }\n            break;\n          default:\n            outgoingLogger.warn(\"An Unhandled Trigger Event was called: \".concat(argObject.event));\n            argObject.event = undefined;\n            break;\n        }\n        outgoingLogger.debug({\n          msg: \"Got the event arguments for the event: \".concat(argObject.event),\n          argObject\n        });\n        return argObject;\n      }\n      mapEventArgsToData(data, _ref2) {\n        let {\n          event,\n          message,\n          room,\n          owner,\n          user\n        } = _ref2;\n        /* The \"services\" field contains sensitive information such as\n        the user's password hash. To prevent this information from being\n        sent to the webhook, we're checking and removing it by destructuring\n        the user and owner objects while discarding the \"services\" field.\n        */\n\n        const omitServicesField = object => {\n          const {\n              services\n            } = object,\n            objectWithoutServicesField = _objectWithoutProperties(object, _excluded);\n          return objectWithoutServicesField;\n        };\n        const userWithoutServicesField = user !== null && user !== void 0 && user.services ? omitServicesField(user) : user;\n        const ownerWithoutServicesField = owner !== null && owner !== void 0 && owner.services ? omitServicesField(owner) : owner;\n        switch (event) {\n          case 'sendMessage':\n            data.channel_id = room._id;\n            data.channel_name = room.name;\n            data.message_id = message._id;\n            data.timestamp = message.ts;\n            data.user_id = message.u._id;\n            data.user_name = message.u.username;\n            data.text = message.msg;\n            data.siteUrl = settings.get('Site_Url');\n            if (message.alias) {\n              data.alias = message.alias;\n            }\n            if (message.bot) {\n              data.bot = message.bot;\n            }\n            if (message.editedAt) {\n              data.isEdited = true;\n            }\n            if (message.tmid) {\n              data.tmid = message.tmid;\n            }\n            break;\n          case 'fileUploaded':\n            data.channel_id = room._id;\n            data.channel_name = room.name;\n            data.message_id = message._id;\n            data.timestamp = message.ts;\n            data.user_id = message.u._id;\n            data.user_name = message.u.username;\n            data.text = message.msg;\n            data.user = userWithoutServicesField;\n            data.room = room;\n            data.message = message;\n            if (message.alias) {\n              data.alias = message.alias;\n            }\n            if (message.bot) {\n              data.bot = message.bot;\n            }\n            break;\n          case 'roomCreated':\n            data.channel_id = room._id;\n            data.channel_name = room.name;\n            data.timestamp = room.ts;\n            data.user_id = owner._id;\n            data.user_name = owner.username;\n            data.owner = ownerWithoutServicesField;\n            data.room = room;\n            break;\n          case 'roomArchived':\n          case 'roomJoined':\n          case 'roomLeft':\n            data.timestamp = new Date();\n            data.channel_id = room._id;\n            data.channel_name = room.name;\n            data.user_id = user._id;\n            data.user_name = user.username;\n            data.user = userWithoutServicesField;\n            data.room = room;\n            if (user.type === 'bot') {\n              data.bot = true;\n            }\n            break;\n          case 'userCreated':\n            data.timestamp = user.createdAt;\n            data.user_id = user._id;\n            data.user_name = user.username;\n            data.user = userWithoutServicesField;\n            if (user.type === 'bot') {\n              data.bot = true;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      getTriggersToExecute(room, message) {\n        const triggersToExecute = new Set();\n        if (room) {\n          switch (room.t) {\n            case 'd':\n              if (this.triggers.all_direct_messages) {\n                for (const trigger of Object.values(this.triggers.all_direct_messages)) {\n                  triggersToExecute.add(trigger);\n                }\n              }\n              room.uids.filter(uid => this.triggers[\"@\".concat(uid)]).forEach(uid => {\n                for (const trigger of Object.values(this.triggers[\"@\".concat(uid)])) {\n                  triggersToExecute.add(trigger);\n                }\n              });\n              room.usernames.filter(username => {\n                var _message$u;\n                return username !== (message === null || message === void 0 ? void 0 : (_message$u = message.u) === null || _message$u === void 0 ? void 0 : _message$u.username) && this.triggers[\"@\".concat(username)];\n              }).forEach(username => {\n                for (const trigger of Object.values(this.triggers[\"@\".concat(username)])) {\n                  triggersToExecute.add(trigger);\n                }\n              });\n              break;\n            case 'c':\n              if (this.triggers.all_public_channels) {\n                for (const trigger of Object.values(this.triggers.all_public_channels)) {\n                  triggersToExecute.add(trigger);\n                }\n              }\n              if (this.triggers[\"#\".concat(room._id)]) {\n                for (const trigger of Object.values(this.triggers[\"#\".concat(room._id)])) {\n                  triggersToExecute.add(trigger);\n                }\n              }\n              if (room._id !== room.name && this.triggers[\"#\".concat(room.name)]) {\n                for (const trigger of Object.values(this.triggers[\"#\".concat(room.name)])) {\n                  triggersToExecute.add(trigger);\n                }\n              }\n              break;\n            default:\n              if (this.triggers.all_private_groups) {\n                for (const trigger of Object.values(this.triggers.all_private_groups)) {\n                  triggersToExecute.add(trigger);\n                }\n              }\n              if (this.triggers[\"#\".concat(room._id)]) {\n                for (const trigger of Object.values(this.triggers[\"#\".concat(room._id)])) {\n                  triggersToExecute.add(trigger);\n                }\n              }\n              if (room._id !== room.name && this.triggers[\"#\".concat(room.name)]) {\n                for (const trigger of Object.values(this.triggers[\"#\".concat(room.name)])) {\n                  triggersToExecute.add(trigger);\n                }\n              }\n              break;\n          }\n        }\n        return [...triggersToExecute];\n      }\n      async executeTriggers() {\n        outgoingLogger.debug({\n          msg: 'Execute Trigger:',\n          arg: arguments.length <= 0 ? undefined : arguments[0]\n        });\n        const argObject = this.eventNameArgumentsToObject(...arguments);\n        const {\n          event,\n          message,\n          room\n        } = argObject;\n\n        // Each type of event should have an event and a room attached, otherwise we\n        // wouldn't know how to handle the trigger nor would we have anywhere to send the\n        // result of the integration\n        if (!event) {\n          return;\n        }\n        outgoingLogger.debug(\"Starting search for triggers for the room: \".concat(room ? room._id : '__any'));\n        const triggersToExecute = this.getTriggersToExecute(room, message);\n        if (this.triggers.__any) {\n          // For outgoing integration which don't rely on rooms.\n          for (const trigger of Object.values(this.triggers.__any)) {\n            triggersToExecute.push(trigger);\n          }\n        }\n        outgoingLogger.debug(\"Found \".concat(triggersToExecute.length, \" to iterate over and see if the match the event.\"));\n        var _iteratorAbruptCompletion = false;\n        var _didIteratorError = false;\n        var _iteratorError;\n        try {\n          for (var _iterator = _asyncIterator(triggersToExecute), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n            const triggerToExecute = _step.value;\n            {\n              outgoingLogger.debug(\"Is \\\"\".concat(triggerToExecute.name, \"\\\" enabled, \").concat(triggerToExecute.enabled, \", and what is the event? \").concat(triggerToExecute.event));\n              if (triggerToExecute.enabled === true && triggerToExecute.event === event) {\n                await this.executeTrigger(triggerToExecute, argObject);\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion && _iterator.return != null) {\n              await _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n      async executeTrigger(trigger, argObject) {\n        var _iteratorAbruptCompletion2 = false;\n        var _didIteratorError2 = false;\n        var _iteratorError2;\n        try {\n          for (var _iterator2 = _asyncIterator(trigger.urls), _step2; _iteratorAbruptCompletion2 = !(_step2 = await _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n            const url = _step2.value;\n            {\n              await this.executeTriggerUrl(url, trigger, argObject, 0);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n              await _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n\n      // Ensure that any errors thrown by the script engine will contibue to be compatible with Meteor.Error\n      async wrapScriptEngineCall(getter) {\n        return wrapExceptions(getter).catch(error => {\n          if (error instanceof Error) {\n            throw new Meteor.Error(error.message);\n          }\n          throw error;\n        });\n      }\n      async executeTriggerUrl(url, trigger, _ref3, theHistoryId) {\n        let {\n          event,\n          message,\n          room,\n          owner,\n          user\n        } = _ref3;\n        let tries = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n        if (!this.isTriggerEnabled(trigger)) {\n          outgoingLogger.warn(\"The trigger \\\"\".concat(trigger.name, \"\\\" is no longer enabled, stopping execution of it at try: \").concat(tries));\n          return;\n        }\n        outgoingLogger.debug(\"Starting to execute trigger: \".concat(trigger.name, \" (\").concat(trigger._id, \")\"));\n        let word;\n        // Not all triggers/events support triggerWords\n        if (outgoingEvents[event].use.triggerWords) {\n          if (trigger.triggerWords && trigger.triggerWords.length > 0) {\n            for (const triggerWord of trigger.triggerWords) {\n              if (!trigger.triggerWordAnywhere && message.msg.indexOf(triggerWord) === 0) {\n                word = triggerWord;\n                break;\n              } else if (trigger.triggerWordAnywhere && message.msg.includes(triggerWord)) {\n                word = triggerWord;\n                break;\n              }\n            }\n\n            // Stop if there are triggerWords but none match\n            if (!word) {\n              outgoingLogger.debug(\"The trigger word which \\\"\".concat(trigger.name, \"\\\" was expecting could not be found, not executing.\"));\n              return;\n            }\n          }\n        }\n        if (message && message.editedAt && !trigger.runOnEdits) {\n          outgoingLogger.debug(\"The trigger \\\"\".concat(trigger.name, \"\\\"'s run on edits is disabled and the message was edited.\"));\n          return;\n        }\n        const historyId = await updateHistory({\n          step: 'start-execute-trigger-url',\n          integration: trigger,\n          event\n        });\n        const data = {\n          token: trigger.token,\n          bot: false\n        };\n        if (word) {\n          data.trigger_word = word;\n        }\n        this.mapEventArgsToData(data, {\n          trigger,\n          event,\n          message,\n          room,\n          owner,\n          user\n        });\n        await updateHistory({\n          historyId,\n          step: 'mapped-args-to-data',\n          data,\n          triggerWord: word\n        });\n        outgoingLogger.info(\"Will be executing the Integration \\\"\".concat(trigger.name, \"\\\" to the url: \").concat(url));\n        outgoingLogger.debug({\n          data\n        });\n        const scriptEngine = this.getEngine(trigger);\n        const opts = await this.wrapScriptEngineCall(() => scriptEngine.prepareOutgoingRequest({\n          integration: trigger,\n          data,\n          url,\n          historyId\n        }));\n        await updateHistory({\n          historyId,\n          step: 'after-maybe-ran-prepare',\n          ranPrepareScript: true\n        });\n        if (!opts) {\n          await updateHistory({\n            historyId,\n            step: 'after-prepare-no-opts',\n            finished: true\n          });\n          return;\n        }\n        if (opts.message) {\n          const prepareMessage = await this.sendMessage({\n            trigger,\n            room,\n            message: opts.message,\n            data\n          });\n          await updateHistory({\n            historyId,\n            step: 'after-prepare-send-message',\n            prepareSentMessage: prepareMessage\n          });\n        }\n        if (!opts.url || !opts.method) {\n          await updateHistory({\n            historyId,\n            step: 'after-prepare-no-url_or_method',\n            finished: true\n          });\n          return;\n        }\n\n        // based on HTTP.call implementation\n        if (opts.auth) {\n          if (opts.auth.indexOf(':') < 0) {\n            throw new Error('auth option should be of the form \"username:password\"');\n          }\n          const base64 = Buffer.from(opts.auth, 'ascii').toString('base64');\n          opts.headers.Authorization = \"Basic \".concat(base64);\n        }\n        await updateHistory({\n          historyId,\n          step: 'pre-http-call',\n          url: opts.url,\n          httpCallData: opts.data\n        });\n        if (opts.data) {\n          opts.headers['Content-Type'] = 'application/json';\n        }\n        fetch(opts.url, _objectSpread(_objectSpread({\n          method: opts.method,\n          headers: opts.headers\n        }, opts.timeout && {\n          timeout: opts.timeout\n        }), opts.data && {\n          body: opts.data\n        }), settings.get('Allow_Invalid_SelfSigned_Certs')).then(async res => {\n          const content = await res.text();\n          if (!content) {\n            outgoingLogger.warn(\"Result for the Integration \".concat(trigger.name, \" to \").concat(url, \" is empty\"));\n          } else {\n            outgoingLogger.info(\"Status code for the Integration \".concat(trigger.name, \" to \").concat(url, \" is \").concat(res.status));\n          }\n          const data = (() => {\n            const contentType = (res.headers.get('content-type') || '').split(';')[0];\n            if (!['application/json', 'text/javascript', 'application/javascript', 'application/x-javascript'].includes(contentType)) {\n              return null;\n            }\n            try {\n              return JSON.parse(content);\n            } catch (_error) {\n              return null;\n            }\n          })();\n          await updateHistory({\n            historyId,\n            step: 'after-http-call',\n            httpError: null,\n            httpResult: content\n          });\n          const responseContent = await this.wrapScriptEngineCall(() => scriptEngine.processOutgoingResponse({\n            integration: trigger,\n            request: opts,\n            response: res,\n            content,\n            historyId\n          }));\n          if (responseContent) {\n            const resultMessage = await this.sendMessage({\n              trigger,\n              room,\n              message: responseContent,\n              data\n            });\n            await updateHistory({\n              historyId,\n              step: 'after-process-send-message',\n              processSentMessage: resultMessage,\n              finished: true\n            });\n            return;\n          }\n          if (responseContent === false) {\n            await updateHistory({\n              historyId,\n              step: 'after-process-false-result',\n              finished: true\n            });\n            return;\n          }\n\n          // if the result contained nothing or wasn't a successful statusCode\n          if (!content || !this.successResults.includes(res.status)) {\n            if (content) {\n              outgoingLogger.error({\n                msg: \"Error for the Integration \\\"\".concat(trigger.name, \"\\\" to \").concat(url),\n                result: content\n              });\n              if (res.status === 410) {\n                await updateHistory({\n                  historyId,\n                  step: 'after-process-http-status-410',\n                  error: true\n                });\n                outgoingLogger.error(\"Disabling the Integration \\\"\".concat(trigger.name, \"\\\" because the status code was 401 (Gone).\"));\n                await Integrations.updateOne({\n                  _id: trigger._id\n                }, {\n                  $set: {\n                    enabled: false\n                  }\n                });\n                void notifyOnIntegrationChangedById(trigger._id);\n                return;\n              }\n              if (res.status === 500) {\n                await updateHistory({\n                  historyId,\n                  step: 'after-process-http-status-500',\n                  error: true\n                });\n                outgoingLogger.error({\n                  msg: \"Error \\\"500\\\" for the Integration \\\"\".concat(trigger.name, \"\\\" to \").concat(url, \".\"),\n                  content\n                });\n                return;\n              }\n            }\n            if (trigger.retryFailedCalls) {\n              if (tries < trigger.retryCount && trigger.retryDelay) {\n                await updateHistory({\n                  historyId,\n                  error: true,\n                  step: \"going-to-retry-\".concat(tries + 1)\n                });\n                let waitTime;\n                switch (trigger.retryDelay) {\n                  case 'powers-of-ten':\n                    // Try again in 0.1s, 1s, 10s, 1m40s, 16m40s, 2h46m40s, 27h46m40s, etc\n                    waitTime = Math.pow(10, tries + 2);\n                    break;\n                  case 'powers-of-two':\n                    // 2 seconds, 4 seconds, 8 seconds\n                    waitTime = Math.pow(2, tries + 1) * 1000;\n                    break;\n                  case 'increments-of-two':\n                    // 2 second, 4 seconds, 6 seconds, etc\n                    waitTime = (tries + 1) * 2 * 1000;\n                    break;\n                  default:\n                    const er = new Error(\"The integration's retryDelay setting is invalid.\");\n                    await updateHistory({\n                      historyId,\n                      step: 'failed-and-retry-delay-is-invalid',\n                      error: true,\n                      errorStack: er.stack\n                    });\n                    return;\n                }\n                outgoingLogger.info(\"Trying the Integration \".concat(trigger.name, \" to \").concat(url, \" again in \").concat(waitTime, \" milliseconds.\"));\n                setTimeout(() => {\n                  void this.executeTriggerUrl(url, trigger, {\n                    event,\n                    message,\n                    room,\n                    owner,\n                    user\n                  }, historyId, tries + 1);\n                }, waitTime);\n              } else {\n                await updateHistory({\n                  historyId,\n                  step: 'too-many-retries',\n                  error: true\n                });\n              }\n            } else {\n              await updateHistory({\n                historyId,\n                step: 'failed-and-not-configured-to-retry',\n                error: true\n              });\n            }\n            return;\n          }\n\n          // process outgoing webhook response as a new message\n          if (content && this.successResults.includes(res.status)) {\n            if (data !== null && data !== void 0 && data.text || data !== null && data !== void 0 && data.attachments) {\n              const resultMsg = await this.sendMessage({\n                trigger,\n                room,\n                message: data,\n                data\n              });\n              await updateHistory({\n                historyId,\n                step: 'url-response-sent-message',\n                resultMessage: resultMsg,\n                finished: true\n              });\n            }\n          }\n        }).catch(async error => {\n          outgoingLogger.error(error);\n          await updateHistory({\n            historyId,\n            step: 'after-http-call',\n            httpError: error,\n            httpResult: null\n          });\n        });\n      }\n      async replay(integration, history) {\n        if (!integration || integration.type !== 'webhook-outgoing') {\n          throw new Meteor.Error('integration-type-must-be-outgoing', 'The integration type to replay must be an outgoing webhook.');\n        }\n        if (!history || !history.data) {\n          throw new Meteor.Error('history-data-must-be-defined', 'The history data must be defined to replay an integration.');\n        }\n        const {\n          event\n        } = history;\n        const message = await Messages.findOneById(history.data.message_id);\n        const room = await Rooms.findOneById(history.data.channel_id);\n        const user = await Users.findOneById(history.data.user_id);\n        let owner;\n        if (history.data.owner && history.data.owner._id) {\n          owner = await Users.findOneById(history.data.owner._id);\n        }\n        return this.executeTriggerUrl(history.url, integration, {\n          event,\n          message,\n          room,\n          owner,\n          user\n        });\n      }\n    }\n    const triggerHandler = new RocketChatIntegrationHandler();\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["_objectSpread","module","link","default","v","_objectWithoutProperties","_asyncIterator","_excluded","export","triggerHandler","Integrations","Users","Rooms","Messages","fetch","serverFetch","wrapExceptions","Meteor","_","getRoomByNameOrIdWithOptionToJoin","processWebhookMessage","notifyOnIntegrationChangedById","settings","outgoingEvents","outgoingLogger","IsolatedVMScriptEngine","updateHistory","__reifyWaitForDeps__","RocketChatIntegrationHandler","constructor","successResults","compiledScripts","triggers","ivmEngine","addIntegration","record","debug","concat","name","event","channels","use","channel","isEmpty","_id","getEngine","_integration","removeIntegration","trigger","Object","values","isTriggerEnabled","trig","enabled","sendMessage","_ref","nameOrId","room","message","data","user","impersonateUser","findOneByUsernameIgnoringCase","user_name","username","tmpRoom","targetRoom","errorOnEmpty","warn","t","bot","i","defaultValues","alias","avatar","emoji","eventNameArgumentsToObject","argObject","arguments","length","undefined","arghhh","owner","msg","mapEventArgsToData","_ref2","omitServicesField","object","services","objectWithoutServicesField","userWithoutServicesField","ownerWithoutServicesField","channel_id","channel_name","message_id","timestamp","ts","user_id","u","text","siteUrl","get","editedAt","isEdited","tmid","Date","type","createdAt","getTriggersToExecute","triggersToExecute","Set","all_direct_messages","add","uids","filter","uid","forEach","usernames","_message$u","all_public_channels","all_private_groups","executeTriggers","arg","__any","push","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","triggerToExecute","value","executeTrigger","err","return","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","urls","_step2","url","executeTriggerUrl","wrapScriptEngineCall","getter","catch","error","Error","_ref3","theHistoryId","tries","word","triggerWords","triggerWord","triggerWordAnywhere","indexOf","includes","runOnEdits","historyId","step","integration","token","trigger_word","info","scriptEngine","opts","prepareOutgoingRequest","ranPrepareScript","finished","prepareMessage","prepareSentMessage","method","auth","base64","Buffer","from","toString","headers","Authorization","httpCallData","timeout","body","then","res","content","status","contentType","split","JSON","parse","_error","httpError","httpResult","responseContent","processOutgoingResponse","request","response","resultMessage","processSentMessage","result","updateOne","$set","retryFailedCalls","retryCount","retryDelay","waitTime","Math","pow","er","errorStack","stack","setTimeout","attachments","resultMsg","replay","history","findOneById","__reify_async_result__","_reifyError","self","async"],"sources":["app/integrations/server/lib/triggerHandler.js"],"sourcesContent":["import { Integrations, Users, Rooms, Messages } from '@rocket.chat/models';\nimport { serverFetch as fetch } from '@rocket.chat/server-fetch';\nimport { wrapExceptions } from '@rocket.chat/tools';\nimport { Meteor } from 'meteor/meteor';\nimport _ from 'underscore';\n\nimport { getRoomByNameOrIdWithOptionToJoin } from '../../../lib/server/functions/getRoomByNameOrIdWithOptionToJoin';\nimport { processWebhookMessage } from '../../../lib/server/functions/processWebhookMessage';\nimport { notifyOnIntegrationChangedById } from '../../../lib/server/lib/notifyListener';\nimport { settings } from '../../../settings/server';\nimport { outgoingEvents } from '../../lib/outgoingEvents';\nimport { outgoingLogger } from '../logger';\nimport { IsolatedVMScriptEngine } from './isolated-vm/isolated-vm';\nimport { updateHistory } from './updateHistory';\n\nclass RocketChatIntegrationHandler {\n\tconstructor() {\n\t\tthis.successResults = [200, 201, 202];\n\t\tthis.compiledScripts = {};\n\t\tthis.triggers = {};\n\t\tthis.ivmEngine = new IsolatedVMScriptEngine(false);\n\t}\n\n\taddIntegration(record) {\n\t\toutgoingLogger.debug(`Adding the integration ${record.name} of the event ${record.event}!`);\n\t\tlet channels;\n\t\tif (record.event && !outgoingEvents[record.event].use.channel) {\n\t\t\toutgoingLogger.debug('The integration doesnt rely on channels.');\n\t\t\t// We don't use any channels, so it's special ;)\n\t\t\tchannels = ['__any'];\n\t\t} else if (_.isEmpty(record.channel)) {\n\t\t\toutgoingLogger.debug('The integration had an empty channel property, so it is going on all the public channels.');\n\t\t\tchannels = ['all_public_channels'];\n\t\t} else {\n\t\t\toutgoingLogger.debug('The integration is going on these channels:', record.channel);\n\t\t\tchannels = [].concat(record.channel);\n\t\t}\n\n\t\tfor (const channel of channels) {\n\t\t\tif (!this.triggers[channel]) {\n\t\t\t\tthis.triggers[channel] = {};\n\t\t\t}\n\n\t\t\tthis.triggers[channel][record._id] = record;\n\t\t}\n\t}\n\n\t// eslint-disable-next-line no-unused-vars\n\tgetEngine(_integration) {\n\t\treturn this.ivmEngine;\n\t}\n\n\tremoveIntegration(record) {\n\t\tfor (const trigger of Object.values(this.triggers)) {\n\t\t\tdelete trigger[record._id];\n\t\t}\n\t}\n\n\tisTriggerEnabled(trigger) {\n\t\tfor (const trig of Object.values(this.triggers)) {\n\t\t\tif (trig[trigger._id]) {\n\t\t\t\treturn trig[trigger._id].enabled;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// Trigger is the trigger, nameOrId is a string which is used to try and find a room, room is a room, message is a message, and data contains \"user_name\" if trigger.impersonateUser is truthful.\n\tasync sendMessage({ trigger, nameOrId = '', room, message, data }) {\n\t\tlet user;\n\t\t// Try to find the user who we are impersonating\n\t\tif (trigger.impersonateUser) {\n\t\t\tuser = await Users.findOneByUsernameIgnoringCase(data.user_name);\n\t\t}\n\n\t\t// If they don't exist (aka the trigger didn't contain a user) then we set the user based upon the\n\t\t// configured username for the integration since this is required at all times.\n\t\tif (!user) {\n\t\t\tuser = await Users.findOneByUsernameIgnoringCase(trigger.username);\n\t\t}\n\n\t\tlet tmpRoom;\n\t\tif (nameOrId || trigger.targetRoom || message.channel) {\n\t\t\ttmpRoom =\n\t\t\t\t(await getRoomByNameOrIdWithOptionToJoin({\n\t\t\t\t\tuser,\n\t\t\t\t\tnameOrId: nameOrId || message.channel || trigger.targetRoom,\n\t\t\t\t\terrorOnEmpty: false,\n\t\t\t\t})) || room;\n\t\t} else {\n\t\t\ttmpRoom = room;\n\t\t}\n\n\t\t// If no room could be found, we won't be sending any messages but we'll warn in the logs\n\t\tif (!tmpRoom) {\n\t\t\toutgoingLogger.warn(\n\t\t\t\t`The Integration \"${trigger.name}\" doesn't have a room configured nor did it provide a room to send the message to.`,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\toutgoingLogger.debug(`Found a room for ${trigger.name} which is: ${tmpRoom.name} with a type of ${tmpRoom.t}`);\n\n\t\tmessage.bot = { i: trigger._id };\n\n\t\tconst defaultValues = {\n\t\t\talias: trigger.alias,\n\t\t\tavatar: trigger.avatar,\n\t\t\temoji: trigger.emoji,\n\t\t};\n\n\t\tif (tmpRoom.t === 'd') {\n\t\t\tmessage.channel = `@${tmpRoom._id}`;\n\t\t} else {\n\t\t\tmessage.channel = `#${tmpRoom._id}`;\n\t\t}\n\n\t\tmessage = await processWebhookMessage(message, user, defaultValues);\n\t\treturn message;\n\t}\n\n\teventNameArgumentsToObject(...args) {\n\t\tconst argObject = {\n\t\t\tevent: args[0],\n\t\t};\n\n\t\tswitch (argObject.event) {\n\t\t\tcase 'sendMessage':\n\t\t\t\tif (args.length >= 3) {\n\t\t\t\t\targObject.message = args[1];\n\t\t\t\t\targObject.room = args[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'fileUploaded':\n\t\t\t\tif (args.length >= 2) {\n\t\t\t\t\tconst arghhh = args[1];\n\t\t\t\t\targObject.user = arghhh.user;\n\t\t\t\t\targObject.room = arghhh.room;\n\t\t\t\t\targObject.message = arghhh.message;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'roomArchived':\n\t\t\t\tif (args.length >= 3) {\n\t\t\t\t\targObject.room = args[1];\n\t\t\t\t\targObject.user = args[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'roomCreated':\n\t\t\t\tif (args.length >= 3) {\n\t\t\t\t\targObject.owner = args[1];\n\t\t\t\t\targObject.room = args[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'roomJoined':\n\t\t\tcase 'roomLeft':\n\t\t\t\tif (args.length >= 3) {\n\t\t\t\t\targObject.user = args[1];\n\t\t\t\t\targObject.room = args[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'userCreated':\n\t\t\t\tif (args.length >= 2) {\n\t\t\t\t\targObject.user = args[1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutgoingLogger.warn(`An Unhandled Trigger Event was called: ${argObject.event}`);\n\t\t\t\targObject.event = undefined;\n\t\t\t\tbreak;\n\t\t}\n\n\t\toutgoingLogger.debug({\n\t\t\tmsg: `Got the event arguments for the event: ${argObject.event}`,\n\t\t\targObject,\n\t\t});\n\n\t\treturn argObject;\n\t}\n\n\tmapEventArgsToData(data, { event, message, room, owner, user }) {\n\t\t/* The \"services\" field contains sensitive information such as\n\t\tthe user's password hash. To prevent this information from being\n\t\tsent to the webhook, we're checking and removing it by destructuring\n\t\tthe user and owner objects while discarding the \"services\" field.\n\t\t*/\n\n\t\tconst omitServicesField = (object) => {\n\t\t\tconst { services, ...objectWithoutServicesField } = object;\n\t\t\treturn objectWithoutServicesField;\n\t\t};\n\n\t\tconst userWithoutServicesField = user?.services ? omitServicesField(user) : user;\n\t\tconst ownerWithoutServicesField = owner?.services ? omitServicesField(owner) : owner;\n\n\t\tswitch (event) {\n\t\t\tcase 'sendMessage':\n\t\t\t\tdata.channel_id = room._id;\n\t\t\t\tdata.channel_name = room.name;\n\t\t\t\tdata.message_id = message._id;\n\t\t\t\tdata.timestamp = message.ts;\n\t\t\t\tdata.user_id = message.u._id;\n\t\t\t\tdata.user_name = message.u.username;\n\t\t\t\tdata.text = message.msg;\n\t\t\t\tdata.siteUrl = settings.get('Site_Url');\n\n\t\t\t\tif (message.alias) {\n\t\t\t\t\tdata.alias = message.alias;\n\t\t\t\t}\n\n\t\t\t\tif (message.bot) {\n\t\t\t\t\tdata.bot = message.bot;\n\t\t\t\t}\n\n\t\t\t\tif (message.editedAt) {\n\t\t\t\t\tdata.isEdited = true;\n\t\t\t\t}\n\n\t\t\t\tif (message.tmid) {\n\t\t\t\t\tdata.tmid = message.tmid;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'fileUploaded':\n\t\t\t\tdata.channel_id = room._id;\n\t\t\t\tdata.channel_name = room.name;\n\t\t\t\tdata.message_id = message._id;\n\t\t\t\tdata.timestamp = message.ts;\n\t\t\t\tdata.user_id = message.u._id;\n\t\t\t\tdata.user_name = message.u.username;\n\t\t\t\tdata.text = message.msg;\n\t\t\t\tdata.user = userWithoutServicesField;\n\t\t\t\tdata.room = room;\n\t\t\t\tdata.message = message;\n\n\t\t\t\tif (message.alias) {\n\t\t\t\t\tdata.alias = message.alias;\n\t\t\t\t}\n\n\t\t\t\tif (message.bot) {\n\t\t\t\t\tdata.bot = message.bot;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'roomCreated':\n\t\t\t\tdata.channel_id = room._id;\n\t\t\t\tdata.channel_name = room.name;\n\t\t\t\tdata.timestamp = room.ts;\n\t\t\t\tdata.user_id = owner._id;\n\t\t\t\tdata.user_name = owner.username;\n\t\t\t\tdata.owner = ownerWithoutServicesField;\n\t\t\t\tdata.room = room;\n\t\t\t\tbreak;\n\t\t\tcase 'roomArchived':\n\t\t\tcase 'roomJoined':\n\t\t\tcase 'roomLeft':\n\t\t\t\tdata.timestamp = new Date();\n\t\t\t\tdata.channel_id = room._id;\n\t\t\t\tdata.channel_name = room.name;\n\t\t\t\tdata.user_id = user._id;\n\t\t\t\tdata.user_name = user.username;\n\t\t\t\tdata.user = userWithoutServicesField;\n\t\t\t\tdata.room = room;\n\n\t\t\t\tif (user.type === 'bot') {\n\t\t\t\t\tdata.bot = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'userCreated':\n\t\t\t\tdata.timestamp = user.createdAt;\n\t\t\t\tdata.user_id = user._id;\n\t\t\t\tdata.user_name = user.username;\n\t\t\t\tdata.user = userWithoutServicesField;\n\n\t\t\t\tif (user.type === 'bot') {\n\t\t\t\t\tdata.bot = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tgetTriggersToExecute(room, message) {\n\t\tconst triggersToExecute = new Set();\n\t\tif (room) {\n\t\t\tswitch (room.t) {\n\t\t\t\tcase 'd':\n\t\t\t\t\tif (this.triggers.all_direct_messages) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers.all_direct_messages)) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\troom.uids\n\t\t\t\t\t\t.filter((uid) => this.triggers[`@${uid}`])\n\t\t\t\t\t\t.forEach((uid) => {\n\t\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers[`@${uid}`])) {\n\t\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\troom.usernames\n\t\t\t\t\t\t.filter((username) => username !== message?.u?.username && this.triggers[`@${username}`])\n\t\t\t\t\t\t.forEach((username) => {\n\t\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers[`@${username}`])) {\n\t\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tif (this.triggers.all_public_channels) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers.all_public_channels)) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.triggers[`#${room._id}`]) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers[`#${room._id}`])) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (room._id !== room.name && this.triggers[`#${room.name}`]) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers[`#${room.name}`])) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (this.triggers.all_private_groups) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers.all_private_groups)) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.triggers[`#${room._id}`]) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers[`#${room._id}`])) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (room._id !== room.name && this.triggers[`#${room.name}`]) {\n\t\t\t\t\t\tfor (const trigger of Object.values(this.triggers[`#${room.name}`])) {\n\t\t\t\t\t\t\ttriggersToExecute.add(trigger);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn [...triggersToExecute];\n\t}\n\n\tasync executeTriggers(...args) {\n\t\toutgoingLogger.debug({ msg: 'Execute Trigger:', arg: args[0] });\n\n\t\tconst argObject = this.eventNameArgumentsToObject(...args);\n\t\tconst { event, message, room } = argObject;\n\n\t\t// Each type of event should have an event and a room attached, otherwise we\n\t\t// wouldn't know how to handle the trigger nor would we have anywhere to send the\n\t\t// result of the integration\n\t\tif (!event) {\n\t\t\treturn;\n\t\t}\n\n\t\toutgoingLogger.debug(`Starting search for triggers for the room: ${room ? room._id : '__any'}`);\n\n\t\tconst triggersToExecute = this.getTriggersToExecute(room, message);\n\n\t\tif (this.triggers.__any) {\n\t\t\t// For outgoing integration which don't rely on rooms.\n\t\t\tfor (const trigger of Object.values(this.triggers.__any)) {\n\t\t\t\ttriggersToExecute.push(trigger);\n\t\t\t}\n\t\t}\n\n\t\toutgoingLogger.debug(`Found ${triggersToExecute.length} to iterate over and see if the match the event.`);\n\n\t\tfor await (const triggerToExecute of triggersToExecute) {\n\t\t\toutgoingLogger.debug(\n\t\t\t\t`Is \"${triggerToExecute.name}\" enabled, ${triggerToExecute.enabled}, and what is the event? ${triggerToExecute.event}`,\n\t\t\t);\n\t\t\tif (triggerToExecute.enabled === true && triggerToExecute.event === event) {\n\t\t\t\tawait this.executeTrigger(triggerToExecute, argObject);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync executeTrigger(trigger, argObject) {\n\t\tfor await (const url of trigger.urls) {\n\t\t\tawait this.executeTriggerUrl(url, trigger, argObject, 0);\n\t\t}\n\t}\n\n\t// Ensure that any errors thrown by the script engine will contibue to be compatible with Meteor.Error\n\tasync wrapScriptEngineCall(getter) {\n\t\treturn wrapExceptions(getter).catch((error) => {\n\t\t\tif (error instanceof Error) {\n\t\t\t\tthrow new Meteor.Error(error.message);\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t});\n\t}\n\n\tasync executeTriggerUrl(url, trigger, { event, message, room, owner, user }, theHistoryId, tries = 0) {\n\t\tif (!this.isTriggerEnabled(trigger)) {\n\t\t\toutgoingLogger.warn(`The trigger \"${trigger.name}\" is no longer enabled, stopping execution of it at try: ${tries}`);\n\t\t\treturn;\n\t\t}\n\n\t\toutgoingLogger.debug(`Starting to execute trigger: ${trigger.name} (${trigger._id})`);\n\n\t\tlet word;\n\t\t// Not all triggers/events support triggerWords\n\t\tif (outgoingEvents[event].use.triggerWords) {\n\t\t\tif (trigger.triggerWords && trigger.triggerWords.length > 0) {\n\t\t\t\tfor (const triggerWord of trigger.triggerWords) {\n\t\t\t\t\tif (!trigger.triggerWordAnywhere && message.msg.indexOf(triggerWord) === 0) {\n\t\t\t\t\t\tword = triggerWord;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (trigger.triggerWordAnywhere && message.msg.includes(triggerWord)) {\n\t\t\t\t\t\tword = triggerWord;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Stop if there are triggerWords but none match\n\t\t\t\tif (!word) {\n\t\t\t\t\toutgoingLogger.debug(`The trigger word which \"${trigger.name}\" was expecting could not be found, not executing.`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (message && message.editedAt && !trigger.runOnEdits) {\n\t\t\toutgoingLogger.debug(`The trigger \"${trigger.name}\"'s run on edits is disabled and the message was edited.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst historyId = await updateHistory({\n\t\t\tstep: 'start-execute-trigger-url',\n\t\t\tintegration: trigger,\n\t\t\tevent,\n\t\t});\n\n\t\tconst data = {\n\t\t\ttoken: trigger.token,\n\t\t\tbot: false,\n\t\t};\n\n\t\tif (word) {\n\t\t\tdata.trigger_word = word;\n\t\t}\n\n\t\tthis.mapEventArgsToData(data, { trigger, event, message, room, owner, user });\n\t\tawait updateHistory({ historyId, step: 'mapped-args-to-data', data, triggerWord: word });\n\n\t\toutgoingLogger.info(`Will be executing the Integration \"${trigger.name}\" to the url: ${url}`);\n\t\toutgoingLogger.debug({ data });\n\n\t\tconst scriptEngine = this.getEngine(trigger);\n\n\t\tconst opts = await this.wrapScriptEngineCall(() =>\n\t\t\tscriptEngine.prepareOutgoingRequest({\n\t\t\t\tintegration: trigger,\n\t\t\t\tdata,\n\t\t\t\turl,\n\t\t\t\thistoryId,\n\t\t\t}),\n\t\t);\n\n\t\tawait updateHistory({ historyId, step: 'after-maybe-ran-prepare', ranPrepareScript: true });\n\n\t\tif (!opts) {\n\t\t\tawait updateHistory({ historyId, step: 'after-prepare-no-opts', finished: true });\n\t\t\treturn;\n\t\t}\n\n\t\tif (opts.message) {\n\t\t\tconst prepareMessage = await this.sendMessage({ trigger, room, message: opts.message, data });\n\t\t\tawait updateHistory({\n\t\t\t\thistoryId,\n\t\t\t\tstep: 'after-prepare-send-message',\n\t\t\t\tprepareSentMessage: prepareMessage,\n\t\t\t});\n\t\t}\n\n\t\tif (!opts.url || !opts.method) {\n\t\t\tawait updateHistory({ historyId, step: 'after-prepare-no-url_or_method', finished: true });\n\t\t\treturn;\n\t\t}\n\n\t\t// based on HTTP.call implementation\n\t\tif (opts.auth) {\n\t\t\tif (opts.auth.indexOf(':') < 0) {\n\t\t\t\tthrow new Error('auth option should be of the form \"username:password\"');\n\t\t\t}\n\n\t\t\tconst base64 = Buffer.from(opts.auth, 'ascii').toString('base64');\n\t\t\topts.headers.Authorization = `Basic ${base64}`;\n\t\t}\n\n\t\tawait updateHistory({\n\t\t\thistoryId,\n\t\t\tstep: 'pre-http-call',\n\t\t\turl: opts.url,\n\t\t\thttpCallData: opts.data,\n\t\t});\n\n\t\tif (opts.data) {\n\t\t\topts.headers['Content-Type'] = 'application/json';\n\t\t}\n\n\t\tfetch(\n\t\t\topts.url,\n\t\t\t{\n\t\t\t\tmethod: opts.method,\n\t\t\t\theaders: opts.headers,\n\t\t\t\t...(opts.timeout && { timeout: opts.timeout }),\n\t\t\t\t...(opts.data && { body: opts.data }),\n\t\t\t},\n\t\t\tsettings.get('Allow_Invalid_SelfSigned_Certs'),\n\t\t)\n\t\t\t.then(async (res) => {\n\t\t\t\tconst content = await res.text();\n\t\t\t\tif (!content) {\n\t\t\t\t\toutgoingLogger.warn(`Result for the Integration ${trigger.name} to ${url} is empty`);\n\t\t\t\t} else {\n\t\t\t\t\toutgoingLogger.info(`Status code for the Integration ${trigger.name} to ${url} is ${res.status}`);\n\t\t\t\t}\n\n\t\t\t\tconst data = (() => {\n\t\t\t\t\tconst contentType = (res.headers.get('content-type') || '').split(';')[0];\n\t\t\t\t\tif (!['application/json', 'text/javascript', 'application/javascript', 'application/x-javascript'].includes(contentType)) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn JSON.parse(content);\n\t\t\t\t\t} catch (_error) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t})();\n\n\t\t\t\tawait updateHistory({\n\t\t\t\t\thistoryId,\n\t\t\t\t\tstep: 'after-http-call',\n\t\t\t\t\thttpError: null,\n\t\t\t\t\thttpResult: content,\n\t\t\t\t});\n\n\t\t\t\tconst responseContent = await this.wrapScriptEngineCall(() =>\n\t\t\t\t\tscriptEngine.processOutgoingResponse({\n\t\t\t\t\t\tintegration: trigger,\n\t\t\t\t\t\trequest: opts,\n\t\t\t\t\t\tresponse: res,\n\t\t\t\t\t\tcontent,\n\t\t\t\t\t\thistoryId,\n\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\tif (responseContent) {\n\t\t\t\t\tconst resultMessage = await this.sendMessage({\n\t\t\t\t\t\ttrigger,\n\t\t\t\t\t\troom,\n\t\t\t\t\t\tmessage: responseContent,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t});\n\t\t\t\t\tawait updateHistory({\n\t\t\t\t\t\thistoryId,\n\t\t\t\t\t\tstep: 'after-process-send-message',\n\t\t\t\t\t\tprocessSentMessage: resultMessage,\n\t\t\t\t\t\tfinished: true,\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (responseContent === false) {\n\t\t\t\t\tawait updateHistory({ historyId, step: 'after-process-false-result', finished: true });\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// if the result contained nothing or wasn't a successful statusCode\n\t\t\t\tif (!content || !this.successResults.includes(res.status)) {\n\t\t\t\t\tif (content) {\n\t\t\t\t\t\toutgoingLogger.error({\n\t\t\t\t\t\t\tmsg: `Error for the Integration \"${trigger.name}\" to ${url}`,\n\t\t\t\t\t\t\tresult: content,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (res.status === 410) {\n\t\t\t\t\t\t\tawait updateHistory({ historyId, step: 'after-process-http-status-410', error: true });\n\t\t\t\t\t\t\toutgoingLogger.error(`Disabling the Integration \"${trigger.name}\" because the status code was 401 (Gone).`);\n\t\t\t\t\t\t\tawait Integrations.updateOne({ _id: trigger._id }, { $set: { enabled: false } });\n\t\t\t\t\t\t\tvoid notifyOnIntegrationChangedById(trigger._id);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (res.status === 500) {\n\t\t\t\t\t\t\tawait updateHistory({ historyId, step: 'after-process-http-status-500', error: true });\n\t\t\t\t\t\t\toutgoingLogger.error({\n\t\t\t\t\t\t\t\tmsg: `Error \"500\" for the Integration \"${trigger.name}\" to ${url}.`,\n\t\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (trigger.retryFailedCalls) {\n\t\t\t\t\t\tif (tries < trigger.retryCount && trigger.retryDelay) {\n\t\t\t\t\t\t\tawait updateHistory({ historyId, error: true, step: `going-to-retry-${tries + 1}` });\n\n\t\t\t\t\t\t\tlet waitTime;\n\n\t\t\t\t\t\t\tswitch (trigger.retryDelay) {\n\t\t\t\t\t\t\t\tcase 'powers-of-ten':\n\t\t\t\t\t\t\t\t\t// Try again in 0.1s, 1s, 10s, 1m40s, 16m40s, 2h46m40s, 27h46m40s, etc\n\t\t\t\t\t\t\t\t\twaitTime = Math.pow(10, tries + 2);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'powers-of-two':\n\t\t\t\t\t\t\t\t\t// 2 seconds, 4 seconds, 8 seconds\n\t\t\t\t\t\t\t\t\twaitTime = Math.pow(2, tries + 1) * 1000;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'increments-of-two':\n\t\t\t\t\t\t\t\t\t// 2 second, 4 seconds, 6 seconds, etc\n\t\t\t\t\t\t\t\t\twaitTime = (tries + 1) * 2 * 1000;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tconst er = new Error(\"The integration's retryDelay setting is invalid.\");\n\t\t\t\t\t\t\t\t\tawait updateHistory({\n\t\t\t\t\t\t\t\t\t\thistoryId,\n\t\t\t\t\t\t\t\t\t\tstep: 'failed-and-retry-delay-is-invalid',\n\t\t\t\t\t\t\t\t\t\terror: true,\n\t\t\t\t\t\t\t\t\t\terrorStack: er.stack,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutgoingLogger.info(`Trying the Integration ${trigger.name} to ${url} again in ${waitTime} milliseconds.`);\n\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\tvoid this.executeTriggerUrl(url, trigger, { event, message, room, owner, user }, historyId, tries + 1);\n\t\t\t\t\t\t\t}, waitTime);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tawait updateHistory({ historyId, step: 'too-many-retries', error: true });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tawait updateHistory({\n\t\t\t\t\t\t\thistoryId,\n\t\t\t\t\t\t\tstep: 'failed-and-not-configured-to-retry',\n\t\t\t\t\t\t\terror: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// process outgoing webhook response as a new message\n\t\t\t\tif (content && this.successResults.includes(res.status)) {\n\t\t\t\t\tif (data?.text || data?.attachments) {\n\t\t\t\t\t\tconst resultMsg = await this.sendMessage({ trigger, room, message: data, data });\n\t\t\t\t\t\tawait updateHistory({\n\t\t\t\t\t\t\thistoryId,\n\t\t\t\t\t\t\tstep: 'url-response-sent-message',\n\t\t\t\t\t\t\tresultMessage: resultMsg,\n\t\t\t\t\t\t\tfinished: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(async (error) => {\n\t\t\t\toutgoingLogger.error(error);\n\t\t\t\tawait updateHistory({\n\t\t\t\t\thistoryId,\n\t\t\t\t\tstep: 'after-http-call',\n\t\t\t\t\thttpError: error,\n\t\t\t\t\thttpResult: null,\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\tasync replay(integration, history) {\n\t\tif (!integration || integration.type !== 'webhook-outgoing') {\n\t\t\tthrow new Meteor.Error('integration-type-must-be-outgoing', 'The integration type to replay must be an outgoing webhook.');\n\t\t}\n\n\t\tif (!history || !history.data) {\n\t\t\tthrow new Meteor.Error('history-data-must-be-defined', 'The history data must be defined to replay an integration.');\n\t\t}\n\n\t\tconst { event } = history;\n\t\tconst message = await Messages.findOneById(history.data.message_id);\n\t\tconst room = await Rooms.findOneById(history.data.channel_id);\n\t\tconst user = await Users.findOneById(history.data.user_id);\n\t\tlet owner;\n\n\t\tif (history.data.owner && history.data.owner._id) {\n\t\t\towner = await Users.findOneById(history.data.owner._id);\n\t\t}\n\n\t\treturn this.executeTriggerUrl(history.url, integration, { event, message, room, owner, user });\n\t}\n}\nconst triggerHandler = new RocketChatIntegrationHandler();\nexport { triggerHandler };\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"a4f325d19136a8e59d936edfaebce8291fbf0395"}
