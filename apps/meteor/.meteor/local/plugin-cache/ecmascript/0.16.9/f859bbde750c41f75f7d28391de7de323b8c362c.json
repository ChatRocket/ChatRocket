{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/federation/server/lib/dns.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"app/federation/server/lib/dns.js","filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/federation/server/lib/dns.js","targets":{"android":"125.0.0","chrome":"125.0.0","edge":"125.0.0","firefox":"115.0.0","ie":"10.0.0","ios":"17.4.0","opera":"110.0.0","opera_mobile":"80.0.0","safari":"17.4.0","samsung":"24.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","root":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/guilhermegazzo/dev/Rocket.Chat/apps/meteor/app/federation/server/lib/dns.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/federation/server/lib/dns.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    module.export({\n      registerWithHub: () => registerWithHub,\n      search: () => search\n    });\n    let dnsResolver;\n    module.link(\"dns\", {\n      default(v) {\n        dnsResolver = v;\n      }\n    }, 0);\n    let util;\n    module.link(\"util\", {\n      default(v) {\n        util = v;\n      }\n    }, 1);\n    let mem;\n    module.link(\"mem\", {\n      default(v) {\n        mem = v;\n      }\n    }, 2);\n    let federationRequest;\n    module.link(\"./http\", {\n      federationRequest(v) {\n        federationRequest = v;\n      }\n    }, 3);\n    let isFederationEnabled;\n    module.link(\"./isFederationEnabled\", {\n      isFederationEnabled(v) {\n        isFederationEnabled = v;\n      }\n    }, 4);\n    let dnsLogger;\n    module.link(\"./logger\", {\n      dnsLogger(v) {\n        dnsLogger = v;\n      }\n    }, 5);\n    let federationErrors;\n    module.link(\"../functions/errors\", {\n      \"*\"(v) {\n        federationErrors = v;\n      }\n    }, 6);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    const dnsResolveSRV = util.promisify(dnsResolver.resolveSrv);\n    const dnsResolveTXT = util.promisify(dnsResolver.resolveTxt);\n    const cacheMaxAge = 3600000; // one hour\n    const memoizedDnsResolveSRV = mem(dnsResolveSRV, {\n      maxAge: cacheMaxAge\n    });\n    const memoizedDnsResolveTXT = mem(dnsResolveTXT, {\n      maxAge: cacheMaxAge\n    });\n    const hubUrl = process.env.NODE_ENV === 'development' ? 'http://localhost:8080' : 'https://hub.rocket.chat';\n    async function registerWithHub(peerDomain, url, publicKey) {\n      const body = {\n        domain: peerDomain,\n        url,\n        public_key: publicKey\n      };\n      try {\n        // If there is no DNS entry for that, get from the Hub\n        await federationRequest('POST', \"\".concat(hubUrl, \"/api/v1/peers\"), body);\n        return true;\n      } catch (err) {\n        dnsLogger.error(err);\n        throw federationErrors.peerCouldNotBeRegisteredWithHub('dns.registerWithHub');\n      }\n    }\n    async function searchHub(peerDomain) {\n      try {\n        dnsLogger.debug(\"searchHub: peerDomain=\".concat(peerDomain));\n\n        // If there is no DNS entry for that, get from the Hub\n        const {\n          data: {\n            peer\n          }\n        } = await federationRequest('GET', \"\".concat(hubUrl, \"/api/v1/peers?search=\").concat(peerDomain));\n        if (!peer) {\n          dnsLogger.debug(\"searchHub: could not find peerDomain=\".concat(peerDomain));\n          throw federationErrors.peerCouldNotBeRegisteredWithHub('dns.registerWithHub');\n        }\n        const {\n          url,\n          public_key: publicKey\n        } = peer;\n        dnsLogger.debug(\"searchHub: found peerDomain=\".concat(peerDomain, \" url=\").concat(url));\n        return {\n          url,\n          peerDomain,\n          publicKey\n        };\n      } catch (err) {\n        dnsLogger.error(err);\n        throw federationErrors.peerNotFoundUsingDNS('dns.searchHub');\n      }\n    }\n    async function search(peerDomain) {\n      if (!isFederationEnabled()) {\n        throw federationErrors.disabled('dns.search');\n      }\n      dnsLogger.debug(\"search: peerDomain=\".concat(peerDomain));\n      let srvEntries = [];\n      let protocol = '';\n\n      // Search by HTTPS first\n      try {\n        dnsLogger.debug(\"search: peerDomain=\".concat(peerDomain, \" srv=_rocketchat._https.\").concat(peerDomain));\n        srvEntries = await memoizedDnsResolveSRV(\"_rocketchat._https.\".concat(peerDomain));\n        protocol = 'https';\n      } catch (err) {\n        // Ignore errors when looking for DNS entries\n      }\n\n      // If there is not entry, try with http\n      if (!srvEntries.length) {\n        try {\n          dnsLogger.debug(\"search: peerDomain=\".concat(peerDomain, \" srv=_rocketchat._http.\").concat(peerDomain));\n          srvEntries = await memoizedDnsResolveSRV(\"_rocketchat._http.\".concat(peerDomain));\n          protocol = 'http';\n        } catch (err) {\n          // Ignore errors when looking for DNS entries\n        }\n      }\n\n      // If there is not entry, try with tcp\n      if (!srvEntries.length) {\n        try {\n          dnsLogger.debug(\"search: peerDomain=\".concat(peerDomain, \" srv=_rocketchat._tcp.\").concat(peerDomain));\n          srvEntries = await memoizedDnsResolveSRV(\"_rocketchat._tcp.\".concat(peerDomain));\n          protocol = 'https'; // https is the default\n\n          // Then, also try to get the protocol\n          dnsLogger.debug(\"search: peerDomain=\".concat(peerDomain, \" txt=rocketchat-tcp-protocol.\").concat(peerDomain));\n          protocol = await memoizedDnsResolveSRV(\"rocketchat-tcp-protocol.\".concat(peerDomain));\n          protocol = protocol[0].join('');\n          if (protocol !== 'http' && protocol !== 'https') {\n            protocol = null;\n          }\n        } catch (err) {\n          // if there is an error while getting the _tcp entry, it means the config is not there\n          // but if there is an error looking for the `_rocketchat_tcp_protocol` entry, it means we should use https\n        }\n      }\n      const [srvEntry] = srvEntries;\n\n      // If there is no entry, throw error\n      if (!srvEntry || !protocol) {\n        dnsLogger.debug({\n          msg: 'search: could not find valid SRV entry',\n          peerDomain,\n          srvEntry,\n          protocol\n        });\n        return searchHub(peerDomain);\n      }\n      let publicKey = null;\n\n      // Get the public key from the TXT record\n      try {\n        dnsLogger.debug(\"search: peerDomain=\".concat(peerDomain, \" txt=rocketchat-public-key.\").concat(peerDomain));\n        const publicKeyTxtRecords = await memoizedDnsResolveTXT(\"rocketchat-public-key.\".concat(peerDomain));\n\n        // Join the TXT record, that might be split\n        publicKey = publicKeyTxtRecords[0].join('');\n      } catch (err) {\n        // Ignore errors when looking for DNS entries\n      }\n\n      // If there is no entry, throw error\n      if (!publicKey) {\n        dnsLogger.debug(\"search: could not find TXT entry for peerDomain=\".concat(peerDomain, \" - SRV entry found\"));\n        return searchHub(peerDomain);\n      }\n      dnsLogger.debug({\n        msg: 'search: found',\n        peerDomain,\n        srvEntry,\n        protocol\n      });\n      return {\n        url: \"\".concat(protocol, \"://\").concat(srvEntry.name, \":\").concat(srvEntry.port),\n        peerDomain,\n        publicKey\n      };\n    }\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["module","export","registerWithHub","search","dnsResolver","link","default","v","util","mem","federationRequest","isFederationEnabled","dnsLogger","federationErrors","*","__reifyWaitForDeps__","dnsResolveSRV","promisify","resolveSrv","dnsResolveTXT","resolveTxt","cacheMaxAge","memoizedDnsResolveSRV","maxAge","memoizedDnsResolveTXT","hubUrl","process","env","NODE_ENV","peerDomain","url","publicKey","body","domain","public_key","concat","err","error","peerCouldNotBeRegisteredWithHub","searchHub","debug","data","peer","peerNotFoundUsingDNS","disabled","srvEntries","protocol","length","join","srvEntry","msg","publicKeyTxtRecords","name","port","__reify_async_result__","_reifyError","self","async"],"sources":["app/federation/server/lib/dns.js"],"sourcesContent":["import dnsResolver from 'dns';\nimport util from 'util';\n\nimport mem from 'mem';\n\nimport { federationRequest } from './http';\nimport { isFederationEnabled } from './isFederationEnabled';\nimport { dnsLogger } from './logger';\nimport * as federationErrors from '../functions/errors';\n\nconst dnsResolveSRV = util.promisify(dnsResolver.resolveSrv);\nconst dnsResolveTXT = util.promisify(dnsResolver.resolveTxt);\n\nconst cacheMaxAge = 3600000; // one hour\nconst memoizedDnsResolveSRV = mem(dnsResolveSRV, { maxAge: cacheMaxAge });\nconst memoizedDnsResolveTXT = mem(dnsResolveTXT, { maxAge: cacheMaxAge });\n\nconst hubUrl = process.env.NODE_ENV === 'development' ? 'http://localhost:8080' : 'https://hub.rocket.chat';\n\nexport async function registerWithHub(peerDomain, url, publicKey) {\n\tconst body = { domain: peerDomain, url, public_key: publicKey };\n\n\ttry {\n\t\t// If there is no DNS entry for that, get from the Hub\n\t\tawait federationRequest('POST', `${hubUrl}/api/v1/peers`, body);\n\n\t\treturn true;\n\t} catch (err) {\n\t\tdnsLogger.error(err);\n\n\t\tthrow federationErrors.peerCouldNotBeRegisteredWithHub('dns.registerWithHub');\n\t}\n}\n\nasync function searchHub(peerDomain) {\n\ttry {\n\t\tdnsLogger.debug(`searchHub: peerDomain=${peerDomain}`);\n\n\t\t// If there is no DNS entry for that, get from the Hub\n\t\tconst {\n\t\t\tdata: { peer },\n\t\t} = await federationRequest('GET', `${hubUrl}/api/v1/peers?search=${peerDomain}`);\n\n\t\tif (!peer) {\n\t\t\tdnsLogger.debug(`searchHub: could not find peerDomain=${peerDomain}`);\n\t\t\tthrow federationErrors.peerCouldNotBeRegisteredWithHub('dns.registerWithHub');\n\t\t}\n\n\t\tconst { url, public_key: publicKey } = peer;\n\n\t\tdnsLogger.debug(`searchHub: found peerDomain=${peerDomain} url=${url}`);\n\n\t\treturn {\n\t\t\turl,\n\t\t\tpeerDomain,\n\t\t\tpublicKey,\n\t\t};\n\t} catch (err) {\n\t\tdnsLogger.error(err);\n\n\t\tthrow federationErrors.peerNotFoundUsingDNS('dns.searchHub');\n\t}\n}\n\nexport async function search(peerDomain) {\n\tif (!isFederationEnabled()) {\n\t\tthrow federationErrors.disabled('dns.search');\n\t}\n\n\tdnsLogger.debug(`search: peerDomain=${peerDomain}`);\n\n\tlet srvEntries = [];\n\tlet protocol = '';\n\n\t// Search by HTTPS first\n\ttry {\n\t\tdnsLogger.debug(`search: peerDomain=${peerDomain} srv=_rocketchat._https.${peerDomain}`);\n\t\tsrvEntries = await memoizedDnsResolveSRV(`_rocketchat._https.${peerDomain}`);\n\t\tprotocol = 'https';\n\t} catch (err) {\n\t\t// Ignore errors when looking for DNS entries\n\t}\n\n\t// If there is not entry, try with http\n\tif (!srvEntries.length) {\n\t\ttry {\n\t\t\tdnsLogger.debug(`search: peerDomain=${peerDomain} srv=_rocketchat._http.${peerDomain}`);\n\t\t\tsrvEntries = await memoizedDnsResolveSRV(`_rocketchat._http.${peerDomain}`);\n\t\t\tprotocol = 'http';\n\t\t} catch (err) {\n\t\t\t// Ignore errors when looking for DNS entries\n\t\t}\n\t}\n\n\t// If there is not entry, try with tcp\n\tif (!srvEntries.length) {\n\t\ttry {\n\t\t\tdnsLogger.debug(`search: peerDomain=${peerDomain} srv=_rocketchat._tcp.${peerDomain}`);\n\t\t\tsrvEntries = await memoizedDnsResolveSRV(`_rocketchat._tcp.${peerDomain}`);\n\t\t\tprotocol = 'https'; // https is the default\n\n\t\t\t// Then, also try to get the protocol\n\t\t\tdnsLogger.debug(`search: peerDomain=${peerDomain} txt=rocketchat-tcp-protocol.${peerDomain}`);\n\t\t\tprotocol = await memoizedDnsResolveSRV(`rocketchat-tcp-protocol.${peerDomain}`);\n\t\t\tprotocol = protocol[0].join('');\n\n\t\t\tif (protocol !== 'http' && protocol !== 'https') {\n\t\t\t\tprotocol = null;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t// if there is an error while getting the _tcp entry, it means the config is not there\n\t\t\t// but if there is an error looking for the `_rocketchat_tcp_protocol` entry, it means we should use https\n\t\t}\n\t}\n\n\tconst [srvEntry] = srvEntries;\n\n\t// If there is no entry, throw error\n\tif (!srvEntry || !protocol) {\n\t\tdnsLogger.debug({\n\t\t\tmsg: 'search: could not find valid SRV entry',\n\t\t\tpeerDomain,\n\t\t\tsrvEntry,\n\t\t\tprotocol,\n\t\t});\n\t\treturn searchHub(peerDomain);\n\t}\n\n\tlet publicKey = null;\n\n\t// Get the public key from the TXT record\n\ttry {\n\t\tdnsLogger.debug(`search: peerDomain=${peerDomain} txt=rocketchat-public-key.${peerDomain}`);\n\t\tconst publicKeyTxtRecords = await memoizedDnsResolveTXT(`rocketchat-public-key.${peerDomain}`);\n\n\t\t// Join the TXT record, that might be split\n\t\tpublicKey = publicKeyTxtRecords[0].join('');\n\t} catch (err) {\n\t\t// Ignore errors when looking for DNS entries\n\t}\n\n\t// If there is no entry, throw error\n\tif (!publicKey) {\n\t\tdnsLogger.debug(`search: could not find TXT entry for peerDomain=${peerDomain} - SRV entry found`);\n\t\treturn searchHub(peerDomain);\n\t}\n\n\tdnsLogger.debug({ msg: 'search: found', peerDomain, srvEntry, protocol });\n\n\treturn {\n\t\turl: `${protocol}://${srvEntry.name}:${srvEntry.port}`,\n\t\tpeerDomain,\n\t\tpublicKey,\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"f859bbde750c41f75f7d28391de7de323b8c362c"}
