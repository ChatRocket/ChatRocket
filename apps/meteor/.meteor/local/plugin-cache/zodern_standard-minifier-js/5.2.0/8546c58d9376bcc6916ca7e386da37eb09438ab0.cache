{"code":"Package[\"core-runtime\"].queue(\"id-map\",function(){Package.meteor.Meteor,Package.meteor.global,Package.meteor.meteorEnv;var e,t=Package.ejson.EJSON,i=Package.modules.meteorInstall;return Package.promise.Promise,{export:function(){return{IdMap:e}},require:i({node_modules:{meteor:{\"id-map\":{\"id-map.js\":function e(e,i,a){a.export({IdMap:()=>s});class s{constructor(e,t){this._map=new Map,this._idStringify=e||JSON.stringify,this._idParse=t||JSON.parse}get(e){let t=this._idStringify(e);return this._map.get(t)}set(e,t){let i=this._idStringify(e);this._map.set(i,t)}remove(e){let t=this._idStringify(e);this._map.delete(t)}has(e){let t=this._idStringify(e);return this._map.has(t)}empty(){return 0===this._map.size}clear(){this._map.clear()}forEach(e){for(let[t,i]of this._map){let a=e.call(null,i,this._idParse(t));if(!1===a)return}}async forEachAsync(e){for(let[t,i]of this._map){let a=await e.call(null,i,this._idParse(t));if(!1===a)return}}size(){return this._map.size}setDefault(e,t){let i=this._idStringify(e);return this._map.has(i)?this._map.get(i):(this._map.set(i,t),t)}clone(){let e=new s(this._idStringify,this._idParse);return this._map.forEach(function(i,a){e._map.set(a,t.clone(i))}),e}}}}}}},{extensions:[\".js\",\".json\"]}),eagerModulePaths:[\"/node_modules/meteor/id-map/id-map.js\"],mainModulePath:\"/node_modules/meteor/id-map/id-map.js\"}});","map":"{\"version\":3,\"sources\":[\"packages/id-map/id-map.js\",\"<anon>\"],\"sourcesContent\":[\"\\nexport class IdMap {\\n  constructor(idStringify, idParse) {\\n    this._map = new Map();\\n    this._idStringify = idStringify || JSON.stringify;\\n    this._idParse = idParse || JSON.parse;\\n  }\\n\\n// Some of these methods are designed to match methods on OrderedDict, since\\n// (eg) ObserveMultiplex and _CachingChangeObserver use them interchangeably.\\n// (Conceivably, this should be replaced with \\\"UnorderedDict\\\" with a specific\\n// set of methods that overlap between the two.)\\n\\n  get(id) {\\n    const key = this._idStringify(id);\\n    return this._map.get(key);\\n  }\\n\\n  set(id, value) {\\n    const key = this._idStringify(id);\\n    this._map.set(key, value);\\n  }\\n\\n  remove(id) {\\n    const key = this._idStringify(id);\\n    this._map.delete(key);\\n  }\\n\\n  has(id) {\\n    const key = this._idStringify(id);\\n    return this._map.has(key);\\n  }\\n\\n  empty() {\\n    return this._map.size === 0;\\n  }\\n\\n  clear() {\\n    this._map.clear();\\n  }\\n\\n  // Iterates over the items in the map. Return `false` to break the loop.\\n  forEach(iterator) {\\n    // don't use _.each, because we can't break out of it.\\n    for (let [key, value] of this._map){\\n      const breakIfFalse = iterator.call(\\n        null,\\n        value,\\n        this._idParse(key)\\n      );\\n      if (breakIfFalse === false) {\\n        return;\\n      }\\n    }\\n  }\\n\\n  async forEachAsync(iterator) {\\n    for (let [key, value] of this._map){\\n      const breakIfFalse = await iterator.call(\\n          null,\\n          value,\\n          this._idParse(key)\\n      );\\n      if (breakIfFalse === false) {\\n        return;\\n      }\\n    }\\n  }\\n\\n  size() {\\n    return this._map.size;\\n  }\\n\\n  setDefault(id, def) {\\n    const key = this._idStringify(id);\\n    if (this._map.has(key)) {\\n      return this._map.get(key);\\n    }\\n    this._map.set(key, def);\\n    return def;\\n  }\\n\\n  // Assumes that values are EJSON-cloneable, and that we don't need to clone\\n  // IDs (ie, that nobody is going to mutate an ObjectId).\\n  clone() {\\n    const clone = new IdMap(this._idStringify, this._idParse);\\n    // copy directly to avoid stringify/parse overhead\\n    this._map.forEach(function(value, key){\\n      clone._map.set(key, EJSON.clone(value));\\n    });\\n    return clone;\\n  }\\n}\\n\",null],\"names\":[\"module\",\"export\",\"IdMap\",\"constructor\",\"idStringify\",\"idParse\",\"_map\",\"Map\",\"_idStringify\",\"JSON\",\"stringify\",\"_idParse\",\"parse\",\"get\",\"id\",\"key\",\"set\",\"value\",\"remove\",\"delete\",\"has\",\"empty\",\"size\",\"clear\",\"forEach\",\"iterator\",\"breakIfFalse\",\"call\",\"forEachAsync\",\"setDefault\",\"def\",\"clone\",\"EJSON\"],\"mappings\":\"+TAAAA,EAAOC,MAAM,CAAC,CAACC,MAAMA,IAAIA,CAAK,EACvB,OAAMA,EACXC,YAAYC,CAAW,CAAEC,CAAO,CAAE,CAChC,IAAI,CAACC,IAAI,CAAG,IAAIC,IAChB,IAAI,CAACC,YAAY,CAAGJ,GAAeK,KAAKC,SAAS,CACjD,IAAI,CAACC,QAAQ,CAAGN,GAAWI,KAAKG,KAAK,AACvC,CAOAC,IAAIC,CAAE,CAAE,CACN,IAAMC,EAAM,IAAI,CAACP,YAAY,CAACM,GAC9B,OAAO,IAAI,CAACR,IAAI,CAACO,GAAG,CAACE,EACvB,CAEAC,IAAIF,CAAE,CAAEG,CAAK,CAAE,CACb,IAAMF,EAAM,IAAI,CAACP,YAAY,CAACM,GAC9B,IAAI,CAACR,IAAI,CAACU,GAAG,CAACD,EAAKE,EACrB,CAEAC,OAAOJ,CAAE,CAAE,CACT,IAAMC,EAAM,IAAI,CAACP,YAAY,CAACM,GAC9B,IAAI,CAACR,IAAI,CAACa,MAAM,CAACJ,EACnB,CAEAK,IAAIN,CAAE,CAAE,CACN,IAAMC,EAAM,IAAI,CAACP,YAAY,CAACM,GAC9B,OAAO,IAAI,CAACR,IAAI,CAACc,GAAG,CAACL,EACvB,CAEAM,OAAQ,CACN,OAAO,AAAmB,IAAnB,IAAI,CAACf,IAAI,CAACgB,IAAI,AACvB,CAEAC,OAAQ,CACN,IAAI,CAACjB,IAAI,CAACiB,KAAK,EACjB,CAGAC,QAAQC,CAAQ,CAAE,CAEhB,IAAK,GAAI,CAACV,EAAKE,EAAM,GAAI,IAAI,CAACX,IAAI,CAAC,CACjC,IAAMoB,EAAeD,EAASE,IAAI,CAChC,KACAV,EACA,IAAI,CAACN,QAAQ,CAACI,IAEhB,GAAIW,AAAiB,CAAA,IAAjBA,EACF,MAEJ,CACF,CAEA,MAAME,aAAaH,CAAQ,CAAE,CAC3B,IAAK,GAAI,CAACV,EAAKE,EAAM,GAAI,IAAI,CAACX,IAAI,CAAC,CACjC,IAAMoB,EAAe,MAAMD,EAASE,IAAI,CACpC,KACAV,EACA,IAAI,CAACN,QAAQ,CAACI,IAElB,GAAIW,AAAiB,CAAA,IAAjBA,EACF,MAEJ,CACF,CAEAJ,MAAO,CACL,OAAO,IAAI,CAAChB,IAAI,CAACgB,IAAI,AACvB,CAEAO,WAAWf,CAAE,CAAEgB,CAAG,CAAE,CAClB,IAAMf,EAAM,IAAI,CAACP,YAAY,CAACM,UAC9B,AAAI,IAAI,CAACR,IAAI,CAACc,GAAG,CAACL,GACT,IAAI,CAACT,IAAI,CAACO,GAAG,CAACE,IAEvB,IAAI,CAACT,IAAI,CAACU,GAAG,CAACD,EAAKe,GACZA,EACT,CAIAC,OAAQ,CACN,IAAMA,EAAQ,IAAI7B,EAAM,IAAI,CAACM,YAAY,CAAE,IAAI,CAACG,QAAQ,EAKxD,OAHA,IAAI,CAACL,IAAI,CAACkB,OAAO,CAAC,SAASP,CAAK,CAAEF,CAAG,EACnCgB,EAAMzB,IAAI,CAACU,GAAG,CAACD,EAAKiB,EAAMD,KAAK,CAACd,GAClC,GACOc,CACT,CACF\"}"}