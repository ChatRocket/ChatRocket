{"code":"function module(e,t){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.useTranslation=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{i18n:o}=t,{i18n:i,defaultNS:u}=(0,n.useContext)(r.I18nContext)||{},l=o||i||(0,r.getI18n)();if(l&&!l.reportNamespaces&&(l.reportNamespaces=new r.ReportNamespaces),!l){(0,a.warnOnce)(\"You will need to pass in an i18next instance by using initReactI18next\");let e=(e,t)=>\"string\"==typeof t?t:t&&\"object\"==typeof t&&\"string\"==typeof t.defaultValue?t.defaultValue:Array.isArray(e)?e[e.length-1]:e,t=[e,{},!1];return t.t=e,t.i18n={},t.ready=!1,t}l.options.react&&void 0!==l.options.react.wait&&(0,a.warnOnce)(\"It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.\");let c={...(0,r.getDefaults)(),...l.options.react,...t},{useSuspense:f,keyPrefix:p}=c,d=e||u||l.options&&l.options.defaultNS;d=\"string\"==typeof d?[d]:d||[\"translation\"],l.reportNamespaces.addUsedNamespaces&&l.reportNamespaces.addUsedNamespaces(d);let g=(l.isInitialized||l.initializedStoreOnce)&&d.every(e=>(0,a.hasLoadedNamespace)(e,l,c));function m(){return l.getFixedT(t.lng||null,\"fallback\"===c.nsMode?d:d[0],p)}let[y,N]=(0,n.useState)(m),h=d.join();t.lng&&(h=`${t.lng}${h}`);let w=s(h),v=(0,n.useRef)(!0);(0,n.useEffect)(()=>{let{bindI18n:e,bindI18nStore:n}=c;function r(){v.current&&N(m)}return v.current=!0,g||f||(t.lng?(0,a.loadLanguages)(l,t.lng,d,()=>{v.current&&N(m)}):(0,a.loadNamespaces)(l,d,()=>{v.current&&N(m)})),g&&w&&w!==h&&v.current&&N(m),e&&l&&l.on(e,r),n&&l&&l.store.on(n,r),()=>{v.current=!1,e&&l&&e.split(\" \").forEach(e=>l.off(e,r)),n&&l&&n.split(\" \").forEach(e=>l.store.off(e,r))}},[l,h]);let x=(0,n.useRef)(!0);(0,n.useEffect)(()=>{v.current&&!x.current&&N(m),x.current=!1},[l,p]);let b=[y,l,g];if(b.t=y,b.i18n=l,b.ready=g,g||!g&&!f)return b;throw new Promise(e=>{t.lng?(0,a.loadLanguages)(l,t.lng,d,()=>e()):(0,a.loadNamespaces)(l,d,()=>e())})};var n=e(\"react\"),r=e(\"./context.js\"),a=e(\"./utils.js\");let s=(e,t)=>{let r=(0,n.useRef)();return(0,n.useEffect)(()=>{r.current=t?r.current:e},[e,t]),r.current}}","map":"{\"version\":3,\"sources\":[\"<anon>\"],\"names\":[],\"mappings\":\"\"}"}