{"code":"function module(e,s,a){let t,r,p,o,n;a.export({l:()=>i}),a.link(\"../../_virtual/index.mjs\",{__module(e){t=e}},0),a.link(\"./util.mjs\"),a.link(\"./types.mjs\",{t(e){r=e}},1),a.link(\"./sets.mjs\"),a.link(\"./positions.mjs\"),a.link(\"../../_virtual/util.mjs\",{__exports(e){p=e}},2),a.link(\"../../_virtual/sets.mjs\",{__exports(e){o=e}},3),a.link(\"../../_virtual/positions.mjs\",{__exports(e){n=e}},4);let l=p,c=r,u=o,h=n;t.exports=e=>{var s,a,t=0,r={type:c.ROOT,stack:[]},p=r,o=r.stack,n=[],i=s=>{l.error(e,\"Nothing to repeat at column \".concat(s-1))},k=l.strToChars(e);for(s=k.length;t<s;)switch(a=k[t++]){case\"\\\\\":switch(a=k[t++]){case\"b\":o.push(h.wordBoundary());break;case\"B\":o.push(h.nonWordBoundary());break;case\"w\":o.push(u.words());break;case\"W\":o.push(u.notWords());break;case\"d\":o.push(u.ints());break;case\"D\":o.push(u.notInts());break;case\"s\":o.push(u.whitespace());break;case\"S\":o.push(u.notWhitespace());break;default:/\\d/.test(a)?o.push({type:c.REFERENCE,value:parseInt(a,10)}):o.push({type:c.CHAR,value:a.charCodeAt(0)})}break;case\"^\":o.push(h.begin());break;case\"$\":o.push(h.end());break;case\"[\":\"^\"===k[t]?(m=!0,t++):m=!1;var m,b=l.tokenizeClass(k.slice(t),e);t+=b[1],o.push({type:c.SET,set:b[0],not:m});break;case\".\":o.push(u.anyChar());break;case\"(\":var d={type:c.GROUP,stack:[],remember:!0};\"?\"===(a=k[t])&&(a=k[t+1],t+=2,\"=\"===a?d.followedBy=!0:\"!\"===a?d.notFollowedBy=!0:\":\"!==a&&l.error(e,\"Invalid group, character '\".concat(a,\"'\")+\" after '?' at column \".concat(t-1)),d.remember=!1),o.push(d),n.push(p),p=d,o=d.stack;break;case\")\":0===n.length&&l.error(e,\"Unmatched ) at column \".concat(t-1)),o=(p=n.pop()).options?p.options[p.options.length-1]:p.stack;break;case\"|\":p.options||(p.options=[p.stack],delete p.stack);var v=[];p.options.push(v),o=v;break;case\"{\":var y,g,E=/^(\\d+)(,(\\d+)?)?\\}/.exec(k.slice(t));null!==E?(0===o.length&&i(t),y=parseInt(E[1],10),g=E[2]?E[3]?parseInt(E[3],10):1/0:y,t+=E[0].length,o.push({type:c.REPETITION,min:y,max:g,value:o.pop()})):o.push({type:c.CHAR,value:123});break;case\"?\":0===o.length&&i(t),o.push({type:c.REPETITION,min:0,max:1,value:o.pop()});break;case\"+\":0===o.length&&i(t),o.push({type:c.REPETITION,min:1,max:1/0,value:o.pop()});break;case\"*\":0===o.length&&i(t),o.push({type:c.REPETITION,min:0,max:1/0,value:o.pop()});break;default:o.push({type:c.CHAR,value:a.charCodeAt(0)})}return 0!==n.length&&l.error(e,\"Unterminated group\"),r},t.exports.types=c;var i=t.exports}","map":"{\"version\":3,\"sources\":[\"../../../node_modules/ret/lib/index.js\",\"<anon>\"],\"sourcesContent\":[\"const util      = require('./util');\\nconst types     = require('./types');\\nconst sets      = require('./sets');\\nconst positions = require('./positions');\\n\\n\\nmodule.exports = (regexpStr) => {\\n  var i = 0, l, c,\\n    start = { type: types.ROOT, stack: []},\\n\\n    // Keep track of last clause/group and stack.\\n    lastGroup = start,\\n    last = start.stack,\\n    groupStack = [];\\n\\n\\n  var repeatErr = (i) => {\\n    util.error(regexpStr, `Nothing to repeat at column ${i - 1}`);\\n  };\\n\\n  // Decode a few escaped characters.\\n  var str = util.strToChars(regexpStr);\\n  l = str.length;\\n\\n  // Iterate through each character in string.\\n  while (i < l) {\\n    c = str[i++];\\n\\n    switch (c) {\\n      // Handle escaped characters, inclues a few sets.\\n      case '\\\\\\\\':\\n        c = str[i++];\\n\\n        switch (c) {\\n          case 'b':\\n            last.push(positions.wordBoundary());\\n            break;\\n\\n          case 'B':\\n            last.push(positions.nonWordBoundary());\\n            break;\\n\\n          case 'w':\\n            last.push(sets.words());\\n            break;\\n\\n          case 'W':\\n            last.push(sets.notWords());\\n            break;\\n\\n          case 'd':\\n            last.push(sets.ints());\\n            break;\\n\\n          case 'D':\\n            last.push(sets.notInts());\\n            break;\\n\\n          case 's':\\n            last.push(sets.whitespace());\\n            break;\\n\\n          case 'S':\\n            last.push(sets.notWhitespace());\\n            break;\\n\\n          default:\\n            // Check if c is integer.\\n            // In which case it's a reference.\\n            if (/\\\\d/.test(c)) {\\n              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });\\n\\n            // Escaped character.\\n            } else {\\n              last.push({ type: types.CHAR, value: c.charCodeAt(0) });\\n            }\\n        }\\n\\n        break;\\n\\n\\n      // Positionals.\\n      case '^':\\n        last.push(positions.begin());\\n        break;\\n\\n      case '$':\\n        last.push(positions.end());\\n        break;\\n\\n\\n      // Handle custom sets.\\n      case '[':\\n        // Check if this class is 'anti' i.e. [^abc].\\n        var not;\\n        if (str[i] === '^') {\\n          not = true;\\n          i++;\\n        } else {\\n          not = false;\\n        }\\n\\n        // Get all the characters in class.\\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\\n\\n        // Increase index by length of class.\\n        i += classTokens[1];\\n        last.push({\\n          type: types.SET,\\n          set: classTokens[0],\\n          not,\\n        });\\n\\n        break;\\n\\n\\n      // Class of any character except \\\\n.\\n      case '.':\\n        last.push(sets.anyChar());\\n        break;\\n\\n\\n      // Push group onto stack.\\n      case '(':\\n        // Create group.\\n        var group = {\\n          type: types.GROUP,\\n          stack: [],\\n          remember: true,\\n        };\\n\\n        c = str[i];\\n\\n        // If if this is a special kind of group.\\n        if (c === '?') {\\n          c = str[i + 1];\\n          i += 2;\\n\\n          // Match if followed by.\\n          if (c === '=') {\\n            group.followedBy = true;\\n\\n          // Match if not followed by.\\n          } else if (c === '!') {\\n            group.notFollowedBy = true;\\n\\n          } else if (c !== ':') {\\n            util.error(regexpStr,\\n              `Invalid group, character '${c}'` +\\n              ` after '?' at column ${i - 1}`);\\n          }\\n\\n          group.remember = false;\\n        }\\n\\n        // Insert subgroup into current group stack.\\n        last.push(group);\\n\\n        // Remember the current group for when the group closes.\\n        groupStack.push(lastGroup);\\n\\n        // Make this new group the current group.\\n        lastGroup = group;\\n        last = group.stack;\\n        break;\\n\\n\\n      // Pop group out of stack.\\n      case ')':\\n        if (groupStack.length === 0) {\\n          util.error(regexpStr, `Unmatched ) at column ${i - 1}`);\\n        }\\n        lastGroup = groupStack.pop();\\n\\n        // Check if this group has a PIPE.\\n        // To get back the correct last stack.\\n        last = lastGroup.options ?\\n          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\\n        break;\\n\\n\\n      // Use pipe character to give more choices.\\n      case '|':\\n        // Create array where options are if this is the first PIPE\\n        // in this clause.\\n        if (!lastGroup.options) {\\n          lastGroup.options = [lastGroup.stack];\\n          delete lastGroup.stack;\\n        }\\n\\n        // Create a new stack and add to options for rest of clause.\\n        var stack = [];\\n        lastGroup.options.push(stack);\\n        last = stack;\\n        break;\\n\\n\\n      // Repetition.\\n      // For every repetition, remove last element from last stack\\n      // then insert back a RANGE object.\\n      // This design is chosen because there could be more than\\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\\n      case '{':\\n        var rs = /^(\\\\d+)(,(\\\\d+)?)?\\\\}/.exec(str.slice(i)), min, max;\\n        if (rs !== null) {\\n          if (last.length === 0) {\\n            repeatErr(i);\\n          }\\n          min = parseInt(rs[1], 10);\\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\\n          i += rs[0].length;\\n\\n          last.push({\\n            type: types.REPETITION,\\n            min,\\n            max,\\n            value: last.pop(),\\n          });\\n        } else {\\n          last.push({\\n            type: types.CHAR,\\n            value: 123,\\n          });\\n        }\\n        break;\\n\\n      case '?':\\n        if (last.length === 0) {\\n          repeatErr(i);\\n        }\\n        last.push({\\n          type: types.REPETITION,\\n          min: 0,\\n          max: 1,\\n          value: last.pop(),\\n        });\\n        break;\\n\\n      case '+':\\n        if (last.length === 0) {\\n          repeatErr(i);\\n        }\\n        last.push({\\n          type: types.REPETITION,\\n          min: 1,\\n          max: Infinity,\\n          value: last.pop(),\\n        });\\n        break;\\n\\n      case '*':\\n        if (last.length === 0) {\\n          repeatErr(i);\\n        }\\n        last.push({\\n          type: types.REPETITION,\\n          min: 0,\\n          max: Infinity,\\n          value: last.pop(),\\n        });\\n        break;\\n\\n\\n      // Default is a character that is not `\\\\[](){}?+*^$`.\\n      default:\\n        last.push({\\n          type: types.CHAR,\\n          value: c.charCodeAt(0),\\n        });\\n    }\\n\\n  }\\n\\n  // Check if any groups have not been closed.\\n  if (groupStack.length !== 0) {\\n    util.error(regexpStr, 'Unterminated group');\\n  }\\n\\n  return start;\\n};\\n\\nmodule.exports.types = types;\\n\",null],\"names\":[\"util\",\"util$1\",\"types\",\"types$1\",\"sets\",\"sets$1\",\"positions\",\"positions$1\",\"lib\",\"exports\",\"regexpStr\",\"l\",\"c\",\"i\",\"start\",\"type\",\"ROOT\",\"stack\",\"lastGroup\",\"last\",\"groupStack\",\"repeatErr\",\"error\",\"concat\",\"str\",\"strToChars\",\"length\",\"push\",\"wordBoundary\",\"nonWordBoundary\",\"words\",\"notWords\",\"ints\",\"notInts\",\"whitespace\",\"notWhitespace\",\"test\",\"REFERENCE\",\"value\",\"parseInt\",\"CHAR\",\"charCodeAt\",\"begin\",\"end\",\"not\",\"classTokens\",\"tokenizeClass\",\"slice\",\"SET\",\"set\",\"anyChar\",\"group\",\"GROUP\",\"remember\",\"followedBy\",\"notFollowedBy\",\"pop\",\"options\",\"min\",\"max\",\"rs\",\"exec\",\"Infinity\",\"REPETITION\"],\"mappings\":\"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\"}"}