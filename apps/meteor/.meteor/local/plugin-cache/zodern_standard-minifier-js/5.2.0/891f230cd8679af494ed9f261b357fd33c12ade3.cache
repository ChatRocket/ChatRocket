{"code":"Package[\"core-runtime\"].queue(\"session\",function(){Package.meteor.Meteor,Package.meteor.global,Package.meteor.meteorEnv,Package[\"reactive-dict\"].ReactiveDict,Package.ejson.EJSON;var e,s=Package.modules.meteorInstall;return Package.promise.Promise,{export:function(){return{Session:e}},require:s({node_modules:{meteor:{session:{\"session.js\":function e(e,s,o){let t;o.export({Session:()=>n}),o.link(\"meteor/reactive-dict\",{ReactiveDict(e){t=e}},0);let n=new t(\"session\")}}}}},{extensions:[\".js\",\".json\"]}),eagerModulePaths:[\"/node_modules/meteor/session/session.js\"],mainModulePath:\"/node_modules/meteor/session/session.js\"}});","map":"{\"version\":3,\"sources\":[\"packages/session/session.js\",\"<anon>\"],\"sourcesContent\":[\"import { ReactiveDict } from 'meteor/reactive-dict';\\n\\nexport const Session = new ReactiveDict('session');\\n\\n// Documentation here is really awkward because the methods are defined\\n// elsewhere\\n\\n/**\\n * @memberOf Session\\n * @method set\\n * @summary Set a variable in the session. Notify any listeners that the value\\n * has changed (eg: redraw templates, and rerun any\\n * [`Tracker.autorun`](#tracker_autorun) computations, that called\\n * [`Session.get`](#session_get) on this `key`.)\\n * @locus Client\\n * @param {String} key The key to set, eg, `selectedItem`\\n * @param {EJSONable | undefined} value The new value for `key`\\n */\\n\\n/**\\n * @memberOf Session\\n * @method setDefault\\n * @summary Set a variable in the session if it hasn't been set before.\\n * Otherwise works exactly the same as [`Session.set`](#session_set).\\n * @locus Client\\n * @param {String} key The key to set, eg, `selectedItem`\\n * @param {EJSONable | undefined} value The new value for `key`\\n */\\n\\n/**\\n * @memberOf Session\\n * @method get\\n * @summary Get the value of a session variable. If inside a [reactive\\n * computation](#reactivity), invalidate the computation the next time the\\n * value of the variable is changed by [`Session.set`](#session_set). This\\n * returns a clone of the session value, so if it's an object or an array,\\n * mutating the returned value has no effect on the value stored in the\\n * session.\\n * @locus Client\\n * @param {String} key The name of the session variable to return\\n */\\n\\n/**\\n * @memberOf Session\\n * @method equals\\n * @summary Test if a session variable is equal to a value. If inside a\\n * [reactive computation](#reactivity), invalidate the computation the next\\n * time the variable changes to or from the value.\\n * @locus Client\\n * @param {String} key The name of the session variable to test\\n * @param {String | Number | Boolean | null | undefined} value The value to\\n * test against\\n */\\n\",null],\"names\":[\"ReactiveDict\",\"module\",\"export\",\"Session\",\"link\",\"v\"],\"mappings\":\"0WAAyCA,EAAzCC,EAAOC,MAAM,CAAC,CAACC,QAAQA,IAAIA,CAAO,GAAoBF,EAAOG,IAAI,CAAC,uBAAuB,CAACJ,aAAaK,CAAC,EAAEL,EAAaK,CAAC,CAAC,EAAE,GAEpH,IAAMF,EAAU,IAAIH,EAAa\"}"}