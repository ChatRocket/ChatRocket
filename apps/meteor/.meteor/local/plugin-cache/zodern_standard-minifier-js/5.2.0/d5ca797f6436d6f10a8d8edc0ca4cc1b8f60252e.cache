{"code":"function module(e,t,i){let s,n,o,r,a,h,l,c,d,u,g,m,E,R,S,p;i.export({VoIPUser:()=>v}),i.link(\"@rocket.chat/core-typings\",{Operation(e){s=e},UserState(e){n=e},WorkflowTypes(e){o=e}},0),i.link(\"@rocket.chat/emitter\",{Emitter(e){r=e}},1),i.link(\"sip.js\",{UserAgent(e){a=e},Invitation(e){h=e},SessionState(e){l=e},Registerer(e){c=e},RequestPendingError(e){d=e},Inviter(e){u=e}},2),i.link(\"sip.js/lib/core\",{URI(e){g=e}},3),i.link(\"sip.js/lib/platform/web\",{SessionDescriptionHandler(e){m=e}},4),i.link(\"./Helper\",{toggleMediaStreamTracks(e){E=e}},5),i.link(\"./LocalStream\",{default(e){R=e}},6),i.link(\"./QueueAggregator\",{QueueAggregator(e){S=e}},7),i.link(\"./RemoteStream\",{default(e){p=e}},8);class v extends r{get operationInProgress(){return this._opInProgress}get userState(){return this._userState}constructor(e,t){super(),this.config=void 0,this.state={isReady:!1,enableVideo:!1},this.remoteStream=void 0,this.userAgentOptions={},this.userAgent=void 0,this.registerer=void 0,this.mediaStreamRendered=void 0,this._connectionState=\"INITIAL\",this._held=!1,this.mode=void 0,this.queueInfo=void 0,this.connectionRetryCount=void 0,this.stop=void 0,this.networkEmitter=void 0,this.offlineNetworkHandler=void 0,this.onlineNetworkHandler=void 0,this.optionsKeepaliveInterval=5,this.optionsKeepAliveDebounceTimeInSec=5,this.attemptRegistration=!1,this.session=void 0,this._callState=\"INITIAL\",this._callerInfo=void 0,this._userState=n.IDLE,this._opInProgress=s.OP_NONE,this.config=e,this.mediaStreamRendered=t,this.networkEmitter=new r,this.connectionRetryCount=this.config.connectionRetryCount,this.stop=!1,this.onlineNetworkHandler=this.onNetworkRestored.bind(this),this.offlineNetworkHandler=this.onNetworkLost.bind(this)}async init(){let e=\"sip:\".concat(this.config.authUserName,\"@\").concat(this.config.sipRegistrarHostnameOrIP),t={server:this.config.webSocketURI,connectionTimeout:100,keepAliveInterval:20},i={iceGatheringTimeout:10,peerConnectionConfiguration:{iceServers:this.config.iceServers}};this.userAgentOptions={delegate:{onInvite:async e=>{await this.handleIncomingCall(e)}},authorizationPassword:this.config.authPassword,authorizationUsername:this.config.authUserName,uri:a.makeURI(e),transportOptions:t,sessionDescriptionHandlerFactoryOptions:i,logConfiguration:!1,logLevel:\"error\"},this.userAgent=new a(this.userAgentOptions),this.userAgent.transport.isConnected(),this._opInProgress=s.OP_CONNECT;try{this.registerer=new c(this.userAgent),this.userAgent.transport.onConnect=this.onConnected.bind(this),this.userAgent.transport.onDisconnect=this.onDisconnected.bind(this),window.addEventListener(\"online\",this.onlineNetworkHandler),window.addEventListener(\"offline\",this.offlineNetworkHandler),await this.userAgent.start(),this.config.enableKeepAliveUsingOptionsForUnstableNetworks&&this.startOptionsPingForUnstableNetworks()}catch(e){throw this._connectionState=\"ERROR\",e}}async onConnected(){this._connectionState=\"SERVER_CONNECTED\",this.state.isReady=!0,this.sendOptions(),this.networkEmitter.emit(\"connected\"),this.registerer&&\"INITIAL\"!==this.callState&&(this.attemptRegistration=!0)}onDisconnected(e){this._connectionState=\"SERVER_DISCONNECTED\",this._opInProgress=s.OP_NONE,this.networkEmitter.emit(\"disconnected\"),e&&(this.networkEmitter.emit(\"connectionerror\",e),this.state.isReady=!1,this.attemptReconnection(0,!1))}onNetworkRestored(){this.networkEmitter.emit(\"localnetworkonline\"),\"WAITING_FOR_NETWORK\"===this._connectionState&&(this.attemptReconnection(),this.registerer&&\"INITIAL\"!==this.callState&&(this.attemptRegistration=!0))}onNetworkLost(){this.networkEmitter.emit(\"localnetworkoffline\"),this._connectionState=\"WAITING_FOR_NETWORK\"}get userConfig(){return this.config}get callState(){return this._callState}get connectionState(){return this._connectionState}get callerInfo(){if(\"IN_CALL\"===this.callState||\"OFFER_RECEIVED\"===this.callState||\"ON_HOLD\"===this.callState||\"OFFER_SENT\"===this.callState){if(!this._callerInfo)throw Error(\"[VoIPUser callerInfo] invalid state\");return{state:this.callState,caller:this._callerInfo,userState:this._userState}}return{state:this.callState,userState:this._userState}}get localMediaStream(){var e;let t=null===(e=this.session)||void 0===e?void 0:e.sessionDescriptionHandler;if(t){if(!(t instanceof m))throw Error(\"Session description handler not instance of web SessionDescriptionHandler\");return t.localMediaStream}}onRegistrationRequestAccept(){this._opInProgress===s.OP_REGISTER&&(this._callState=\"REGISTERED\",this.emit(\"registered\"),this.emit(\"stateChanged\")),this._opInProgress===s.OP_UNREGISTER&&(this._callState=\"UNREGISTERED\",this.emit(\"unregistered\"),this.emit(\"stateChanged\"))}onRegistrationRequestReject(e){this._opInProgress===s.OP_REGISTER&&this.emit(\"registrationerror\",e),this._opInProgress===s.OP_UNREGISTER&&this.emit(\"unregistrationerror\",e)}async handleIncomingCall(e){if(\"REGISTERED\"===this.callState){this._opInProgress=s.OP_PROCESS_INVITE,this._callState=\"OFFER_RECEIVED\",this._userState=n.UAS,this.session=e,this.setupSessionEventHandlers(e);let t={callerId:e.remoteIdentity.uri.user?e.remoteIdentity.uri.user:\"\",callerName:e.remoteIdentity.displayName,host:e.remoteIdentity.uri.host};this._callerInfo=t,this.emit(\"incomingcall\",t),this.emit(\"stateChanged\");return}await e.reject()}setupSessionEventHandlers(e){var t;null===(t=this.session)||void 0===t||t.stateChange.addListener(t=>{var i;if(this.session===e)switch(t){case l.Initial:break;case l.Establishing:this.emit(\"ringing\",{userState:this._userState,callInfo:this._callerInfo});break;case l.Established:this._userState===n.UAC&&(this._callState=\"ANSWER_RECEIVED\"),this._opInProgress=s.OP_NONE,this.setupRemoteMedia(),this._callState=\"IN_CALL\",this.emit(\"callestablished\",{userState:this._userState,callInfo:this._callerInfo}),this.emit(\"stateChanged\");break;case l.Terminating:case l.Terminated:this.session=void 0,this._callState=\"REGISTERED\",this._opInProgress=s.OP_NONE,this._userState=n.IDLE,this.emit(\"callterminated\"),null===(i=this.remoteStream)||void 0===i||i.clear(),this.emit(\"stateChanged\");break;default:throw Error(\"Unknown session state.\")}})}onTrackAdded(e){console.log(\"onTrackAdded\")}onTrackRemoved(e){console.log(\"onTrackRemoved\")}setupRemoteMedia(){var e,t;if(!this.session)throw Error(\"Session does not exist.\");let i=null===(e=this.session)||void 0===e?void 0:e.sessionDescriptionHandler;if(!i)return;if(!(i instanceof m))throw Error(\"Session description handler not instance of web SessionDescriptionHandler\");let s=i.remoteMediaStream;if(!s)throw Error(\"Remote media stream is undefined.\");this.remoteStream=new p(s);let n=null===(t=this.mediaStreamRendered)||void 0===t?void 0:t.remoteMediaElement;n&&(this.remoteStream.init(n),this.remoteStream.onTrackAdded(this.onTrackAdded.bind(this)),this.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this)),this.remoteStream.play())}async handleMuteUnmute(e){var t,i;let{session:s}=this;if(this._held===e)return Promise.resolve();if(!s)throw Error(\"Session not found\");let n=null===(t=this.session)||void 0===t?void 0:t.sessionDescriptionHandler;if(!(n instanceof m))throw Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");let{peerConnection:o}=n;if(!o)throw Error(\"Peer connection closed.\");return null===(i=this.session)||void 0===i?void 0:i.invite({requestDelegate:{onAccept:()=>{this._held=e,E(!this._held,s,\"receiver\"),E(!this._held,s,\"sender\")},onReject:()=>{this.emit(\"muteerror\")}}}).then(()=>{E(!this._held,s,\"receiver\"),E(!this._held,s,\"sender\")}).catch(e=>{if(e instanceof d){var t;console.error(\"[\".concat(null===(t=this.session)||void 0===t?void 0:t.id,\"] A mute request is already in progress.\"))}throw this.emit(\"muteerror\"),e})}async handleHoldUnhold(e){var t,i;let{session:s}=this;if(this._held===e)return Promise.resolve();if(!s)throw Error(\"Session not found\");let n=null===(t=this.session)||void 0===t?void 0:t.sessionDescriptionHandler;if(!(n instanceof m))throw Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");let o=s.sessionDescriptionHandlerOptionsReInvite;o.hold=e,s.sessionDescriptionHandlerOptionsReInvite=o;let{peerConnection:r}=n;if(!r)throw Error(\"Peer connection closed.\");return null===(i=this.session)||void 0===i?void 0:i.invite({requestDelegate:{onAccept:()=>{this._held=e,this._callState=e?\"ON_HOLD\":\"IN_CALL\",E(!this._held,s,\"receiver\"),E(!this._held,s,\"sender\"),\"ON_HOLD\"===this._callState?this.emit(\"hold\"):this.emit(\"unhold\"),this.emit(\"stateChanged\")},onReject:()=>{E(!this._held,s,\"receiver\"),E(!this._held,s,\"sender\"),this.emit(\"holderror\")}}}).then(()=>{E(!this._held,s,\"receiver\"),E(!this._held,s,\"sender\")}).catch(e=>{if(e instanceof d){var t;console.error(\"[\".concat(null===(t=this.session)||void 0===t?void 0:t.id,\"] A hold request is already in progress.\"))}throw this.emit(\"holderror\"),e})}static async create(e,t){let i=new v(e,t);return await i.init(),i}sendOptions(e){var t,i;let s=new g(\"sip\",this.config.authUserName,this.config.sipRegistrarHostnameOrIP),n=null===(t=this.userAgent)||void 0===t?void 0:t.userAgentCore.makeOutgoingRequestMessage(\"OPTIONS\",s,s,s,{});n&&(null===(i=this.userAgent)||void 0===i||i.userAgentCore.request(n,e))}register(){var e;this._opInProgress=s.OP_REGISTER,null===(e=this.registerer)||void 0===e||e.register({requestDelegate:{onAccept:this.onRegistrationRequestAccept.bind(this),onReject:this.onRegistrationRequestReject.bind(this)}})}unregister(){var e;this._opInProgress=s.OP_UNREGISTER,null===(e=this.registerer)||void 0===e||e.unregister({all:!0,requestDelegate:{onAccept:this.onRegistrationRequestAccept.bind(this),onReject:this.onRegistrationRequestReject.bind(this)}})}async acceptCall(e){if(e&&(this.mediaStreamRendered=e),\"OFFER_RECEIVED\"===this._callState&&this._opInProgress===s.OP_PROCESS_INVITE){if(this._callState=\"ANSWER_SENT\",!(this.session instanceof h))throw Error(\"Session not instance of Invitation.\");let e=!!this.config.enableVideo,{body:t}=this.session;t&&-1===t.indexOf(\"m=video\")&&(e=!1);let i={sessionDescriptionHandlerOptions:{constraints:{audio:!0,video:!!this.config.enableVideo&&e}}};return this.session.accept(i)}throw Error(\"Something went wrong\")}canRejectCall(){return[\"OFFER_RECEIVED\",\"OFFER_SENT\"].includes(this._callState)}canEndOrHoldCall(){return[\"ANSWER_SENT\",\"ANSWER_RECEIVED\",\"IN_CALL\",\"ON_HOLD\",\"OFFER_SENT\"].includes(this._callState)}rejectCall(){if(!this.session)throw Error(\"Session does not exist.\");if(!this.canRejectCall())throw Error(\"Incorrect call State = \".concat(this.callState));if(!(this.session instanceof h))throw Error(\"Session not instance of Invitation.\");return this.session.reject()}async endCall(){if(!this.session)throw Error(\"Session does not exist.\");if(!this.canEndOrHoldCall())throw Error(\"Incorrect call State = \".concat(this.callState));switch(this.emit(\"stateChanged\"),this.session.state){case l.Initial:if(this.session instanceof h)return this.session.reject();throw Error(\"Session not instance of Invitation.\");case l.Establishing:if(this.session instanceof h)return this.session.reject();if(this.session instanceof u)return this.session.cancel();throw Error(\"Session not instance of Invitation.\");case l.Established:return this.session.bye();case l.Terminating:case l.Terminated:break;default:throw Error(\"Unknown state\")}}async muteCall(e){if(!this.session)throw Error(\"Session does not exist.\");if(\"IN_CALL\"!==this._callState)throw Error(\"Incorrect call State = \".concat(this.callState));this.handleMuteUnmute(e)}async holdCall(e){if(!this.session)throw Error(\"Session does not exist.\");if(!this.canEndOrHoldCall())throw Error(\"Incorrect call State = \".concat(this.callState));this.handleHoldUnhold(e)}isReady(){return this.state.isReady}switchMediaRenderer(e){this.remoteStream&&(this.mediaStreamRendered=e,this.remoteStream.init(e.remoteMediaElement),this.remoteStream.onTrackAdded(this.onTrackAdded.bind(this)),this.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this)),this.remoteStream.play())}setWorkflowMode(e){this.mode=e,e===o.CONTACT_CENTER_USER&&(this.queueInfo=new S)}setMembershipSubscription(e){var t;this.mode===o.CONTACT_CENTER_USER&&(null===(t=this.queueInfo)||void 0===t||t.setMembership(e))}getAggregator(){return this.queueInfo}getRegistrarState(){var e;return null===(e=this.registerer)||void 0===e?void 0:e.state.toString().toLocaleLowerCase()}clear(){var e,t;this._opInProgress=s.OP_CLEANUP,this.stop=!0,null===(e=this.userAgent)||void 0===e||e.stop(),null===(t=this.registerer)||void 0===t||t.dispose(),this._connectionState=\"STOP\",this.userAgent&&(this.userAgent.transport.onConnect=void 0,this.userAgent.transport.onDisconnect=void 0,window.removeEventListener(\"online\",this.onlineNetworkHandler),window.removeEventListener(\"offline\",this.offlineNetworkHandler))}onNetworkEvent(e,t){this.networkEmitter.on(e,t)}offNetworkEvent(e,t){this.networkEmitter.off(e,t)}async attemptReconnection(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=this.connectionRetryCount;if(this._connectionState=\"SERVER_RECONNECTING\",!this.userAgent||this.stop)return;if(-1!==i&&e>i){this._connectionState=\"ERROR\";return}let s=Math.pow(2,e%4);console.error(\"Attempting to reconnect with backoff due to network loss. Backoff time [\".concat(s,\"]\")),setTimeout(()=>{var i;this.stop||\"SERVER_CONNECTED\"===this._connectionState||null===(i=this.userAgent)||void 0===i||i.reconnect().then(()=>{this._connectionState=\"SERVER_CONNECTED\"}).catch(()=>{this.attemptReconnection(++e,t)})},1e3*s)}async attemptPostRecoveryRoutine(){this.sendOptions({onAccept:()=>{this.attemptPostRecoveryRegistrationRoutine()},onReject:e=>{console.error(\"[\".concat(e,\"] Failed to do options in attemptPostRecoveryRoutine()\"))}})}async sendKeepAliveAndWaitForResponse(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=new Promise((t,i)=>{let s=!1,n=this.optionsKeepaliveInterval/2;e&&(n+=this.optionsKeepAliveDebounceTimeInSec),this.sendOptions({onAccept:()=>{s=!0},onReject:e=>{console.error(\"Failed to do options.\")}}),setTimeout(async()=>{s?(this.attemptRegistration&&(this.attemptPostRecoveryRoutine(),this.attemptRegistration=!1),t(!0)):i(!1)},1e3*n)});return t}async startOptionsPingForUnstableNetworks(){setTimeout(async()=>{if(this.userAgent&&!this.stop){if(\"SERVER_RECONNECTING\"!==this._connectionState){let e=!1;try{await this.sendKeepAliveAndWaitForResponse(),e=!0}catch(e){console.error(\"[\".concat(e,\"] Failed to do options ping.\"))}finally{e||this.networkEmitter.emit(\"disconnected\"),e&&this.networkEmitter.emit(\"connected\")}}this.startOptionsPingForUnstableNetworks()}},1e3*this.optionsKeepaliveInterval)}async attemptPostRecoveryRegistrationRoutine(){var e;let t=new Promise((e,t)=>{var i;null===(i=this.registerer)||void 0===i||i.unregister({all:!0,requestDelegate:{onAccept:()=>{e()},onReject:e=>{console.error(\"[\".concat(e,\"] While unregistering after recovery\")),this.emit(\"unregistrationerror\",e),t(\"Error in Unregistering\")}}})});try{await t}catch(e){console.error(\"[\".concat(e,\"] While waiting for unregister promise\"))}null===(e=this.registerer)||void 0===e||e.register({requestDelegate:{onReject:e=>{this._callState=\"UNREGISTERED\",this.emit(\"registrationerror\",e),this.emit(\"stateChanged\")}}})}async changeAudioInputDevice(e){var t;if(!this.session)return console.warn(\"changeAudioInputDevice() : No session. Returning\"),!1;let i=await R.requestNewStream(e,this.session);if(!i)return console.warn(\"changeAudioInputDevice() : Unable to get local stream. Returning\"),!1;let{peerConnection:s}=null===(t=this.session)||void 0===t?void 0:t.sessionDescriptionHandler;return s?(R.replaceTrack(s,i,\"audio\"),!0):(console.warn(\"changeAudioInputDevice() : No peer connection. Returning\"),!1)}async makeCallURI(e,t){throw Error(\"Not implemented\")}async makeCall(e){throw Error(\"Not implemented\")}}}","map":"{\"version\":3,\"sources\":[\"client/lib/voip/VoIPUser.ts\",\"<anon>\"],\"sourcesContent\":[\"/**\\n * Class representing SIP UserAgent\\n * @remarks\\n * This class encapsulates all the details of sip.js and exposes\\n * a very simple functions and callback handlers to the outside world.\\n * This class thus abstracts user from Browser specific media details as well as\\n * SIP specific protocol details.\\n */\\nimport type {\\n\\tCallStates,\\n\\tConnectionState,\\n\\tICallerInfo,\\n\\tIQueueMembershipSubscription,\\n\\tSignalingSocketEvents,\\n\\tSocketEventKeys,\\n\\tIMediaStreamRenderer,\\n\\tVoIPUserConfiguration,\\n\\tVoIpCallerInfo,\\n\\tIState,\\n\\tVoipEvents,\\n} from '@rocket.chat/core-typings';\\nimport { Operation, UserState, WorkflowTypes } from '@rocket.chat/core-typings';\\nimport { Emitter } from '@rocket.chat/emitter';\\nimport type { UserAgentOptions, InvitationAcceptOptions, Session, SessionInviteOptions } from 'sip.js';\\nimport { UserAgent, Invitation, SessionState, Registerer, RequestPendingError, Inviter } from 'sip.js';\\nimport type { OutgoingByeRequest, OutgoingRequestDelegate } from 'sip.js/lib/core';\\nimport { URI } from 'sip.js/lib/core';\\nimport type { SessionDescriptionHandlerOptions } from 'sip.js/lib/platform/web';\\nimport { SessionDescriptionHandler } from 'sip.js/lib/platform/web';\\n\\nimport { toggleMediaStreamTracks } from './Helper';\\nimport LocalStream from './LocalStream';\\nimport { QueueAggregator } from './QueueAggregator';\\nimport RemoteStream from './RemoteStream';\\n\\nexport class VoIPUser extends Emitter<VoipEvents> {\\n\\tstate: IState = {\\n\\t\\tisReady: false,\\n\\t\\tenableVideo: false,\\n\\t};\\n\\n\\tprivate remoteStream: RemoteStream | undefined;\\n\\n\\tuserAgentOptions: UserAgentOptions = {};\\n\\n\\tuserAgent: UserAgent | undefined;\\n\\n\\tregisterer: Registerer | undefined;\\n\\n\\tmediaStreamRendered?: IMediaStreamRenderer;\\n\\n\\tprivate _connectionState: ConnectionState = 'INITIAL';\\n\\n\\tprivate _held = false;\\n\\n\\tprivate mode: WorkflowTypes;\\n\\n\\tprivate queueInfo: QueueAggregator;\\n\\n\\tprivate connectionRetryCount;\\n\\n\\tprivate stop;\\n\\n\\tprivate networkEmitter: Emitter<SignalingSocketEvents>;\\n\\n\\tprivate offlineNetworkHandler: () => void;\\n\\n\\tprivate onlineNetworkHandler: () => void;\\n\\n\\tprivate optionsKeepaliveInterval = 5;\\n\\n\\tprivate optionsKeepAliveDebounceTimeInSec = 5;\\n\\n\\tprivate attemptRegistration = false;\\n\\n\\tprotected session: Session | undefined;\\n\\n\\tprotected _callState: CallStates = 'INITIAL';\\n\\n\\tprotected _callerInfo: ICallerInfo | undefined;\\n\\n\\tprotected _userState: UserState = UserState.IDLE;\\n\\n\\tprotected _opInProgress: Operation = Operation.OP_NONE;\\n\\n\\tget operationInProgress(): Operation {\\n\\t\\treturn this._opInProgress;\\n\\t}\\n\\n\\tget userState(): UserState | undefined {\\n\\t\\treturn this._userState;\\n\\t}\\n\\n\\tconstructor(private readonly config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer) {\\n\\t\\tsuper();\\n\\t\\tthis.mediaStreamRendered = mediaRenderer;\\n\\t\\tthis.networkEmitter = new Emitter<SignalingSocketEvents>();\\n\\t\\tthis.connectionRetryCount = this.config.connectionRetryCount;\\n\\t\\tthis.stop = false;\\n\\n\\t\\tthis.onlineNetworkHandler = this.onNetworkRestored.bind(this);\\n\\t\\tthis.offlineNetworkHandler = this.onNetworkLost.bind(this);\\n\\t}\\n\\n\\t/**\\n\\t * Configures and initializes sip.js UserAgent\\n\\t * call gets established.\\n\\t * @remarks\\n\\t * This class configures transport properties such as websocket url, passed down in config,\\n\\t * sets up ICE servers,\\n\\t * SIP UserAgent options such as userName, Password, URI.\\n\\t * Once initialized, it starts the userAgent.\\n\\t */\\n\\n\\tasync init(): Promise<void> {\\n\\t\\tconst sipUri = `sip:${this.config.authUserName}@${this.config.sipRegistrarHostnameOrIP}`;\\n\\t\\tconst transportOptions = {\\n\\t\\t\\tserver: this.config.webSocketURI,\\n\\t\\t\\tconnectionTimeout: 100, // Replace this with config\\n\\t\\t\\tkeepAliveInterval: 20,\\n\\t\\t\\t// traceSip: true,\\n\\t\\t};\\n\\t\\tconst sdpFactoryOptions = {\\n\\t\\t\\ticeGatheringTimeout: 10,\\n\\t\\t\\tpeerConnectionConfiguration: {\\n\\t\\t\\t\\ticeServers: this.config.iceServers,\\n\\t\\t\\t},\\n\\t\\t};\\n\\t\\tthis.userAgentOptions = {\\n\\t\\t\\tdelegate: {\\n\\t\\t\\t\\tonInvite: async (invitation: Invitation): Promise<void> => {\\n\\t\\t\\t\\t\\tawait this.handleIncomingCall(invitation);\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t\\tauthorizationPassword: this.config.authPassword,\\n\\t\\t\\tauthorizationUsername: this.config.authUserName,\\n\\t\\t\\turi: UserAgent.makeURI(sipUri),\\n\\t\\t\\ttransportOptions,\\n\\t\\t\\tsessionDescriptionHandlerFactoryOptions: sdpFactoryOptions,\\n\\t\\t\\tlogConfiguration: false,\\n\\t\\t\\tlogLevel: 'error',\\n\\t\\t};\\n\\n\\t\\tthis.userAgent = new UserAgent(this.userAgentOptions);\\n\\t\\tthis.userAgent.transport.isConnected();\\n\\t\\tthis._opInProgress = Operation.OP_CONNECT;\\n\\t\\ttry {\\n\\t\\t\\tthis.registerer = new Registerer(this.userAgent);\\n\\n\\t\\t\\tthis.userAgent.transport.onConnect = this.onConnected.bind(this);\\n\\t\\t\\tthis.userAgent.transport.onDisconnect = this.onDisconnected.bind(this);\\n\\t\\t\\twindow.addEventListener('online', this.onlineNetworkHandler);\\n\\t\\t\\twindow.addEventListener('offline', this.offlineNetworkHandler);\\n\\t\\t\\tawait this.userAgent.start();\\n\\t\\t\\tif (this.config.enableKeepAliveUsingOptionsForUnstableNetworks) {\\n\\t\\t\\t\\tthis.startOptionsPingForUnstableNetworks();\\n\\t\\t\\t}\\n\\t\\t} catch (error) {\\n\\t\\t\\tthis._connectionState = 'ERROR';\\n\\t\\t\\tthrow error;\\n\\t\\t}\\n\\t}\\n\\n\\tasync onConnected(): Promise<void> {\\n\\t\\tthis._connectionState = 'SERVER_CONNECTED';\\n\\t\\tthis.state.isReady = true;\\n\\t\\tthis.sendOptions();\\n\\t\\tthis.networkEmitter.emit('connected');\\n\\t\\t/**\\n\\t\\t * Re-registration post network recovery should be attempted\\n\\t\\t * if it was previously registered or incall/onhold\\n\\t\\t */\\n\\n\\t\\tif (this.registerer && this.callState !== 'INITIAL') {\\n\\t\\t\\tthis.attemptRegistration = true;\\n\\t\\t}\\n\\t}\\n\\n\\tonDisconnected(error: any): void {\\n\\t\\tthis._connectionState = 'SERVER_DISCONNECTED';\\n\\t\\tthis._opInProgress = Operation.OP_NONE;\\n\\t\\tthis.networkEmitter.emit('disconnected');\\n\\t\\tif (error) {\\n\\t\\t\\tthis.networkEmitter.emit('connectionerror', error);\\n\\t\\t\\tthis.state.isReady = false;\\n\\t\\t\\t/**\\n\\t\\t\\t * Signalling socket reconnection should be attempted assuming\\n\\t\\t\\t * that the disconnect happened from the remote side or due to sleep\\n\\t\\t\\t * In case of remote side disconnection, if config.connectionRetryCount is -1,\\n\\t\\t\\t * attemptReconnection attempts continuously. Else stops after |config.connectionRetryCount|\\n\\t\\t\\t *\\n\\t\\t\\t */\\n\\t\\t\\t// this.attemptReconnection();\\n\\t\\t\\tthis.attemptReconnection(0, false);\\n\\t\\t}\\n\\t}\\n\\n\\tonNetworkRestored(): void {\\n\\t\\tthis.networkEmitter.emit('localnetworkonline');\\n\\t\\tif (this._connectionState === 'WAITING_FOR_NETWORK') {\\n\\t\\t\\t/**\\n\\t\\t\\t * Signalling socket reconnection should be attempted when online event handler\\n\\t\\t\\t * gets notified.\\n\\t\\t\\t * Important thing to note is that the second parameter |checkRegistration| = true passed here\\n\\t\\t\\t * because after the network recovery and after reconnecting to the server,\\n\\t\\t\\t * the transport layer of SIPUA does not call onConnected. So by passing |checkRegistration = true |\\n\\t\\t\\t * the code will check if the endpoint was previously registered before the disconnection.\\n\\t\\t\\t * If such is the case, it will first unregister and then re-register.\\n\\t\\t\\t * */\\n\\t\\t\\tthis.attemptReconnection();\\n\\t\\t\\tif (this.registerer && this.callState !== 'INITIAL') {\\n\\t\\t\\t\\tthis.attemptRegistration = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tonNetworkLost(): void {\\n\\t\\tthis.networkEmitter.emit('localnetworkoffline');\\n\\t\\tthis._connectionState = 'WAITING_FOR_NETWORK';\\n\\t}\\n\\n\\tget userConfig(): VoIPUserConfiguration {\\n\\t\\treturn this.config;\\n\\t}\\n\\n\\tget callState(): CallStates {\\n\\t\\treturn this._callState;\\n\\t}\\n\\n\\tget connectionState(): ConnectionState {\\n\\t\\treturn this._connectionState;\\n\\t}\\n\\n\\tget callerInfo(): VoIpCallerInfo {\\n\\t\\tif (\\n\\t\\t\\tthis.callState === 'IN_CALL' ||\\n\\t\\t\\tthis.callState === 'OFFER_RECEIVED' ||\\n\\t\\t\\tthis.callState === 'ON_HOLD' ||\\n\\t\\t\\tthis.callState === 'OFFER_SENT'\\n\\t\\t) {\\n\\t\\t\\tif (!this._callerInfo) {\\n\\t\\t\\t\\tthrow new Error('[VoIPUser callerInfo] invalid state');\\n\\t\\t\\t}\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tstate: this.callState,\\n\\t\\t\\t\\tcaller: this._callerInfo,\\n\\t\\t\\t\\tuserState: this._userState,\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\treturn {\\n\\t\\t\\tstate: this.callState,\\n\\t\\t\\tuserState: this._userState,\\n\\t\\t};\\n\\t}\\n\\n\\t/* Media Stream functions begin */\\n\\t/** The local media stream. Undefined if call not answered. */\\n\\tget localMediaStream(): MediaStream | undefined {\\n\\t\\tconst sdh = this.session?.sessionDescriptionHandler;\\n\\t\\tif (!sdh) {\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\t\\tif (!(sdh instanceof SessionDescriptionHandler)) {\\n\\t\\t\\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\\n\\t\\t}\\n\\t\\treturn sdh.localMediaStream;\\n\\t}\\n\\n\\t/* Media Stream functions end */\\n\\t/* OutgoingRequestDelegate methods begin */\\n\\tonRegistrationRequestAccept(): void {\\n\\t\\tif (this._opInProgress === Operation.OP_REGISTER) {\\n\\t\\t\\tthis._callState = 'REGISTERED';\\n\\t\\t\\tthis.emit('registered');\\n\\t\\t\\tthis.emit('stateChanged');\\n\\t\\t}\\n\\t\\tif (this._opInProgress === Operation.OP_UNREGISTER) {\\n\\t\\t\\tthis._callState = 'UNREGISTERED';\\n\\t\\t\\tthis.emit('unregistered');\\n\\t\\t\\tthis.emit('stateChanged');\\n\\t\\t}\\n\\t}\\n\\n\\tonRegistrationRequestReject(error: any): void {\\n\\t\\tif (this._opInProgress === Operation.OP_REGISTER) {\\n\\t\\t\\tthis.emit('registrationerror', error);\\n\\t\\t}\\n\\t\\tif (this._opInProgress === Operation.OP_UNREGISTER) {\\n\\t\\t\\tthis.emit('unregistrationerror', error);\\n\\t\\t}\\n\\t}\\n\\t/* OutgoingRequestDelegate methods end */\\n\\n\\tprivate async handleIncomingCall(invitation: Invitation): Promise<void> {\\n\\t\\tif (this.callState === 'REGISTERED') {\\n\\t\\t\\tthis._opInProgress = Operation.OP_PROCESS_INVITE;\\n\\t\\t\\tthis._callState = 'OFFER_RECEIVED';\\n\\t\\t\\tthis._userState = UserState.UAS;\\n\\t\\t\\tthis.session = invitation;\\n\\t\\t\\tthis.setupSessionEventHandlers(invitation);\\n\\t\\t\\tconst callerInfo: ICallerInfo = {\\n\\t\\t\\t\\tcallerId: invitation.remoteIdentity.uri.user ? invitation.remoteIdentity.uri.user : '',\\n\\t\\t\\t\\tcallerName: invitation.remoteIdentity.displayName,\\n\\t\\t\\t\\thost: invitation.remoteIdentity.uri.host,\\n\\t\\t\\t};\\n\\t\\t\\tthis._callerInfo = callerInfo;\\n\\t\\t\\tthis.emit('incomingcall', callerInfo);\\n\\t\\t\\tthis.emit('stateChanged');\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tawait invitation.reject();\\n\\t}\\n\\n\\t/**\\n\\t * Sets up an listener handler for handling session's state change\\n\\t * @remarks\\n\\t * Called for setting up various state listeners. These listeners will\\n\\t * decide the next action to be taken when the session state changes.\\n\\t * e.g when session.state changes from |Establishing| to |Established|\\n\\t * one must set up local and remote media rendering.\\n\\t *\\n\\t * This class handles such session state changes and takes necessary actions.\\n\\t */\\n\\n\\tprotected setupSessionEventHandlers(session: Session): void {\\n\\t\\tthis.session?.stateChange.addListener((state: SessionState) => {\\n\\t\\t\\tif (this.session !== session) {\\n\\t\\t\\t\\treturn; // if our session has changed, just return\\n\\t\\t\\t}\\n\\t\\t\\tswitch (state) {\\n\\t\\t\\t\\tcase SessionState.Initial:\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase SessionState.Establishing:\\n\\t\\t\\t\\t\\tthis.emit('ringing', { userState: this._userState, callInfo: this._callerInfo });\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase SessionState.Established:\\n\\t\\t\\t\\t\\tif (this._userState === UserState.UAC) {\\n\\t\\t\\t\\t\\t\\t/**\\n\\t\\t\\t\\t\\t\\t * We need to decide about user-state ANSWER-RECEIVED for outbound.\\n\\t\\t\\t\\t\\t\\t * This state is there for the symmetry of ANSWER-SENT.\\n\\t\\t\\t\\t\\t\\t * ANSWER-SENT occurs when there is incoming invite. So then the UA\\n\\t\\t\\t\\t\\t\\t * accepts a call, it sends the answer and state becomes ANSWER-SENT.\\n\\t\\t\\t\\t\\t\\t * The call gets established only when the remote party sends ACK.\\n\\t\\t\\t\\t\\t\\t *\\n\\t\\t\\t\\t\\t\\t * But in case of UAC where the invite is sent out, there is no intermediate\\n\\t\\t\\t\\t\\t\\t * state where the UA can be in ANSWER-RECEIVED. As soon this UA receives the answer,\\n\\t\\t\\t\\t\\t\\t * it sends ack and changes the SessionState to established.\\n\\t\\t\\t\\t\\t\\t *\\n\\t\\t\\t\\t\\t\\t * So we do not have an actual state transitions from ANSWER-RECEIVED to IN-CALL.\\n\\t\\t\\t\\t\\t\\t *\\n\\t\\t\\t\\t\\t\\t * Nevertheless, this state is just added to maintain the symmetry. This can be safely removed.\\n\\t\\t\\t\\t\\t\\t *\\n\\t\\t\\t\\t\\t\\t * */\\n\\t\\t\\t\\t\\t\\tthis._callState = 'ANSWER_RECEIVED';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis._opInProgress = Operation.OP_NONE;\\n\\t\\t\\t\\t\\tthis.setupRemoteMedia();\\n\\t\\t\\t\\t\\tthis._callState = 'IN_CALL';\\n\\t\\t\\t\\t\\tthis.emit('callestablished', { userState: this._userState, callInfo: this._callerInfo });\\n\\t\\t\\t\\t\\tthis.emit('stateChanged');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase SessionState.Terminating:\\n\\t\\t\\t\\t// fall through\\n\\t\\t\\t\\tcase SessionState.Terminated:\\n\\t\\t\\t\\t\\tthis.session = undefined;\\n\\t\\t\\t\\t\\tthis._callState = 'REGISTERED';\\n\\t\\t\\t\\t\\tthis._opInProgress = Operation.OP_NONE;\\n\\t\\t\\t\\t\\tthis._userState = UserState.IDLE;\\n\\t\\t\\t\\t\\tthis.emit('callterminated');\\n\\t\\t\\t\\t\\tthis.remoteStream?.clear();\\n\\t\\t\\t\\t\\tthis.emit('stateChanged');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tthrow new Error('Unknown session state.');\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n\\n\\tonTrackAdded(_event: any): void {\\n\\t\\tconsole.log('onTrackAdded');\\n\\t}\\n\\n\\tonTrackRemoved(_event: any): void {\\n\\t\\tconsole.log('onTrackRemoved');\\n\\t}\\n\\n\\t/**\\n\\t * Carries out necessary steps for rendering remote media whe\\n\\t * call gets established.\\n\\t * @remarks\\n\\t * Sets up Stream class and plays the stream on given Media element/\\n\\t * Also sets up various event handlers.\\n\\t */\\n\\tprivate setupRemoteMedia(): any {\\n\\t\\tif (!this.session) {\\n\\t\\t\\tthrow new Error('Session does not exist.');\\n\\t\\t}\\n\\t\\tconst sdh = this.session?.sessionDescriptionHandler;\\n\\t\\tif (!sdh) {\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\t\\tif (!(sdh instanceof SessionDescriptionHandler)) {\\n\\t\\t\\tthrow new Error('Session description handler not instance of web SessionDescriptionHandler');\\n\\t\\t}\\n\\n\\t\\tconst remoteStream = sdh.remoteMediaStream;\\n\\t\\tif (!remoteStream) {\\n\\t\\t\\tthrow new Error('Remote media stream is undefined.');\\n\\t\\t}\\n\\n\\t\\tthis.remoteStream = new RemoteStream(remoteStream);\\n\\t\\tconst mediaElement = this.mediaStreamRendered?.remoteMediaElement;\\n\\t\\tif (mediaElement) {\\n\\t\\t\\tthis.remoteStream.init(mediaElement);\\n\\t\\t\\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\\n\\t\\t\\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\\n\\t\\t\\tthis.remoteStream.play();\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Handles call mute-unmute\\n\\t */\\n\\tprivate async handleMuteUnmute(muteState: boolean): Promise<void> {\\n\\t\\tconst { session } = this;\\n\\t\\tif (this._held === muteState) {\\n\\t\\t\\treturn Promise.resolve();\\n\\t\\t}\\n\\t\\tif (!session) {\\n\\t\\t\\tthrow new Error('Session not found');\\n\\t\\t}\\n\\n\\t\\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\\n\\t\\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\\n\\t\\t\\tthrow new Error(\\\"Session's session description handler not instance of SessionDescriptionHandler.\\\");\\n\\t\\t}\\n\\n\\t\\tconst options: SessionInviteOptions = {\\n\\t\\t\\trequestDelegate: {\\n\\t\\t\\t\\tonAccept: (): void => {\\n\\t\\t\\t\\t\\tthis._held = muteState;\\n\\t\\t\\t\\t\\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\\n\\t\\t\\t\\t\\ttoggleMediaStreamTracks(!this._held, session, 'sender');\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tonReject: (): void => {\\n\\t\\t\\t\\t\\tthis.emit('muteerror');\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t};\\n\\n\\t\\tconst { peerConnection } = sessionDescriptionHandler;\\n\\t\\tif (!peerConnection) {\\n\\t\\t\\tthrow new Error('Peer connection closed.');\\n\\t\\t}\\n\\t\\treturn this.session\\n\\t\\t\\t?.invite(options)\\n\\t\\t\\t.then(() => {\\n\\t\\t\\t\\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\\n\\t\\t\\t\\ttoggleMediaStreamTracks(!this._held, session, 'sender');\\n\\t\\t\\t})\\n\\t\\t\\t.catch((error: Error) => {\\n\\t\\t\\t\\tif (error instanceof RequestPendingError) {\\n\\t\\t\\t\\t\\tconsole.error(`[${this.session?.id}] A mute request is already in progress.`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.emit('muteerror');\\n\\t\\t\\t\\tthrow error;\\n\\t\\t\\t});\\n\\t}\\n\\n\\t/**\\n\\t * Handles call hold-unhold\\n\\t */\\n\\tprivate async handleHoldUnhold(holdState: boolean): Promise<void> {\\n\\t\\tconst { session } = this;\\n\\t\\tif (this._held === holdState) {\\n\\t\\t\\treturn Promise.resolve();\\n\\t\\t}\\n\\t\\tif (!session) {\\n\\t\\t\\tthrow new Error('Session not found');\\n\\t\\t}\\n\\n\\t\\tconst sessionDescriptionHandler = this.session?.sessionDescriptionHandler;\\n\\t\\tif (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\\n\\t\\t\\tthrow new Error(\\\"Session's session description handler not instance of SessionDescriptionHandler.\\\");\\n\\t\\t}\\n\\t\\tconst options: SessionInviteOptions = {\\n\\t\\t\\trequestDelegate: {\\n\\t\\t\\t\\tonAccept: (): void => {\\n\\t\\t\\t\\t\\tthis._held = holdState;\\n\\t\\t\\t\\t\\tthis._callState = holdState ? 'ON_HOLD' : 'IN_CALL';\\n\\t\\t\\t\\t\\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\\n\\t\\t\\t\\t\\ttoggleMediaStreamTracks(!this._held, session, 'sender');\\n\\t\\t\\t\\t\\tthis._callState === 'ON_HOLD' ? this.emit('hold') : this.emit('unhold');\\n\\t\\t\\t\\t\\tthis.emit('stateChanged');\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tonReject: (): void => {\\n\\t\\t\\t\\t\\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\\n\\t\\t\\t\\t\\ttoggleMediaStreamTracks(!this._held, session, 'sender');\\n\\t\\t\\t\\t\\tthis.emit('holderror');\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t};\\n\\n\\t\\t// Session properties used to pass options to the SessionDescriptionHandler:\\n\\t\\t//\\n\\t\\t// 1) Session.sessionDescriptionHandlerOptions\\n\\t\\t//    SDH options for the initial INVITE transaction.\\n\\t\\t//    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\\n\\t\\t//    - May be set directly at anytime.\\n\\t\\t//    - May optionally be set via constructor option.\\n\\t\\t//    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\\n\\t\\t//\\n\\t\\t// 2) Session.sessionDescriptionHandlerOptionsReInvite\\n\\t\\t//    SDH options for re-INVITE transactions.\\n\\t\\t//    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\\n\\t\\t//    - May be set directly at anytime.\\n\\t\\t//    - May optionally be set via constructor option.\\n\\t\\t//    - May optionally be set via options passed to Session.invite().\\n\\n\\t\\tconst sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite as SessionDescriptionHandlerOptions;\\n\\t\\tsessionDescriptionHandlerOptions.hold = holdState;\\n\\t\\tsession.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;\\n\\n\\t\\tconst { peerConnection } = sessionDescriptionHandler;\\n\\t\\tif (!peerConnection) {\\n\\t\\t\\tthrow new Error('Peer connection closed.');\\n\\t\\t}\\n\\t\\treturn this.session\\n\\t\\t\\t?.invite(options)\\n\\t\\t\\t.then(() => {\\n\\t\\t\\t\\ttoggleMediaStreamTracks(!this._held, session, 'receiver');\\n\\t\\t\\t\\ttoggleMediaStreamTracks(!this._held, session, 'sender');\\n\\t\\t\\t})\\n\\t\\t\\t.catch((error: Error) => {\\n\\t\\t\\t\\tif (error instanceof RequestPendingError) {\\n\\t\\t\\t\\t\\tconsole.error(`[${this.session?.id}] A hold request is already in progress.`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.emit('holderror');\\n\\t\\t\\t\\tthrow error;\\n\\t\\t\\t});\\n\\t}\\n\\n\\tstatic async create(config: VoIPUserConfiguration, mediaRenderer?: IMediaStreamRenderer): Promise<VoIPUser> {\\n\\t\\tconst voip = new VoIPUser(config, mediaRenderer);\\n\\t\\tawait voip.init();\\n\\t\\treturn voip;\\n\\t}\\n\\n\\t/**\\n\\t * Sends SIP OPTIONS message to asterisk\\n\\t *\\n\\t * There is an interesting problem that happens with Asterisk.\\n\\t * After websocket connection succeeds and if there is no SIP\\n\\t * message goes in 30 seconds, asterisk disconnects the socket.\\n\\t *\\n\\t * If any SIP message goes before 30 seconds, asterisk holds the connection.\\n\\t * This problem could be solved in multiple ways. One is that\\n\\t * whenever disconnect happens make sure that the socket is connected back using\\n\\t * this.userAgent.reconnect() method. But this is expensive as it does connect-disconnect\\n\\t * every 30 seconds till we send register message.\\n\\t *\\n\\t * Another approach is to send SIP OPTIONS just to tell server that\\n\\t * there is a UA using this socket. This is implemented below\\n\\t */\\n\\n\\tsendOptions(outgoingRequestDelegate?: OutgoingRequestDelegate): void {\\n\\t\\tconst uri = new URI('sip', this.config.authUserName, this.config.sipRegistrarHostnameOrIP);\\n\\t\\tconst outgoingMessage = this.userAgent?.userAgentCore.makeOutgoingRequestMessage('OPTIONS', uri, uri, uri, {});\\n\\t\\tif (outgoingMessage) {\\n\\t\\t\\tthis.userAgent?.userAgentCore.request(outgoingMessage, outgoingRequestDelegate);\\n\\t\\t}\\n\\t}\\n\\t/**\\n\\t * Public method called from outside to register the SIP UA with call server.\\n\\t * @remarks\\n\\t */\\n\\n\\tregister(): void {\\n\\t\\tthis._opInProgress = Operation.OP_REGISTER;\\n\\t\\tthis.registerer?.register({\\n\\t\\t\\trequestDelegate: {\\n\\t\\t\\t\\tonAccept: this.onRegistrationRequestAccept.bind(this),\\n\\t\\t\\t\\tonReject: this.onRegistrationRequestReject.bind(this),\\n\\t\\t\\t},\\n\\t\\t});\\n\\t}\\n\\n\\t/**\\n\\t * Public method called from outside to unregister the SIP UA.\\n\\t * @remarks\\n\\t */\\n\\n\\tunregister(): void {\\n\\t\\tthis._opInProgress = Operation.OP_UNREGISTER;\\n\\t\\tthis.registerer?.unregister({\\n\\t\\t\\tall: true,\\n\\t\\t\\trequestDelegate: {\\n\\t\\t\\t\\tonAccept: this.onRegistrationRequestAccept.bind(this),\\n\\t\\t\\t\\tonReject: this.onRegistrationRequestReject.bind(this),\\n\\t\\t\\t},\\n\\t\\t});\\n\\t}\\n\\t/**\\n\\t * Public method called from outside to accept incoming call.\\n\\t * @remarks\\n\\t */\\n\\n\\tasync acceptCall(mediaRenderer: IMediaStreamRenderer): Promise<void> {\\n\\t\\tif (mediaRenderer) {\\n\\t\\t\\tthis.mediaStreamRendered = mediaRenderer;\\n\\t\\t}\\n\\t\\t// Call state must be in offer_received.\\n\\t\\tif (this._callState === 'OFFER_RECEIVED' && this._opInProgress === Operation.OP_PROCESS_INVITE) {\\n\\t\\t\\tthis._callState = 'ANSWER_SENT';\\n\\t\\t\\t// Something is wrong, this session is not an instance of INVITE\\n\\t\\t\\tif (!(this.session instanceof Invitation)) {\\n\\t\\t\\t\\tthrow new Error('Session not instance of Invitation.');\\n\\t\\t\\t}\\n\\t\\t\\t/**\\n\\t\\t\\t * It is important to decide when to add video option to the outgoing offer.\\n\\t\\t\\t * This would matter when the reinvite goes out (In case of hold/unhold)\\n\\t\\t\\t * This was added because there were failures in hold-unhold.\\n\\t\\t\\t * The scenario was that if this client does hold-unhold first, and remote client does\\n\\t\\t\\t * later, remote client goes in inconsistent state and hold-unhold does not work\\n\\t\\t\\t * Where as if the remote client does hold-unhold first, this client can do it any number\\n\\t\\t\\t * of times.\\n\\t\\t\\t *\\n\\t\\t\\t * Logic below works as follows\\n\\t\\t\\t * Local video settings = true, incoming invite has video mline = false -> Any offer = audiovideo/ answer = audioonly\\n\\t\\t\\t * Local video settings = true, incoming invite has video mline = true -> Any offer = audiovideo/ answer = audiovideo\\n\\t\\t\\t * Local video settings = false, incoming invite has video mline = false -> Any offer = audioonly/ answer = audioonly\\n\\t\\t\\t * Local video settings = false, incoming invite has video mline = true -> Any offer = audioonly/ answer = audioonly\\n\\t\\t\\t *\\n\\t\\t\\t */\\n\\t\\t\\tlet videoInvite = !!this.config.enableVideo;\\n\\n\\t\\t\\tconst { body } = this.session;\\n\\t\\t\\tif (body && body.indexOf('m=video') === -1) {\\n\\t\\t\\t\\tvideoInvite = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst invitationAcceptOptions: InvitationAcceptOptions = {\\n\\t\\t\\t\\tsessionDescriptionHandlerOptions: {\\n\\t\\t\\t\\t\\tconstraints: {\\n\\t\\t\\t\\t\\t\\taudio: true,\\n\\t\\t\\t\\t\\t\\tvideo: !!this.config.enableVideo && videoInvite,\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t};\\n\\n\\t\\t\\treturn this.session.accept(invitationAcceptOptions);\\n\\t\\t}\\n\\t\\tthrow new Error('Something went wrong');\\n\\t}\\n\\n\\t/* Helper routines for checking call actions BEGIN */\\n\\n\\tprivate canRejectCall(): boolean {\\n\\t\\treturn ['OFFER_RECEIVED', 'OFFER_SENT'].includes(this._callState);\\n\\t}\\n\\n\\tprivate canEndOrHoldCall(): boolean {\\n\\t\\treturn ['ANSWER_SENT', 'ANSWER_RECEIVED', 'IN_CALL', 'ON_HOLD', 'OFFER_SENT'].includes(this._callState);\\n\\t}\\n\\n\\t/* Helper routines for checking call actions END */\\n\\n\\t/**\\n\\t * Public method called from outside to reject a call.\\n\\t * @remarks\\n\\t */\\n\\trejectCall(): Promise<void> {\\n\\t\\tif (!this.session) {\\n\\t\\t\\tthrow new Error('Session does not exist.');\\n\\t\\t}\\n\\t\\tif (!this.canRejectCall()) {\\n\\t\\t\\tthrow new Error(`Incorrect call State = ${this.callState}`);\\n\\t\\t}\\n\\t\\tif (!(this.session instanceof Invitation)) {\\n\\t\\t\\tthrow new Error('Session not instance of Invitation.');\\n\\t\\t}\\n\\t\\treturn this.session.reject();\\n\\t}\\n\\n\\t/**\\n\\t * Public method called from outside to end a call.\\n\\t * @remarks\\n\\t */\\n\\tasync endCall(): Promise<OutgoingByeRequest | void> {\\n\\t\\tif (!this.session) {\\n\\t\\t\\tthrow new Error('Session does not exist.');\\n\\t\\t}\\n\\t\\tif (!this.canEndOrHoldCall()) {\\n\\t\\t\\tthrow new Error(`Incorrect call State = ${this.callState}`);\\n\\t\\t}\\n\\n\\t\\t// When call ends, force state to be revisited\\n\\t\\tthis.emit('stateChanged');\\n\\t\\tswitch (this.session.state) {\\n\\t\\t\\tcase SessionState.Initial:\\n\\t\\t\\t\\tif (this.session instanceof Invitation) {\\n\\t\\t\\t\\t\\treturn this.session.reject();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthrow new Error('Session not instance of Invitation.');\\n\\t\\t\\tcase SessionState.Establishing:\\n\\t\\t\\t\\tif (this.session instanceof Invitation) {\\n\\t\\t\\t\\t\\treturn this.session.reject();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (this.session instanceof Inviter) {\\n\\t\\t\\t\\t\\treturn this.session.cancel();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthrow new Error('Session not instance of Invitation.');\\n\\t\\t\\tcase SessionState.Established:\\n\\t\\t\\t\\treturn this.session.bye();\\n\\t\\t\\tcase SessionState.Terminating:\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase SessionState.Terminated:\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new Error('Unknown state');\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Public method called from outside to mute the call.\\n\\t * @remarks\\n\\t */\\n\\tasync muteCall(muteState: boolean): Promise<void> {\\n\\t\\tif (!this.session) {\\n\\t\\t\\tthrow new Error('Session does not exist.');\\n\\t\\t}\\n\\t\\tif (this._callState !== 'IN_CALL') {\\n\\t\\t\\tthrow new Error(`Incorrect call State = ${this.callState}`);\\n\\t\\t}\\n\\t\\tthis.handleMuteUnmute(muteState);\\n\\t}\\n\\n\\t/**\\n\\t * Public method called from outside to hold the call.\\n\\t * @remarks\\n\\t */\\n\\tasync holdCall(holdState: boolean): Promise<void> {\\n\\t\\tif (!this.session) {\\n\\t\\t\\tthrow new Error('Session does not exist.');\\n\\t\\t}\\n\\t\\tif (!this.canEndOrHoldCall()) {\\n\\t\\t\\tthrow new Error(`Incorrect call State = ${this.callState}`);\\n\\t\\t}\\n\\t\\tthis.handleHoldUnhold(holdState);\\n\\t}\\n\\n\\t/* CallEventDelegate implementation end */\\n\\tisReady(): boolean {\\n\\t\\treturn this.state.isReady;\\n\\t}\\n\\n\\t/**\\n\\t * This function allows to change the media renderer media elements.\\n\\t */\\n\\tswitchMediaRenderer(mediaRenderer: IMediaStreamRenderer): void {\\n\\t\\tif (this.remoteStream) {\\n\\t\\t\\tthis.mediaStreamRendered = mediaRenderer;\\n\\t\\t\\tthis.remoteStream.init(mediaRenderer.remoteMediaElement);\\n\\t\\t\\tthis.remoteStream.onTrackAdded(this.onTrackAdded.bind(this));\\n\\t\\t\\tthis.remoteStream.onTrackRemoved(this.onTrackRemoved.bind(this));\\n\\t\\t\\tthis.remoteStream.play();\\n\\t\\t}\\n\\t}\\n\\n\\tsetWorkflowMode(mode: WorkflowTypes): void {\\n\\t\\tthis.mode = mode;\\n\\t\\tif (mode === WorkflowTypes.CONTACT_CENTER_USER) {\\n\\t\\t\\tthis.queueInfo = new QueueAggregator();\\n\\t\\t}\\n\\t}\\n\\n\\tsetMembershipSubscription(subscription: IQueueMembershipSubscription): void {\\n\\t\\tif (this.mode !== WorkflowTypes.CONTACT_CENTER_USER) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tthis.queueInfo?.setMembership(subscription);\\n\\t}\\n\\n\\tgetAggregator(): QueueAggregator {\\n\\t\\treturn this.queueInfo;\\n\\t}\\n\\n\\tgetRegistrarState(): string | undefined {\\n\\t\\treturn this.registerer?.state.toString().toLocaleLowerCase();\\n\\t}\\n\\n\\tclear(): void {\\n\\t\\tthis._opInProgress = Operation.OP_CLEANUP;\\n\\t\\t/** Socket reconnection is attempted when the socket is disconnected with some error.\\n\\t\\t * While disconnecting, if there is any socket error, there should be no reconnection attempt.\\n\\t\\t * So when userAgent.stop() is called which closes the sockets, it should be made sure that\\n\\t\\t * if the socket is disconnected with error, connection attempts are not started or\\n\\t\\t * if there are any previously ongoing attempts, they should be terminated.\\n\\t\\t * flag attemptReconnect is used for ensuring this.\\n\\t\\t */\\n\\t\\tthis.stop = true;\\n\\t\\tthis.userAgent?.stop();\\n\\t\\tthis.registerer?.dispose();\\n\\t\\tthis._connectionState = 'STOP';\\n\\n\\t\\tif (this.userAgent) {\\n\\t\\t\\tthis.userAgent.transport.onConnect = undefined;\\n\\t\\t\\tthis.userAgent.transport.onDisconnect = undefined;\\n\\t\\t\\twindow.removeEventListener('online', this.onlineNetworkHandler);\\n\\t\\t\\twindow.removeEventListener('offline', this.offlineNetworkHandler);\\n\\t\\t}\\n\\t}\\n\\n\\tonNetworkEvent(event: SocketEventKeys, handler: () => void): void {\\n\\t\\tthis.networkEmitter.on(event, handler);\\n\\t}\\n\\n\\toffNetworkEvent(event: SocketEventKeys, handler: () => void): void {\\n\\t\\tthis.networkEmitter.off(event, handler);\\n\\t}\\n\\n\\t/**\\n\\t * Connection is lost in 3 ways\\n\\t * 1. When local network is lost (Router is disconnected, switching networks, devtools->network->offline)\\n\\t * In this case, the SIP.js's transport layer does not detect the disconnection. Hence, it does not\\n\\t * call |onDisconnect|. To detect this kind of disconnection, window event listeners have been added.\\n\\t * These event listeners would be get called when the browser detects that network is offline or online.\\n\\t * When the network is restored, the code tries to reconnect. The useragent.transport \\\"does not\\\" generate the\\n\\t * onconnected event in this case as well. so onlineNetworkHandler calls attemptReconnection.\\n\\t * Which calls attemptRegistrationPostRecovery based on correct state. attemptRegistrationPostRecovery first tries to\\n\\t * unregister and then re-register.\\n\\t * Important note : We use the event listeners using bind function object offlineNetworkHandler and onlineNetworkHandler\\n\\t * It is done so because the same event handlers need to be used for removeEventListener, which becomes impossible\\n\\t * if done inline.\\n\\t *\\n\\t * 2. Computer goes to sleep. In this case onDisconnect is triggered. The code tries to reconnect but cant go ahead\\n\\t * as it goes to sleep. On waking up, The attemptReconnection gets executed, connection is completed.\\n\\t * In this case, it generates onConnected event. In this onConnected event it calls attemptRegistrationPostRecovery\\n\\t *\\n\\t * 3. When Asterisk disconnects all the endpoints either because it crashes or restarted,\\n\\t * As soon as the agent successfully connects to asterisk, it should re-register\\n\\t *\\n\\t * Retry count :\\n\\t * connectionRetryCount is the parameter called |Retry Count| in\\n\\t * Administration -> Call Center -> Server configuration -> Retry count.\\n\\t * The retry is implemented with backoff, maxbackoff = 8 seconds.\\n\\t * For continuous retries (In case Asterisk restart happens) Set this parameter to -1.\\n\\t *\\n\\t * Important to note is how attemptRegistrationPostRecovery is called. In case of\\n\\t * the router connection loss or while switching the networks,\\n\\t * there is no disconnect and connect event from the transport layer of the userAgent.\\n\\t * So in this case, when the connection is successful after reconnect, the code should try to re-register by calling\\n\\t * attemptRegistrationPostRecovery.\\n\\t * In case of computer waking from sleep or asterisk getting restored, connect and disconnect events are generated.\\n\\t * In this case, re-registration should be triggered (by calling) only when onConnected gets called and not otherwise.\\n\\t */\\n\\n\\tasync attemptReconnection(reconnectionAttempt = 0, checkRegistration = false): Promise<void> {\\n\\t\\tconst reconnectionAttempts = this.connectionRetryCount;\\n\\t\\tthis._connectionState = 'SERVER_RECONNECTING';\\n\\t\\tif (!this.userAgent) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (this.stop) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// reconnectionAttempts == -1 then keep continuously trying\\n\\t\\tif (reconnectionAttempts !== -1 && reconnectionAttempt > reconnectionAttempts) {\\n\\t\\t\\tthis._connectionState = 'ERROR';\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tconst reconnectionDelay = Math.pow(2, reconnectionAttempt % 4);\\n\\n\\t\\tconsole.error(`Attempting to reconnect with backoff due to network loss. Backoff time [${reconnectionDelay}]`);\\n\\t\\tsetTimeout(() => {\\n\\t\\t\\tif (this.stop) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (this._connectionState === 'SERVER_CONNECTED') {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tthis.userAgent\\n\\t\\t\\t\\t?.reconnect()\\n\\t\\t\\t\\t.then(() => {\\n\\t\\t\\t\\t\\tthis._connectionState = 'SERVER_CONNECTED';\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.catch(() => {\\n\\t\\t\\t\\t\\tthis.attemptReconnection(++reconnectionAttempt, checkRegistration);\\n\\t\\t\\t\\t});\\n\\t\\t}, reconnectionDelay * 1000);\\n\\t}\\n\\n\\tasync attemptPostRecoveryRoutine(): Promise<void> {\\n\\t\\t/**\\n\\t\\t * It might happen that the whole network loss can happen\\n\\t\\t * while there is ongoing call. In that case, we want to maintain\\n\\t\\t * the call.\\n\\t\\t *\\n\\t\\t * So after re-registration, it should remain in the same state.\\n\\t\\t * */\\n\\t\\tthis.sendOptions({\\n\\t\\t\\tonAccept: (): void => {\\n\\t\\t\\t\\tthis.attemptPostRecoveryRegistrationRoutine();\\n\\t\\t\\t},\\n\\t\\t\\tonReject: (error: unknown): void => {\\n\\t\\t\\t\\tconsole.error(`[${error}] Failed to do options in attemptPostRecoveryRoutine()`);\\n\\t\\t\\t},\\n\\t\\t});\\n\\t}\\n\\n\\tasync sendKeepAliveAndWaitForResponse(withDebounce = false): Promise<boolean> {\\n\\t\\tconst promise = new Promise<boolean>((resolve, reject) => {\\n\\t\\t\\tlet keepAliveAccepted = false;\\n\\t\\t\\tlet responseWaitTime = this.optionsKeepaliveInterval / 2;\\n\\t\\t\\tif (withDebounce) {\\n\\t\\t\\t\\tresponseWaitTime += this.optionsKeepAliveDebounceTimeInSec;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.sendOptions({\\n\\t\\t\\t\\tonAccept: (): void => {\\n\\t\\t\\t\\t\\tkeepAliveAccepted = true;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tonReject: (_error: unknown): void => {\\n\\t\\t\\t\\t\\tconsole.error('Failed to do options.');\\n\\t\\t\\t\\t},\\n\\t\\t\\t});\\n\\t\\t\\tsetTimeout(async () => {\\n\\t\\t\\t\\tif (!keepAliveAccepted) {\\n\\t\\t\\t\\t\\treject(false);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (this.attemptRegistration) {\\n\\t\\t\\t\\t\\t\\tthis.attemptPostRecoveryRoutine();\\n\\t\\t\\t\\t\\t\\tthis.attemptRegistration = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tresolve(true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, responseWaitTime * 1000);\\n\\t\\t});\\n\\t\\treturn promise;\\n\\t}\\n\\n\\tasync startOptionsPingForUnstableNetworks(): Promise<void> {\\n\\t\\tsetTimeout(async () => {\\n\\t\\t\\tif (!this.userAgent || this.stop) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (this._connectionState !== 'SERVER_RECONNECTING') {\\n\\t\\t\\t\\tlet isConnected = false;\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tawait this.sendKeepAliveAndWaitForResponse();\\n\\t\\t\\t\\t\\tisConnected = true;\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\tconsole.error(`[${e}] Failed to do options ping.`);\\n\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\t// Send event only if it's a \\\"change\\\" on the status (avoid unnecessary event flooding)\\n\\t\\t\\t\\t\\t!isConnected && this.networkEmitter.emit('disconnected');\\n\\t\\t\\t\\t\\tisConnected && this.networkEmitter.emit('connected');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// Each seconds check if the network can reach asterisk. If not, try to reconnect\\n\\t\\t\\tthis.startOptionsPingForUnstableNetworks();\\n\\t\\t}, this.optionsKeepaliveInterval * 1000);\\n\\t}\\n\\n\\tasync attemptPostRecoveryRegistrationRoutine(): Promise<void> {\\n\\t\\t/**\\n\\t\\t * It might happen that the whole network loss can happen\\n\\t\\t * while there is ongoing call. In that case, we want to maintain\\n\\t\\t * the call.\\n\\t\\t *\\n\\t\\t * So after re-registration, it should remain in the same state.\\n\\t\\t * */\\n\\t\\tconst promise = new Promise<void>((_resolve, _reject) => {\\n\\t\\t\\tthis.registerer?.unregister({\\n\\t\\t\\t\\tall: true,\\n\\t\\t\\t\\trequestDelegate: {\\n\\t\\t\\t\\t\\tonAccept: (): void => {\\n\\t\\t\\t\\t\\t\\t_resolve();\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tonReject: (error): void => {\\n\\t\\t\\t\\t\\t\\tconsole.error(`[${error}] While unregistering after recovery`);\\n\\t\\t\\t\\t\\t\\tthis.emit('unregistrationerror', error);\\n\\t\\t\\t\\t\\t\\t_reject('Error in Unregistering');\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t});\\n\\t\\t});\\n\\t\\ttry {\\n\\t\\t\\tawait promise;\\n\\t\\t} catch (error) {\\n\\t\\t\\tconsole.error(`[${error}] While waiting for unregister promise`);\\n\\t\\t}\\n\\t\\tthis.registerer?.register({\\n\\t\\t\\trequestDelegate: {\\n\\t\\t\\t\\tonReject: (error): void => {\\n\\t\\t\\t\\t\\tthis._callState = 'UNREGISTERED';\\n\\t\\t\\t\\t\\tthis.emit('registrationerror', error);\\n\\t\\t\\t\\t\\tthis.emit('stateChanged');\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t});\\n\\t}\\n\\n\\tasync changeAudioInputDevice(constraints: MediaStreamConstraints): Promise<boolean> {\\n\\t\\tif (!this.session) {\\n\\t\\t\\tconsole.warn('changeAudioInputDevice() : No session. Returning');\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tconst newStream = await LocalStream.requestNewStream(constraints, this.session);\\n\\t\\tif (!newStream) {\\n\\t\\t\\tconsole.warn('changeAudioInputDevice() : Unable to get local stream. Returning');\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\\n\\t\\tif (!peerConnection) {\\n\\t\\t\\tconsole.warn('changeAudioInputDevice() : No peer connection. Returning');\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tLocalStream.replaceTrack(peerConnection, newStream, 'audio');\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// Commenting this as Video Configuration is not part of the scope for now\\n\\t// async changeVideoInputDevice(selectedVideoDevices: IDevice): Promise<boolean> {\\n\\t// \\tif (!this.session) {\\n\\t// \\t\\tconsole.warn('changeVideoInputDevice() : No session. Returning');\\n\\t// \\t\\treturn false;\\n\\t// \\t}\\n\\t// \\tif (!this.config.enableVideo || this.deviceManager.hasVideoInputDevice()) {\\n\\t// \\t\\tconsole.warn('changeVideoInputDevice() : Unable change video device. Returning');\\n\\t// \\t\\treturn false;\\n\\t// \\t}\\n\\t// \\tthis.deviceManager.changeVideoInputDevice(selectedVideoDevices);\\n\\t// \\tconst newStream = await LocalStream.requestNewStream(this.deviceManager.getConstraints('video'), this.session);\\n\\t// \\tif (!newStream) {\\n\\t// \\t\\tconsole.warn('changeVideoInputDevice() : Unable to get local stream. Returning');\\n\\t// \\t\\treturn false;\\n\\t// \\t}\\n\\t// \\tconst { peerConnection } = this.session?.sessionDescriptionHandler as SessionDescriptionHandler;\\n\\t// \\tif (!peerConnection) {\\n\\t// \\t\\tconsole.warn('changeVideoInputDevice() : No peer connection. Returning');\\n\\t// \\t\\treturn false;\\n\\t// \\t}\\n\\t// \\tLocalStream.replaceTrack(peerConnection, newStream, 'video');\\n\\t// \\treturn true;\\n\\t// }\\n\\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\\n\\n\\tasync makeCallURI(_callee: string, _mediaRenderer?: IMediaStreamRenderer): Promise<void> {\\n\\t\\tthrow new Error('Not implemented');\\n\\t}\\n\\n\\tasync makeCall(_calleeNumber: string): Promise<void> {\\n\\t\\tthrow new Error('Not implemented');\\n\\t}\\n}\\n\",null],\"names\":[\"Operation\",\"UserState\",\"WorkflowTypes\",\"Emitter\",\"UserAgent\",\"Invitation\",\"SessionState\",\"Registerer\",\"RequestPendingError\",\"Inviter\",\"URI\",\"SessionDescriptionHandler\",\"toggleMediaStreamTracks\",\"LocalStream\",\"QueueAggregator\",\"RemoteStream\",\"module\",\"export\",\"VoIPUser\",\"link\",\"v\",\"default\",\"operationInProgress\",\"_opInProgress\",\"userState\",\"_userState\",\"constructor\",\"config\",\"mediaRenderer\",\"state\",\"isReady\",\"enableVideo\",\"remoteStream\",\"userAgentOptions\",\"userAgent\",\"registerer\",\"mediaStreamRendered\",\"_connectionState\",\"_held\",\"mode\",\"queueInfo\",\"connectionRetryCount\",\"stop\",\"networkEmitter\",\"offlineNetworkHandler\",\"onlineNetworkHandler\",\"optionsKeepaliveInterval\",\"optionsKeepAliveDebounceTimeInSec\",\"attemptRegistration\",\"session\",\"_callState\",\"_callerInfo\",\"IDLE\",\"OP_NONE\",\"onNetworkRestored\",\"bind\",\"onNetworkLost\",\"init\",\"sipUri\",\"concat\",\"authUserName\",\"sipRegistrarHostnameOrIP\",\"transportOptions\",\"server\",\"webSocketURI\",\"connectionTimeout\",\"keepAliveInterval\",\"sdpFactoryOptions\",\"iceGatheringTimeout\",\"peerConnectionConfiguration\",\"iceServers\",\"delegate\",\"onInvite\",\"invitation\",\"handleIncomingCall\",\"authorizationPassword\",\"authPassword\",\"authorizationUsername\",\"uri\",\"makeURI\",\"sessionDescriptionHandlerFactoryOptions\",\"logConfiguration\",\"logLevel\",\"transport\",\"isConnected\",\"OP_CONNECT\",\"onConnect\",\"onConnected\",\"onDisconnect\",\"onDisconnected\",\"window\",\"addEventListener\",\"start\",\"enableKeepAliveUsingOptionsForUnstableNetworks\",\"startOptionsPingForUnstableNetworks\",\"error\",\"sendOptions\",\"emit\",\"callState\",\"attemptReconnection\",\"userConfig\",\"connectionState\",\"callerInfo\",\"Error\",\"caller\",\"localMediaStream\",\"_this$session\",\"sdh\",\"sessionDescriptionHandler\",\"onRegistrationRequestAccept\",\"OP_REGISTER\",\"OP_UNREGISTER\",\"onRegistrationRequestReject\",\"OP_PROCESS_INVITE\",\"UAS\",\"setupSessionEventHandlers\",\"callerId\",\"remoteIdentity\",\"user\",\"callerName\",\"displayName\",\"host\",\"reject\",\"_this$session2\",\"stateChange\",\"addListener\",\"_this$remoteStream\",\"Initial\",\"Establishing\",\"callInfo\",\"Established\",\"UAC\",\"setupRemoteMedia\",\"Terminating\",\"Terminated\",\"undefined\",\"clear\",\"onTrackAdded\",\"_event\",\"console\",\"log\",\"onTrackRemoved\",\"_this$session3\",\"_this$mediaStreamRend\",\"remoteMediaStream\",\"mediaElement\",\"remoteMediaElement\",\"play\",\"handleMuteUnmute\",\"muteState\",\"_this$session4\",\"_this$session5\",\"Promise\",\"resolve\",\"peerConnection\",\"invite\",\"requestDelegate\",\"onAccept\",\"onReject\",\"then\",\"catch\",\"_this$session6\",\"id\",\"handleHoldUnhold\",\"holdState\",\"_this$session7\",\"_this$session8\",\"sessionDescriptionHandlerOptions\",\"sessionDescriptionHandlerOptionsReInvite\",\"hold\",\"_this$session9\",\"create\",\"voip\",\"outgoingRequestDelegate\",\"_this$userAgent\",\"_this$userAgent2\",\"outgoingMessage\",\"userAgentCore\",\"makeOutgoingRequestMessage\",\"request\",\"register\",\"_this$registerer\",\"unregister\",\"_this$registerer2\",\"all\",\"acceptCall\",\"videoInvite\",\"body\",\"indexOf\",\"invitationAcceptOptions\",\"constraints\",\"audio\",\"video\",\"accept\",\"canRejectCall\",\"includes\",\"canEndOrHoldCall\",\"rejectCall\",\"endCall\",\"cancel\",\"bye\",\"muteCall\",\"holdCall\",\"switchMediaRenderer\",\"setWorkflowMode\",\"CONTACT_CENTER_USER\",\"setMembershipSubscription\",\"subscription\",\"_this$queueInfo\",\"setMembership\",\"getAggregator\",\"getRegistrarState\",\"_this$registerer3\",\"toString\",\"toLocaleLowerCase\",\"_this$userAgent3\",\"_this$registerer4\",\"OP_CLEANUP\",\"dispose\",\"removeEventListener\",\"onNetworkEvent\",\"event\",\"handler\",\"on\",\"offNetworkEvent\",\"off\",\"reconnectionAttempt\",\"arguments\",\"length\",\"checkRegistration\",\"reconnectionAttempts\",\"reconnectionDelay\",\"Math\",\"pow\",\"setTimeout\",\"_this$userAgent4\",\"reconnect\",\"attemptPostRecoveryRoutine\",\"attemptPostRecoveryRegistrationRoutine\",\"sendKeepAliveAndWaitForResponse\",\"withDebounce\",\"promise\",\"keepAliveAccepted\",\"responseWaitTime\",\"_error\",\"e\",\"_this$registerer6\",\"_resolve\",\"_reject\",\"_this$registerer5\",\"changeAudioInputDevice\",\"_this$session10\",\"warn\",\"newStream\",\"requestNewStream\",\"replaceTrack\",\"makeCallURI\",\"_callee\",\"_mediaRenderer\",\"makeCall\",\"_calleeNumber\"],\"mappings\":\"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\"}"}