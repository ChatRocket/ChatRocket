{"code":"Package[\"core-runtime\"].queue(\"allow-deny\",function(){var e,t=Package.meteor.Meteor;Package.meteor.global,Package.meteor.meteorEnv;var r=Package.minimongo.LocalCollection;Package.minimongo.Minimongo;var n=Package.check.check,a=Package.check.Match,s=Package.ejson.EJSON,c=Package[\"ddp-client\"].DDP,o=Package.modules.meteorInstall;Package.modules.meteorBabelHelpers;var i=Package.promise.Promise;return Package[\"ecmascript-runtime-client\"].Symbol,Package[\"ecmascript-runtime-client\"].Map,Package[\"ecmascript-runtime-client\"].Set,{export:function(){return{AllowDeny:e}},require:o({node_modules:{meteor:{\"allow-deny\":{\"allow-deny.js\":function o(o,l,u){u.link(\"@babel/runtime/regenerator\",{default:function(e){d=e}},0),u.link(\"@babel/runtime/helpers/objectSpread2\",{default:function(e){f=e}},1),u.link(\"@babel/runtime/helpers/createForOfIteratorHelperLoose\",{default:function(e){h=e}},2);var d,f,h,p=Object.prototype.hasOwnProperty,v=(e={CollectionPrototype:{}}).CollectionPrototype;function _(e,t){var r,n,a;return d.async(function(s){for(;;)switch(s.prev=s.next){case 0:r=h(e);case 1:if((n=r()).done){s.next=9;break}return a=n.value,s.next=5,d.awrap(t(a));case 5:if(!s.sent){s.next=7;break}return s.abrupt(\"return\",!0);case 7:s.next=1;break;case 9:return s.abrupt(\"return\",!1);case 10:case\"end\":return s.stop()}},null,null,null,i)}function y(e,t){var r,n,a;return d.async(function(s){for(;;)switch(s.prev=s.next){case 0:r=h(e);case 1:if((n=r()).done){s.next=9;break}return a=n.value,s.next=5,d.awrap(t(a));case 5:if(s.sent){s.next=7;break}return s.abrupt(\"return\",!1);case 7:s.next=1;break;case 9:return s.abrupt(\"return\",!0);case 10:case\"end\":return s.stop()}},null,null,null,i)}v.allow=function(e){A(this,\"allow\",e)},v.deny=function(e){A(this,\"deny\",e)},v._defineMutationMethods=function(e){var r=this;if(e=e||{},r._restricted=!1,r._insecure=void 0,r._validators={insert:{allow:[],deny:[]},update:{allow:[],deny:[]},remove:{allow:[],deny:[]},insertAsync:{allow:[],deny:[]},updateAsync:{allow:[],deny:[]},removeAsync:{allow:[],deny:[]},upsertAsync:{allow:[],deny:[]},fetch:[],fetchAllFields:!1},r._name&&(r._prefix=\"/\"+r._name+\"/\",r._connection&&(r._connection===t.server||t.isClient))){var s={};[\"insertAsync\",\"updateAsync\",\"removeAsync\",\"insert\",\"update\",\"remove\"].forEach(function(c){var o=r._prefix+c;if(e.useExisting){var i=t.isClient?\"_methodHandlers\":\"method_handlers\";if(r._connection[i]&&\"function\"==typeof r._connection[i][o])return}var l=function(e){return e.includes(\"insert\")};s[o]=function(){n(arguments,[a.Any]);var e=Array.from(arguments);try{var s=null;if(l(c)&&!p.call(e[0],\"_id\")&&(s=r._makeNewID()),this.isSimulation)return null!==s&&(e[0]._id=s),r._collection[c].apply(r._collection,e);if(l(c)||x(e[0],c),r._restricted){if(0===r._validators[c].allow.length)throw new t.Error(403,\"Access denied. No allow validators set on restricted collection for method '\"+c+\"'.\");var o=c.replace(\"Async\",\"\"),i=\"_validated\"+c.charAt(0).toUpperCase()+o.slice(1),u=t.isServer?i+\"Async\":i;return e.unshift(this.userId),l(c)&&e.push(s),r[u].apply(r,e)}if(r._isInsecure())return null!==s&&(e[0]._id=s),r._collection[({insert:\"insertAsync\",update:\"updateAsync\",remove:\"removeAsync\"})[c]||c].apply(r._collection,e);throw new t.Error(403,\"Access denied\")}catch(e){if(\"MongoError\"===e.name||\"BulkWriteError\"===e.name||\"MongoBulkWriteError\"===e.name||\"MinimongoError\"===e.name)throw new t.Error(409,e.toString());throw e}}}),r._connection.methods(s)}},v._updateFetch=function(e){if(!this._validators.fetchAllFields){if(e){var t=Object.create(null),r=function(e){return e&&e.forEach(function(e){return t[e]=1})};r(this._validators.fetch),r(e),this._validators.fetch=Object.keys(t)}else this._validators.fetchAllFields=!0,this._validators.fetch=null}},v._isInsecure=function(){return void 0===this._insecure?!!Package.insecure:this._insecure},v._validatedInsertAsync=function(e,r,n){var a;return d.async(function(s){for(;;)switch(s.prev=s.next){case 0:return a=this,s.next=3,d.awrap(_(a._validators.insertAsync.deny,function a(a){var s;return d.async(function c(c){for(;;)switch(c.prev=c.next){case 0:if(s=a(e,b(a,r,n)),!t._isPromise(s)){c.next=7;break}return c.next=4,d.awrap(s);case 4:c.t0=c.sent,c.next=8;break;case 7:c.t0=s;case 8:return c.abrupt(\"return\",c.t0);case 9:case\"end\":return c.stop()}},null,null,null,i)}));case 3:if(!s.sent){s.next=5;break}throw new t.Error(403,\"Access denied\");case 5:return s.next=7,d.awrap(y(a._validators.insertAsync.allow,function a(a){var s;return d.async(function c(c){for(;;)switch(c.prev=c.next){case 0:if(s=a(e,b(a,r,n)),!t._isPromise(s)){c.next=7;break}return c.next=4,d.awrap(s);case 4:c.t0=c.sent,c.next=8;break;case 7:c.t0=s;case 8:return c.abrupt(\"return\",!c.t0);case 9:case\"end\":return c.stop()}},null,null,null,i)}));case 7:if(!s.sent){s.next=9;break}throw new t.Error(403,\"Access denied\");case 9:return null!==n&&(r._id=n),s.abrupt(\"return\",a._collection.insertAsync.call(a._collection,r));case 11:case\"end\":return s.stop()}},null,this,null,i)},v._validatedInsert=function(e,r,n){if(this._validators.insert.deny.some(function(t){return t(e,b(t,r,n))})||this._validators.insert.allow.every(function(t){return!t(e,b(t,r,n))}))throw new t.Error(403,\"Access denied\");return null!==n&&(r._id=n),(t.isServer?this._collection.insertAsync:this._collection.insert).call(this._collection,r)},v._validatedUpdateAsync=function(e,a,s,c){var o,l,u,f,h,v,b;return d.async(function(A){for(;;)switch(A.prev=A.next){case 0:if(o=this,n(s,Object),c=Object.assign(Object.create(null),c),r._selectorIsIdPerhapsAsObject(a)){A.next=5;break}throw Error(\"validated update should be of a single ID\");case 5:if(!c.upsert){A.next=7;break}throw new t.Error(403,\"Access denied. Upserts not allowed in a restricted collection.\");case 7:if(l=\"Access denied. In a restricted collection you can only update documents, not replace them. Use a Mongo update operator, such as '$set'.\",u=Object.keys(s),f={},0!==u.length){A.next=12;break}throw new t.Error(403,l);case 12:return u.forEach(function(e){var r=s[e];if(\"$\"!==e.charAt(0))throw new t.Error(403,l);if(p.call(w,e))Object.keys(r).forEach(function(e){-1!==e.indexOf(\".\")&&(e=e.substring(0,e.indexOf(\".\"))),f[e]=!0});else throw new t.Error(403,\"Access denied. Operator \"+e+\" not allowed in a restricted collection.\")}),h=Object.keys(f),v={transform:null},o._validators.fetchAllFields||(v.fields={},o._validators.fetch.forEach(function(e){v.fields[e]=1})),A.next=18,d.awrap(o._collection.findOneAsync(a,v));case 18:if(b=A.sent){A.next=21;break}return A.abrupt(\"return\",0);case 21:return A.next=23,d.awrap(_(o._validators.updateAsync.deny,function r(r){var n,a;return d.async(function c(c){for(;;)switch(c.prev=c.next){case 0:if(n=m(r,b),a=r(e,n,h,s),!t._isPromise(a)){c.next=8;break}return c.next=5,d.awrap(a);case 5:c.t0=c.sent,c.next=9;break;case 8:c.t0=a;case 9:return c.abrupt(\"return\",c.t0);case 10:case\"end\":return c.stop()}},null,null,null,i)}));case 23:if(!A.sent){A.next=25;break}throw new t.Error(403,\"Access denied\");case 25:return A.next=27,d.awrap(y(o._validators.updateAsync.allow,function r(r){var n,a;return d.async(function c(c){for(;;)switch(c.prev=c.next){case 0:if(n=m(r,b),a=r(e,n,h,s),!t._isPromise(a)){c.next=8;break}return c.next=5,d.awrap(a);case 5:c.t0=c.sent,c.next=9;break;case 8:c.t0=a;case 9:return c.abrupt(\"return\",!c.t0);case 10:case\"end\":return c.stop()}},null,null,null,i)}));case 27:if(!A.sent){A.next=29;break}throw new t.Error(403,\"Access denied\");case 29:return c._forbidReplace=!0,A.abrupt(\"return\",o._collection.updateAsync.call(o._collection,a,s,c));case 31:case\"end\":return A.stop()}},null,this,null,i)},v._validatedUpdate=function(e,a,s,c){if(n(s,Object),c=Object.assign(Object.create(null),c),!r._selectorIsIdPerhapsAsObject(a))throw Error(\"validated update should be of a single ID\");if(c.upsert)throw new t.Error(403,\"Access denied. Upserts not allowed in a restricted collection.\");var o=\"Access denied. In a restricted collection you can only update documents, not replace them. Use a Mongo update operator, such as '$set'.\",i=Object.keys(s),l={};if(0===i.length)throw new t.Error(403,o);i.forEach(function(e){var r=s[e];if(\"$\"!==e.charAt(0))throw new t.Error(403,o);if(p.call(w,e))Object.keys(r).forEach(function(e){-1!==e.indexOf(\".\")&&(e=e.substring(0,e.indexOf(\".\"))),l[e]=!0});else throw new t.Error(403,\"Access denied. Operator \"+e+\" not allowed in a restricted collection.\")});var u=Object.keys(l),d={transform:null};this._validators.fetchAllFields||(d.fields={},this._validators.fetch.forEach(function(e){d.fields[e]=1}));var f=this._collection.findOne(a,d);if(!f)return 0;if(this._validators.update.deny.some(function(t){var r=m(t,f);return t(e,r,u,s)})||this._validators.update.allow.every(function(t){var r=m(t,f);return!t(e,r,u,s)}))throw new t.Error(403,\"Access denied\");return c._forbidReplace=!0,this._collection.update.call(this._collection,a,s,c)};var w={$inc:1,$set:1,$unset:1,$addToSet:1,$pop:1,$pullAll:1,$pull:1,$pushAll:1,$push:1,$bit:1};function m(e,t){return e.transform?e.transform(t):t}function b(e,t,r){var n=t;return e.transform&&(n=s.clone(t),null!==r&&(n._id=r),n=e.transform(n)),n}function A(e,t,n){var a=/^(?:insertAsync|updateAsync|removeAsync|insert|update|remove|fetch|transform)$/;if(Object.keys(n).forEach(function(e){if(!a.test(e))throw Error(t+\": Invalid key: \"+e)}),e._restricted=!0,[\"insertAsync\",\"updateAsync\",\"removeAsync\",\"insert\",\"update\",\"remove\"].forEach(function(a){if(p.call(n,a)){if(!(n[a]instanceof Function))throw Error(t+\": Value for `\"+a+\"` must be a function\");void 0===n.transform?n[a].transform=e._transform:n[a].transform=r.wrapTransform(n.transform),e._validators[a][t].push(n[a])}}),n.updateAsync||n.removeAsync||n.fetch){if(n.fetch&&!(n.fetch instanceof Array))throw Error(t+\": Value for `fetch` must be an array\");e._updateFetch(n.fetch)}}function x(e,n){if(!r._selectorIsIdPerhapsAsObject(e))throw new t.Error(403,\"Not permitted. Untrusted code may only \"+n+\" documents by ID.\")}function k(){var e=(c._CurrentMethodInvocation||c._CurrentInvocation).get();return e&&e.isSimulation}v._validatedRemoveAsync=function(e,r){var n,a,s;return d.async(function(c){for(;;)switch(c.prev=c.next){case 0:return n=this,a={transform:null},n._validators.fetchAllFields||(a.fields={},n._validators.fetch.forEach(function(e){a.fields[e]=1})),c.next=5,d.awrap(n._collection.findOneAsync(r,a));case 5:if(s=c.sent){c.next=8;break}return c.abrupt(\"return\",0);case 8:return c.next=10,d.awrap(_(n._validators.removeAsync.deny,function r(r){var n;return d.async(function a(a){for(;;)switch(a.prev=a.next){case 0:if(n=r(e,m(r,s)),!t._isPromise(n)){a.next=7;break}return a.next=4,d.awrap(n);case 4:a.t0=a.sent,a.next=8;break;case 7:a.t0=n;case 8:return a.abrupt(\"return\",a.t0);case 9:case\"end\":return a.stop()}},null,null,null,i)}));case 10:if(!c.sent){c.next=12;break}throw new t.Error(403,\"Access denied\");case 12:return c.next=14,d.awrap(y(n._validators.removeAsync.allow,function r(r){var n;return d.async(function a(a){for(;;)switch(a.prev=a.next){case 0:if(n=r(e,m(r,s)),!t._isPromise(n)){a.next=7;break}return a.next=4,d.awrap(n);case 4:a.t0=a.sent,a.next=8;break;case 7:a.t0=n;case 8:return a.abrupt(\"return\",!a.t0);case 9:case\"end\":return a.stop()}},null,null,null,i)}));case 14:if(!c.sent){c.next=16;break}throw new t.Error(403,\"Access denied\");case 16:return c.abrupt(\"return\",n._collection.removeAsync.call(n._collection,r));case 17:case\"end\":return c.stop()}},null,this,null,i)},v._validatedRemove=function(e,r){var n={transform:null};this._validators.fetchAllFields||(n.fields={},this._validators.fetch.forEach(function(e){n.fields[e]=1}));var a=this._collection.findOne(r,n);if(!a)return 0;if(this._validators.remove.deny.some(function(t){return t(e,m(t,a))})||this._validators.remove.allow.every(function(t){return!t(e,m(t,a))}))throw new t.Error(403,\"Access denied\");return this._collection.remove.call(this._collection,r)},v._callMutatorMethodAsync=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};\"updateAsync\"!==e&&\"removeAsync\"!==e||k()||x(t[0],e);var n=this._prefix+e;return this._connection.applyAsync(n,t,f({returnStubValue:\"stub\"===this.resolverType||null==this.resolverType,returnServerResultPromise:!this._connection._stream._isStub&&\"stub\"!==this.resolverType},r))},v._callMutatorMethod=function(e,r,n){!t.isClient||n||k()||(n=function(r){r&&t._debug(e+\" failed\",r)}),\"update\"!==e&&\"remove\"!==e||k()||x(r[0],e);var a=this._prefix+e;return this._connection.apply(a,r,{returnStubValue:!0},n)}}}}}},{extensions:[\".js\",\".json\"]}),eagerModulePaths:[\"/node_modules/meteor/allow-deny/allow-deny.js\"]}});","map":"{\"version\":3,\"sources\":[\"packages/allow-deny/allow-deny.js\",\"<anon>\"],\"sourcesContent\":[\"///\\n/// Remote methods and access control.\\n///\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\n// Restrict default mutators on collection. allow() and deny() take the\\n// same options:\\n//\\n// options.insertAsync {Function(userId, doc)}\\n//   return true to allow/deny adding this document\\n//\\n// options.updateAsync {Function(userId, docs, fields, modifier)}\\n//   return true to allow/deny updating these documents.\\n//   `fields` is passed as an array of fields that are to be modified\\n//\\n// options.removeAsync {Function(userId, docs)}\\n//   return true to allow/deny removing these documents\\n//\\n// options.fetch {Array}\\n//   Fields to fetch for these validators. If any call to allow or deny\\n//   does not have this option then all fields are loaded.\\n//\\n// allow and deny can be called multiple times. The validators are\\n// evaluated as follows:\\n// - If neither deny() nor allow() has been called on the collection,\\n//   then the request is allowed if and only if the \\\"insecure\\\" smart\\n//   package is in use.\\n// - Otherwise, if any deny() function returns true, the request is denied.\\n// - Otherwise, if any allow() function returns true, the request is allowed.\\n// - Otherwise, the request is denied.\\n//\\n// Meteor may call your deny() and allow() functions in any order, and may not\\n// call all of them if it is able to make a decision without calling them all\\n// (so don't include side effects).\\n\\nAllowDeny = {\\n  CollectionPrototype: {}\\n};\\n\\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these\\n// methods\\nconst CollectionPrototype = AllowDeny.CollectionPrototype;\\n\\n/**\\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\\n * @locus Server\\n * @method allow\\n * @memberOf Mongo.Collection\\n * @instance\\n * @param {Object} options\\n * @param {Function} options.insertAsync,updateAsync,removeAsync Functions that look at a proposed modification to the database and return true if it should be allowed.\\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\\n */\\nCollectionPrototype.allow = function(options) {\\n  addValidator(this, 'allow', options);\\n};\\n\\n/**\\n * @summary Override `allow` rules.\\n * @locus Server\\n * @method deny\\n * @memberOf Mongo.Collection\\n * @instance\\n * @param {Object} options\\n * @param {Function} options.insertAsync,updateAsync,removeAsync Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\\n */\\nCollectionPrototype.deny = function(options) {\\n  addValidator(this, 'deny', options);\\n};\\n\\nCollectionPrototype._defineMutationMethods = function(options) {\\n  const self = this;\\n  options = options || {};\\n\\n  // set to true once we call any allow or deny methods. If true, use\\n  // allow/deny semantics. If false, use insecure mode semantics.\\n  self._restricted = false;\\n\\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which\\n  // means insecure iff the insecure package is loaded. This property can be\\n  // overriden by tests or packages wishing to change insecure mode behavior of\\n  // their collections.\\n  self._insecure = undefined;\\n\\n  self._validators = {\\n    insert: {allow: [], deny: []},\\n    update: {allow: [], deny: []},\\n    remove: {allow: [], deny: []},\\n    insertAsync: {allow: [], deny: []},\\n    updateAsync: {allow: [], deny: []},\\n    removeAsync: {allow: [], deny: []},\\n    upsertAsync: {allow: [], deny: []}, // dummy arrays; can't set these!\\n    fetch: [],\\n    fetchAllFields: false\\n  };\\n\\n  if (!self._name)\\n    return; // anonymous collection\\n\\n  // XXX Think about method namespacing. Maybe methods should be\\n  // \\\"Meteor:Mongo:insertAsync/NAME\\\"?\\n  self._prefix = '/' + self._name + '/';\\n\\n  // Mutation Methods\\n  // Minimongo on the server gets no stubs; instead, by default\\n  // it wait()s until its result is ready, yielding.\\n  // This matches the behavior of macromongo on the server better.\\n  // XXX see #MeteorServerNull\\n  if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {\\n    const m = {};\\n\\n    [\\n      'insertAsync',\\n      'updateAsync',\\n      'removeAsync',\\n      'insert',\\n      'update',\\n      'remove',\\n    ].forEach(method => {\\n      const methodName = self._prefix + method;\\n\\n      if (options.useExisting) {\\n        const handlerPropName = Meteor.isClient\\n          ? '_methodHandlers'\\n          : 'method_handlers';\\n        // Do not try to create additional methods if this has already been called.\\n        // (Otherwise the .methods() call below will throw an error.)\\n        if (\\n          self._connection[handlerPropName] &&\\n          typeof self._connection[handlerPropName][methodName] === 'function'\\n        )\\n          return;\\n      }\\n\\n      const isInsert = name => name.includes('insert');\\n\\n      m[methodName] = function (/* ... */) {\\n        // All the methods do their own validation, instead of using check().\\n        check(arguments, [Match.Any]);\\n        const args = Array.from(arguments);\\n        try {\\n          // For an insert/insertAsync, if the client didn't specify an _id, generate one\\n          // now; because this uses DDP.randomStream, it will be consistent with\\n          // what the client generated. We generate it now rather than later so\\n          // that if (eg) an allow/deny rule does an insert/insertAsync to the same\\n          // collection (not that it really should), the generated _id will\\n          // still be the first use of the stream and will be consistent.\\n          //\\n          // However, we don't actually stick the _id onto the document yet,\\n          // because we want allow/deny rules to be able to differentiate\\n          // between arbitrary client-specified _id fields and merely\\n          // client-controlled-via-randomSeed fields.\\n          let generatedId = null;\\n          if (isInsert(method) && !hasOwn.call(args[0], '_id')) {\\n            generatedId = self._makeNewID();\\n          }\\n\\n          if (this.isSimulation) {\\n            // In a client simulation, you can do any mutation (even with a\\n            // complex selector).\\n            if (generatedId !== null) {\\n              args[0]._id = generatedId;\\n            }\\n            return self._collection[method].apply(self._collection, args);\\n          }\\n\\n          // This is the server receiving a method call from the client.\\n\\n          // We don't allow arbitrary selectors in mutations from the client: only\\n          // single-ID selectors.\\n          if (!isInsert(method)) throwIfSelectorIsNotId(args[0], method);\\n\\n          if (self._restricted) {\\n            // short circuit if there is no way it will pass.\\n            if (self._validators[method].allow.length === 0) {\\n              throw new Meteor.Error(\\n                403,\\n                'Access denied. No allow validators set on restricted ' +\\n                  \\\"collection for method '\\\" +\\n                  method +\\n                  \\\"'.\\\"\\n              );\\n            }\\n\\n            const syncMethodName = method.replace('Async', '');\\n            const syncValidatedMethodName = '_validated' + method.charAt(0).toUpperCase() + syncMethodName.slice(1);\\n            // it forces to use async validated behavior on the server\\n            const validatedMethodName = Meteor.isServer ? syncValidatedMethodName + 'Async' : syncValidatedMethodName;\\n\\n            args.unshift(this.userId);\\n            isInsert(method) && args.push(generatedId);\\n            return self[validatedMethodName].apply(self, args);\\n          } else if (self._isInsecure()) {\\n            if (generatedId !== null) args[0]._id = generatedId;\\n            // In insecure mode we use the server _collection methods, and these sync methods\\n            // do not exist in the server anymore, so we have this mapper to call the async methods\\n            // instead.\\n            const syncMethodsMapper = {\\n              insert: \\\"insertAsync\\\",\\n              update: \\\"updateAsync\\\",\\n              remove: \\\"removeAsync\\\",\\n            };\\n\\n\\n            // In insecure mode, allow any mutation (with a simple selector).\\n            // XXX This is kind of bogus.  Instead of blindly passing whatever\\n            //     we get from the network to this function, we should actually\\n            //     know the correct arguments for the function and pass just\\n            //     them.  For example, if you have an extraneous extra null\\n            //     argument and this is Mongo on the server, the .wrapAsync'd\\n            //     functions like update will get confused and pass the\\n            //     \\\"fut.resolver()\\\" in the wrong slot, where _update will never\\n            //     invoke it. Bam, broken DDP connection.  Probably should just\\n            //     take this whole method and write it three times, invoking\\n            //     helpers for the common code.\\n            return self._collection[syncMethodsMapper[method] || method].apply(self._collection, args);\\n          } else {\\n            // In secure mode, if we haven't called allow or deny, then nothing\\n            // is permitted.\\n            throw new Meteor.Error(403, 'Access denied');\\n          }\\n        } catch (e) {\\n          if (\\n            e.name === 'MongoError' ||\\n            // for old versions of MongoDB (probably not necessary but it's here just in case)\\n            e.name === 'BulkWriteError' ||\\n            // for newer versions of MongoDB (https://docs.mongodb.com/drivers/node/current/whats-new/#bulkwriteerror---mongobulkwriteerror)\\n            e.name === 'MongoBulkWriteError' ||\\n            e.name === 'MinimongoError'\\n          ) {\\n            throw new Meteor.Error(409, e.toString());\\n          } else {\\n            throw e;\\n          }\\n        }\\n      };\\n    });\\n\\n    self._connection.methods(m);\\n  }\\n};\\n\\nCollectionPrototype._updateFetch = function (fields) {\\n  const self = this;\\n\\n  if (!self._validators.fetchAllFields) {\\n    if (fields) {\\n      const union = Object.create(null);\\n      const add = names => names && names.forEach(name => union[name] = 1);\\n      add(self._validators.fetch);\\n      add(fields);\\n      self._validators.fetch = Object.keys(union);\\n    } else {\\n      self._validators.fetchAllFields = true;\\n      // clear fetch just to make sure we don't accidentally read it\\n      self._validators.fetch = null;\\n    }\\n  }\\n};\\n\\nCollectionPrototype._isInsecure = function () {\\n  const self = this;\\n  if (self._insecure === undefined)\\n    return !!Package.insecure;\\n  return self._insecure;\\n};\\n\\nasync function asyncSome(array, predicate) {\\n  for (let item of array) {\\n    if (await predicate(item)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\n\\nasync function asyncEvery(array, predicate) {\\n  for (let item of array) {\\n    if (!await predicate(item)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\nCollectionPrototype._validatedInsertAsync = async function(userId, doc,\\n                                                           generatedId) {\\n  const self = this;\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (await asyncSome(self._validators.insertAsync.deny, async (validator) => {\\n    const result = validator(userId, docToValidate(validator, doc, generatedId));\\n    return Meteor._isPromise(result) ? await result : result;\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n\\n  if (await asyncEvery(self._validators.insertAsync.allow, async (validator) => {\\n    const result = validator(userId, docToValidate(validator, doc, generatedId));\\n    return !(Meteor._isPromise(result) ? await result : result);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  // If we generated an ID above, insertAsync it now: after the validation, but\\n  // before actually inserting.\\n  if (generatedId !== null)\\n    doc._id = generatedId;\\n\\n  return self._collection.insertAsync.call(self._collection, doc);\\n};\\n\\nCollectionPrototype._validatedInsert = function (userId, doc,\\n                                                         generatedId) {\\n  const self = this;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (self._validators.insert.deny.some((validator) => {\\n    return validator(userId, docToValidate(validator, doc, generatedId));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n\\n  if (self._validators.insert.allow.every((validator) => {\\n    return !validator(userId, docToValidate(validator, doc, generatedId));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  // If we generated an ID above, insert it now: after the validation, but\\n  // before actually inserting.\\n  if (generatedId !== null)\\n    doc._id = generatedId;\\n\\n  return (Meteor.isServer\\n    ? self._collection.insertAsync\\n    : self._collection.insert\\n  ).call(self._collection, doc);\\n};\\n\\n// Simulate a mongo `update` operation while validating that the access\\n// control rules set by calls to `allow/deny` are satisfied. If all\\n// pass, rewrite the mongo operation to use $in to set the list of\\n// document ids to change ##ValidatedChange\\nCollectionPrototype._validatedUpdateAsync = async function(\\n    userId, selector, mutator, options) {\\n  const self = this;\\n\\n  check(mutator, Object);\\n\\n  options = Object.assign(Object.create(null), options);\\n\\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))\\n    throw new Error(\\\"validated update should be of a single ID\\\");\\n\\n  // We don't support upserts because they don't fit nicely into allow/deny\\n  // rules.\\n  if (options.upsert)\\n    throw new Meteor.Error(403, \\\"Access denied. Upserts not \\\" +\\n                           \\\"allowed in a restricted collection.\\\");\\n\\n  const noReplaceError = \\\"Access denied. In a restricted collection you can only\\\" +\\n        \\\" update documents, not replace them. Use a Mongo update operator, such \\\" +\\n        \\\"as '$set'.\\\";\\n\\n  const mutatorKeys = Object.keys(mutator);\\n\\n  // compute modified fields\\n  const modifiedFields = {};\\n\\n  if (mutatorKeys.length === 0) {\\n    throw new Meteor.Error(403, noReplaceError);\\n  }\\n  mutatorKeys.forEach((op) => {\\n    const params = mutator[op];\\n    if (op.charAt(0) !== '$') {\\n      throw new Meteor.Error(403, noReplaceError);\\n    } else if (!hasOwn.call(ALLOWED_UPDATE_OPERATIONS, op)) {\\n      throw new Meteor.Error(\\n        403, \\\"Access denied. Operator \\\" + op + \\\" not allowed in a restricted collection.\\\");\\n    } else {\\n      Object.keys(params).forEach((field) => {\\n        // treat dotted fields as if they are replacing their\\n        // top-level part\\n        if (field.indexOf('.') !== -1)\\n          field = field.substring(0, field.indexOf('.'));\\n\\n        // record the field we are trying to change\\n        modifiedFields[field] = true;\\n      });\\n    }\\n  });\\n\\n  const fields = Object.keys(modifiedFields);\\n\\n  const findOptions = {transform: null};\\n  if (!self._validators.fetchAllFields) {\\n    findOptions.fields = {};\\n    self._validators.fetch.forEach((fieldName) => {\\n      findOptions.fields[fieldName] = 1;\\n    });\\n  }\\n\\n  const doc = await self._collection.findOneAsync(selector, findOptions);\\n  if (!doc)  // none satisfied!\\n    return 0;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (await asyncSome(self._validators.updateAsync.deny, async (validator) => {\\n    const factoriedDoc = transformDoc(validator, doc);\\n    const result = validator(userId,\\n      factoriedDoc,\\n      fields,\\n      mutator);\\n    return Meteor._isPromise(result) ? await result : result;\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (await asyncEvery(self._validators.updateAsync.allow, async (validator) => {\\n    const factoriedDoc = transformDoc(validator, doc);\\n    const result = validator(userId,\\n      factoriedDoc,\\n      fields,\\n      mutator);\\n    return !(Meteor._isPromise(result) ? await result : result);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  options._forbidReplace = true;\\n\\n  // Back when we supported arbitrary client-provided selectors, we actually\\n  // rewrote the selector to include an _id clause before passing to Mongo to\\n  // avoid races, but since selector is guaranteed to already just be an ID, we\\n  // don't have to any more.\\n\\n  return self._collection.updateAsync.call(\\n    self._collection, selector, mutator, options);\\n};\\n\\nCollectionPrototype._validatedUpdate = function(\\n    userId, selector, mutator, options) {\\n  const self = this;\\n\\n  check(mutator, Object);\\n\\n  options = Object.assign(Object.create(null), options);\\n\\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))\\n    throw new Error(\\\"validated update should be of a single ID\\\");\\n\\n  // We don't support upserts because they don't fit nicely into allow/deny\\n  // rules.\\n  if (options.upsert)\\n    throw new Meteor.Error(403, \\\"Access denied. Upserts not \\\" +\\n                           \\\"allowed in a restricted collection.\\\");\\n\\n  const noReplaceError = \\\"Access denied. In a restricted collection you can only\\\" +\\n        \\\" update documents, not replace them. Use a Mongo update operator, such \\\" +\\n        \\\"as '$set'.\\\";\\n\\n  const mutatorKeys = Object.keys(mutator);\\n\\n  // compute modified fields\\n  const modifiedFields = {};\\n\\n  if (mutatorKeys.length === 0) {\\n    throw new Meteor.Error(403, noReplaceError);\\n  }\\n  mutatorKeys.forEach((op) => {\\n    const params = mutator[op];\\n    if (op.charAt(0) !== '$') {\\n      throw new Meteor.Error(403, noReplaceError);\\n    } else if (!hasOwn.call(ALLOWED_UPDATE_OPERATIONS, op)) {\\n      throw new Meteor.Error(\\n        403, \\\"Access denied. Operator \\\" + op + \\\" not allowed in a restricted collection.\\\");\\n    } else {\\n      Object.keys(params).forEach((field) => {\\n        // treat dotted fields as if they are replacing their\\n        // top-level part\\n        if (field.indexOf('.') !== -1)\\n          field = field.substring(0, field.indexOf('.'));\\n\\n        // record the field we are trying to change\\n        modifiedFields[field] = true;\\n      });\\n    }\\n  });\\n\\n  const fields = Object.keys(modifiedFields);\\n\\n  const findOptions = {transform: null};\\n  if (!self._validators.fetchAllFields) {\\n    findOptions.fields = {};\\n    self._validators.fetch.forEach((fieldName) => {\\n      findOptions.fields[fieldName] = 1;\\n    });\\n  }\\n\\n  const doc = self._collection.findOne(selector, findOptions);\\n  if (!doc)  // none satisfied!\\n    return 0;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (self._validators.update.deny.some((validator) => {\\n    const factoriedDoc = transformDoc(validator, doc);\\n    return validator(userId,\\n                     factoriedDoc,\\n                     fields,\\n                     mutator);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (self._validators.update.allow.every((validator) => {\\n    const factoriedDoc = transformDoc(validator, doc);\\n    return !validator(userId,\\n                      factoriedDoc,\\n                      fields,\\n                      mutator);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  options._forbidReplace = true;\\n\\n  // Back when we supported arbitrary client-provided selectors, we actually\\n  // rewrote the selector to include an _id clause before passing to Mongo to\\n  // avoid races, but since selector is guaranteed to already just be an ID, we\\n  // don't have to any more.\\n\\n  return self._collection.update.call(\\n    self._collection, selector, mutator, options);\\n};\\n\\n// Only allow these operations in validated updates. Specifically\\n// whitelist operations, rather than blacklist, so new complex\\n// operations that are added aren't automatically allowed. A complex\\n// operation is one that does more than just modify its target\\n// field. For now this contains all update operations except '$rename'.\\n// http://docs.mongodb.org/manual/reference/operators/#update\\nconst ALLOWED_UPDATE_OPERATIONS = {\\n  $inc:1, $set:1, $unset:1, $addToSet:1, $pop:1, $pullAll:1, $pull:1,\\n  $pushAll:1, $push:1, $bit:1\\n};\\n\\n// Simulate a mongo `remove` operation while validating access control\\n// rules. See #ValidatedChange\\nCollectionPrototype._validatedRemoveAsync = async function(userId, selector) {\\n  const self = this;\\n\\n  const findOptions = {transform: null};\\n  if (!self._validators.fetchAllFields) {\\n    findOptions.fields = {};\\n    self._validators.fetch.forEach((fieldName) => {\\n      findOptions.fields[fieldName] = 1;\\n    });\\n  }\\n\\n  const doc = await self._collection.findOneAsync(selector, findOptions);\\n  if (!doc)\\n    return 0;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (await asyncSome(self._validators.removeAsync.deny, async (validator) => {\\n    const result = validator(userId, transformDoc(validator, doc));\\n    return Meteor._isPromise(result) ? await result : result;\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (await asyncEvery(self._validators.removeAsync.allow, async (validator) => {\\n    const result = validator(userId, transformDoc(validator, doc));\\n    return !(Meteor._isPromise(result) ? await result : result);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  // Back when we supported arbitrary client-provided selectors, we actually\\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\\n  // Mongo to avoid races, but since selector is guaranteed to already just be\\n  // an ID, we don't have to any more.\\n\\n  return self._collection.removeAsync.call(self._collection, selector);\\n};\\n\\nCollectionPrototype._validatedRemove = function(userId, selector) {\\n  const self = this;\\n\\n  const findOptions = {transform: null};\\n  if (!self._validators.fetchAllFields) {\\n    findOptions.fields = {};\\n    self._validators.fetch.forEach((fieldName) => {\\n      findOptions.fields[fieldName] = 1;\\n    });\\n  }\\n\\n  const doc = self._collection.findOne(selector, findOptions);\\n  if (!doc)\\n    return 0;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (self._validators.remove.deny.some((validator) => {\\n    return validator(userId, transformDoc(validator, doc));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (self._validators.remove.allow.every((validator) => {\\n    return !validator(userId, transformDoc(validator, doc));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  // Back when we supported arbitrary client-provided selectors, we actually\\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\\n  // Mongo to avoid races, but since selector is guaranteed to already just be\\n  // an ID, we don't have to any more.\\n\\n  return self._collection.remove.call(self._collection, selector);\\n};\\n\\nCollectionPrototype._callMutatorMethodAsync = function _callMutatorMethodAsync(name, args, options = {}) {\\n\\n  // For two out of three mutator methods, the first argument is a selector\\n  const firstArgIsSelector = name === \\\"updateAsync\\\" || name === \\\"removeAsync\\\";\\n  if (firstArgIsSelector && !alreadyInSimulation()) {\\n    // If we're about to actually send an RPC, we should throw an error if\\n    // this is a non-ID selector, because the mutation methods only allow\\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\\n    throwIfSelectorIsNotId(args[0], name);\\n  }\\n\\n  const mutatorMethodName = this._prefix + name;\\n  return this._connection.applyAsync(mutatorMethodName, args, {\\n    returnStubValue: this.resolverType === 'stub' || this.resolverType == null,\\n    // StubStream is only used for testing where you don't care about the server\\n    returnServerResultPromise: !this._connection._stream._isStub && this.resolverType !== 'stub',\\n    ...options,\\n  });\\n}\\n\\nCollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {\\n  if (Meteor.isClient && !callback && !alreadyInSimulation()) {\\n    // Client can't block, so it can't report errors by exception,\\n    // only by callback. If they forget the callback, give them a\\n    // default one that logs the error, so they aren't totally\\n    // baffled if their writes don't work because their database is\\n    // down.\\n    // Don't give a default callback in simulation, because inside stubs we\\n    // want to return the results from the local collection immediately and\\n    // not force a callback.\\n    callback = function (err) {\\n      if (err)\\n        Meteor._debug(name + \\\" failed\\\", err);\\n    };\\n  }\\n\\n  // For two out of three mutator methods, the first argument is a selector\\n  const firstArgIsSelector = name === \\\"update\\\" || name === \\\"remove\\\";\\n  if (firstArgIsSelector && !alreadyInSimulation()) {\\n    // If we're about to actually send an RPC, we should throw an error if\\n    // this is a non-ID selector, because the mutation methods only allow\\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\\n    throwIfSelectorIsNotId(args[0], name);\\n  }\\n\\n  const mutatorMethodName = this._prefix + name;\\n  return this._connection.apply(\\n    mutatorMethodName, args, { returnStubValue: true }, callback);\\n}\\n\\nfunction transformDoc(validator, doc) {\\n  if (validator.transform)\\n    return validator.transform(doc);\\n  return doc;\\n}\\n\\nfunction docToValidate(validator, doc, generatedId) {\\n  let ret = doc;\\n  if (validator.transform) {\\n    ret = EJSON.clone(doc);\\n    // If you set a server-side transform on your collection, then you don't get\\n    // to tell the difference between \\\"client specified the ID\\\" and \\\"server\\n    // generated the ID\\\", because transforms expect to get _id.  If you want to\\n    // do that check, you can do it with a specific\\n    // `C.allow({insertAsync: f, transform: null})` validator.\\n    if (generatedId !== null) {\\n      ret._id = generatedId;\\n    }\\n    ret = validator.transform(ret);\\n  }\\n  return ret;\\n}\\n\\nfunction addValidator(collection, allowOrDeny, options) {\\n  // validate keys\\n  const validKeysRegEx = /^(?:insertAsync|updateAsync|removeAsync|insert|update|remove|fetch|transform)$/;\\n  Object.keys(options).forEach((key) => {\\n    if (!validKeysRegEx.test(key))\\n      throw new Error(allowOrDeny + \\\": Invalid key: \\\" + key);\\n  });\\n\\n  collection._restricted = true;\\n\\n  [\\n    'insertAsync',\\n    'updateAsync',\\n    'removeAsync',\\n    'insert',\\n    'update',\\n    'remove',\\n  ].forEach(name => {\\n    if (hasOwn.call(options, name)) {\\n      if (!(options[name] instanceof Function)) {\\n        throw new Error(\\n          allowOrDeny + ': Value for `' + name + '` must be a function'\\n        );\\n      }\\n\\n      // If the transform is specified at all (including as 'null') in this\\n      // call, then take that; otherwise, take the transform from the\\n      // collection.\\n      if (options.transform === undefined) {\\n        options[name].transform = collection._transform; // already wrapped\\n      } else {\\n        options[name].transform = LocalCollection.wrapTransform(\\n          options.transform\\n        );\\n      }\\n      collection._validators[name][allowOrDeny].push(options[name]);\\n    }\\n  });\\n\\n  // Only updateAsync the fetch fields if we're passed things that affect\\n  // fetching. This way allow({}) and allow({insertAsync: f}) don't result in\\n  // setting fetchAllFields\\n  if (options.updateAsync || options.removeAsync || options.fetch) {\\n    if (options.fetch && !(options.fetch instanceof Array)) {\\n      throw new Error(allowOrDeny + \\\": Value for `fetch` must be an array\\\");\\n    }\\n    collection._updateFetch(options.fetch);\\n  }\\n}\\n\\nfunction throwIfSelectorIsNotId(selector, methodName) {\\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\\n    throw new Meteor.Error(\\n      403, \\\"Not permitted. Untrusted code may only \\\" + methodName +\\n        \\\" documents by ID.\\\");\\n  }\\n};\\n\\n// Determine if we are in a DDP method simulation\\nfunction alreadyInSimulation() {\\n  var CurrentInvocation =\\n    DDP._CurrentMethodInvocation ||\\n    // For backwards compatibility, as explained in this issue:\\n    // https://github.com/meteor/meteor/issues/8947\\n    DDP._CurrentInvocation;\\n\\n  const enclosing = CurrentInvocation.get();\\n  return enclosing && enclosing.isSimulation;\\n}\\n\",null],\"names\":[\"module\",\"link\",\"default\",\"v\",\"_regeneratorRuntime\",\"_objectSpread\",\"_createForOfIteratorHelperLoose\",\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"CollectionPrototype\",\"AllowDeny\",\"asyncSome\",\"array\",\"predicate\",\"_iterator\",\"_step\",\"item\",\"async\",\"_context\",\"prev\",\"next\",\"done\",\"value\",\"awrap\",\"sent\",\"abrupt\",\"stop\",\"Promise\",\"asyncEvery\",\"_iterator2\",\"_step2\",\"_context2\",\"allow\",\"options\",\"addValidator\",\"deny\",\"_defineMutationMethods\",\"self\",\"_restricted\",\"_insecure\",\"undefined\",\"_validators\",\"insert\",\"update\",\"remove\",\"insertAsync\",\"updateAsync\",\"removeAsync\",\"upsertAsync\",\"fetch\",\"fetchAllFields\",\"_name\",\"_prefix\",\"_connection\",\"Meteor\",\"server\",\"isClient\",\"m\",\"forEach\",\"method\",\"methodName\",\"useExisting\",\"handlerPropName\",\"isInsert\",\"name\",\"includes\",\"check\",\"arguments\",\"Match\",\"Any\",\"args\",\"Array\",\"from\",\"generatedId\",\"call\",\"_makeNewID\",\"isSimulation\",\"_id\",\"_collection\",\"apply\",\"throwIfSelectorIsNotId\",\"length\",\"Error\",\"syncMethodName\",\"replace\",\"syncValidatedMethodName\",\"charAt\",\"toUpperCase\",\"slice\",\"validatedMethodName\",\"isServer\",\"unshift\",\"userId\",\"push\",\"_isInsecure\",\"syncMethodsMapper\",\"e\",\"toString\",\"methods\",\"_updateFetch\",\"fields\",\"union\",\"create\",\"add\",\"names\",\"keys\",\"Package\",\"insecure\",\"_validatedInsertAsync\",\"doc\",\"_context5\",\"_callee\",\"validator\",\"result\",\"_callee$\",\"_context3\",\"docToValidate\",\"_isPromise\",\"t0\",\"_callee2\",\"_callee2$\",\"_context4\",\"_validatedInsert\",\"some\",\"every\",\"_validatedUpdateAsync\",\"selector\",\"mutator\",\"noReplaceError\",\"mutatorKeys\",\"modifiedFields\",\"findOptions\",\"_context8\",\"assign\",\"LocalCollection\",\"_selectorIsIdPerhapsAsObject\",\"upsert\",\"op\",\"params\",\"ALLOWED_UPDATE_OPERATIONS\",\"field\",\"indexOf\",\"substring\",\"transform\",\"fieldName\",\"findOneAsync\",\"_callee4\",\"factoriedDoc\",\"_callee4$\",\"_context6\",\"transformDoc\",\"_callee5\",\"_callee5$\",\"_context7\",\"_forbidReplace\",\"_validatedUpdate\",\"findOne\",\"$inc\",\"$set\",\"$unset\",\"$addToSet\",\"$pop\",\"$pullAll\",\"$pull\",\"$pushAll\",\"$push\",\"$bit\",\"ret\",\"EJSON\",\"clone\",\"collection\",\"allowOrDeny\",\"validKeysRegEx\",\"key\",\"test\",\"Function\",\"_transform\",\"wrapTransform\",\"alreadyInSimulation\",\"enclosing\",\"CurrentInvocation\",\"DDP\",\"_CurrentMethodInvocation\",\"_CurrentInvocation\",\"get\",\"_validatedRemoveAsync\",\"_context11\",\"_callee7\",\"_callee7$\",\"_context9\",\"_callee8\",\"_callee8$\",\"_context10\",\"_validatedRemove\",\"_callMutatorMethodAsync\",\"mutatorMethodName\",\"applyAsync\",\"returnStubValue\",\"resolverType\",\"returnServerResultPromise\",\"_stream\",\"_isStub\",\"_callMutatorMethod\",\"callback\",\"err\",\"_debug\"],\"mappings\":\"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\"}"}