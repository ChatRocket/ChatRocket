{"code":"Package[\"core-runtime\"].queue(\"rate-limit\",function(){Package.meteor.Meteor,Package.meteor.global,Package.meteor.meteorEnv,Package.random.Random;var e,t=Package.modules.meteorInstall;return Package.promise.Promise,{export:function(){return{RateLimiter:e}},require:t({node_modules:{meteor:{\"rate-limit\":{\"rate-limit.js\":function e(e,t,i){let r,s;i.export({RateLimiter:()=>l}),i.link(\"meteor/meteor\",{Meteor(e){r=e}},0),i.link(\"meteor/random\",{Random(e){s=e}},1);let n=Object.prototype.hasOwnProperty;class o{constructor(e,t){this.id=s.id(),this.options=e,this._matchers=t,this._lastResetTime=new Date().getTime(),this.counters={}}match(e){return Object.entries(this._matchers).every(t=>{let[i,r]=t;if(null!==r){if(!n.call(e,i))return!1;if(\"function\"==typeof r){if(!r(e[i]))return!1}else if(r!==e[i])return!1}return!0})}_generateKeyString(e){return Object.entries(this._matchers).filter(e=>{let[t]=e;return null!==this._matchers[t]}).reduce((t,i)=>{let[r,s]=i;return\"function\"==typeof s?s(e[r])&&(t+=r+e[r]):t+=r+e[r],t},\"\")}apply(e){let t=this._generateKeyString(e),i=new Date().getTime()-this._lastResetTime,r=this.options.intervalTime-i;return{key:t,timeSinceLastReset:i,timeToNextReset:r}}resetCounter(){this.counters={},this._lastResetTime=new Date().getTime()}_executeCallback(e,t){try{this.options.callback&&this.options.callback(e,t)}catch(e){console.error(e)}}}class l{constructor(){this.rules={}}check(e){let t={allowed:!0,timeToReset:0,numInvocationsLeft:1/0},i=this._findAllMatchingRules(e);return i.forEach(i=>{let r=i.apply(e),s=i.counters[r.key];r.timeToNextReset<0&&(i.resetCounter(),r.timeSinceLastReset=new Date().getTime()-i._lastResetTime,r.timeToNextReset=i.options.intervalTime,s=0),s>i.options.numRequestsAllowed?(t.timeToReset<r.timeToNextReset&&(t.timeToReset=r.timeToNextReset),t.allowed=!1,t.numInvocationsLeft=0):i.options.numRequestsAllowed-s<t.numInvocationsLeft&&t.allowed&&(t.timeToReset=r.timeToNextReset,t.numInvocationsLeft=i.options.numRequestsAllowed-s),t.ruleId=i.id,i._executeCallback(t,e)}),t}addRule(e,t,i,s){let n={numRequestsAllowed:t||10,intervalTime:i||1e3,callback:s&&r.bindEnvironment(s)},l=new o(n,e);return this.rules[l.id]=l,l.id}increment(e){let t=this._findAllMatchingRules(e);t.forEach(t=>{let i=t.apply(e);i.timeSinceLastReset>t.options.intervalTime&&t.resetCounter(),n.call(t.counters,i.key)?t.counters[i.key]++:t.counters[i.key]=1})}_findAllMatchingRules(e){return Object.values(this.rules).filter(t=>t.match(e))}removeRule(e){return!!this.rules[e]&&(delete this.rules[e],!0)}}}}}}},{extensions:[\".js\",\".json\"]}),eagerModulePaths:[\"/node_modules/meteor/rate-limit/rate-limit.js\"],mainModulePath:\"/node_modules/meteor/rate-limit/rate-limit.js\"}});","map":"{\"version\":3,\"sources\":[\"packages/rate-limit/rate-limit.js\",\"<anon>\"],\"sourcesContent\":[\"import { Meteor } from 'meteor/meteor';\\nimport { Random } from 'meteor/random';\\n\\n// Default time interval (in milliseconds) to reset rate limit counters\\nconst DEFAULT_INTERVAL_TIME_IN_MILLISECONDS = 1000;\\n// Default number of events allowed per time interval\\nconst DEFAULT_REQUESTS_PER_INTERVAL = 10;\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\n// A rule is defined by an options object that contains two fields,\\n// `numRequestsAllowed` which is the number of events allowed per interval, and\\n// an `intervalTime` which is the amount of time in milliseconds before the\\n// rate limit restarts its internal counters, and by a matchers object. A\\n// matchers object is a POJO that contains a set of keys with values that\\n// define the entire set of inputs that match for each key. The values can\\n// either be null (optional), a primitive or a function that returns a boolean\\n// of whether the provided input's value matches for this key.\\n//\\n// Rules are uniquely assigned an `id` and they store a dictionary of counters,\\n// which are records used to keep track of inputs that match the rule. If a\\n// counter reaches the `numRequestsAllowed` within a given `intervalTime`, a\\n// rate limit is reached and future inputs that map to that counter will\\n// result in errors being returned to the client.\\nclass Rule {\\n  constructor(options, matchers) {\\n    this.id = Random.id();\\n\\n    this.options = options;\\n\\n    this._matchers = matchers;\\n\\n    this._lastResetTime = new Date().getTime();\\n\\n    // Dictionary of input keys to counters\\n    this.counters = {};\\n  }\\n  // Determine if this rule applies to the given input by comparing all\\n  // rule.matchers. If the match fails, search short circuits instead of\\n  // iterating through all matchers.\\n  match(input) {\\n    return Object\\n      .entries(this._matchers)\\n      .every(([key, matcher]) => {\\n        if (matcher !== null) {\\n          if (!hasOwn.call(input, key)) {\\n            return false;\\n          } else if (typeof matcher === 'function') {\\n            if (!(matcher(input[key]))) {\\n              return false;\\n            }\\n          } else if (matcher !== input[key]) {\\n            return false;\\n          }\\n        }\\n        return true;\\n      });\\n  }\\n\\n  // Generates unique key string for provided input by concatenating all the\\n  // keys in the matcher with the corresponding values in the input.\\n  // Only called if rule matches input.\\n  _generateKeyString(input) {\\n    return Object.entries(this._matchers)\\n      .filter(([key]) => this._matchers[key] !== null)\\n      .reduce((returnString, [key, matcher]) => {\\n        if (typeof matcher === 'function') {\\n          if (matcher(input[key])) {\\n            returnString += key + input[key];\\n          }\\n        } else {\\n          returnString += key + input[key];\\n        }\\n        return returnString;\\n      }, '');\\n  }\\n\\n  // Applies the provided input and returns the key string, time since counters\\n  // were last reset and time to next reset.\\n  apply(input) {\\n    const key = this._generateKeyString(input);\\n    const timeSinceLastReset = new Date().getTime() - this._lastResetTime;\\n    const timeToNextReset = this.options.intervalTime - timeSinceLastReset;\\n    return {\\n      key,\\n      timeSinceLastReset,\\n      timeToNextReset,\\n    };\\n  }\\n\\n  // Reset counter dictionary for this specific rule. Called once the\\n  // timeSinceLastReset has exceeded the intervalTime. _lastResetTime is\\n  // set to be the current time in milliseconds.\\n  resetCounter() {\\n    // Delete the old counters dictionary to allow for garbage collection\\n    this.counters = {};\\n    this._lastResetTime = new Date().getTime();\\n  }\\n\\n  _executeCallback(reply, ruleInput) {\\n    try {\\n      if (this.options.callback) {\\n        this.options.callback(reply, ruleInput);\\n      }\\n    } catch (e) {\\n      // Do not throw error here\\n      console.error(e);\\n    }\\n  }\\n}\\n\\nclass RateLimiter {\\n  // Initialize rules to be an empty dictionary.\\n  constructor() {\\n    // Dictionary of all rules associated with this RateLimiter, keyed by their\\n    // id. Each rule object stores the rule pattern, number of events allowed,\\n    // last reset time and the rule reset interval in milliseconds.\\n\\n    this.rules = {};\\n  }\\n\\n  /**\\n  * Checks if this input has exceeded any rate limits.\\n  * @param  {object} input dictionary containing key-value pairs of attributes\\n  * that match to rules\\n  * @return {object} Returns object of following structure\\n  * { 'allowed': boolean - is this input allowed\\n  *   'timeToReset': integer | Infinity - returns time until counters are reset\\n  *                   in milliseconds\\n  *   'numInvocationsLeft': integer | Infinity - returns number of calls left\\n  *   before limit is reached\\n  * }\\n  * If multiple rules match, the least number of invocations left is returned.\\n  * If the rate limit has been reached, the longest timeToReset is returned.\\n  */\\n  check(input) {\\n    const reply = {\\n      allowed: true,\\n      timeToReset: 0,\\n      numInvocationsLeft: Infinity,\\n    };\\n\\n    const matchedRules = this._findAllMatchingRules(input);\\n    matchedRules.forEach((rule) => {\\n      const ruleResult = rule.apply(input);\\n      let numInvocations = rule.counters[ruleResult.key];\\n\\n      if (ruleResult.timeToNextReset < 0) {\\n        // Reset all the counters since the rule has reset\\n        rule.resetCounter();\\n        ruleResult.timeSinceLastReset = new Date().getTime() -\\n          rule._lastResetTime;\\n        ruleResult.timeToNextReset = rule.options.intervalTime;\\n        numInvocations = 0;\\n      }\\n\\n      if (numInvocations > rule.options.numRequestsAllowed) {\\n        // Only update timeToReset if the new time would be longer than the\\n        // previously set time. This is to ensure that if this input triggers\\n        // multiple rules, we return the longest period of time until they can\\n        // successfully make another call\\n        if (reply.timeToReset < ruleResult.timeToNextReset) {\\n          reply.timeToReset = ruleResult.timeToNextReset;\\n        }\\n        reply.allowed = false;\\n        reply.numInvocationsLeft = 0;\\n        reply.ruleId = rule.id;\\n        rule._executeCallback(reply, input);\\n      } else {\\n        // If this is an allowed attempt and we haven't failed on any of the\\n        // other rules that match, update the reply field.\\n        if (rule.options.numRequestsAllowed - numInvocations <\\n          reply.numInvocationsLeft && reply.allowed) {\\n          reply.timeToReset = ruleResult.timeToNextReset;\\n          reply.numInvocationsLeft = rule.options.numRequestsAllowed -\\n            numInvocations;\\n        }\\n        reply.ruleId = rule.id;\\n        rule._executeCallback(reply, input);\\n      }\\n    });\\n    return reply;\\n  }\\n\\n  /**\\n  * Adds a rule to dictionary of rules that are checked against on every call.\\n  * Only inputs that pass all of the rules will be allowed. Returns unique rule\\n  * id that can be passed to `removeRule`.\\n  * @param {object} rule    Input dictionary defining certain attributes and\\n  * rules associated with them.\\n  * Each attribute's value can either be a value, a function or null. All\\n  * functions must return a boolean of whether the input is matched by that\\n  * attribute's rule or not\\n  * @param {integer} numRequestsAllowed Optional. Number of events allowed per\\n  * interval. Default = 10.\\n  * @param {integer} intervalTime Optional. Number of milliseconds before\\n  * rule's counters are reset. Default = 1000.\\n  * @param {function} callback Optional. Function to be called after a\\n  * rule is executed. Two objects will be passed to this function.\\n  * The first one is the result of RateLimiter.prototype.check\\n  * The second is the input object of the rule, it has the following structure:\\n  * {\\n  *   'type': string - either 'method' or 'subscription'\\n  *   'name': string - the name of the method or subscription being called\\n  *   'userId': string - the user ID attempting the method or subscription\\n  *   'connectionId': string - a string representing the user's DDP connection\\n  *   'clientAddress': string - the IP address of the user\\n  * }\\n  * @return {string} Returns unique rule id\\n  */\\n  addRule(rule, numRequestsAllowed, intervalTime, callback) {\\n    const options = {\\n      numRequestsAllowed: numRequestsAllowed || DEFAULT_REQUESTS_PER_INTERVAL,\\n      intervalTime: intervalTime || DEFAULT_INTERVAL_TIME_IN_MILLISECONDS,\\n      callback: callback && Meteor.bindEnvironment(callback),\\n    };\\n\\n    const newRule = new Rule(options, rule);\\n    this.rules[newRule.id] = newRule;\\n    return newRule.id;\\n  }\\n\\n  /**\\n  * Increment counters in every rule that match to this input\\n  * @param  {object} input Dictionary object containing attributes that may\\n  * match to rules\\n  */\\n  increment(input) {\\n    // Only increment rule counters that match this input\\n    const matchedRules = this._findAllMatchingRules(input);\\n    matchedRules.forEach((rule) => {\\n      const ruleResult = rule.apply(input);\\n\\n      if (ruleResult.timeSinceLastReset > rule.options.intervalTime) {\\n        // Reset all the counters since the rule has reset\\n        rule.resetCounter();\\n      }\\n\\n      // Check whether the key exists, incrementing it if so or otherwise\\n      // adding the key and setting its value to 1\\n      if (hasOwn.call(rule.counters, ruleResult.key)) {\\n        rule.counters[ruleResult.key]++;\\n      } else {\\n        rule.counters[ruleResult.key] = 1;\\n      }\\n    });\\n  }\\n\\n  // Returns an array of all rules that apply to provided input\\n  _findAllMatchingRules(input) {\\n    return Object.values(this.rules).filter(rule => rule.match(input));\\n  }\\n\\n  /**\\n   * Provides a mechanism to remove rules from the rate limiter. Returns boolean\\n   * about success.\\n   * @param  {string} id Rule id returned from #addRule\\n   * @return {boolean} Returns true if rule was found and deleted, else false.\\n   */\\n  removeRule(id) {\\n    if (this.rules[id]) {\\n      delete this.rules[id];\\n      return true;\\n    }\\n    return false;\\n  }\\n}\\n\\nexport { RateLimiter };\\n\",null],\"names\":[\"Meteor\",\"Random\",\"module\",\"export\",\"RateLimiter\",\"link\",\"v\",\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"Rule\",\"constructor\",\"options\",\"matchers\",\"id\",\"_matchers\",\"_lastResetTime\",\"Date\",\"getTime\",\"counters\",\"match\",\"input\",\"entries\",\"every\",\"_ref\",\"key\",\"matcher\",\"call\",\"_generateKeyString\",\"filter\",\"_ref2\",\"reduce\",\"returnString\",\"_ref3\",\"apply\",\"timeSinceLastReset\",\"timeToNextReset\",\"intervalTime\",\"resetCounter\",\"_executeCallback\",\"reply\",\"ruleInput\",\"callback\",\"e\",\"console\",\"error\",\"rules\",\"check\",\"allowed\",\"timeToReset\",\"numInvocationsLeft\",\"Infinity\",\"matchedRules\",\"_findAllMatchingRules\",\"forEach\",\"rule\",\"ruleResult\",\"numInvocations\",\"numRequestsAllowed\",\"ruleId\",\"addRule\",\"bindEnvironment\",\"newRule\",\"increment\",\"values\",\"removeRule\"],\"mappings\":\"qVAAiDA,EAAgEC,EAAjHC,EAAOC,MAAM,CAAC,CAACC,YAAYA,IAAIA,CAAW,GAAcF,EAAOG,IAAI,CAAC,gBAAgB,CAACL,OAAOM,CAAC,EAAEN,EAAOM,CAAC,CAAC,EAAE,GAAcJ,EAAOG,IAAI,CAAC,gBAAgB,CAACJ,OAAOK,CAAC,EAAEL,EAAOK,CAAC,CAAC,EAAE,GAQ1K,IAAMC,EAASC,OAAOC,SAAS,CAACC,cAAc,AAgB9C,OAAMC,EACJC,YAAYC,CAAO,CAAEC,CAAQ,CAAE,CAC7B,IAAI,CAACC,EAAE,CAAGd,EAAOc,EAAE,GAEnB,IAAI,CAACF,OAAO,CAAGA,EAEf,IAAI,CAACG,SAAS,CAAGF,EAEjB,IAAI,CAACG,cAAc,CAAG,IAAIC,OAAOC,OAAO,GAGxC,IAAI,CAACC,QAAQ,CAAG,CAAC,CACnB,CAIAC,MAAMC,CAAK,CAAE,CACX,OAAOd,OACJe,OAAO,CAAC,IAAI,CAACP,SAAS,EACtBQ,KAAK,CAACC,IAAoB,GAAnB,CAACC,EAAKC,EAAQ,CAAAF,EACpB,GAAIE,AAAY,OAAZA,EAAkB,CACpB,GAAI,CAACpB,EAAOqB,IAAI,CAACN,EAAOI,GACtB,MAAO,CAAA,EACF,GAAI,AAAmB,YAAnB,OAAOC,EAChB,CAAA,GAAI,CAAEA,EAAQL,CAAK,CAACI,EAAI,EACtB,MAAO,CAAA,CACT,MACK,GAAIC,IAAYL,CAAK,CAACI,EAAI,CAC/B,MAAO,CAAA,CAEX,CACA,MAAO,CAAA,CACT,EACJ,CAKAG,mBAAmBP,CAAK,CAAE,CACxB,OAAOd,OAAOe,OAAO,CAAC,IAAI,CAACP,SAAS,EACjCc,MAAM,CAACC,IAAA,GAAC,CAACL,EAAI,CAAAK,EAAA,OAAK,AAAwB,OAAxB,IAAI,CAACf,SAAS,CAACU,EAAI,AAAS,GAC9CM,MAAM,CAAC,CAACC,EAAYC,KAAqB,GAAnB,CAACR,EAAKC,EAAQ,CAAAO,EAQnC,MAPI,AAAmB,YAAnB,OAAOP,EACLA,EAAQL,CAAK,CAACI,EAAI,GACpBO,CAAAA,GAAgBP,EAAMJ,CAAK,CAACI,EAAI,AAAD,EAGjCO,GAAgBP,EAAMJ,CAAK,CAACI,EAAI,CAE3BO,CACT,EAAG,GACP,CAIAE,MAAMb,CAAK,CAAE,CACX,IAAMI,EAAM,IAAI,CAACG,kBAAkB,CAACP,GAC9Bc,EAAqB,IAAIlB,OAAOC,OAAO,GAAK,IAAI,CAACF,cAAc,CAC/DoB,EAAkB,IAAI,CAACxB,OAAO,CAACyB,YAAY,CAAGF,EACpD,MAAO,CACLV,IAAAA,EACAU,mBAAAA,EACAC,gBAAAA,CACF,CACF,CAKAE,cAAe,CAEb,IAAI,CAACnB,QAAQ,CAAG,CAAC,EACjB,IAAI,CAACH,cAAc,CAAG,IAAIC,OAAOC,OAAO,EAC1C,CAEAqB,iBAAiBC,CAAK,CAAEC,CAAS,CAAE,CACjC,GAAI,CACE,IAAI,CAAC7B,OAAO,CAAC8B,QAAQ,EACvB,IAAI,CAAC9B,OAAO,CAAC8B,QAAQ,CAACF,EAAOC,EAEjC,CAAE,MAAOE,EAAG,CAEVC,QAAQC,KAAK,CAACF,EAChB,CACF,CACF,CAEA,MAAMxC,EAEJQ,aAAc,CAKZ,IAAI,CAACmC,KAAK,CAAG,CAAC,CAChB,CAgBAC,MAAM1B,CAAK,CAAE,CACX,IAAMmB,EAAQ,CACZQ,QAAS,CAAA,EACTC,YAAa,EACbC,mBAAoBC,GACtB,EAEMC,EAAe,IAAI,CAACC,qBAAqB,CAAChC,GAuChD,OAtCA+B,EAAaE,OAAO,CAAEC,IACpB,IAAMC,EAAaD,EAAKrB,KAAK,CAACb,GAC1BoC,EAAiBF,EAAKpC,QAAQ,CAACqC,EAAW/B,GAAG,CAAC,AAE9C+B,CAAAA,EAAWpB,eAAe,CAAG,IAE/BmB,EAAKjB,YAAY,GACjBkB,EAAWrB,kBAAkB,CAAG,IAAIlB,OAAOC,OAAO,GAChDqC,EAAKvC,cAAc,CACrBwC,EAAWpB,eAAe,CAAGmB,EAAK3C,OAAO,CAACyB,YAAY,CACtDoB,EAAiB,GAGfA,EAAiBF,EAAK3C,OAAO,CAAC8C,kBAAkB,EAK9ClB,EAAMS,WAAW,CAAGO,EAAWpB,eAAe,EAChDI,CAAAA,EAAMS,WAAW,CAAGO,EAAWpB,eAAe,AAAfA,EAEjCI,EAAMQ,OAAO,CAAG,CAAA,EAChBR,EAAMU,kBAAkB,CAAG,GAMvBK,EAAK3C,OAAO,CAAC8C,kBAAkB,CAAGD,EACpCjB,EAAMU,kBAAkB,EAAIV,EAAMQ,OAAO,GACzCR,EAAMS,WAAW,CAAGO,EAAWpB,eAAe,CAC9CI,EAAMU,kBAAkB,CAAGK,EAAK3C,OAAO,CAAC8C,kBAAkB,CACxDD,GAEJjB,EAAMmB,MAAM,CAAGJ,EAAKzC,EAAE,CACtByC,EAAKhB,gBAAgB,CAACC,EAAOnB,EAEjC,GACOmB,CACT,CA4BAoB,QAAQL,CAAI,CAAEG,CAAkB,CAAErB,CAAY,CAAEK,CAAQ,CAAE,CACxD,IAAM9B,EAAU,CACd8C,mBAAoBA,GA9MY,GA+MhCrB,aAAcA,GAjN0B,IAkNxCK,SAAUA,GAAY3C,EAAO8D,eAAe,CAACnB,EAC/C,EAEMoB,EAAU,IAAIpD,EAAKE,EAAS2C,GAElC,OADA,IAAI,CAACT,KAAK,CAACgB,EAAQhD,EAAE,CAAC,CAAGgD,EAClBA,EAAQhD,EAAE,AACnB,CAOAiD,UAAU1C,CAAK,CAAE,CAEf,IAAM+B,EAAe,IAAI,CAACC,qBAAqB,CAAChC,GAChD+B,EAAaE,OAAO,CAAEC,IACpB,IAAMC,EAAaD,EAAKrB,KAAK,CAACb,EAE1BmC,CAAAA,EAAWrB,kBAAkB,CAAGoB,EAAK3C,OAAO,CAACyB,YAAY,EAE3DkB,EAAKjB,YAAY,GAKfhC,EAAOqB,IAAI,CAAC4B,EAAKpC,QAAQ,CAAEqC,EAAW/B,GAAG,EAC3C8B,EAAKpC,QAAQ,CAACqC,EAAW/B,GAAG,CAAC,GAE7B8B,EAAKpC,QAAQ,CAACqC,EAAW/B,GAAG,CAAC,CAAG,CAEpC,EACF,CAGA4B,sBAAsBhC,CAAK,CAAE,CAC3B,OAAOd,OAAOyD,MAAM,CAAC,IAAI,CAAClB,KAAK,EAAEjB,MAAM,CAAC0B,GAAQA,EAAKnC,KAAK,CAACC,GAC7D,CAQA4C,WAAWnD,CAAE,CAAE,OACb,EAAI,IAAI,CAACgC,KAAK,CAAChC,EAAG,GAChB,OAAO,IAAI,CAACgC,KAAK,CAAChC,EAAG,CACd,CAAA,EAGX,CACF\"}"}