{"code":"function module(e,t,a){var i,n;a.export({BSONType:()=>i}),(n=i||a.runSetters(i={},[\"BSONType\"]))[n.Double=1]=\"Double\",n[n.String=2]=\"String\",n[n.Object=3]=\"Object\",n[n.Array=4]=\"Array\",n[n.BinData=5]=\"BinData\",n[n.Undefined=6]=\"Undefined\",n[n.ObjectId=7]=\"ObjectId\",n[n.Boolean=8]=\"Boolean\",n[n.Date=9]=\"Date\",n[n.Null=10]=\"Null\",n[n.Regex=11]=\"Regex\",n[n.DBPointer=12]=\"DBPointer\",n[n.JavaScript=13]=\"JavaScript\",n[n.Symbol=14]=\"Symbol\",n[n.JavaScriptWithScope=15]=\"JavaScriptWithScope\",n[n.Int=16]=\"Int\",n[n.Timestamp=17]=\"Timestamp\",n[n.Long=18]=\"Long\",n[n.Decimal=19]=\"Decimal\",n[n.MinKey=-1]=\"MinKey\",n[n.MaxKey=127]=\"MaxKey\"}","map":"{\"version\":3,\"sources\":[\"client/lib/minimongo/types.ts\",\"<anon>\"],\"sourcesContent\":[\"export const enum BSONType {\\n\\tDouble = 1,\\n\\tString,\\n\\tObject,\\n\\tArray,\\n\\tBinData,\\n\\t/** @deprecated */\\n\\tUndefined,\\n\\tObjectId,\\n\\tBoolean,\\n\\tDate,\\n\\tNull,\\n\\tRegex,\\n\\t/** @deprecated */\\n\\tDBPointer,\\n\\tJavaScript,\\n\\t/** @deprecated */\\n\\tSymbol,\\n\\tJavaScriptWithScope,\\n\\tInt,\\n\\tTimestamp,\\n\\tLong,\\n\\tDecimal,\\n\\tMinKey = -1,\\n\\tMaxKey = 127,\\n}\\n\\nexport type FieldExpression<T> = {\\n\\t$eq?: T;\\n\\t$gt?: T;\\n\\t$gte?: T;\\n\\t$lt?: T;\\n\\t$lte?: T;\\n\\t$in?: T[];\\n\\t$nin?: T[];\\n\\t$ne?: T;\\n\\t$exists?: boolean;\\n\\t$type?: BSONType[] | BSONType;\\n\\t$not?: FieldExpression<T>;\\n\\t$expr?: FieldExpression<T>;\\n\\t$jsonSchema?: unknown;\\n\\t$mod?: number[];\\n\\t$regex?: RegExp | string;\\n\\t$options?: string;\\n\\t$text?: {\\n\\t\\t$search: string;\\n\\t\\t$language?: string;\\n\\t\\t$caseSensitive?: boolean;\\n\\t\\t$diacriticSensitive?: boolean;\\n\\t};\\n\\t$where?: string | ((this: T) => boolean);\\n\\t$geoIntersects?: unknown;\\n\\t$geoWithin?: unknown;\\n\\t$near?: unknown;\\n\\t$nearSphere?: unknown;\\n\\t$all?: T[];\\n\\t$elemMatch?: T extends Record<string, unknown> ? Query<T> : FieldExpression<T>;\\n\\t$size?: number;\\n\\t$bitsAllClear?: unknown;\\n\\t$bitsAllSet?: unknown;\\n\\t$bitsAnyClear?: unknown;\\n\\t$bitsAnySet?: unknown;\\n\\t$comment?: string;\\n};\\n\\nexport type Flatten<T> = T extends unknown[] ? T[0] : T;\\n\\nexport type Query<T> = {\\n\\t[P in keyof T]?: Flatten<T[P]> | RegExp | FieldExpression<Flatten<T[P]>>;\\n} & {\\n\\t[P in keyof T as P extends string ? `${P}.${Extract<keyof T[P], string>}` : never]?: Flatten<T[P]> | RegExp | FieldExpression<unknown>;\\n} & {\\n\\t$or?: Query<T>[];\\n\\t$and?: Query<T>[];\\n\\t$nor?: Query<T>[];\\n};\\n\\nexport type Sort =\\n\\t| (string | [string, 'asc' | 'desc'])[]\\n\\t| {\\n\\t\\t\\t[key: string]: -1 | 1;\\n\\t  };\\n\",null],\"names\":[\"BSONType\",\"module\",\"export\",\"runSetters\"],\"mappings\":\"2BAAkBA,EAAAA,EAAlBC,EAAAC,MAAkB,CAAA,CAAAF,SAyBjBA,IAAAA,CAAA,GAxBAA,CADiBA,EAAAA,GAAQC,EAAAE,UAAA,CAARH,EAAQ,CAAA,EAAA,CAAA,WAAA,EACzB,CAAAA,EAAA,MAAA,CAAA,EAAA,CAAA,SACAA,CAAA,CAAAA,EAAA,MAAA,CAAA,EAAA,CAAA,SACAA,CAAA,CAAAA,EAAA,MAAA,CAAA,EAAA,CAAA,SACAA,CAAA,CAAAA,EAAA,KAAA,CAAA,EAAA,CAAA,QACAA,CAAA,CAAAA,EAAA,OAAA,CAAA,EAAA,CAAA,UAEAA,CAAA,CAAAA,EAAA,SAAA,CAAA,EAAA,CAAA,YACAA,CAAA,CAAAA,EAAA,QAAA,CAAA,EAAA,CAAA,WACAA,CAAA,CAAAA,EAAA,OAAA,CAAA,EAAA,CAAA,UACAA,CAAA,CAAAA,EAAA,IAAA,CAAA,EAAA,CAAA,OACAA,CAAA,CAAAA,EAAA,IAAA,CAAA,GAAA,CAAA,OACAA,CAAA,CAAAA,EAAA,KAAA,CAAA,GAAA,CAAA,QAEAA,CAAA,CAAAA,EAAA,SAAA,CAAA,GAAA,CAAA,YACAA,CAAA,CAAAA,EAAA,UAAA,CAAA,GAAA,CAAA,aAEAA,CAAA,CAAAA,EAAA,MAAA,CAAA,GAAA,CAAA,SACAA,CAAA,CAAAA,EAAA,mBAAA,CAAA,GAAA,CAAA,sBACAA,CAAA,CAAAA,EAAA,GAAA,CAAA,GAAA,CAAA,MACAA,CAAA,CAAAA,EAAA,SAAA,CAAA,GAAA,CAAA,YACAA,CAAA,CAAAA,EAAA,IAAA,CAAA,GAAA,CAAA,OACAA,CAAA,CAAAA,EAAA,OAAA,CAAA,GAAA,CAAA,UACAA,CAAA,CAAAA,EAAA,MAAA,CAAA,GAAA,CAAA,SACAA,CAAA,CAAAA,EAAA,MAAA,CAAA,IAAA,CAAA\"}"}