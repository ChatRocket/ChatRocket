{"code":"Package[\"core-runtime\"].queue(\"accounts-base\",function(){var e,t=Package.meteor.Meteor;Package.meteor.global,Package.meteor.meteorEnv;var o=Package.tracker.Tracker;Package.tracker.Deps;var n=Package.random.Random,i=Package[\"callback-hook\"].Hook,s=Package[\"reactive-var\"].ReactiveVar;Package.url.URL,Package.url.URLSearchParams;var r=Package[\"ddp-client\"].DDP,l=Package.mongo.Mongo,a=Package.modules.meteorInstall;return Package.promise.Promise,{export:function(){return{Accounts:e}},require:a({node_modules:{meteor:{\"accounts-base\":{\"client_main.js\":function o(o,n,i){var s,r,l;let a,c;i.export({Accounts:()=>e,AccountsClient:()=>a,AccountsTest:()=>c,default:()=>n}),i.link(\"./accounts_client.js\",{AccountsClient(e){a=e},AccountsTest(e){c=e}},0),i.runSetters(e=new a((null===(s=t.settings)||void 0===s?void 0:null===(r=s.public)||void 0===r?void 0:null===(l=r.packages)||void 0===l?void 0:l.accounts)||{}),[\"Accounts\"]),t.users=e.users},\"accounts_client.js\":function i(i,l,a){let c,g;a.link(\"@babel/runtime/helpers/objectSpread2\",{default(e){c=e}},0),a.export({AccountsClient:()=>u,AccountsTest:()=>d}),a.link(\"./accounts_common.js\",{AccountsCommon(e){g=e}},0);class u extends g{constructor(e){super(e),this._loggingIn=new s(!1),this._loggingOut=new s(!1),this._loginServicesHandle=this.connection.subscribe(\"meteor.loginServiceConfiguration\"),this._pageLoadLoginCallbacks=[],this._pageLoadLoginAttemptInfo=null,this.savedHash=window.location.hash,this._initUrlMatching(),this.initStorageLocation(),this._initLocalStorage(),this._loginFuncs={},this._loginCallbacksCalled=!1}initStorageLocation(e){var o,n,i,s;this.storageLocation=(null==e?void 0:e.clientStorage)===\"session\"||(null===(o=t.settings)||void 0===o?void 0:null===(n=o.public)||void 0===n?void 0:null===(i=n.packages)||void 0===i?void 0:null===(s=i.accounts)||void 0===s?void 0:s.clientStorage)===\"session\"?window.sessionStorage:t._localStorage}config(e){super.config(e),this.initStorageLocation(e)}userId(){return this.connection.userId()}_setLoggingIn(e){this._loggingIn.set(e)}loggingIn(){return this._loggingIn.get()}loggingOut(){return this._loggingOut.get()}registerClientLoginFunction(e,t){if(this._loginFuncs[e])throw Error(\"\".concat(e,\" has been defined already\"));this._loginFuncs[e]=t}callLoginFunction(e){if(!this._loginFuncs[e])throw Error(\"\".concat(e,\" was not defined\"));for(var t=arguments.length,o=Array(t>1?t-1:0),n=1;n<t;n++)o[n-1]=arguments[n];return this._loginFuncs[e].apply(this,o)}applyLoginFunction(e,t){if(!this._loginFuncs[e])throw Error(\"\".concat(e,\" was not defined\"));return this._loginFuncs[e].apply(this,t)}logout(e){this._loggingOut.set(!0),this.connection.applyAsync(\"logout\",[],{wait:!0}).then(t=>{this._loggingOut.set(!1),this._loginCallbacksCalled=!1,this.makeClientLoggedOut(),e&&e()}).catch(t=>{this._loggingOut.set(!1),e&&e(t)})}logoutOtherClients(e){this.connection.apply(\"getNewToken\",[],{wait:!0},(e,t)=>{e||this._storeLoginToken(this.userId(),t.token,t.tokenExpires)}),this.connection.apply(\"removeOtherTokens\",[],{wait:!0},t=>e&&e(t))}callLoginMethod(e){let n;e=c({methodName:\"login\",methodArguments:[{}],_suppressLoggingIn:!1},e),[\"validateResult\",\"userCallback\"].forEach(t=>{e[t]||(e[t]=()=>null)});let i=t=>{let{error:o,loginDetails:i}=t;n||(n=!0,o?(this._loginCallbacksCalled=!1,this._onLoginFailureHook.forEach(e=>(e({error:o}),!0))):(this._onLoginHook.forEach(e=>(e(i),!0)),this._loginCallbacksCalled=!0),e.userCallback(o,i))},s=!1;e._suppressLoggingIn||this._setLoggingIn(!0),this.connection.applyAsync(e.methodName,e.methodArguments,{wait:!0,onResultReceived:(e,t)=>{!e&&t&&t.token&&(this._reconnectStopper&&this._reconnectStopper.stop(),this._reconnectStopper=r.onReconnect(e=>{if(e!=this.connection)return;s=!0;let o=this._storedLoginToken();o&&(t={token:o,tokenExpires:this._storedLoginTokenExpires()}),t.tokenExpires||(t.tokenExpires=this._tokenExpiration(new Date)),this._tokenExpiresSoon(t.tokenExpires)?this.makeClientLoggedOut():this.callLoginMethod({methodArguments:[{resume:t.token}],_suppressLoggingIn:!0,userCallback:(e,o)=>{let n=this._storedLoginToken();e&&n&&n===t.token&&this.makeClientLoggedOut(),i({error:e,loginDetails:o})}})}))}},(n,r)=>{if(!s){if(n||!r){i({error:n=n||Error(\"No result from call to \".concat(e.methodName))}),this._setLoggingIn(!1);return}try{e.validateResult(r)}catch(e){i({error:e}),this._setLoggingIn(!1);return}this.makeClientLoggedIn(r.id,r.token,r.tokenExpires),o.autorun(async e=>{let n=await o.withComputation(e,()=>t.userAsync());n&&(i({loginDetails:r}),this._setLoggingIn(!1),e.stop())})}})}makeClientLoggedOut(){this.connection._userId&&this._onLogoutHook.each(e=>(e(),!0)),this._unstoreLoginToken(),this.connection.setUserId(null),this._reconnectStopper&&this._reconnectStopper.stop()}makeClientLoggedIn(e,t,o){this._storeLoginToken(e,t,o),this.connection.setUserId(e)}loginServicesConfigured(){return this._loginServicesHandle.ready()}onPageLoadLogin(e){this._pageLoadLoginAttemptInfo?e(this._pageLoadLoginAttemptInfo):this._pageLoadLoginCallbacks.push(e)}_pageLoadLogin(e){if(this._pageLoadLoginAttemptInfo){t._debug(\"Ignoring unexpected duplicate page load login attempt info\");return}this._pageLoadLoginCallbacks.forEach(t=>t(e)),this._pageLoadLoginCallbacks=[],this._pageLoadLoginAttemptInfo=e}_startupCallback(e){this._loginCallbacksCalled&&t.setTimeout(()=>e({type:\"resume\"}),0)}loginWithToken(e,t){this.callLoginMethod({methodArguments:[{resume:e}],userCallback:t})}_enableAutoLogin(){this._autoLoginEnabled=!0,this._pollStoredLoginToken()}_isolateLoginTokenForTest(){this.LOGIN_TOKEN_KEY=this.LOGIN_TOKEN_KEY+n.id(),this.USER_ID_KEY=this.USER_ID_KEY+n.id()}_storeLoginToken(e,t,o){this.storageLocation.setItem(this.USER_ID_KEY,e),this.storageLocation.setItem(this.LOGIN_TOKEN_KEY,t),o||(o=this._tokenExpiration(new Date)),this.storageLocation.setItem(this.LOGIN_TOKEN_EXPIRES_KEY,o),this._lastLoginTokenWhenPolled=t}_unstoreLoginToken(){this.storageLocation.removeItem(this.USER_ID_KEY),this.storageLocation.removeItem(this.LOGIN_TOKEN_KEY),this.storageLocation.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY),this._lastLoginTokenWhenPolled=null}_storedLoginToken(){return this.storageLocation.getItem(this.LOGIN_TOKEN_KEY)}_storedLoginTokenExpires(){return this.storageLocation.getItem(this.LOGIN_TOKEN_EXPIRES_KEY)}_storedUserId(){return this.storageLocation.getItem(this.USER_ID_KEY)}_unstoreLoginTokenIfExpiresSoon(){let e=this._storedLoginTokenExpires();e&&this._tokenExpiresSoon(new Date(e))&&this._unstoreLoginToken()}_initLocalStorage(){let e;this.LOGIN_TOKEN_KEY=\"Meteor.loginToken\",this.LOGIN_TOKEN_EXPIRES_KEY=\"Meteor.loginTokenExpires\",this.USER_ID_KEY=\"Meteor.userId\";let o=__meteor_runtime_config__.ROOT_URL_PATH_PREFIX;if(o||this.connection!==t.connection){let e=\":\".concat(this.connection._stream.rawUrl);o&&(e+=\":\".concat(o)),this.LOGIN_TOKEN_KEY+=e,this.LOGIN_TOKEN_EXPIRES_KEY+=e,this.USER_ID_KEY+=e}if(this._autoLoginEnabled&&(this._unstoreLoginTokenIfExpiresSoon(),e=this._storedLoginToken())){let o=this._storedUserId();o&&this.connection.setUserId(o),this.loginWithToken(e,o=>{o&&(t._debug(\"Error logging in with token: \".concat(o)),this.makeClientLoggedOut()),this._pageLoadLogin({type:\"resume\",allowed:!o,error:o,methodName:\"login\",methodArguments:[{resume:e}]})})}this._lastLoginTokenWhenPolled=e,this._pollIntervalTimer&&clearInterval(this._pollIntervalTimer),this._pollIntervalTimer=setInterval(()=>{this._pollStoredLoginToken()},3e3)}_pollStoredLoginToken(){if(!this._autoLoginEnabled)return;let e=this._storedLoginToken();this._lastLoginTokenWhenPolled!=e&&(e?this.loginWithToken(e,e=>{e&&this.makeClientLoggedOut()}):this.logout()),this._lastLoginTokenWhenPolled=e}_initUrlMatching(){this._autoLoginEnabled=!0,this._accountsCallbacks={},this._attemptToMatchHash()}_attemptToMatchHash(){_(this,this.savedHash,h)}onResetPasswordLink(e){this._accountsCallbacks[\"reset-password\"]&&t._debug(\"Accounts.onResetPasswordLink was called more than once. Only one callback added will be executed.\"),this._accountsCallbacks[\"reset-password\"]=e}onEmailVerificationLink(e){this._accountsCallbacks[\"verify-email\"]&&t._debug(\"Accounts.onEmailVerificationLink was called more than once. Only one callback added will be executed.\"),this._accountsCallbacks[\"verify-email\"]=e}onEnrollmentLink(e){this._accountsCallbacks[\"enroll-account\"]&&t._debug(\"Accounts.onEnrollmentLink was called more than once. Only one callback added will be executed.\"),this._accountsCallbacks[\"enroll-account\"]=e}}if(t.loggingIn=()=>e.loggingIn(),t.loggingOut=()=>e.loggingOut(),t.logout=t=>e.logout(t),t.logoutOtherClients=t=>e.logoutOtherClients(t),t.loginWithToken=(t,o)=>e.loginWithToken(t,o),Package.blaze){let{Template:e}=Package.blaze.Blaze;e.registerHelper(\"currentUser\",()=>t.user()),e.registerHelper(\"loggingIn\",()=>t.loggingIn()),e.registerHelper(\"loggingOut\",()=>t.loggingOut()),e.registerHelper(\"loggingInOrOut\",()=>t.loggingIn()||t.loggingOut())}let h=function(e,o){this._autoLoginEnabled=!1,t.startup(()=>{this._accountsCallbacks[o]&&this._accountsCallbacks[o](e,()=>this._enableAutoLogin())})},_=(e,t,o)=>{[\"reset-password\",\"verify-email\",\"enroll-account\"].forEach(n=>{let i;let s=new RegExp(\"^\\\\#\\\\/\".concat(n,\"\\\\/(.*)$\")),r=t.match(s);r&&(i=r[1],\"reset-password\"===n?e._resetPasswordToken=i:\"verify-email\"===n?e._verifyEmailToken=i:\"enroll-account\"===n&&(e._enrollAccountToken=i),window.location.hash=\"\",o.call(e,i,n))})},d={attemptToMatchHash:(t,o)=>_(e,t,o)}},\"accounts_common.js\":function t(t,o,n){let s,a;n.link(\"@babel/runtime/helpers/objectSpread2\",{default(e){s=e}},0),n.export({AccountsCommon:()=>g,EXPIRE_TOKENS_INTERVAL_MS:()=>p}),n.link(\"meteor/meteor\",{Meteor(e){a=e}},0);let c=[\"sendVerificationEmail\",\"forbidClientAccountCreation\",\"restrictCreationByEmailDomain\",\"loginExpiration\",\"loginExpirationInDays\",\"oauthSecretKey\",\"passwordResetTokenExpirationInDays\",\"passwordResetTokenExpiration\",\"passwordEnrollTokenExpirationInDays\",\"passwordEnrollTokenExpiration\",\"ambiguousErrorMessages\",\"bcryptRounds\",\"defaultFieldSelector\",\"collection\",\"loginTokenExpirationHours\",\"tokenSequenceLength\",\"clientStorage\",\"ddpUrl\",\"connection\"];class g{constructor(e){for(let t of Object.keys(e))c.includes(t)||console.error(\"Accounts.config: Invalid key: \".concat(t));this._options=e||{},this.connection=void 0,this._initConnection(e||{}),this.users=this._initializeCollection(e||{}),this._onLoginHook=new i({bindEnvironment:!1,debugPrintExceptions:\"onLogin callback\"}),this._onLoginFailureHook=new i({bindEnvironment:!1,debugPrintExceptions:\"onLoginFailure callback\"}),this._onLogoutHook=new i({bindEnvironment:!1,debugPrintExceptions:\"onLogout callback\"}),this.DEFAULT_LOGIN_EXPIRATION_DAYS=u,this.LOGIN_UNEXPIRING_TOKEN_DAYS=k;let t=\"Accounts.LoginCancelledError\";this.LoginCancelledError=a.makeErrorType(t,function(e){this.message=e}),this.LoginCancelledError.prototype.name=t,this.LoginCancelledError.numericError=145546287}_initializeCollection(e){let t;if(e.collection&&\"string\"!=typeof e.collection&&!(e.collection instanceof l.Collection))throw new a.Error('Collection parameter can be only of type string or \"Mongo.Collection\"');let o=\"users\";return\"string\"==typeof e.collection&&(o=e.collection),t=e.collection instanceof l.Collection?e.collection:new l.Collection(o,{_preventAutopublish:!0,connection:this.connection})}userId(){throw Error(\"userId method not implemented\")}_addDefaultFieldSelector(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!this._options.defaultFieldSelector)return e;if(!e.fields)return s(s({},e),{},{fields:this._options.defaultFieldSelector});let t=Object.keys(e.fields);if(!t.length||e.fields[t[0]])return e;let o=Object.keys(this._options.defaultFieldSelector);return this._options.defaultFieldSelector[o[0]]?e:s(s({},e),{},{fields:s(s({},e.fields),this._options.defaultFieldSelector)})}user(e){a.isServer&&console.warn(\"`Meteor.user()` is deprecated on the server side.\\n    To fetch the current user record on the server,\\n    use `Meteor.userAsync()` instead.\");let t=this,o=t.userId();return o?function(){return a.isClient?t.users.findOne(...arguments):t.users.findOneAsync(...arguments)}(o,this._addDefaultFieldSelector(e)):null}async userAsync(e){let t=this.userId();return t?this.users.findOneAsync(t,this._addDefaultFieldSelector(e)):null}config(e){if(a.isServer?__meteor_runtime_config__.accountsConfigCalled=!0:__meteor_runtime_config__.accountsConfigCalled||a._debug(\"Accounts.config was called on the client but not on the server; some configuration options may not take effect.\"),Object.prototype.hasOwnProperty.call(e,\"oauthSecretKey\")){if(a.isClient)throw Error(\"The oauthSecretKey option may only be specified on the server\");if(!Package[\"oauth-encryption\"])throw Error(\"The oauth-encryption package must be loaded to set oauthSecretKey\");Package[\"oauth-encryption\"].OAuthEncryption.loadKey(e.oauthSecretKey),e=s({},e),delete e.oauthSecretKey}for(let t of Object.keys(e))c.includes(t)||console.error(\"Accounts.config: Invalid key: \".concat(t));for(let t of c)if(t in e){if(t in this._options&&\"collection\"!==t&&a.isTest&&\"clientStorage\"!==t)throw new a.Error(\"Can't set `\".concat(t,\"` more than once\"));this._options[t]=e[t]}e.collection&&e.collection!==this.users._name&&e.collection!==this.users&&(this.users=this._initializeCollection(e))}onLogin(e){let t=this._onLoginHook.register(e);return this._startupCallback(t.callback),t}onLoginFailure(e){return this._onLoginFailureHook.register(e)}onLogout(e){return this._onLogoutHook.register(e)}_initConnection(e){a.isClient&&(e.connection?this.connection=e.connection:e.ddpUrl?this.connection=r.connect(e.ddpUrl):\"undefined\"!=typeof __meteor_runtime_config__&&__meteor_runtime_config__.ACCOUNTS_CONNECTION_URL?this.connection=r.connect(__meteor_runtime_config__.ACCOUNTS_CONNECTION_URL):this.connection=a.connection)}_getTokenLifetimeMs(){let e=null===this._options.loginExpirationInDays?k:this._options.loginExpirationInDays;return this._options.loginExpiration||864e5*(e||u)}_getPasswordResetTokenLifetimeMs(){return this._options.passwordResetTokenExpiration||864e5*(this._options.passwordResetTokenExpirationInDays||h)}_getPasswordEnrollTokenLifetimeMs(){return this._options.passwordEnrollTokenExpiration||864e5*(this._options.passwordEnrollTokenExpirationInDays||_)}_tokenExpiration(e){return new Date(new Date(e).getTime()+this._getTokenLifetimeMs())}_tokenExpiresSoon(e){let t=.1*this._getTokenLifetimeMs(),o=1e3*d;return t>o&&(t=o),new Date>new Date(e)-t}_startupCallback(e){}}a.userId=()=>e.userId(),a.user=t=>e.user(t),a.userAsync=t=>e.userAsync(t);let u=90,h=3,_=30,d=3600,p=6e5,k=36500}}}}},{extensions:[\".js\",\".json\"]}),eagerModulePaths:[\"/node_modules/meteor/accounts-base/client_main.js\"],mainModulePath:\"/node_modules/meteor/accounts-base/client_main.js\"}});","map":"{\"version\":3,\"sources\":[\"packages/accounts-base/client_main.js\",\"packages/accounts-base/accounts_client.js\",\"packages/accounts-base/accounts_common.js\",\"<anon>\"],\"sourcesContent\":[\"import {\\n  AccountsClient,\\n  AccountsTest,\\n} from \\\"./accounts_client.js\\\";\\n\\n/**\\n * @namespace Accounts\\n * @summary The namespace for all client-side accounts-related methods.\\n */\\nAccounts = new AccountsClient(Meteor.settings?.public?.packages?.accounts || {});\\n\\n/**\\n * @summary A [Mongo.Collection](#collections) containing user documents.\\n * @locus Anywhere\\n * @type {Mongo.Collection}\\n * @importFromPackage meteor\\n */\\nMeteor.users = Accounts.users;\\n\\nexport {\\n  Accounts,\\n  AccountsClient,\\n  AccountsTest,\\n  // For backwards compatibility. Note that exporting an object as the\\n  // default export is *not* the same as exporting its properties as named\\n  // exports, as was previously assumed.\\n  exports as default,\\n};\\n\",\"import {AccountsCommon} from \\\"./accounts_common.js\\\";\\n\\n/**\\n * @summary Constructor for the `Accounts` object on the client.\\n * @locus Client\\n * @class AccountsClient\\n * @extends AccountsCommon\\n * @instancename accountsClient\\n * @param {Object} options an object with fields:\\n * @param {Object} options.connection Optional DDP connection to reuse.\\n * @param {String} options.ddpUrl Optional URL for creating a new DDP connection.\\n * @param {'session' | 'local'} options.clientStorage Optional Define what kind of storage you want for credentials on the client. Default is 'local' to use `localStorage`. Set to 'session' to use session storage.\\n */\\nexport class AccountsClient extends AccountsCommon {\\n  constructor(options) {\\n    super(options);\\n\\n    this._loggingIn = new ReactiveVar(false);\\n    this._loggingOut = new ReactiveVar(false);\\n\\n    this._loginServicesHandle =\\n      this.connection.subscribe(\\\"meteor.loginServiceConfiguration\\\");\\n\\n    this._pageLoadLoginCallbacks = [];\\n    this._pageLoadLoginAttemptInfo = null;\\n\\n    this.savedHash = window.location.hash;\\n    this._initUrlMatching();\\n\\n    this.initStorageLocation();\\n\\n    // Defined in localstorage_token.js.\\n    this._initLocalStorage();\\n\\n    // This is for .registerClientLoginFunction & .callLoginFunction.\\n    this._loginFuncs = {};\\n\\n    // This tracks whether callbacks registered with\\n    // Accounts.onLogin have been called\\n    this._loginCallbacksCalled = false;\\n  }\\n\\n  initStorageLocation(options) {\\n    // Determine whether to use local or session storage to storage credentials and anything else.\\n    this.storageLocation = (options?.clientStorage === 'session' || Meteor.settings?.public?.packages?.accounts?.clientStorage === 'session') ? window.sessionStorage : Meteor._localStorage;\\n  }\\n\\n  config(options) {\\n    super.config(options);\\n\\n    this.initStorageLocation(options);\\n  }\\n\\n  ///\\n  /// CURRENT USER\\n  ///\\n\\n  // @override\\n  userId() {\\n    return this.connection.userId();\\n  }\\n\\n  // This is mostly just called within this file, but Meteor.loginWithPassword\\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\\n  // method call too.\\n  _setLoggingIn(x) {\\n    this._loggingIn.set(x);\\n  }\\n\\n  /**\\n   * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\\n   * @locus Client\\n   */\\n  loggingIn() {\\n    return this._loggingIn.get();\\n  }\\n\\n  /**\\n   * @summary True if a logout method (such as `Meteor.logout`) is currently in progress. A reactive data source.\\n   * @locus Client\\n   */\\n  loggingOut() {\\n    return this._loggingOut.get();\\n  }\\n\\n  /**\\n   * @summary Register a new login function on the client. Intended for OAuth package authors. You can call the login function by using\\n   `Accounts.callLoginFunction` or `Accounts.callLoginFunction`.\\n   * @locus Client\\n   * @param {String} funcName The name of your login function. Used by `Accounts.callLoginFunction` and `Accounts.applyLoginFunction`.\\n   Should be the OAuth provider name accordingly.\\n   * @param {Function} func The actual function you want to call. Just write it in the manner of `loginWithFoo`.\\n   */\\n  registerClientLoginFunction(funcName, func) {\\n    if (this._loginFuncs[funcName]) {\\n      throw new Error(`${funcName} has been defined already`);\\n    }\\n    this._loginFuncs[funcName] = func;\\n  }\\n\\n  /**\\n   * @summary Call a login function defined using `Accounts.registerClientLoginFunction`. Excluding the first argument, all remaining\\n   arguments are passed to the login function accordingly. Use `applyLoginFunction` if you want to pass in an arguments array that contains\\n   all arguments for the login function.\\n   * @locus Client\\n   * @param {String} funcName The name of the login function you wanted to call.\\n   */\\n  callLoginFunction(funcName, ...funcArgs) {\\n    if (!this._loginFuncs[funcName]) {\\n      throw new Error(`${funcName} was not defined`);\\n    }\\n    return this._loginFuncs[funcName].apply(this, funcArgs);\\n  }\\n\\n  /**\\n   * @summary Same as ``callLoginFunction` but accept an `arguments` which contains all arguments for the login\\n   function.\\n   * @locus Client\\n   * @param {String} funcName The name of the login function you wanted to call.\\n   * @param {Array} funcArgs The `arguments` for the login function.\\n   */\\n  applyLoginFunction(funcName, funcArgs) {\\n    if (!this._loginFuncs[funcName]) {\\n      throw new Error(`${funcName} was not defined`);\\n    }\\n    return this._loginFuncs[funcName].apply(this, funcArgs);\\n  }\\n\\n  /**\\n   * @summary Log the user out.\\n   * @locus Client\\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n   */\\n  logout(callback) {\\n    this._loggingOut.set(true);\\n\\n    this.connection.applyAsync('logout', [], {\\n      // TODO[FIBERS]: Look this { wait: true } later.\\n      wait: true\\n    })\\n      .then((result) => {\\n        this._loggingOut.set(false);\\n        this._loginCallbacksCalled = false;\\n        this.makeClientLoggedOut();\\n        callback && callback();\\n      })\\n      .catch((e) => {\\n        this._loggingOut.set(false);\\n        callback && callback(e);\\n      });\\n  }\\n\\n  /**\\n   * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\\n   * @locus Client\\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n   */\\n  logoutOtherClients(callback) {\\n    // We need to make two method calls: one to replace our current token,\\n    // and another to remove all tokens except the current one. We want to\\n    // call these two methods one after the other, without any other\\n    // methods running between them. For example, we don't want `logout`\\n    // to be called in between our two method calls (otherwise the second\\n    // method call would return an error). Another example: we don't want\\n    // logout to be called before the callback for `getNewToken`;\\n    // otherwise we would momentarily log the user out and then write a\\n    // new token to localStorage.\\n    //\\n    // To accomplish this, we make both calls as wait methods, and queue\\n    // them one after the other, without spinning off the event loop in\\n    // between. Even though we queue `removeOtherTokens` before\\n    // `getNewToken`, we won't actually send the `removeOtherTokens` call\\n    // until the `getNewToken` callback has finished running, because they\\n    // are both wait methods.\\n    this.connection.apply(\\n      'getNewToken',\\n      [],\\n      { wait: true },\\n      (err, result) => {\\n        if (! err) {\\n          this._storeLoginToken(\\n            this.userId(),\\n            result.token,\\n            result.tokenExpires\\n          );\\n        }\\n      }\\n    );\\n\\n    this.connection.apply(\\n      'removeOtherTokens',\\n      [],\\n      { wait: true },\\n      err => callback && callback(err)\\n    );\\n  }\\n\\n  ///\\n  /// LOGIN METHODS\\n  ///\\n\\n  // Call a login method on the server.\\n  //\\n  // A login method is a method which on success calls `this.setUserId(id)` and\\n  // `Accounts._setLoginToken` on the server and returns an object with fields\\n  // 'id' (containing the user id), 'token' (containing a resume token), and\\n  // optionally `tokenExpires`.\\n  //\\n  // This function takes care of:\\n  //   - Updating the Meteor.loggingIn() reactive data source\\n  //   - Calling the method in 'wait' mode\\n  //   - On success, saving the resume token to localStorage\\n  //   - On success, calling Accounts.connection.setUserId()\\n  //   - Setting up an onReconnect handler which logs in with\\n  //     the resume token\\n  //\\n  // Options:\\n  // - methodName: The method to call (default 'login')\\n  // - methodArguments: The arguments for the method\\n  // - validateResult: If provided, will be called with the result of the\\n  //                 method. If it throws, the client will not be logged in (and\\n  //                 its error will be passed to the callback).\\n  // - userCallback: Will be called with no arguments once the user is fully\\n  //                 logged in, or with the error on error.\\n  //\\n  callLoginMethod(options) {\\n    options = {\\n      methodName: 'login',\\n      methodArguments: [{}],\\n      _suppressLoggingIn: false,\\n      ...options,\\n    };\\n\\n    // Set defaults for callback arguments to no-op functions; make sure we\\n    // override falsey values too.\\n    ['validateResult', 'userCallback'].forEach(f => {\\n      if (!options[f])\\n        options[f] = () => null;\\n    });\\n\\n    let called;\\n    // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\\n    const loginCallbacks = ({ error, loginDetails }) => {\\n      if (!called) {\\n        called = true;\\n        if (!error) {\\n          this._onLoginHook.forEach(callback => {\\n            callback(loginDetails);\\n            return true;\\n          });\\n          this._loginCallbacksCalled = true;\\n        } else {\\n          this._loginCallbacksCalled = false;\\n          this._onLoginFailureHook.forEach(callback => {\\n            callback({ error });\\n            return true;\\n          });\\n        }\\n        options.userCallback(error, loginDetails);\\n      }\\n    };\\n\\n    let reconnected = false;\\n\\n    // We want to set up onReconnect as soon as we get a result token back from\\n    // the server, without having to wait for subscriptions to rerun. This is\\n    // because if we disconnect and reconnect between getting the result and\\n    // getting the results of subscription rerun, we WILL NOT re-send this\\n    // method (because we never re-send methods whose results we've received)\\n    // but we WILL call loggedInAndDataReadyCallback at \\\"reconnect quiesce\\\"\\n    // time. This will lead to makeClientLoggedIn(result.id) even though we\\n    // haven't actually sent a login method!\\n    //\\n    // But by making sure that we send this \\\"resume\\\" login in that case (and\\n    // calling makeClientLoggedOut if it fails), we'll end up with an accurate\\n    // client-side userId. (It's important that livedata_connection guarantees\\n    // that the \\\"reconnect quiesce\\\"-time call to loggedInAndDataReadyCallback\\n    // will occur before the callback from the resume login call.)\\n    const onResultReceived = (err, result) => {\\n      if (err || !result || !result.token) {\\n        // Leave onReconnect alone if there was an error, so that if the user was\\n        // already logged in they will still get logged in on reconnect.\\n        // See issue #4970.\\n      } else {\\n        // First clear out any previously set Acccounts login onReconnect\\n        // callback (to make sure we don't keep piling up duplicate callbacks,\\n        // which would then all be triggered when reconnecting).\\n        if (this._reconnectStopper) {\\n          this._reconnectStopper.stop();\\n        }\\n\\n        this._reconnectStopper = DDP.onReconnect(conn => {\\n          if (conn != this.connection) {\\n            return;\\n          }\\n          reconnected = true;\\n          // If our token was updated in storage, use the latest one.\\n          const storedToken = this._storedLoginToken();\\n          if (storedToken) {\\n            result = {\\n              token: storedToken,\\n              tokenExpires: this._storedLoginTokenExpires()\\n            };\\n          }\\n          if (!result.tokenExpires)\\n            result.tokenExpires = this._tokenExpiration(new Date());\\n          if (this._tokenExpiresSoon(result.tokenExpires)) {\\n            this.makeClientLoggedOut();\\n          } else {\\n            this.callLoginMethod({\\n              methodArguments: [{resume: result.token}],\\n              // Reconnect quiescence ensures that the user doesn't see an\\n              // intermediate state before the login method finishes. So we don't\\n              // need to show a logging-in animation.\\n              _suppressLoggingIn: true,\\n              userCallback: (error, loginDetails) => {\\n                const storedTokenNow = this._storedLoginToken();\\n                if (error) {\\n                  // If we had a login error AND the current stored token is the\\n                  // one that we tried to log in with, then declare ourselves\\n                  // logged out. If there's a token in storage but it's not the\\n                  // token that we tried to log in with, we don't know anything\\n                  // about whether that token is valid or not, so do nothing. The\\n                  // periodic localStorage poll will decide if we are logged in or\\n                  // out with this token, if it hasn't already. Of course, even\\n                  // with this check, another tab could insert a new valid token\\n                  // immediately before we clear localStorage here, which would\\n                  // lead to both tabs being logged out, but by checking the token\\n                  // in storage right now we hope to make that unlikely to happen.\\n                  //\\n                  // If there is no token in storage right now, we don't have to\\n                  // do anything; whatever code removed the token from storage was\\n                  // responsible for calling `makeClientLoggedOut()`, or the\\n                  // periodic localStorage poll will call `makeClientLoggedOut`\\n                  // eventually if another tab wiped the token from storage.\\n                  if (storedTokenNow && storedTokenNow === result.token) {\\n                    this.makeClientLoggedOut();\\n                  }\\n                }\\n                // Possibly a weird callback to call, but better than nothing if\\n                // there is a reconnect between \\\"login result received\\\" and \\\"data\\n                // ready\\\".\\n                loginCallbacks({ error, loginDetails });\\n              }});\\n          }\\n        });\\n      }\\n    };\\n\\n    // This callback is called once the local cache of the current-user\\n    // subscription (and all subscriptions, in fact) are guaranteed to be up to\\n    // date.\\n    const loggedInAndDataReadyCallback = (error, result) => {\\n      // If the login method returns its result but the connection is lost\\n      // before the data is in the local cache, it'll set an onReconnect (see\\n      // above). The onReconnect will try to log in using the token, and *it*\\n      // will call userCallback via its own version of this\\n      // loggedInAndDataReadyCallback. So we don't have to do anything here.\\n      if (reconnected)\\n        return;\\n\\n      // Note that we need to call this even if _suppressLoggingIn is true,\\n      // because it could be matching a _setLoggingIn(true) from a\\n      // half-completed pre-reconnect login method.\\n      if (error || !result) {\\n        error = error || new Error(\\n          `No result from call to ${options.methodName}`\\n        );\\n        loginCallbacks({ error });\\n        this._setLoggingIn(false);\\n        return;\\n      }\\n      try {\\n        options.validateResult(result);\\n      } catch (e) {\\n        loginCallbacks({ error: e });\\n        this._setLoggingIn(false);\\n        return;\\n      }\\n\\n      // Make the client logged in. (The user data should already be loaded!)\\n      this.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\\n\\n      // use Tracker to make we sure have a user before calling the callbacks\\n      Tracker.autorun(async (computation) => {\\n        const user = await Tracker.withComputation(computation, () =>\\n          Meteor.userAsync(),\\n        );\\n\\n        if (user) {\\n          loginCallbacks({ loginDetails: result });\\n          this._setLoggingIn(false);\\n          computation.stop();\\n        }\\n      });\\n\\n    };\\n\\n    if (!options._suppressLoggingIn) {\\n      this._setLoggingIn(true);\\n    }\\n    this.connection.applyAsync(\\n      options.methodName,\\n      options.methodArguments,\\n      { wait: true, onResultReceived },\\n      loggedInAndDataReadyCallback);\\n  }\\n\\n  makeClientLoggedOut() {\\n    // Ensure client was successfully logged in before running logout hooks.\\n    if (this.connection._userId) {\\n      this._onLogoutHook.each(callback => {\\n        callback();\\n        return true;\\n      });\\n    }\\n    this._unstoreLoginToken();\\n    this.connection.setUserId(null);\\n    this._reconnectStopper && this._reconnectStopper.stop();\\n  }\\n\\n  makeClientLoggedIn(userId, token, tokenExpires) {\\n    this._storeLoginToken(userId, token, tokenExpires);\\n    this.connection.setUserId(userId);\\n  }\\n\\n  ///\\n  /// LOGIN SERVICES\\n  ///\\n\\n  // A reactive function returning whether the loginServiceConfiguration\\n  // subscription is ready. Used by accounts-ui to hide the login button\\n  // until we have all the configuration loaded\\n  //\\n  loginServicesConfigured() {\\n    return this._loginServicesHandle.ready();\\n  };\\n\\n  // Some login services such as the redirect login flow or the resume\\n  // login handler can log the user in at page load time.  The\\n  // Meteor.loginWithX functions have a callback argument, but the\\n  // callback function instance won't be in memory any longer if the\\n  // page was reloaded.  The `onPageLoadLogin` function allows a\\n  // callback to be registered for the case where the login was\\n  // initiated in a previous VM, and we now have the result of the login\\n  // attempt in a new VM.\\n\\n  // Register a callback to be called if we have information about a\\n  // login attempt at page load time.  Call the callback immediately if\\n  // we already have the page load login attempt info, otherwise stash\\n  // the callback to be called if and when we do get the attempt info.\\n  //\\n  onPageLoadLogin(f) {\\n    if (this._pageLoadLoginAttemptInfo) {\\n      f(this._pageLoadLoginAttemptInfo);\\n    } else {\\n      this._pageLoadLoginCallbacks.push(f);\\n    }\\n  };\\n\\n  // Receive the information about the login attempt at page load time.\\n  // Call registered callbacks, and also record the info in case\\n  // someone's callback hasn't been registered yet.\\n  //\\n  _pageLoadLogin(attemptInfo) {\\n    if (this._pageLoadLoginAttemptInfo) {\\n      Meteor._debug(\\n        'Ignoring unexpected duplicate page load login attempt info'\\n      );\\n      return;\\n    }\\n\\n    this._pageLoadLoginCallbacks.forEach(callback => callback(attemptInfo));\\n    this._pageLoadLoginCallbacks = [];\\n    this._pageLoadLoginAttemptInfo = attemptInfo;\\n  }\\n\\n  // _startupCallback executes on onLogin callbacks\\n  // at registration time if already logged in\\n  // this can happen when new AccountsClient is created\\n  // before callbacks are registered see #10157\\n  _startupCallback(callback) {\\n    // Are we already logged in?\\n    if (this._loginCallbacksCalled) {\\n      // If already logged in before handler is registered, it's safe to\\n      // assume type is a 'resume', so we execute the callback at the end\\n      // of the queue so that Meteor.startup can complete before any\\n      // embedded onLogin callbacks would execute.\\n      Meteor.setTimeout(() => callback({ type: 'resume' }), 0);\\n    }\\n  }\\n\\n  ///\\n  /// LOGIN TOKENS\\n  ///\\n\\n  // These methods deal with storing a login token and user id in the\\n  // browser's localStorage facility. It polls local storage every few\\n  // seconds to synchronize login state between multiple tabs in the same\\n  // browser.\\n\\n  loginWithToken(token, callback) {\\n    this.callLoginMethod({\\n      methodArguments: [{\\n        resume: token\\n      }],\\n      userCallback: callback\\n    });\\n  };\\n\\n  // Semi-internal API. Call this function to re-enable auto login after\\n  // if it was disabled at startup.\\n  _enableAutoLogin() {\\n    this._autoLoginEnabled = true;\\n    this._pollStoredLoginToken();\\n  };\\n\\n  ///\\n  /// STORING\\n  ///\\n\\n  // Call this from the top level of the test file for any test that does\\n  // logging in and out, to protect multiple tabs running the same tests\\n  // simultaneously from interfering with each others' localStorage.\\n  _isolateLoginTokenForTest() {\\n    this.LOGIN_TOKEN_KEY = this.LOGIN_TOKEN_KEY + Random.id();\\n    this.USER_ID_KEY = this.USER_ID_KEY + Random.id();\\n  };\\n\\n  _storeLoginToken(userId, token, tokenExpires) {\\n    this.storageLocation.setItem(this.USER_ID_KEY, userId);\\n    this.storageLocation.setItem(this.LOGIN_TOKEN_KEY, token);\\n    if (! tokenExpires)\\n      tokenExpires = this._tokenExpiration(new Date());\\n    this.storageLocation.setItem(this.LOGIN_TOKEN_EXPIRES_KEY, tokenExpires);\\n\\n    // to ensure that the localstorage poller doesn't end up trying to\\n    // connect a second time\\n    this._lastLoginTokenWhenPolled = token;\\n  };\\n\\n  _unstoreLoginToken() {\\n    this.storageLocation.removeItem(this.USER_ID_KEY);\\n    this.storageLocation.removeItem(this.LOGIN_TOKEN_KEY);\\n    this.storageLocation.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY);\\n\\n    // to ensure that the localstorage poller doesn't end up trying to\\n    // connect a second time\\n    this._lastLoginTokenWhenPolled = null;\\n  };\\n\\n  // This is private, but it is exported for now because it is used by a\\n  // test in accounts-password.\\n  _storedLoginToken() {\\n    return this.storageLocation.getItem(this.LOGIN_TOKEN_KEY);\\n  };\\n\\n  _storedLoginTokenExpires() {\\n    return this.storageLocation.getItem(this.LOGIN_TOKEN_EXPIRES_KEY);\\n  };\\n\\n  _storedUserId() {\\n    return this.storageLocation.getItem(this.USER_ID_KEY);\\n  };\\n\\n  _unstoreLoginTokenIfExpiresSoon() {\\n    const tokenExpires = this._storedLoginTokenExpires();\\n    if (tokenExpires && this._tokenExpiresSoon(new Date(tokenExpires))) {\\n      this._unstoreLoginToken();\\n    }\\n  };\\n\\n  ///\\n  /// AUTO-LOGIN\\n  ///\\n\\n  _initLocalStorage() {\\n    // Key names to use in localStorage\\n    this.LOGIN_TOKEN_KEY = \\\"Meteor.loginToken\\\";\\n    this.LOGIN_TOKEN_EXPIRES_KEY = \\\"Meteor.loginTokenExpires\\\";\\n    this.USER_ID_KEY = \\\"Meteor.userId\\\";\\n\\n    const rootUrlPathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\\n    if (rootUrlPathPrefix || this.connection !== Meteor.connection) {\\n      // We want to keep using the same keys for existing apps that do not\\n      // set a custom ROOT_URL_PATH_PREFIX, so that most users will not have\\n      // to log in again after an app updates to a version of Meteor that\\n      // contains this code, but it's generally preferable to namespace the\\n      // keys so that connections from distinct apps to distinct DDP URLs\\n      // will be distinct in Meteor._localStorage.\\n      let namespace = `:${this.connection._stream.rawUrl}`;\\n      if (rootUrlPathPrefix) {\\n        namespace += `:${rootUrlPathPrefix}`;\\n      }\\n      this.LOGIN_TOKEN_KEY += namespace;\\n      this.LOGIN_TOKEN_EXPIRES_KEY += namespace;\\n      this.USER_ID_KEY += namespace;\\n    }\\n\\n    let token;\\n    if (this._autoLoginEnabled) {\\n      // Immediately try to log in via local storage, so that any DDP\\n      // messages are sent after we have established our user account\\n      this._unstoreLoginTokenIfExpiresSoon();\\n      token = this._storedLoginToken();\\n      if (token) {\\n        // On startup, optimistically present us as logged in while the\\n        // request is in flight. This reduces page flicker on startup.\\n        const userId = this._storedUserId();\\n        userId && this.connection.setUserId(userId);\\n        this.loginWithToken(token, err => {\\n          if (err) {\\n            Meteor._debug(`Error logging in with token: ${err}`);\\n            this.makeClientLoggedOut();\\n          }\\n\\n          this._pageLoadLogin({\\n            type: \\\"resume\\\",\\n            allowed: !err,\\n            error: err,\\n            methodName: \\\"login\\\",\\n            // XXX This is duplicate code with loginWithToken, but\\n            // loginWithToken can also be called at other times besides\\n            // page load.\\n            methodArguments: [{resume: token}]\\n          });\\n        });\\n      }\\n    }\\n\\n    // Poll local storage every 3 seconds to login if someone logged in in\\n    // another tab\\n    this._lastLoginTokenWhenPolled = token;\\n\\n    if (this._pollIntervalTimer) {\\n      // Unlikely that _initLocalStorage will be called more than once for\\n      // the same AccountsClient instance, but just in case...\\n      clearInterval(this._pollIntervalTimer);\\n    }\\n\\n    this._pollIntervalTimer = setInterval(() => {\\n      this._pollStoredLoginToken();\\n    }, 3000);\\n  };\\n\\n  _pollStoredLoginToken() {\\n    if (! this._autoLoginEnabled) {\\n      return;\\n    }\\n\\n    const currentLoginToken = this._storedLoginToken();\\n\\n    // != instead of !== just to make sure undefined and null are treated the same\\n    if (this._lastLoginTokenWhenPolled != currentLoginToken) {\\n      if (currentLoginToken) {\\n        this.loginWithToken(currentLoginToken, (err) => {\\n          if (err) {\\n            this.makeClientLoggedOut();\\n          }\\n        });\\n      } else {\\n        this.logout();\\n      }\\n    }\\n\\n    this._lastLoginTokenWhenPolled = currentLoginToken;\\n  };\\n\\n  ///\\n  /// URLS\\n  ///\\n\\n  _initUrlMatching() {\\n    // By default, allow the autologin process to happen.\\n    this._autoLoginEnabled = true;\\n\\n    // We only support one callback per URL.\\n    this._accountsCallbacks = {};\\n\\n    // Try to match the saved value of window.location.hash.\\n    this._attemptToMatchHash();\\n  };\\n\\n  // Separate out this functionality for testing\\n  _attemptToMatchHash() {\\n    attemptToMatchHash(this, this.savedHash, defaultSuccessHandler);\\n  };\\n\\n  /**\\n   * @summary Register a function to call when a reset password link is clicked\\n   * in an email sent by\\n   * [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail).\\n   * This function should be called in top-level code, not inside\\n   * `Meteor.startup()`.\\n   * @memberof! Accounts\\n   * @name onResetPasswordLink\\n   * @param  {Function} callback The function to call. It is given two arguments:\\n   *\\n   * 1. `token`: A password reset token that can be passed to\\n   * [`Accounts.resetPassword`](#accounts_resetpassword).\\n   * 2. `done`: A function to call when the password reset UI flow is complete. The normal\\n   * login process is suspended until this function is called, so that the\\n   * password for user A can be reset even if user B was logged in.\\n   * @locus Client\\n   */\\n  onResetPasswordLink(callback) {\\n    if (this._accountsCallbacks[\\\"reset-password\\\"]) {\\n      Meteor._debug(\\\"Accounts.onResetPasswordLink was called more than once. \\\" +\\n        \\\"Only one callback added will be executed.\\\");\\n    }\\n\\n    this._accountsCallbacks[\\\"reset-password\\\"] = callback;\\n  };\\n\\n  /**\\n   * @summary Register a function to call when an email verification link is\\n   * clicked in an email sent by\\n   * [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail).\\n   * This function should be called in top-level code, not inside\\n   * `Meteor.startup()`.\\n   * @memberof! Accounts\\n   * @name onEmailVerificationLink\\n   * @param  {Function} callback The function to call. It is given two arguments:\\n   *\\n   * 1. `token`: An email verification token that can be passed to\\n   * [`Accounts.verifyEmail`](#accounts_verifyemail).\\n   * 2. `done`: A function to call when the email verification UI flow is complete.\\n   * The normal login process is suspended until this function is called, so\\n   * that the user can be notified that they are verifying their email before\\n   * being logged in.\\n   * @locus Client\\n   */\\n  onEmailVerificationLink(callback) {\\n    if (this._accountsCallbacks[\\\"verify-email\\\"]) {\\n      Meteor._debug(\\\"Accounts.onEmailVerificationLink was called more than once. \\\" +\\n        \\\"Only one callback added will be executed.\\\");\\n    }\\n\\n    this._accountsCallbacks[\\\"verify-email\\\"] = callback;\\n  };\\n\\n  /**\\n   * @summary Register a function to call when an account enrollment link is\\n   * clicked in an email sent by\\n   * [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).\\n   * This function should be called in top-level code, not inside\\n   * `Meteor.startup()`.\\n   * @memberof! Accounts\\n   * @name onEnrollmentLink\\n   * @param  {Function} callback The function to call. It is given two arguments:\\n   *\\n   * 1. `token`: A password reset token that can be passed to\\n   * [`Accounts.resetPassword`](#accounts_resetpassword) to give the newly\\n   * enrolled account a password.\\n   * 2. `done`: A function to call when the enrollment UI flow is complete.\\n   * The normal login process is suspended until this function is called, so that\\n   * user A can be enrolled even if user B was logged in.\\n   * @locus Client\\n   */\\n  onEnrollmentLink(callback) {\\n    if (this._accountsCallbacks[\\\"enroll-account\\\"]) {\\n      Meteor._debug(\\\"Accounts.onEnrollmentLink was called more than once. \\\" +\\n        \\\"Only one callback added will be executed.\\\");\\n    }\\n\\n    this._accountsCallbacks[\\\"enroll-account\\\"] = callback;\\n  };\\n\\n}\\n\\n/**\\n * @summary True if a login method (such as `Meteor.loginWithPassword`,\\n * `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in\\n * progress. A reactive data source.\\n * @locus Client\\n * @importFromPackage meteor\\n */\\nMeteor.loggingIn = () => Accounts.loggingIn();\\n\\n/**\\n * @summary True if a logout method (such as `Meteor.logout`) is currently in\\n * progress. A reactive data source.\\n * @locus Client\\n * @importFromPackage meteor\\n */\\nMeteor.loggingOut = () => Accounts.loggingOut();\\n\\n/**\\n * @summary Log the user out.\\n * @locus Client\\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n * @importFromPackage meteor\\n */\\nMeteor.logout = callback => Accounts.logout(callback);\\n\\n/**\\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\\n * @locus Client\\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n * @importFromPackage meteor\\n */\\nMeteor.logoutOtherClients = callback => Accounts.logoutOtherClients(callback);\\n\\n/**\\n * @summary Login with a Meteor access token.\\n * @locus Client\\n * @param {Object} [token] Local storage token for use with login across\\n * multiple tabs in the same browser.\\n * @param {Function} [callback] Optional callback. Called with no arguments on\\n * success.\\n * @importFromPackage meteor\\n */\\nMeteor.loginWithToken = (token, callback) =>\\n  Accounts.loginWithToken(token, callback);\\n\\n///\\n/// HANDLEBARS HELPERS\\n///\\n\\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\\n// global helpers.\\nif (Package.blaze) {\\n  const { Template } = Package.blaze.Blaze;\\n\\n  /**\\n   * @global\\n   * @name  currentUser\\n   * @isHelper true\\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\\n   */\\n  Template.registerHelper('currentUser', () => Meteor.user());\\n\\n  // TODO: the code above needs to be changed to Meteor.userAsync() when we have\\n  // a way to make it reactive using async.\\n  // Template.registerHelper('currentUserAsync',\\n  //  async () => await Meteor.userAsync());\\n\\n  /**\\n   * @global\\n   * @name  loggingIn\\n   * @isHelper true\\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\\n   */\\n  Template.registerHelper('loggingIn', () => Meteor.loggingIn());\\n\\n  /**\\n   * @global\\n   * @name  loggingOut\\n   * @isHelper true\\n   * @summary Calls [Meteor.loggingOut()](#meteor_loggingout).\\n   */\\n  Template.registerHelper('loggingOut', () => Meteor.loggingOut());\\n\\n  /**\\n   * @global\\n   * @name  loggingInOrOut\\n   * @isHelper true\\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin) or [Meteor.loggingOut()](#meteor_loggingout).\\n   */\\n  Template.registerHelper(\\n    'loggingInOrOut',\\n    () => Meteor.loggingIn() || Meteor.loggingOut()\\n  );\\n}\\n\\nconst defaultSuccessHandler = function(token, urlPart) {\\n  // put login in a suspended state to wait for the interaction to finish\\n  this._autoLoginEnabled = false;\\n\\n  // wait for other packages to register callbacks\\n  Meteor.startup(() => {\\n    // if a callback has been registered for this kind of token, call it\\n    if (this._accountsCallbacks[urlPart]) {\\n      this._accountsCallbacks[urlPart](token, () => this._enableAutoLogin());\\n    }\\n  });\\n}\\n\\n// Note that both arguments are optional and are currently only passed by\\n// accounts_url_tests.js.\\nconst attemptToMatchHash = (accounts, hash, success) => {\\n  // All of the special hash URLs we support for accounts interactions\\n  [\\\"reset-password\\\", \\\"verify-email\\\", \\\"enroll-account\\\"].forEach(urlPart => {\\n    let token;\\n\\n    const tokenRegex = new RegExp(`^\\\\\\\\#\\\\\\\\/${urlPart}\\\\\\\\/(.*)$`);\\n    const match = hash.match(tokenRegex);\\n\\n    if (match) {\\n      token = match[1];\\n\\n      // XXX COMPAT WITH 0.9.3\\n      if (urlPart === \\\"reset-password\\\") {\\n        accounts._resetPasswordToken = token;\\n      } else if (urlPart === \\\"verify-email\\\") {\\n        accounts._verifyEmailToken = token;\\n      } else if (urlPart === \\\"enroll-account\\\") {\\n        accounts._enrollAccountToken = token;\\n      }\\n    } else {\\n      return;\\n    }\\n\\n    // If no handlers match the hash, then maybe it's meant to be consumed\\n    // by some entirely different code, so we only clear it the first time\\n    // a handler successfully matches. Note that later handlers reuse the\\n    // savedHash, so clearing window.location.hash here will not interfere\\n    // with their needs.\\n    window.location.hash = \\\"\\\";\\n\\n    // Do some stuff with the token we matched\\n    success.call(accounts, token, urlPart);\\n  });\\n}\\n\\n// Export for testing\\nexport const AccountsTest = {\\n  attemptToMatchHash: (hash, success) =>\\n    attemptToMatchHash(Accounts, hash, success),\\n};\\n\",\"import { Meteor } from 'meteor/meteor';\\n\\n// config option keys\\nconst VALID_CONFIG_KEYS = [\\n  'sendVerificationEmail',\\n  'forbidClientAccountCreation',\\n  'restrictCreationByEmailDomain',\\n  'loginExpiration',\\n  'loginExpirationInDays',\\n  'oauthSecretKey',\\n  'passwordResetTokenExpirationInDays',\\n  'passwordResetTokenExpiration',\\n  'passwordEnrollTokenExpirationInDays',\\n  'passwordEnrollTokenExpiration',\\n  'ambiguousErrorMessages',\\n  'bcryptRounds',\\n  'defaultFieldSelector',\\n  'collection',\\n  'loginTokenExpirationHours',\\n  'tokenSequenceLength',\\n  'clientStorage',\\n  'ddpUrl',\\n  'connection',\\n];\\n\\n/**\\n * @summary Super-constructor for AccountsClient and AccountsServer.\\n * @locus Anywhere\\n * @class AccountsCommon\\n * @instancename accountsClientOrServer\\n * @param options {Object} an object with fields:\\n * - connection {Object} Optional DDP connection to reuse.\\n * - ddpUrl {String} Optional URL for creating a new DDP connection.\\n * - collection {String|Mongo.Collection} The name of the Mongo.Collection\\n *     or the Mongo.Collection object to hold the users.\\n */\\nexport class AccountsCommon {\\n  constructor(options) {\\n    // Validate config options keys\\n    for (const key of Object.keys(options)) {\\n      if (!VALID_CONFIG_KEYS.includes(key)) {\\n        console.error(`Accounts.config: Invalid key: ${key}`);\\n      }\\n    }\\n\\n    // Currently this is read directly by packages like accounts-password\\n    // and accounts-ui-unstyled.\\n    this._options = options || {};\\n\\n    // Note that setting this.connection = null causes this.users to be a\\n    // LocalCollection, which is not what we want.\\n    this.connection = undefined;\\n    this._initConnection(options || {});\\n\\n    // There is an allow call in accounts_server.js that restricts writes to\\n    // this collection.\\n    this.users = this._initializeCollection(options || {});\\n\\n    // Callback exceptions are printed with Meteor._debug and ignored.\\n    this._onLoginHook = new Hook({\\n      bindEnvironment: false,\\n      debugPrintExceptions: 'onLogin callback',\\n    });\\n\\n    this._onLoginFailureHook = new Hook({\\n      bindEnvironment: false,\\n      debugPrintExceptions: 'onLoginFailure callback',\\n    });\\n\\n    this._onLogoutHook = new Hook({\\n      bindEnvironment: false,\\n      debugPrintExceptions: 'onLogout callback',\\n    });\\n\\n    // Expose for testing.\\n    this.DEFAULT_LOGIN_EXPIRATION_DAYS = DEFAULT_LOGIN_EXPIRATION_DAYS;\\n    this.LOGIN_UNEXPIRING_TOKEN_DAYS = LOGIN_UNEXPIRING_TOKEN_DAYS;\\n\\n    // Thrown when the user cancels the login process (eg, closes an oauth\\n    // popup, declines retina scan, etc)\\n    const lceName = 'Accounts.LoginCancelledError';\\n    this.LoginCancelledError = Meteor.makeErrorType(lceName, function(\\n      description\\n    ) {\\n      this.message = description;\\n    });\\n    this.LoginCancelledError.prototype.name = lceName;\\n\\n    // This is used to transmit specific subclass errors over the wire. We\\n    // should come up with a more generic way to do this (eg, with some sort of\\n    // symbolic error code rather than a number).\\n    this.LoginCancelledError.numericError = 0x8acdc2f;\\n  }\\n\\n  _initializeCollection(options) {\\n    if (options.collection && typeof options.collection !== 'string' && !(options.collection instanceof Mongo.Collection)) {\\n      throw new Meteor.Error('Collection parameter can be only of type string or \\\"Mongo.Collection\\\"');\\n    }\\n\\n    let collectionName = 'users';\\n    if (typeof options.collection === 'string') {\\n      collectionName = options.collection;\\n    }\\n\\n    let collection;\\n    if (options.collection instanceof Mongo.Collection) {\\n      collection = options.collection;\\n    } else {\\n      collection = new Mongo.Collection(collectionName, {\\n        _preventAutopublish: true,\\n        connection: this.connection,\\n      });\\n    }\\n\\n    return collection;\\n  }\\n\\n  /**\\n   * @summary Get the current user id, or `null` if no user is logged in. A reactive data source.\\n   * @locus Anywhere\\n   */\\n  userId() {\\n    throw new Error('userId method not implemented');\\n  }\\n\\n  // merge the defaultFieldSelector with an existing options object\\n  _addDefaultFieldSelector(options = {}) {\\n    // this will be the most common case for most people, so make it quick\\n    if (!this._options.defaultFieldSelector) return options;\\n\\n    // if no field selector then just use defaultFieldSelector\\n    if (!options.fields)\\n      return {\\n        ...options,\\n        fields: this._options.defaultFieldSelector,\\n      };\\n\\n    // if empty field selector then the full user object is explicitly requested, so obey\\n    const keys = Object.keys(options.fields);\\n    if (!keys.length) return options;\\n\\n    // if the requested fields are +ve then ignore defaultFieldSelector\\n    // assume they are all either +ve or -ve because Mongo doesn't like mixed\\n    if (!!options.fields[keys[0]]) return options;\\n\\n    // The requested fields are -ve.\\n    // If the defaultFieldSelector is +ve then use requested fields, otherwise merge them\\n    const keys2 = Object.keys(this._options.defaultFieldSelector);\\n    return this._options.defaultFieldSelector[keys2[0]]\\n      ? options\\n      : {\\n          ...options,\\n          fields: {\\n            ...options.fields,\\n            ...this._options.defaultFieldSelector,\\n          },\\n        };\\n  }\\n\\n  /**\\n   * @summary Get the current user record, or `null` if no user is logged in. A reactive data source. In the server this fuction returns a promise.\\n   * @locus Anywhere\\n   * @param {Object} [options]\\n   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\\n   */\\n  user(options) {\\n    if (Meteor.isServer) {\\n      console.warn([\\n        \\\"`Meteor.user()` is deprecated on the server side.\\\",\\n        \\\"    To fetch the current user record on the server,\\\",\\n        \\\"    use `Meteor.userAsync()` instead.\\\",\\n      ].join(\\\"\\\\n\\\"));\\n    }\\n\\n    const self = this;\\n    const userId = self.userId();\\n    const findOne = (...args) => Meteor.isClient\\n      ? self.users.findOne(...args)\\n      : self.users.findOneAsync(...args);\\n    return userId\\n      ? findOne(userId, this._addDefaultFieldSelector(options))\\n      : null;\\n  }\\n\\n  /**\\n   * @summary Get the current user record, or `null` if no user is logged in.\\n   * @locus Anywhere\\n   * @param {Object} [options]\\n   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\\n   */\\n  async userAsync(options) {\\n    const userId = this.userId();\\n    return userId\\n      ? this.users.findOneAsync(userId, this._addDefaultFieldSelector(options))\\n      : null;\\n  }\\n  // Set up config for the accounts system. Call this on both the client\\n  // and the server.\\n  //\\n  // Note that this method gets overridden on AccountsServer.prototype, but\\n  // the overriding method calls the overridden method.\\n  //\\n  // XXX we should add some enforcement that this is called on both the\\n  // client and the server. Otherwise, a user can\\n  // 'forbidClientAccountCreation' only on the client and while it looks\\n  // like their app is secure, the server will still accept createUser\\n  // calls. https://github.com/meteor/meteor/issues/828\\n  //\\n  // @param options {Object} an object with fields:\\n  // - sendVerificationEmail {Boolean}\\n  //     Send email address verification emails to new users created from\\n  //     client signups.\\n  // - forbidClientAccountCreation {Boolean}\\n  //     Do not allow clients to create accounts directly.\\n  // - restrictCreationByEmailDomain {Function or String}\\n  //     Require created users to have an email matching the function or\\n  //     having the string as domain.\\n  // - loginExpirationInDays {Number}\\n  //     Number of days since login until a user is logged out (login token\\n  //     expires).\\n  // - collection {String|Mongo.Collection}\\n  //     A collection name or a Mongo.Collection object to hold the users.\\n  // - passwordResetTokenExpirationInDays {Number}\\n  //     Number of days since password reset token creation until the\\n  //     token can't be used any longer (password reset token expires).\\n  // - ambiguousErrorMessages {Boolean}\\n  //     Return ambiguous error messages from login failures to prevent\\n  //     user enumeration.\\n  // - bcryptRounds {Number}\\n  //     Allows override of number of bcrypt rounds (aka work factor) used\\n  //     to store passwords.\\n\\n  /**\\n   * @summary Set global accounts options. You can also set these in `Meteor.settings.packages.accounts` without the need to call this function.\\n   * @locus Anywhere\\n   * @param {Object} options\\n   * @param {Boolean} options.sendVerificationEmail New users with an email address will receive an address verification email.\\n   * @param {Boolean} options.forbidClientAccountCreation Calls to [`createUser`](#accounts_createuser) from the client will be rejected. In addition, if you are using [accounts-ui](#accountsui), the \\\"Create account\\\" link will not be available.\\n   * @param {String | Function} options.restrictCreationByEmailDomain If set to a string, only allows new users if the domain part of their email address matches the string. If set to a function, only allows new users if the function returns true.  The function is passed the full email address of the proposed new user.  Works with password-based sign-in and external services that expose email addresses (Google, Facebook, GitHub). All existing users still can log in after enabling this option. Example: `Accounts.config({ restrictCreationByEmailDomain: 'school.edu' })`.\\n   * @param {Number} options.loginExpiration The number of milliseconds from when a user logs in until their token expires and they are logged out, for a more granular control. If `loginExpirationInDays` is set, it takes precedent.\\n   * @param {Number} options.loginExpirationInDays The number of days from when a user logs in until their token expires and they are logged out. Defaults to 90. Set to `null` to disable login expiration.\\n   * @param {String} options.oauthSecretKey When using the `oauth-encryption` package, the 16 byte key using to encrypt sensitive account credentials in the database, encoded in base64.  This option may only be specified on the server.  See packages/oauth-encryption/README.md for details.\\n   * @param {Number} options.passwordResetTokenExpirationInDays The number of days from when a link to reset password is sent until token expires and user can't reset password with the link anymore. Defaults to 3.\\n   * @param {Number} options.passwordResetTokenExpiration The number of milliseconds from when a link to reset password is sent until token expires and user can't reset password with the link anymore. If `passwordResetTokenExpirationInDays` is set, it takes precedent.\\n   * @param {Number} options.passwordEnrollTokenExpirationInDays The number of days from when a link to set initial password is sent until token expires and user can't set password with the link anymore. Defaults to 30.\\n   * @param {Number} options.passwordEnrollTokenExpiration The number of milliseconds from when a link to set initial password is sent until token expires and user can't set password with the link anymore. If `passwordEnrollTokenExpirationInDays` is set, it takes precedent.\\n   * @param {Boolean} options.ambiguousErrorMessages Return ambiguous error messages from login failures to prevent user enumeration. Defaults to `false`, but in production environments it is recommended it defaults to `true`.\\n   * @param {Number} options.bcryptRounds Allows override of number of bcrypt rounds (aka work factor) used to store passwords. The default is 10.\\n   * @param {MongoFieldSpecifier} options.defaultFieldSelector To exclude by default large custom fields from `Meteor.user()` and `Meteor.findUserBy...()` functions when called without a field selector, and all `onLogin`, `onLoginFailure` and `onLogout` callbacks.  Example: `Accounts.config({ defaultFieldSelector: { myBigArray: 0 }})`. Beware when using this. If, for instance, you do not include `email` when excluding the fields, you can have problems with functions like `forgotPassword` that will break because they won't have the required data available. It's recommend that you always keep the fields `_id`, `username`, and `email`.\\n   * @param {String|Mongo.Collection} options.collection A collection name or a Mongo.Collection object to hold the users.\\n   * @param {Number} options.loginTokenExpirationHours When using the package `accounts-2fa`, use this to set the amount of time a token sent is valid. As it's just a number, you can use, for example, 0.5 to make the token valid for just half hour. The default is 1 hour.\\n   * @param {Number} options.tokenSequenceLength When using the package `accounts-2fa`, use this to the size of the token sequence generated. The default is 6.\\n   * @param {'session' | 'local'} options.clientStorage By default login credentials are stored in local storage, setting this to true will switch to using session storage.\\n   */\\n  config(options) {\\n    // We don't want users to accidentally only call Accounts.config on the\\n    // client, where some of the options will have partial effects (eg removing\\n    // the \\\"create account\\\" button from accounts-ui if forbidClientAccountCreation\\n    // is set, or redirecting Google login to a specific-domain page) without\\n    // having their full effects.\\n    if (Meteor.isServer) {\\n      __meteor_runtime_config__.accountsConfigCalled = true;\\n    } else if (!__meteor_runtime_config__.accountsConfigCalled) {\\n      // XXX would be nice to \\\"crash\\\" the client and replace the UI with an error\\n      // message, but there's no trivial way to do this.\\n      Meteor._debug(\\n        'Accounts.config was called on the client but not on the ' +\\n          'server; some configuration options may not take effect.'\\n      );\\n    }\\n\\n    // We need to validate the oauthSecretKey option at the time\\n    // Accounts.config is called. We also deliberately don't store the\\n    // oauthSecretKey in Accounts._options.\\n    if (Object.prototype.hasOwnProperty.call(options, 'oauthSecretKey')) {\\n      if (Meteor.isClient) {\\n        throw new Error(\\n          'The oauthSecretKey option may only be specified on the server'\\n        );\\n      }\\n      if (!Package['oauth-encryption']) {\\n        throw new Error(\\n          'The oauth-encryption package must be loaded to set oauthSecretKey'\\n        );\\n      }\\n      Package['oauth-encryption'].OAuthEncryption.loadKey(\\n        options.oauthSecretKey\\n      );\\n      options = { ...options };\\n      delete options.oauthSecretKey;\\n    }\\n\\n    // Validate config options keys\\n    for (const key of Object.keys(options)) {\\n      if (!VALID_CONFIG_KEYS.includes(key)) {\\n        console.error(`Accounts.config: Invalid key: ${key}`);\\n      }\\n    }\\n\\n    // set values in Accounts._options\\n    for (const key of VALID_CONFIG_KEYS) {\\n      if (key in options) {\\n        if (key in this._options) {\\n          if (key !== 'collection' && (Meteor.isTest && key !== 'clientStorage')) {\\n            throw new Meteor.Error(`Can't set \\\\`${key}\\\\` more than once`);\\n          }\\n        }\\n        this._options[key] = options[key];\\n      }\\n    }\\n\\n    if (options.collection && options.collection !== this.users._name && options.collection !== this.users) {\\n      this.users = this._initializeCollection(options);\\n    }\\n  }\\n\\n  /**\\n   * @summary Register a callback to be called after a login attempt succeeds.\\n   * @locus Anywhere\\n   * @param {Function} func The callback to be called when login is successful.\\n   *                        The callback receives a single object that\\n   *                        holds login details. This object contains the login\\n   *                        result type (password, resume, etc.) on both the\\n   *                        client and server. `onLogin` callbacks registered\\n   *                        on the server also receive extra data, such\\n   *                        as user details, connection information, etc.\\n   */\\n  onLogin(func) {\\n    let ret = this._onLoginHook.register(func);\\n    // call the just registered callback if already logged in\\n    this._startupCallback(ret.callback);\\n    return ret;\\n  }\\n\\n  /**\\n   * @summary Register a callback to be called after a login attempt fails.\\n   * @locus Anywhere\\n   * @param {Function} func The callback to be called after the login has failed.\\n   */\\n  onLoginFailure(func) {\\n    return this._onLoginFailureHook.register(func);\\n  }\\n\\n  /**\\n   * @summary Register a callback to be called after a logout attempt succeeds.\\n   * @locus Anywhere\\n   * @param {Function} func The callback to be called when logout is successful.\\n   */\\n  onLogout(func) {\\n    return this._onLogoutHook.register(func);\\n  }\\n\\n  _initConnection(options) {\\n    if (!Meteor.isClient) {\\n      return;\\n    }\\n\\n    // The connection used by the Accounts system. This is the connection\\n    // that will get logged in by Meteor.login(), and this is the\\n    // connection whose login state will be reflected by Meteor.userId().\\n    //\\n    // It would be much preferable for this to be in accounts_client.js,\\n    // but it has to be here because it's needed to create the\\n    // Meteor.users collection.\\n    if (options.connection) {\\n      this.connection = options.connection;\\n    } else if (options.ddpUrl) {\\n      this.connection = DDP.connect(options.ddpUrl);\\n    } else if (\\n      typeof __meteor_runtime_config__ !== 'undefined' &&\\n      __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL\\n    ) {\\n      // Temporary, internal hook to allow the server to point the client\\n      // to a different authentication server. This is for a very\\n      // particular use case that comes up when implementing a oauth\\n      // server. Unsupported and may go away at any point in time.\\n      //\\n      // We will eventually provide a general way to use account-base\\n      // against any DDP connection, not just one special one.\\n      this.connection = DDP.connect(\\n        __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL\\n      );\\n    } else {\\n      this.connection = Meteor.connection;\\n    }\\n  }\\n\\n  _getTokenLifetimeMs() {\\n    // When loginExpirationInDays is set to null, we'll use a really high\\n    // number of days (LOGIN_UNEXPIRABLE_TOKEN_DAYS) to simulate an\\n    // unexpiring token.\\n    const loginExpirationInDays =\\n      this._options.loginExpirationInDays === null\\n        ? LOGIN_UNEXPIRING_TOKEN_DAYS\\n        : this._options.loginExpirationInDays;\\n    return (\\n      this._options.loginExpiration ||\\n      (loginExpirationInDays || DEFAULT_LOGIN_EXPIRATION_DAYS) * 86400000\\n    );\\n  }\\n\\n  _getPasswordResetTokenLifetimeMs() {\\n    return (\\n      this._options.passwordResetTokenExpiration ||\\n      (this._options.passwordResetTokenExpirationInDays ||\\n        DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS) * 86400000\\n    );\\n  }\\n\\n  _getPasswordEnrollTokenLifetimeMs() {\\n    return (\\n      this._options.passwordEnrollTokenExpiration ||\\n      (this._options.passwordEnrollTokenExpirationInDays ||\\n        DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS) * 86400000\\n    );\\n  }\\n\\n  _tokenExpiration(when) {\\n    // We pass when through the Date constructor for backwards compatibility;\\n    // `when` used to be a number.\\n    return new Date(new Date(when).getTime() + this._getTokenLifetimeMs());\\n  }\\n\\n  _tokenExpiresSoon(when) {\\n    let minLifetimeMs = 0.1 * this._getTokenLifetimeMs();\\n    const minLifetimeCapMs = MIN_TOKEN_LIFETIME_CAP_SECS * 1000;\\n    if (minLifetimeMs > minLifetimeCapMs) {\\n      minLifetimeMs = minLifetimeCapMs;\\n    }\\n    return new Date() > new Date(when) - minLifetimeMs;\\n  }\\n\\n  // No-op on the server, overridden on the client.\\n  _startupCallback(callback) {}\\n}\\n\\n// Note that Accounts is defined separately in accounts_client.js and\\n// accounts_server.js.\\n\\n/**\\n * @summary Get the current user id, or `null` if no user is logged in. A reactive data source.\\n * @locus Anywhere\\n * @importFromPackage meteor\\n */\\nMeteor.userId = () => Accounts.userId();\\n\\n/**\\n * @summary Get the current user record, or `null` if no user is logged in. A reactive data source.\\n * @locus Anywhere\\n * @importFromPackage meteor\\n * @param {Object} [options]\\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\\n */\\nMeteor.user = options => Accounts.user(options);\\n\\n/**\\n * @summary Get the current user record, or `null` if no user is logged in. A reactive data source.\\n * @locus Anywhere\\n * @importFromPackage meteor\\n * @param {Object} [options]\\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\\n */\\nMeteor.userAsync = options => Accounts.userAsync(options);\\n\\n// how long (in days) until a login token expires\\nconst DEFAULT_LOGIN_EXPIRATION_DAYS = 90;\\n// how long (in days) until reset password token expires\\nconst DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS = 3;\\n// how long (in days) until enrol password token expires\\nconst DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS = 30;\\n// Clients don't try to auto-login with a token that is going to expire within\\n// .1 * DEFAULT_LOGIN_EXPIRATION_DAYS, capped at MIN_TOKEN_LIFETIME_CAP_SECS.\\n// Tries to avoid abrupt disconnects from expiring tokens.\\nconst MIN_TOKEN_LIFETIME_CAP_SECS = 3600; // one hour\\n// how often (in milliseconds) we check for expired tokens\\nexport const EXPIRE_TOKENS_INTERVAL_MS = 600 * 1000; // 10 minutes\\n// A large number of expiration days (approximately 100 years worth) that is\\n// used when creating unexpiring tokens.\\nconst LOGIN_UNEXPIRING_TOKEN_DAYS = 365 * 100;\\n\",null],\"names\":[\"AccountsClient\",\"AccountsTest\",\"module\",\"export\",\"Accounts\",\"default\",\"exports\",\"link\",\"v\",\"runSetters\",\"_Meteor$settings\",\"Meteor\",\"settings\",\"_Meteor$settings$publ\",\"public\",\"_Meteor$settings$publ2\",\"packages\",\"accounts\",\"users\",\"_objectSpread\",\"AccountsCommon\",\"constructor\",\"options\",\"_loggingIn\",\"ReactiveVar\",\"_loggingOut\",\"_loginServicesHandle\",\"connection\",\"subscribe\",\"_pageLoadLoginCallbacks\",\"_pageLoadLoginAttemptInfo\",\"savedHash\",\"window\",\"location\",\"hash\",\"_initUrlMatching\",\"initStorageLocation\",\"_initLocalStorage\",\"_loginFuncs\",\"_loginCallbacksCalled\",\"_Meteor$settings$publ3\",\"storageLocation\",\"clientStorage\",\"sessionStorage\",\"_localStorage\",\"config\",\"userId\",\"_setLoggingIn\",\"x\",\"set\",\"loggingIn\",\"get\",\"loggingOut\",\"registerClientLoginFunction\",\"funcName\",\"func\",\"Error\",\"concat\",\"callLoginFunction\",\"_len\",\"arguments\",\"length\",\"funcArgs\",\"Array\",\"_key\",\"apply\",\"applyLoginFunction\",\"logout\",\"callback\",\"applyAsync\",\"wait\",\"then\",\"result\",\"makeClientLoggedOut\",\"catch\",\"e\",\"logoutOtherClients\",\"err\",\"_storeLoginToken\",\"token\",\"tokenExpires\",\"callLoginMethod\",\"called\",\"methodName\",\"methodArguments\",\"_suppressLoggingIn\",\"forEach\",\"f\",\"loginCallbacks\",\"_ref\",\"error\",\"loginDetails\",\"_onLoginFailureHook\",\"_onLoginHook\",\"userCallback\",\"reconnected\",\"onResultReceived\",\"_reconnectStopper\",\"stop\",\"DDP\",\"onReconnect\",\"conn\",\"storedToken\",\"_storedLoginToken\",\"_storedLoginTokenExpires\",\"_tokenExpiration\",\"Date\",\"_tokenExpiresSoon\",\"resume\",\"storedTokenNow\",\"loggedInAndDataReadyCallback\",\"validateResult\",\"makeClientLoggedIn\",\"id\",\"Tracker\",\"autorun\",\"computation\",\"user\",\"withComputation\",\"userAsync\",\"_userId\",\"_onLogoutHook\",\"each\",\"_unstoreLoginToken\",\"setUserId\",\"loginServicesConfigured\",\"ready\",\"onPageLoadLogin\",\"push\",\"_pageLoadLogin\",\"attemptInfo\",\"_debug\",\"_startupCallback\",\"setTimeout\",\"type\",\"loginWithToken\",\"_enableAutoLogin\",\"_autoLoginEnabled\",\"_pollStoredLoginToken\",\"_isolateLoginTokenForTest\",\"LOGIN_TOKEN_KEY\",\"Random\",\"USER_ID_KEY\",\"setItem\",\"LOGIN_TOKEN_EXPIRES_KEY\",\"_lastLoginTokenWhenPolled\",\"removeItem\",\"getItem\",\"_storedUserId\",\"_unstoreLoginTokenIfExpiresSoon\",\"rootUrlPathPrefix\",\"__meteor_runtime_config__\",\"ROOT_URL_PATH_PREFIX\",\"namespace\",\"_stream\",\"rawUrl\",\"allowed\",\"_pollIntervalTimer\",\"clearInterval\",\"setInterval\",\"currentLoginToken\",\"_accountsCallbacks\",\"_attemptToMatchHash\",\"attemptToMatchHash\",\"defaultSuccessHandler\",\"onResetPasswordLink\",\"onEmailVerificationLink\",\"onEnrollmentLink\",\"Package\",\"blaze\",\"Template\",\"Blaze\",\"registerHelper\",\"urlPart\",\"startup\",\"success\",\"tokenRegex\",\"RegExp\",\"match\",\"_resetPasswordToken\",\"_verifyEmailToken\",\"_enrollAccountToken\",\"call\",\"EXPIRE_TOKENS_INTERVAL_MS\",\"VALID_CONFIG_KEYS\",\"key\",\"Object\",\"keys\",\"includes\",\"console\",\"_options\",\"undefined\",\"_initConnection\",\"_initializeCollection\",\"Hook\",\"bindEnvironment\",\"debugPrintExceptions\",\"DEFAULT_LOGIN_EXPIRATION_DAYS\",\"LOGIN_UNEXPIRING_TOKEN_DAYS\",\"lceName\",\"LoginCancelledError\",\"makeErrorType\",\"description\",\"message\",\"prototype\",\"name\",\"numericError\",\"collection\",\"Mongo\",\"Collection\",\"collectionName\",\"_preventAutopublish\",\"_addDefaultFieldSelector\",\"defaultFieldSelector\",\"fields\",\"keys2\",\"isServer\",\"warn\",\"self\",\"findOne\",\"isClient\",\"findOneAsync\",\"accountsConfigCalled\",\"hasOwnProperty\",\"OAuthEncryption\",\"loadKey\",\"oauthSecretKey\",\"isTest\",\"_name\",\"onLogin\",\"ret\",\"register\",\"onLoginFailure\",\"onLogout\",\"ddpUrl\",\"connect\",\"ACCOUNTS_CONNECTION_URL\",\"_getTokenLifetimeMs\",\"loginExpirationInDays\",\"loginExpiration\",\"_getPasswordResetTokenLifetimeMs\",\"passwordResetTokenExpiration\",\"passwordResetTokenExpirationInDays\",\"DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS\",\"_getPasswordEnrollTokenLifetimeMs\",\"passwordEnrollTokenExpiration\",\"passwordEnrollTokenExpirationInDays\",\"DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS\",\"when\",\"getTime\",\"minLifetimeMs\",\"minLifetimeCapMs\",\"MIN_TOKEN_LIFETIME_CAP_SECS\"],\"mappings\":\"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\"}"}