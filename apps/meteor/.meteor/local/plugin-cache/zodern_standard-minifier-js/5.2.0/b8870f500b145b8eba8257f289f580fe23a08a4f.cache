{"code":"Package[\"core-runtime\"].queue(\"dispatch:run-as-user\",function(){var t,e=Package.meteor.Meteor;Package.meteor.global,Package.meteor.meteorEnv,Package.check.check,Package.check.Match;var n=Package.underscore._,r=Package.mongo.Mongo,i=Package[\"ddp-client\"].DDP;return(function(){void 0===t&&((t={}).MethodInvocation=function(t){this.isSimulation=t.isSimulation,this._unblock=t.unblock||function(){},this._calledUnblock=!1,this.userId=t.userId,this._setUserId=t.setUserId||function(){},this.connection=t.connection,this.randomSeed=t.randomSeed,this.randomStream=null},n.extend(t.MethodInvocation.prototype,{unblock:function(){this._calledUnblock=!0,this._unblock()},setUserId:function(t){if(this._calledUnblock)throw Error(\"Can't call setUserId in a method after calling unblock\");this.userId=t}}))}).call(this),(function(){var n=new e.EnvironmentVariable;e.isRestricted=function(){return!!n.get()},e.runRestricted=function(t){return e.isRestricted()?t():n.withValue(!0,t)},e.runUnrestricted=function(t){if(e.isRestricted())return n.withValue(!1,t);t()},e.runAsUser=function(e,n){var r=i._CurrentInvocation.get(),o=new t.MethodInvocation(r||{connection:null});return o.setUserId(e),i._CurrentInvocation.withValue(o,function(){return n.apply(o,[e])})},e.runAsRestrictedUser=function(t,n){return e.runRestricted(function(){return e.runAsUser(t,n)})};var r=new e.EnvironmentVariable;e.isAdmin=function(){return!!r.get()},e.runAsAdmin=function(t){return e.isAdmin()?t():r.withValue(!1,t)},e.runOutsideInvocation=function(t){e.isServer&&i._CurrentInvocation.get()?i._CurrentInvocation.withValue(null,t):t()}}).call(this),(function(){n.each([\"insert\",\"update\",\"remove\"],function(t){var i=r.Collection.prototype[t];r.Collection.prototype[t]=function(){var r=n.toArray(arguments);if(e.isRestricted()&&this._restricted){var o=null;if(\"insert\"!==t||n.has(r[0],\"_id\")||(o=this._makeNewID()),0===this._validators[t].allow.length)throw new e.Error(403,\"Access denied. No allow validators set on restricted collection for method '\"+t+\"'.\");var c=\"_validated\"+t.charAt(0).toUpperCase()+t.slice(1);return(r.unshift(e.userId()),\"insert\"===t)?(r.push(o),this[c].apply(this,r),o||r[0]._id):this[c].apply(this,r)}return i.apply(this,r)}})}).call(this),{}});","map":"{\"version\":3,\"sources\":[\"packages/dispatch_run-as-user/lib/pre.1.0.3.js\",\"packages/dispatch_run-as-user/lib/common.js\",\"packages/dispatch_run-as-user/lib/collection.overwrites.js\",\"<anon>\"],\"sourcesContent\":[\"// This code will go away in later versions of Meteor, this is just a \\\"polyfill\\\"\\n// until the next release of Meteor maybe 1.0.3?\\n//\\nif (typeof DDPCommon === 'undefined') {\\n\\tDDPCommon = {};\\n\\n\\tDDPCommon.MethodInvocation = function (options) {\\n\\t\\tvar self = this;\\n\\n\\t\\t// true if we're running not the actual method, but a stub (that is,\\n\\t\\t// if we're on a client (which may be a browser, or in the future a\\n\\t\\t// server connecting to another server) and presently running a\\n\\t\\t// simulation of a server-side method for latency compensation\\n\\t\\t// purposes). not currently true except in a client such as a browser,\\n\\t\\t// since there's usually no point in running stubs unless you have a\\n\\t\\t// zero-latency connection to the user.\\n\\n\\t\\t/**\\n\\t\\t * @summary Access inside a method invocation.  Boolean value, true if this invocation is a stub.\\n\\t\\t * @locus Anywhere\\n\\t\\t * @name  isSimulation\\n\\t\\t * @memberOf MethodInvocation\\n\\t\\t * @instance\\n\\t\\t * @type {Boolean}\\n\\t\\t */\\n\\t\\tthis.isSimulation = options.isSimulation;\\n\\n\\t\\t// call this function to allow other method invocations (from the\\n\\t\\t// same client) to continue running without waiting for this one to\\n\\t\\t// complete.\\n\\t\\tthis._unblock = options.unblock || function () {};\\n\\t\\tthis._calledUnblock = false;\\n\\n\\t\\t// current user id\\n\\n\\t\\t/**\\n\\t\\t * @summary The id of the user that made this method call, or `null` if no user was logged in.\\n\\t\\t * @locus Anywhere\\n\\t\\t * @name  userId\\n\\t\\t * @memberOf MethodInvocation\\n\\t\\t * @instance\\n\\t\\t */\\n\\t\\tthis.userId = options.userId;\\n\\n\\t\\t// sets current user id in all appropriate server contexts and\\n\\t\\t// reruns subscriptions\\n\\t\\tthis._setUserId = options.setUserId || function () {};\\n\\n\\t\\t// On the server, the connection this method call came in on.\\n\\n\\t\\t/**\\n\\t\\t * @summary Access inside a method invocation. The [connection](#meteor_onconnection) that this method was received on. `null` if the method is not associated with a connection, eg. a server initiated method call.\\n\\t\\t * @locus Server\\n\\t\\t * @name  connection\\n\\t\\t * @memberOf MethodInvocation\\n\\t\\t * @instance\\n\\t\\t */\\n\\t\\tthis.connection = options.connection;\\n\\n\\t\\t// The seed for randomStream value generation\\n\\t\\tthis.randomSeed = options.randomSeed;\\n\\n\\t\\t// This is set by RandomStream.get; and holds the random stream state\\n\\t\\tthis.randomStream = null;\\n\\t};\\n\\n\\t_.extend(DDPCommon.MethodInvocation.prototype, {\\n\\t\\t/**\\n\\t\\t * @summary Call inside a method invocation.  Allow subsequent method from this client to begin running in a new fiber.\\n\\t\\t * @locus Server\\n\\t\\t * @memberOf MethodInvocation\\n\\t\\t * @instance\\n\\t\\t */\\n\\t\\tunblock: function () {\\n\\t\\t\\tvar self = this;\\n\\t\\t\\tself._calledUnblock = true;\\n\\t\\t\\tself._unblock();\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @summary Set the logged in user.\\n\\t\\t * @locus Server\\n\\t\\t * @memberOf MethodInvocation\\n\\t\\t * @instance\\n\\t\\t * @param {String | null} userId The value that should be returned by `userId` on this connection.\\n\\t\\t */\\n\\t\\tsetUserId: function (userId) {\\n\\t\\t\\tvar self = this;\\n\\t\\t\\tif (self._calledUnblock) throw new Error(\\\"Can't call setUserId in a method after calling unblock\\\");\\n\\t\\t\\tself.userId = userId;\\n\\t\\t\\t// self._setUserId(userId);\\n\\t\\t},\\n\\t});\\n}\\n\\n\",\"// This file adds the actual \\\"Meteor.runAsUser\\\" and \\\"Meteor.isRestricted\\\" api\\n//\\n// It's done by using a DDP method invocation, setting a user id and a\\n// \\\"isRestricted\\\" flag on it.\\n//\\n// If run inside of an existing DDP invocation a nested version will be created.\\n\\nvar restrictedMode = new Meteor.EnvironmentVariable();\\n\\n/**\\n * Returns true if inside a runAsUser user scope\\n * @return {Boolean} True if in a runAsUser user scope\\n */\\nMeteor.isRestricted = function () {\\n\\treturn !!restrictedMode.get();\\n};\\n\\n/**\\n * Run code restricted\\n * @param  {Function} f Code to run in restricted mode\\n * @return {Any}   Result of code running\\n */\\nMeteor.runRestricted = function (f) {\\n\\tif (Meteor.isRestricted()) {\\n\\t\\treturn f();\\n\\t} else {\\n\\t\\treturn restrictedMode.withValue(true, f);\\n\\t}\\n};\\n\\n/**\\n * Run code unrestricted\\n * @param  {Function} f Code to run in restricted mode\\n * @return {Any}   Result of code running\\n */\\nMeteor.runUnrestricted = function (f) {\\n\\tif (Meteor.isRestricted()) {\\n\\t\\treturn restrictedMode.withValue(false, f);\\n\\t} else {\\n\\t\\tf();\\n\\t}\\n};\\n\\n/**\\n * Run as a user\\n * @param  {String} userId The id of user to run as\\n * @param  {Function} f      Function to run as user\\n * @return {Any} Returns function result\\n */\\nMeteor.runAsUser = function (userId, f) {\\n\\tvar currentInvocation = DDP._CurrentInvocation.get();\\n\\n\\t// Create a new method invocation\\n\\tvar invocation = new DDPCommon.MethodInvocation(\\n\\t\\tcurrentInvocation\\n\\t\\t\\t? currentInvocation\\n\\t\\t\\t: {\\n\\t\\t\\t\\t\\tconnection: null,\\n\\t\\t\\t  },\\n\\t);\\n\\n\\t// Now run as user on this invocation\\n\\tinvocation.setUserId(userId);\\n\\n\\treturn DDP._CurrentInvocation.withValue(invocation, function () {\\n\\t\\treturn f.apply(invocation, [userId]);\\n\\t});\\n};\\n\\n/**\\n * Run as restricted user\\n * @param  {Function} f Function to run unrestricted\\n * @return {Any}   Returns function result\\n */\\nMeteor.runAsRestrictedUser = function (userId, f) {\\n\\treturn Meteor.runRestricted(function () {\\n\\t\\treturn Meteor.runAsUser(userId, f);\\n\\t});\\n};\\n\\nvar adminMode = new Meteor.EnvironmentVariable();\\n\\n/**\\n * Check if code is running isside an invocation / method\\n */\\nMeteor.isAdmin = function () {\\n\\treturn !!adminMode.get();\\n};\\n\\n/**\\n * Make the function run outside invocation\\n */\\nMeteor.runAsAdmin = function (f) {\\n\\tif (Meteor.isAdmin()) {\\n\\t\\treturn f();\\n\\t} else {\\n\\t\\treturn adminMode.withValue(false, f);\\n\\t}\\n};\\n\\n/**\\n * Make sure code runs outside an invocation on the\\n * server\\n */\\nMeteor.runOutsideInvocation = function (f) {\\n\\tif (Meteor.isServer && DDP._CurrentInvocation.get()) {\\n\\t\\tDDP._CurrentInvocation.withValue(null, f);\\n\\t} else {\\n\\t\\tf();\\n\\t}\\n};\\n\\n\",\"// This file overwrites the default metoer Mongo.Collection modifiers: \\\"insert\\\",\\n// \\\"update\\\", \\\"remove\\\"\\n//\\n// The new methods are checking if Meteor is in \\\"restricted\\\" mode to apply\\n// allow and deny rules if needed.\\n//\\n// This will allow us to run the modifiers inside of a \\\"Meteor.runAsUser\\\" with\\n// security checks.\\n_.each(['insert', 'update', 'remove'], function (method) {\\n\\tvar _super = Mongo.Collection.prototype[method];\\n\\n\\tMongo.Collection.prototype[method] = function (/* arguments */) {\\n\\t\\tvar self = this;\\n\\t\\tvar args = _.toArray(arguments);\\n\\n\\t\\t// Check if this method is run in restricted mode and collection is\\n\\t\\t// restricted.\\n\\t\\tif (Meteor.isRestricted() && self._restricted) {\\n\\t\\t\\tvar generatedId = null;\\n\\t\\t\\tif (method === 'insert' && !_.has(args[0], '_id')) {\\n\\t\\t\\t\\tgeneratedId = self._makeNewID();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// short circuit if there is no way it will pass.\\n\\t\\t\\tif (self._validators[method].allow.length === 0) {\\n\\t\\t\\t\\tthrow new Meteor.Error(403, 'Access denied. No allow validators set on restricted ' + \\\"collection for method '\\\" + method + \\\"'.\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar validatedMethodName = '_validated' + method.charAt(0).toUpperCase() + method.slice(1);\\n\\t\\t\\targs.unshift(Meteor.userId());\\n\\n\\t\\t\\tif (method === 'insert') {\\n\\t\\t\\t\\targs.push(generatedId);\\n\\n\\t\\t\\t\\tself[validatedMethodName].apply(self, args);\\n\\t\\t\\t\\t// xxx: for now we return the id since self._validatedInsert doesn't\\n\\t\\t\\t\\t// yet return the new id\\n\\t\\t\\t\\treturn generatedId || args[0]._id;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn self[validatedMethodName].apply(self, args);\\n\\t\\t}\\n\\n\\t\\treturn _super.apply(self, args);\\n\\t};\\n});\\n\\n\",null],\"names\":[\"DDPCommon\",\"MethodInvocation\",\"options\",\"isSimulation\",\"_unblock\",\"unblock\",\"_calledUnblock\",\"userId\",\"_setUserId\",\"setUserId\",\"connection\",\"randomSeed\",\"randomStream\",\"_\",\"extend\",\"prototype\",\"self\",\"Error\",\"restrictedMode\",\"Meteor\",\"EnvironmentVariable\",\"isRestricted\",\"get\",\"runRestricted\",\"f\",\"withValue\",\"runUnrestricted\",\"runAsUser\",\"currentInvocation\",\"DDP\",\"_CurrentInvocation\",\"invocation\",\"apply\",\"runAsRestrictedUser\",\"adminMode\",\"isAdmin\",\"runAsAdmin\",\"runOutsideInvocation\",\"isServer\",\"each\",\"method\",\"_super\",\"Mongo\",\"Collection\",\"args\",\"toArray\",\"arguments\",\"_restricted\",\"generatedId\",\"has\",\"_makeNewID\",\"_validators\",\"allow\",\"length\",\"validatedMethodName\",\"charAt\",\"toUpperCase\",\"slice\",\"unshift\",\"push\",\"_id\"],\"mappings\":\"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\"}"}