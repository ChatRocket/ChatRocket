{"code":"Package[\"core-runtime\"].queue(\"accounts-base\",function(){var e,t=Package.meteor.Meteor;Package.meteor.global,Package.meteor.meteorEnv;var o=Package.tracker.Tracker;Package.tracker.Deps;var n=Package.random.Random,i=Package[\"callback-hook\"].Hook,s=Package[\"reactive-var\"].ReactiveVar;Package.url.URL,Package.url.URLSearchParams;var r=Package[\"ddp-client\"].DDP,l=Package.mongo.Mongo,a=Package.modules.meteorInstall;return Package.promise.Promise,{export:function(){return{Accounts:e}},require:a({node_modules:{meteor:{\"accounts-base\":{\"client_main.js\":function o(o,n,i){var s,r,l;let a,c;i.export({Accounts:()=>e,AccountsClient:()=>a,AccountsTest:()=>c,default:()=>n}),i.link(\"./accounts_client.js\",{AccountsClient(e){a=e},AccountsTest(e){c=e}},0),i.runSetters(e=new a((null===(s=t.settings)||void 0===s?void 0:null===(r=s.public)||void 0===r?void 0:null===(l=r.packages)||void 0===l?void 0:l.accounts)||{}),[\"Accounts\"]),t.users=e.users},\"accounts_client.js\":function i(i,l,a){let c,g;a.link(\"@babel/runtime/helpers/objectSpread2\",{default(e){c=e}},0),a.export({AccountsClient:()=>u,AccountsTest:()=>d}),a.link(\"./accounts_common.js\",{AccountsCommon(e){g=e}},0);class u extends g{constructor(e){super(e),this._loggingIn=new s(!1),this._loggingOut=new s(!1),this._loginServicesHandle=this.connection.subscribe(\"meteor.loginServiceConfiguration\"),this._pageLoadLoginCallbacks=[],this._pageLoadLoginAttemptInfo=null,this.savedHash=window.location.hash,this._initUrlMatching(),this.initStorageLocation(),this._initLocalStorage(),this._loginFuncs={},this._loginCallbacksCalled=!1}initStorageLocation(e){var o,n,i,s;this.storageLocation=(null==e?void 0:e.clientStorage)===\"session\"||(null===(o=t.settings)||void 0===o?void 0:null===(n=o.public)||void 0===n?void 0:null===(i=n.packages)||void 0===i?void 0:null===(s=i.accounts)||void 0===s?void 0:s.clientStorage)===\"session\"?window.sessionStorage:t._localStorage}config(e){super.config(e),this.initStorageLocation(e)}userId(){return this.connection.userId()}_setLoggingIn(e){this._loggingIn.set(e)}loggingIn(){return this._loggingIn.get()}loggingOut(){return this._loggingOut.get()}registerClientLoginFunction(e,t){if(this._loginFuncs[e])throw Error(\"\".concat(e,\" has been defined already\"));this._loginFuncs[e]=t}callLoginFunction(e){if(!this._loginFuncs[e])throw Error(\"\".concat(e,\" was not defined\"));for(var t=arguments.length,o=Array(t>1?t-1:0),n=1;n<t;n++)o[n-1]=arguments[n];return this._loginFuncs[e].apply(this,o)}applyLoginFunction(e,t){if(!this._loginFuncs[e])throw Error(\"\".concat(e,\" was not defined\"));return this._loginFuncs[e].apply(this,t)}logout(e){this._loggingOut.set(!0),this.connection.applyAsync(\"logout\",[],{wait:!0}).then(t=>{this._loggingOut.set(!1),this._loginCallbacksCalled=!1,this.makeClientLoggedOut(),e&&e()}).catch(t=>{this._loggingOut.set(!1),e&&e(t)})}logoutOtherClients(e){this.connection.apply(\"getNewToken\",[],{wait:!0},(e,t)=>{e||this._storeLoginToken(this.userId(),t.token,t.tokenExpires)}),this.connection.apply(\"removeOtherTokens\",[],{wait:!0},t=>e&&e(t))}callLoginMethod(e){let n;e=c({methodName:\"login\",methodArguments:[{}],_suppressLoggingIn:!1},e),[\"validateResult\",\"userCallback\"].forEach(t=>{e[t]||(e[t]=()=>null)});let i=t=>{let{error:o,loginDetails:i}=t;n||(n=!0,o?(this._loginCallbacksCalled=!1,this._onLoginFailureHook.forEach(e=>(e({error:o}),!0))):(this._onLoginHook.forEach(e=>(e(i),!0)),this._loginCallbacksCalled=!0),e.userCallback(o,i))},s=!1;e._suppressLoggingIn||this._setLoggingIn(!0),this.connection.applyAsync(e.methodName,e.methodArguments,{wait:!0,onResultReceived:(e,t)=>{!e&&t&&t.token&&(this._reconnectStopper&&this._reconnectStopper.stop(),this._reconnectStopper=r.onReconnect(e=>{if(e!=this.connection)return;s=!0;let o=this._storedLoginToken();o&&(t={token:o,tokenExpires:this._storedLoginTokenExpires()}),t.tokenExpires||(t.tokenExpires=this._tokenExpiration(new Date)),this._tokenExpiresSoon(t.tokenExpires)?this.makeClientLoggedOut():this.callLoginMethod({methodArguments:[{resume:t.token}],_suppressLoggingIn:!0,userCallback:(e,o)=>{let n=this._storedLoginToken();e&&n&&n===t.token&&this.makeClientLoggedOut(),i({error:e,loginDetails:o})}})}))}},(n,r)=>{if(!s){if(n||!r){i({error:n=n||Error(\"No result from call to \".concat(e.methodName))}),this._setLoggingIn(!1);return}try{e.validateResult(r)}catch(e){i({error:e}),this._setLoggingIn(!1);return}this.makeClientLoggedIn(r.id,r.token,r.tokenExpires),o.autorun(async e=>{let n=await o.withComputation(e,()=>t.userAsync());n&&(i({loginDetails:r}),this._setLoggingIn(!1),e.stop())})}})}makeClientLoggedOut(){this.connection._userId&&this._onLogoutHook.each(e=>(e(),!0)),this._unstoreLoginToken(),this.connection.setUserId(null),this._reconnectStopper&&this._reconnectStopper.stop()}makeClientLoggedIn(e,t,o){this._storeLoginToken(e,t,o),this.connection.setUserId(e)}loginServicesConfigured(){return this._loginServicesHandle.ready()}onPageLoadLogin(e){this._pageLoadLoginAttemptInfo?e(this._pageLoadLoginAttemptInfo):this._pageLoadLoginCallbacks.push(e)}_pageLoadLogin(e){if(this._pageLoadLoginAttemptInfo){t._debug(\"Ignoring unexpected duplicate page load login attempt info\");return}this._pageLoadLoginCallbacks.forEach(t=>t(e)),this._pageLoadLoginCallbacks=[],this._pageLoadLoginAttemptInfo=e}_startupCallback(e){this._loginCallbacksCalled&&t.setTimeout(()=>e({type:\"resume\"}),0)}loginWithToken(e,t){this.callLoginMethod({methodArguments:[{resume:e}],userCallback:t})}_enableAutoLogin(){this._autoLoginEnabled=!0,this._pollStoredLoginToken()}_isolateLoginTokenForTest(){this.LOGIN_TOKEN_KEY=this.LOGIN_TOKEN_KEY+n.id(),this.USER_ID_KEY=this.USER_ID_KEY+n.id()}_storeLoginToken(e,t,o){this.storageLocation.setItem(this.USER_ID_KEY,e),this.storageLocation.setItem(this.LOGIN_TOKEN_KEY,t),o||(o=this._tokenExpiration(new Date)),this.storageLocation.setItem(this.LOGIN_TOKEN_EXPIRES_KEY,o),this._lastLoginTokenWhenPolled=t}_unstoreLoginToken(){this.storageLocation.removeItem(this.USER_ID_KEY),this.storageLocation.removeItem(this.LOGIN_TOKEN_KEY),this.storageLocation.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY),this._lastLoginTokenWhenPolled=null}_storedLoginToken(){return this.storageLocation.getItem(this.LOGIN_TOKEN_KEY)}_storedLoginTokenExpires(){return this.storageLocation.getItem(this.LOGIN_TOKEN_EXPIRES_KEY)}_storedUserId(){return this.storageLocation.getItem(this.USER_ID_KEY)}_unstoreLoginTokenIfExpiresSoon(){let e=this._storedLoginTokenExpires();e&&this._tokenExpiresSoon(new Date(e))&&this._unstoreLoginToken()}_initLocalStorage(){let e;this.LOGIN_TOKEN_KEY=\"Meteor.loginToken\",this.LOGIN_TOKEN_EXPIRES_KEY=\"Meteor.loginTokenExpires\",this.USER_ID_KEY=\"Meteor.userId\";let o=__meteor_runtime_config__.ROOT_URL_PATH_PREFIX;if(o||this.connection!==t.connection){let e=\":\".concat(this.connection._stream.rawUrl);o&&(e+=\":\".concat(o)),this.LOGIN_TOKEN_KEY+=e,this.LOGIN_TOKEN_EXPIRES_KEY+=e,this.USER_ID_KEY+=e}if(this._autoLoginEnabled&&(this._unstoreLoginTokenIfExpiresSoon(),e=this._storedLoginToken())){let o=this._storedUserId();o&&this.connection.setUserId(o),this.loginWithToken(e,o=>{o&&(t._debug(\"Error logging in with token: \".concat(o)),this.makeClientLoggedOut()),this._pageLoadLogin({type:\"resume\",allowed:!o,error:o,methodName:\"login\",methodArguments:[{resume:e}]})})}this._lastLoginTokenWhenPolled=e,this._pollIntervalTimer&&clearInterval(this._pollIntervalTimer),this._pollIntervalTimer=setInterval(()=>{this._pollStoredLoginToken()},3e3)}_pollStoredLoginToken(){if(!this._autoLoginEnabled)return;let e=this._storedLoginToken();this._lastLoginTokenWhenPolled!=e&&(e?this.loginWithToken(e,e=>{e&&this.makeClientLoggedOut()}):this.logout()),this._lastLoginTokenWhenPolled=e}_initUrlMatching(){this._autoLoginEnabled=!0,this._accountsCallbacks={},this._attemptToMatchHash()}_attemptToMatchHash(){_(this,this.savedHash,h)}onResetPasswordLink(e){this._accountsCallbacks[\"reset-password\"]&&t._debug(\"Accounts.onResetPasswordLink was called more than once. Only one callback added will be executed.\"),this._accountsCallbacks[\"reset-password\"]=e}onEmailVerificationLink(e){this._accountsCallbacks[\"verify-email\"]&&t._debug(\"Accounts.onEmailVerificationLink was called more than once. Only one callback added will be executed.\"),this._accountsCallbacks[\"verify-email\"]=e}onEnrollmentLink(e){this._accountsCallbacks[\"enroll-account\"]&&t._debug(\"Accounts.onEnrollmentLink was called more than once. Only one callback added will be executed.\"),this._accountsCallbacks[\"enroll-account\"]=e}}if(t.loggingIn=()=>e.loggingIn(),t.loggingOut=()=>e.loggingOut(),t.logout=t=>e.logout(t),t.logoutOtherClients=t=>e.logoutOtherClients(t),t.loginWithToken=(t,o)=>e.loginWithToken(t,o),Package.blaze){let{Template:e}=Package.blaze.Blaze;e.registerHelper(\"currentUser\",()=>t.user()),e.registerHelper(\"loggingIn\",()=>t.loggingIn()),e.registerHelper(\"loggingOut\",()=>t.loggingOut()),e.registerHelper(\"loggingInOrOut\",()=>t.loggingIn()||t.loggingOut())}let h=function(e,o){this._autoLoginEnabled=!1,t.startup(()=>{this._accountsCallbacks[o]&&this._accountsCallbacks[o](e,()=>this._enableAutoLogin())})},_=(e,t,o)=>{[\"reset-password\",\"verify-email\",\"enroll-account\"].forEach(n=>{let i;let s=new RegExp(\"^\\\\#\\\\/\".concat(n,\"\\\\/(.*)$\")),r=t.match(s);r&&(i=r[1],\"reset-password\"===n?e._resetPasswordToken=i:\"verify-email\"===n?e._verifyEmailToken=i:\"enroll-account\"===n&&(e._enrollAccountToken=i),window.location.hash=\"\",o.call(e,i,n))})},d={attemptToMatchHash:(t,o)=>_(e,t,o)}},\"accounts_common.js\":function t(t,o,n){let s,a;n.link(\"@babel/runtime/helpers/objectSpread2\",{default(e){s=e}},0),n.export({AccountsCommon:()=>g,EXPIRE_TOKENS_INTERVAL_MS:()=>p}),n.link(\"meteor/meteor\",{Meteor(e){a=e}},0);let c=[\"sendVerificationEmail\",\"forbidClientAccountCreation\",\"restrictCreationByEmailDomain\",\"loginExpiration\",\"loginExpirationInDays\",\"oauthSecretKey\",\"passwordResetTokenExpirationInDays\",\"passwordResetTokenExpiration\",\"passwordEnrollTokenExpirationInDays\",\"passwordEnrollTokenExpiration\",\"ambiguousErrorMessages\",\"bcryptRounds\",\"defaultFieldSelector\",\"collection\",\"loginTokenExpirationHours\",\"tokenSequenceLength\",\"clientStorage\",\"ddpUrl\",\"connection\"];class g{constructor(e){for(let t of Object.keys(e))c.includes(t)||console.error(\"Accounts.config: Invalid key: \".concat(t));this._options=e||{},this.connection=void 0,this._initConnection(e||{}),this.users=this._initializeCollection(e||{}),this._onLoginHook=new i({bindEnvironment:!1,debugPrintExceptions:\"onLogin callback\"}),this._onLoginFailureHook=new i({bindEnvironment:!1,debugPrintExceptions:\"onLoginFailure callback\"}),this._onLogoutHook=new i({bindEnvironment:!1,debugPrintExceptions:\"onLogout callback\"}),this.DEFAULT_LOGIN_EXPIRATION_DAYS=u,this.LOGIN_UNEXPIRING_TOKEN_DAYS=k;let t=\"Accounts.LoginCancelledError\";this.LoginCancelledError=a.makeErrorType(t,function(e){this.message=e}),this.LoginCancelledError.prototype.name=t,this.LoginCancelledError.numericError=145546287}_initializeCollection(e){let t;if(e.collection&&\"string\"!=typeof e.collection&&!(e.collection instanceof l.Collection))throw new a.Error('Collection parameter can be only of type string or \"Mongo.Collection\"');let o=\"users\";return\"string\"==typeof e.collection&&(o=e.collection),t=e.collection instanceof l.Collection?e.collection:new l.Collection(o,{_preventAutopublish:!0,connection:this.connection})}userId(){throw Error(\"userId method not implemented\")}_addDefaultFieldSelector(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!this._options.defaultFieldSelector)return e;if(!e.fields)return s(s({},e),{},{fields:this._options.defaultFieldSelector});let t=Object.keys(e.fields);if(!t.length||e.fields[t[0]])return e;let o=Object.keys(this._options.defaultFieldSelector);return this._options.defaultFieldSelector[o[0]]?e:s(s({},e),{},{fields:s(s({},e.fields),this._options.defaultFieldSelector)})}user(e){a.isServer&&console.warn(\"`Meteor.user()` is deprecated on the server side.\\n    To fetch the current user record on the server,\\n    use `Meteor.userAsync()` instead.\");let t=this,o=t.userId();return o?function(){return a.isClient?t.users.findOne(...arguments):t.users.findOneAsync(...arguments)}(o,this._addDefaultFieldSelector(e)):null}async userAsync(e){let t=this.userId();return t?this.users.findOneAsync(t,this._addDefaultFieldSelector(e)):null}config(e){if(a.isServer?__meteor_runtime_config__.accountsConfigCalled=!0:__meteor_runtime_config__.accountsConfigCalled||a._debug(\"Accounts.config was called on the client but not on the server; some configuration options may not take effect.\"),Object.prototype.hasOwnProperty.call(e,\"oauthSecretKey\")){if(a.isClient)throw Error(\"The oauthSecretKey option may only be specified on the server\");if(!Package[\"oauth-encryption\"])throw Error(\"The oauth-encryption package must be loaded to set oauthSecretKey\");Package[\"oauth-encryption\"].OAuthEncryption.loadKey(e.oauthSecretKey),e=s({},e),delete e.oauthSecretKey}for(let t of Object.keys(e))c.includes(t)||console.error(\"Accounts.config: Invalid key: \".concat(t));for(let t of c)if(t in e){if(t in this._options&&\"collection\"!==t&&a.isTest&&\"clientStorage\"!==t)throw new a.Error(\"Can't set `\".concat(t,\"` more than once\"));this._options[t]=e[t]}e.collection&&e.collection!==this.users._name&&e.collection!==this.users&&(this.users=this._initializeCollection(e))}onLogin(e){let t=this._onLoginHook.register(e);return this._startupCallback(t.callback),t}onLoginFailure(e){return this._onLoginFailureHook.register(e)}onLogout(e){return this._onLogoutHook.register(e)}_initConnection(e){a.isClient&&(e.connection?this.connection=e.connection:e.ddpUrl?this.connection=r.connect(e.ddpUrl):\"undefined\"!=typeof __meteor_runtime_config__&&__meteor_runtime_config__.ACCOUNTS_CONNECTION_URL?this.connection=r.connect(__meteor_runtime_config__.ACCOUNTS_CONNECTION_URL):this.connection=a.connection)}_getTokenLifetimeMs(){let e=null===this._options.loginExpirationInDays?k:this._options.loginExpirationInDays;return this._options.loginExpiration||864e5*(e||u)}_getPasswordResetTokenLifetimeMs(){return this._options.passwordResetTokenExpiration||864e5*(this._options.passwordResetTokenExpirationInDays||h)}_getPasswordEnrollTokenLifetimeMs(){return this._options.passwordEnrollTokenExpiration||864e5*(this._options.passwordEnrollTokenExpirationInDays||_)}_tokenExpiration(e){return new Date(new Date(e).getTime()+this._getTokenLifetimeMs())}_tokenExpiresSoon(e){let t=.1*this._getTokenLifetimeMs(),o=1e3*d;return t>o&&(t=o),new Date>new Date(e)-t}_startupCallback(e){}}a.userId=()=>e.userId(),a.user=t=>e.user(t),a.userAsync=t=>e.userAsync(t);let u=90,h=3,_=30,d=3600,p=6e5,k=36500}}}}},{extensions:[\".js\",\".json\"]}),eagerModulePaths:[\"/node_modules/meteor/accounts-base/client_main.js\"],mainModulePath:\"/node_modules/meteor/accounts-base/client_main.js\"}});","map":"{\"version\":3,\"sources\":[\"packages/accounts-base/client_main.js\",\"packages/accounts-base/accounts_client.js\",\"packages/accounts-base/accounts_common.js\",\"<anon>\"],\"sourcesContent\":[\"import {\\n  AccountsClient,\\n  AccountsTest,\\n} from \\\"./accounts_client.js\\\";\\n\\n/**\\n * @namespace Accounts\\n * @summary The namespace for all client-side accounts-related methods.\\n */\\nAccounts = new AccountsClient(Meteor.settings?.public?.packages?.accounts || {});\\n\\n/**\\n * @summary A [Mongo.Collection](#collections) containing user documents.\\n * @locus Anywhere\\n * @type {Mongo.Collection}\\n * @importFromPackage meteor\\n */\\nMeteor.users = Accounts.users;\\n\\nexport {\\n  Accounts,\\n  AccountsClient,\\n  AccountsTest,\\n  // For backwards compatibility. Note that exporting an object as the\\n  // default export is *not* the same as exporting its properties as named\\n  // exports, as was previously assumed.\\n  exports as default,\\n};\\n\",\"import { AccountsCommon } from './accounts_common.js';\\n\\n/**\\n * @summary Constructor for the `Accounts` object on the client.\\n * @locus Client\\n * @class AccountsClient\\n * @extends AccountsCommon\\n * @instancename accountsClient\\n * @param {Object} options an object with fields:\\n * @param {Object} options.connection Optional DDP connection to reuse.\\n * @param {String} options.ddpUrl Optional URL for creating a new DDP connection.\\n * @param {'session' | 'local'} options.clientStorage Optional Define what kind of storage you want for credentials on the client. Default is 'local' to use `localStorage`. Set to 'session' to use session storage.\\n */\\nexport class AccountsClient extends AccountsCommon {\\n\\tconstructor(options) {\\n\\t\\tsuper(options);\\n\\n\\t\\tthis._loggingIn = new ReactiveVar(false);\\n\\t\\tthis._loggingOut = new ReactiveVar(false);\\n\\n\\t\\tthis._loginServicesHandle = this.connection.subscribe('meteor.loginServiceConfiguration');\\n\\n\\t\\tthis._pageLoadLoginCallbacks = [];\\n\\t\\tthis._pageLoadLoginAttemptInfo = null;\\n\\n\\t\\tthis.savedHash = window.location.hash;\\n\\t\\tthis._initUrlMatching();\\n\\n\\t\\tthis.initStorageLocation();\\n\\n\\t\\t// Defined in localstorage_token.js.\\n\\t\\tthis._initLocalStorage();\\n\\n\\t\\t// This is for .registerClientLoginFunction & .callLoginFunction.\\n\\t\\tthis._loginFuncs = {};\\n\\n\\t\\t// This tracks whether callbacks registered with\\n\\t\\t// Accounts.onLogin have been called\\n\\t\\tthis._loginCallbacksCalled = false;\\n\\t}\\n\\n\\tinitStorageLocation(options) {\\n\\t\\t// Determine whether to use local or session storage to storage credentials and anything else.\\n\\t\\tthis.storageLocation =\\n\\t\\t\\toptions?.clientStorage === 'session' || Meteor.settings?.public?.packages?.accounts?.clientStorage === 'session'\\n\\t\\t\\t\\t? window.sessionStorage\\n\\t\\t\\t\\t: Meteor._localStorage;\\n\\t}\\n\\n\\tconfig(options) {\\n\\t\\tsuper.config(options);\\n\\n\\t\\tthis.initStorageLocation(options);\\n\\t}\\n\\n\\t///\\n\\t/// CURRENT USER\\n\\t///\\n\\n\\t// @override\\n\\tuserId() {\\n\\t\\treturn this.connection.userId();\\n\\t}\\n\\n\\t// This is mostly just called within this file, but Meteor.loginWithPassword\\n\\t// also uses it to make loggingIn() be true during the beginPasswordExchange\\n\\t// method call too.\\n\\t_setLoggingIn(x) {\\n\\t\\tthis._loggingIn.set(x);\\n\\t}\\n\\n\\t/**\\n\\t * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\\n\\t * @locus Client\\n\\t */\\n\\tloggingIn() {\\n\\t\\treturn this._loggingIn.get();\\n\\t}\\n\\n\\t/**\\n\\t * @summary True if a logout method (such as `Meteor.logout`) is currently in progress. A reactive data source.\\n\\t * @locus Client\\n\\t */\\n\\tloggingOut() {\\n\\t\\treturn this._loggingOut.get();\\n\\t}\\n\\n\\t/**\\n   * @summary Register a new login function on the client. Intended for OAuth package authors. You can call the login function by using\\n   `Accounts.callLoginFunction` or `Accounts.callLoginFunction`.\\n   * @locus Client\\n   * @param {String} funcName The name of your login function. Used by `Accounts.callLoginFunction` and `Accounts.applyLoginFunction`.\\n   Should be the OAuth provider name accordingly.\\n   * @param {Function} func The actual function you want to call. Just write it in the manner of `loginWithFoo`.\\n   */\\n\\tregisterClientLoginFunction(funcName, func) {\\n\\t\\tif (this._loginFuncs[funcName]) {\\n\\t\\t\\tthrow new Error(`${funcName} has been defined already`);\\n\\t\\t}\\n\\t\\tthis._loginFuncs[funcName] = func;\\n\\t}\\n\\n\\t/**\\n   * @summary Call a login function defined using `Accounts.registerClientLoginFunction`. Excluding the first argument, all remaining\\n   arguments are passed to the login function accordingly. Use `applyLoginFunction` if you want to pass in an arguments array that contains\\n   all arguments for the login function.\\n   * @locus Client\\n   * @param {String} funcName The name of the login function you wanted to call.\\n   */\\n\\tcallLoginFunction(funcName, ...funcArgs) {\\n\\t\\tif (!this._loginFuncs[funcName]) {\\n\\t\\t\\tthrow new Error(`${funcName} was not defined`);\\n\\t\\t}\\n\\t\\treturn this._loginFuncs[funcName].apply(this, funcArgs);\\n\\t}\\n\\n\\t/**\\n   * @summary Same as ``callLoginFunction` but accept an `arguments` which contains all arguments for the login\\n   function.\\n   * @locus Client\\n   * @param {String} funcName The name of the login function you wanted to call.\\n   * @param {Array} funcArgs The `arguments` for the login function.\\n   */\\n\\tapplyLoginFunction(funcName, funcArgs) {\\n\\t\\tif (!this._loginFuncs[funcName]) {\\n\\t\\t\\tthrow new Error(`${funcName} was not defined`);\\n\\t\\t}\\n\\t\\treturn this._loginFuncs[funcName].apply(this, funcArgs);\\n\\t}\\n\\n\\t/**\\n\\t * @summary Log the user out.\\n\\t * @locus Client\\n\\t * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n\\t */\\n\\tlogout(callback) {\\n\\t\\tthis._loggingOut.set(true);\\n\\n\\t\\tthis.connection\\n\\t\\t\\t.applyAsync('logout', [], {\\n\\t\\t\\t\\t// TODO[FIBERS]: Look this { wait: true } later.\\n\\t\\t\\t\\twait: true,\\n\\t\\t\\t})\\n\\t\\t\\t.then((result) => {\\n\\t\\t\\t\\tthis._loggingOut.set(false);\\n\\t\\t\\t\\tthis._loginCallbacksCalled = false;\\n\\t\\t\\t\\tthis.makeClientLoggedOut();\\n\\t\\t\\t\\tcallback && callback();\\n\\t\\t\\t})\\n\\t\\t\\t.catch((e) => {\\n\\t\\t\\t\\tthis._loggingOut.set(false);\\n\\t\\t\\t\\tcallback && callback(e);\\n\\t\\t\\t});\\n\\t}\\n\\n\\t/**\\n\\t * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\\n\\t * @locus Client\\n\\t * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n\\t */\\n\\tlogoutOtherClients(callback) {\\n\\t\\t// We need to make two method calls: one to replace our current token,\\n\\t\\t// and another to remove all tokens except the current one. We want to\\n\\t\\t// call these two methods one after the other, without any other\\n\\t\\t// methods running between them. For example, we don't want `logout`\\n\\t\\t// to be called in between our two method calls (otherwise the second\\n\\t\\t// method call would return an error). Another example: we don't want\\n\\t\\t// logout to be called before the callback for `getNewToken`;\\n\\t\\t// otherwise we would momentarily log the user out and then write a\\n\\t\\t// new token to localStorage.\\n\\t\\t//\\n\\t\\t// To accomplish this, we make both calls as wait methods, and queue\\n\\t\\t// them one after the other, without spinning off the event loop in\\n\\t\\t// between. Even though we queue `removeOtherTokens` before\\n\\t\\t// `getNewToken`, we won't actually send the `removeOtherTokens` call\\n\\t\\t// until the `getNewToken` callback has finished running, because they\\n\\t\\t// are both wait methods.\\n\\t\\tthis.connection.apply('getNewToken', [], { wait: true }, (err, result) => {\\n\\t\\t\\tif (!err) {\\n\\t\\t\\t\\tthis._storeLoginToken(this.userId(), result.token, result.tokenExpires);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tthis.connection.apply('removeOtherTokens', [], { wait: true }, (err) => callback && callback(err));\\n\\t}\\n\\n\\t///\\n\\t/// LOGIN METHODS\\n\\t///\\n\\n\\t// Call a login method on the server.\\n\\t//\\n\\t// A login method is a method which on success calls `this.setUserId(id)` and\\n\\t// `Accounts._setLoginToken` on the server and returns an object with fields\\n\\t// 'id' (containing the user id), 'token' (containing a resume token), and\\n\\t// optionally `tokenExpires`.\\n\\t//\\n\\t// This function takes care of:\\n\\t//   - Updating the Meteor.loggingIn() reactive data source\\n\\t//   - Calling the method in 'wait' mode\\n\\t//   - On success, saving the resume token to localStorage\\n\\t//   - On success, calling Accounts.connection.setUserId()\\n\\t//   - Setting up an onReconnect handler which logs in with\\n\\t//     the resume token\\n\\t//\\n\\t// Options:\\n\\t// - methodName: The method to call (default 'login')\\n\\t// - methodArguments: The arguments for the method\\n\\t// - validateResult: If provided, will be called with the result of the\\n\\t//                 method. If it throws, the client will not be logged in (and\\n\\t//                 its error will be passed to the callback).\\n\\t// - userCallback: Will be called with no arguments once the user is fully\\n\\t//                 logged in, or with the error on error.\\n\\t//\\n\\tcallLoginMethod(options) {\\n\\t\\toptions = {\\n\\t\\t\\tmethodName: 'login',\\n\\t\\t\\tmethodArguments: [{}],\\n\\t\\t\\t_suppressLoggingIn: false,\\n\\t\\t\\t...options,\\n\\t\\t};\\n\\n\\t\\t// Set defaults for callback arguments to no-op functions; make sure we\\n\\t\\t// override falsey values too.\\n\\t\\t['validateResult', 'userCallback'].forEach((f) => {\\n\\t\\t\\tif (!options[f]) options[f] = () => null;\\n\\t\\t});\\n\\n\\t\\tlet called;\\n\\t\\t// Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\\n\\t\\tconst loginCallbacks = ({ error, loginDetails }) => {\\n\\t\\t\\tif (!called) {\\n\\t\\t\\t\\tcalled = true;\\n\\t\\t\\t\\tif (!error) {\\n\\t\\t\\t\\t\\tthis._onLoginHook.forEach((callback) => {\\n\\t\\t\\t\\t\\t\\tcallback(loginDetails);\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\tthis._loginCallbacksCalled = true;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tthis._loginCallbacksCalled = false;\\n\\t\\t\\t\\t\\tthis._onLoginFailureHook.forEach((callback) => {\\n\\t\\t\\t\\t\\t\\tcallback({ error });\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\toptions.userCallback(error, loginDetails);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tlet reconnected = false;\\n\\n\\t\\t// We want to set up onReconnect as soon as we get a result token back from\\n\\t\\t// the server, without having to wait for subscriptions to rerun. This is\\n\\t\\t// because if we disconnect and reconnect between getting the result and\\n\\t\\t// getting the results of subscription rerun, we WILL NOT re-send this\\n\\t\\t// method (because we never re-send methods whose results we've received)\\n\\t\\t// but we WILL call loggedInAndDataReadyCallback at \\\"reconnect quiesce\\\"\\n\\t\\t// time. This will lead to makeClientLoggedIn(result.id) even though we\\n\\t\\t// haven't actually sent a login method!\\n\\t\\t//\\n\\t\\t// But by making sure that we send this \\\"resume\\\" login in that case (and\\n\\t\\t// calling makeClientLoggedOut if it fails), we'll end up with an accurate\\n\\t\\t// client-side userId. (It's important that livedata_connection guarantees\\n\\t\\t// that the \\\"reconnect quiesce\\\"-time call to loggedInAndDataReadyCallback\\n\\t\\t// will occur before the callback from the resume login call.)\\n\\t\\tconst onResultReceived = (err, result) => {\\n\\t\\t\\tif (err || !result || !result.token) {\\n\\t\\t\\t\\t// Leave onReconnect alone if there was an error, so that if the user was\\n\\t\\t\\t\\t// already logged in they will still get logged in on reconnect.\\n\\t\\t\\t\\t// See issue #4970.\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// First clear out any previously set Acccounts login onReconnect\\n\\t\\t\\t\\t// callback (to make sure we don't keep piling up duplicate callbacks,\\n\\t\\t\\t\\t// which would then all be triggered when reconnecting).\\n\\t\\t\\t\\tif (this._reconnectStopper) {\\n\\t\\t\\t\\t\\tthis._reconnectStopper.stop();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis._reconnectStopper = DDP.onReconnect((conn) => {\\n\\t\\t\\t\\t\\tif (conn != this.connection) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treconnected = true;\\n\\t\\t\\t\\t\\t// If our token was updated in storage, use the latest one.\\n\\t\\t\\t\\t\\tconst storedToken = this._storedLoginToken();\\n\\t\\t\\t\\t\\tif (storedToken) {\\n\\t\\t\\t\\t\\t\\tresult = {\\n\\t\\t\\t\\t\\t\\t\\ttoken: storedToken,\\n\\t\\t\\t\\t\\t\\t\\ttokenExpires: this._storedLoginTokenExpires(),\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!result.tokenExpires) result.tokenExpires = this._tokenExpiration(new Date());\\n\\t\\t\\t\\t\\tif (this._tokenExpiresSoon(result.tokenExpires)) {\\n\\t\\t\\t\\t\\t\\tthis.makeClientLoggedOut();\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tthis.callLoginMethod({\\n\\t\\t\\t\\t\\t\\t\\tmethodArguments: [{ resume: result.token }],\\n\\t\\t\\t\\t\\t\\t\\t// Reconnect quiescence ensures that the user doesn't see an\\n\\t\\t\\t\\t\\t\\t\\t// intermediate state before the login method finishes. So we don't\\n\\t\\t\\t\\t\\t\\t\\t// need to show a logging-in animation.\\n\\t\\t\\t\\t\\t\\t\\t_suppressLoggingIn: true,\\n\\t\\t\\t\\t\\t\\t\\tuserCallback: (error, loginDetails) => {\\n\\t\\t\\t\\t\\t\\t\\t\\tconst storedTokenNow = this._storedLoginToken();\\n\\t\\t\\t\\t\\t\\t\\t\\tif (error) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// If we had a login error AND the current stored token is the\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// one that we tried to log in with, then declare ourselves\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// logged out. If there's a token in storage but it's not the\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// token that we tried to log in with, we don't know anything\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// about whether that token is valid or not, so do nothing. The\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// periodic localStorage poll will decide if we are logged in or\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// out with this token, if it hasn't already. Of course, even\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// with this check, another tab could insert a new valid token\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// immediately before we clear localStorage here, which would\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// lead to both tabs being logged out, but by checking the token\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// in storage right now we hope to make that unlikely to happen.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// If there is no token in storage right now, we don't have to\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// do anything; whatever code removed the token from storage was\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// responsible for calling `makeClientLoggedOut()`, or the\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// periodic localStorage poll will call `makeClientLoggedOut`\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// eventually if another tab wiped the token from storage.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (storedTokenNow && storedTokenNow === result.token) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.makeClientLoggedOut();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t// Possibly a weird callback to call, but better than nothing if\\n\\t\\t\\t\\t\\t\\t\\t\\t// there is a reconnect between \\\"login result received\\\" and \\\"data\\n\\t\\t\\t\\t\\t\\t\\t\\t// ready\\\".\\n\\t\\t\\t\\t\\t\\t\\t\\tloginCallbacks({ error, loginDetails });\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t// This callback is called once the local cache of the current-user\\n\\t\\t// subscription (and all subscriptions, in fact) are guaranteed to be up to\\n\\t\\t// date.\\n\\t\\tconst loggedInAndDataReadyCallback = (error, result) => {\\n\\t\\t\\t// If the login method returns its result but the connection is lost\\n\\t\\t\\t// before the data is in the local cache, it'll set an onReconnect (see\\n\\t\\t\\t// above). The onReconnect will try to log in using the token, and *it*\\n\\t\\t\\t// will call userCallback via its own version of this\\n\\t\\t\\t// loggedInAndDataReadyCallback. So we don't have to do anything here.\\n\\t\\t\\tif (reconnected) return;\\n\\n\\t\\t\\t// Note that we need to call this even if _suppressLoggingIn is true,\\n\\t\\t\\t// because it could be matching a _setLoggingIn(true) from a\\n\\t\\t\\t// half-completed pre-reconnect login method.\\n\\t\\t\\tif (error || !result) {\\n\\t\\t\\t\\terror = error || new Error(`No result from call to ${options.methodName}`);\\n\\t\\t\\t\\tloginCallbacks({ error });\\n\\t\\t\\t\\tthis._setLoggingIn(false);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\ttry {\\n\\t\\t\\t\\toptions.validateResult(result);\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\tloginCallbacks({ error: e });\\n\\t\\t\\t\\tthis._setLoggingIn(false);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Make the client logged in. (The user data should already be loaded!)\\n\\t\\t\\tthis.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\\n\\n\\t\\t\\t// use Tracker to make we sure have a user before calling the callbacks\\n\\t\\t\\tTracker.autorun(async (computation) => {\\n\\t\\t\\t\\tconst user = await Tracker.withComputation(computation, () => Meteor.userAsync());\\n\\n\\t\\t\\t\\tif (user) {\\n\\t\\t\\t\\t\\tloginCallbacks({ loginDetails: result });\\n\\t\\t\\t\\t\\tthis._setLoggingIn(false);\\n\\t\\t\\t\\t\\tcomputation.stop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t};\\n\\n\\t\\tif (!options._suppressLoggingIn) {\\n\\t\\t\\tthis._setLoggingIn(true);\\n\\t\\t}\\n\\t\\tthis.connection.applyAsync(options.methodName, options.methodArguments, { wait: true, onResultReceived }, loggedInAndDataReadyCallback);\\n\\t}\\n\\n\\tmakeClientLoggedOut() {\\n\\t\\t// Ensure client was successfully logged in before running logout hooks.\\n\\t\\tif (this.connection._userId) {\\n\\t\\t\\tthis._onLogoutHook.each((callback) => {\\n\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\tthis._unstoreLoginToken();\\n\\t\\tthis.connection.setUserId(null);\\n\\t\\tthis._reconnectStopper && this._reconnectStopper.stop();\\n\\t}\\n\\n\\tmakeClientLoggedIn(userId, token, tokenExpires) {\\n\\t\\tthis._storeLoginToken(userId, token, tokenExpires);\\n\\t\\tthis.connection.setUserId(userId);\\n\\t}\\n\\n\\t///\\n\\t/// LOGIN SERVICES\\n\\t///\\n\\n\\t// A reactive function returning whether the loginServiceConfiguration\\n\\t// subscription is ready. Used by accounts-ui to hide the login button\\n\\t// until we have all the configuration loaded\\n\\t//\\n\\tloginServicesConfigured() {\\n\\t\\treturn this._loginServicesHandle.ready();\\n\\t}\\n\\n\\t// Some login services such as the redirect login flow or the resume\\n\\t// login handler can log the user in at page load time.  The\\n\\t// Meteor.loginWithX functions have a callback argument, but the\\n\\t// callback function instance won't be in memory any longer if the\\n\\t// page was reloaded.  The `onPageLoadLogin` function allows a\\n\\t// callback to be registered for the case where the login was\\n\\t// initiated in a previous VM, and we now have the result of the login\\n\\t// attempt in a new VM.\\n\\n\\t// Register a callback to be called if we have information about a\\n\\t// login attempt at page load time.  Call the callback immediately if\\n\\t// we already have the page load login attempt info, otherwise stash\\n\\t// the callback to be called if and when we do get the attempt info.\\n\\t//\\n\\tonPageLoadLogin(f) {\\n\\t\\tif (this._pageLoadLoginAttemptInfo) {\\n\\t\\t\\tf(this._pageLoadLoginAttemptInfo);\\n\\t\\t} else {\\n\\t\\t\\tthis._pageLoadLoginCallbacks.push(f);\\n\\t\\t}\\n\\t}\\n\\n\\t// Receive the information about the login attempt at page load time.\\n\\t// Call registered callbacks, and also record the info in case\\n\\t// someone's callback hasn't been registered yet.\\n\\t//\\n\\t_pageLoadLogin(attemptInfo) {\\n\\t\\tif (this._pageLoadLoginAttemptInfo) {\\n\\t\\t\\tMeteor._debug('Ignoring unexpected duplicate page load login attempt info');\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._pageLoadLoginCallbacks.forEach((callback) => callback(attemptInfo));\\n\\t\\tthis._pageLoadLoginCallbacks = [];\\n\\t\\tthis._pageLoadLoginAttemptInfo = attemptInfo;\\n\\t}\\n\\n\\t// _startupCallback executes on onLogin callbacks\\n\\t// at registration time if already logged in\\n\\t// this can happen when new AccountsClient is created\\n\\t// before callbacks are registered see #10157\\n\\t_startupCallback(callback) {\\n\\t\\t// Are we already logged in?\\n\\t\\tif (this._loginCallbacksCalled) {\\n\\t\\t\\t// If already logged in before handler is registered, it's safe to\\n\\t\\t\\t// assume type is a 'resume', so we execute the callback at the end\\n\\t\\t\\t// of the queue so that Meteor.startup can complete before any\\n\\t\\t\\t// embedded onLogin callbacks would execute.\\n\\t\\t\\tMeteor.setTimeout(() => callback({ type: 'resume' }), 0);\\n\\t\\t}\\n\\t}\\n\\n\\t///\\n\\t/// LOGIN TOKENS\\n\\t///\\n\\n\\t// These methods deal with storing a login token and user id in the\\n\\t// browser's localStorage facility. It polls local storage every few\\n\\t// seconds to synchronize login state between multiple tabs in the same\\n\\t// browser.\\n\\n\\tloginWithToken(token, callback) {\\n\\t\\tthis.callLoginMethod({\\n\\t\\t\\tmethodArguments: [\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tresume: token,\\n\\t\\t\\t\\t},\\n\\t\\t\\t],\\n\\t\\t\\tuserCallback: callback,\\n\\t\\t});\\n\\t}\\n\\n\\t// Semi-internal API. Call this function to re-enable auto login after\\n\\t// if it was disabled at startup.\\n\\t_enableAutoLogin() {\\n\\t\\tthis._autoLoginEnabled = true;\\n\\t\\tthis._pollStoredLoginToken();\\n\\t}\\n\\n\\t///\\n\\t/// STORING\\n\\t///\\n\\n\\t// Call this from the top level of the test file for any test that does\\n\\t// logging in and out, to protect multiple tabs running the same tests\\n\\t// simultaneously from interfering with each others' localStorage.\\n\\t_isolateLoginTokenForTest() {\\n\\t\\tthis.LOGIN_TOKEN_KEY = this.LOGIN_TOKEN_KEY + Random.id();\\n\\t\\tthis.USER_ID_KEY = this.USER_ID_KEY + Random.id();\\n\\t}\\n\\n\\t_storeLoginToken(userId, token, tokenExpires) {\\n\\t\\tthis.storageLocation.setItem(this.USER_ID_KEY, userId);\\n\\t\\tthis.storageLocation.setItem(this.LOGIN_TOKEN_KEY, token);\\n\\t\\tif (!tokenExpires) tokenExpires = this._tokenExpiration(new Date());\\n\\t\\tthis.storageLocation.setItem(this.LOGIN_TOKEN_EXPIRES_KEY, tokenExpires);\\n\\n\\t\\t// to ensure that the localstorage poller doesn't end up trying to\\n\\t\\t// connect a second time\\n\\t\\tthis._lastLoginTokenWhenPolled = token;\\n\\t}\\n\\n\\t_unstoreLoginToken() {\\n\\t\\tthis.storageLocation.removeItem(this.USER_ID_KEY);\\n\\t\\tthis.storageLocation.removeItem(this.LOGIN_TOKEN_KEY);\\n\\t\\tthis.storageLocation.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY);\\n\\n\\t\\t// to ensure that the localstorage poller doesn't end up trying to\\n\\t\\t// connect a second time\\n\\t\\tthis._lastLoginTokenWhenPolled = null;\\n\\t}\\n\\n\\t// This is private, but it is exported for now because it is used by a\\n\\t// test in accounts-password.\\n\\t_storedLoginToken() {\\n\\t\\treturn this.storageLocation.getItem(this.LOGIN_TOKEN_KEY);\\n\\t}\\n\\n\\t_storedLoginTokenExpires() {\\n\\t\\treturn this.storageLocation.getItem(this.LOGIN_TOKEN_EXPIRES_KEY);\\n\\t}\\n\\n\\t_storedUserId() {\\n\\t\\treturn this.storageLocation.getItem(this.USER_ID_KEY);\\n\\t}\\n\\n\\t_unstoreLoginTokenIfExpiresSoon() {\\n\\t\\tconst tokenExpires = this._storedLoginTokenExpires();\\n\\t\\tif (tokenExpires && this._tokenExpiresSoon(new Date(tokenExpires))) {\\n\\t\\t\\tthis._unstoreLoginToken();\\n\\t\\t}\\n\\t}\\n\\n\\t///\\n\\t/// AUTO-LOGIN\\n\\t///\\n\\n\\t_initLocalStorage() {\\n\\t\\t// Key names to use in localStorage\\n\\t\\tthis.LOGIN_TOKEN_KEY = 'Meteor.loginToken';\\n\\t\\tthis.LOGIN_TOKEN_EXPIRES_KEY = 'Meteor.loginTokenExpires';\\n\\t\\tthis.USER_ID_KEY = 'Meteor.userId';\\n\\n\\t\\tconst rootUrlPathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\\n\\t\\tif (rootUrlPathPrefix || this.connection !== Meteor.connection) {\\n\\t\\t\\t// We want to keep using the same keys for existing apps that do not\\n\\t\\t\\t// set a custom ROOT_URL_PATH_PREFIX, so that most users will not have\\n\\t\\t\\t// to log in again after an app updates to a version of Meteor that\\n\\t\\t\\t// contains this code, but it's generally preferable to namespace the\\n\\t\\t\\t// keys so that connections from distinct apps to distinct DDP URLs\\n\\t\\t\\t// will be distinct in Meteor._localStorage.\\n\\t\\t\\tlet namespace = `:${this.connection._stream.rawUrl}`;\\n\\t\\t\\tif (rootUrlPathPrefix) {\\n\\t\\t\\t\\tnamespace += `:${rootUrlPathPrefix}`;\\n\\t\\t\\t}\\n\\t\\t\\tthis.LOGIN_TOKEN_KEY += namespace;\\n\\t\\t\\tthis.LOGIN_TOKEN_EXPIRES_KEY += namespace;\\n\\t\\t\\tthis.USER_ID_KEY += namespace;\\n\\t\\t}\\n\\n\\t\\tlet token;\\n\\t\\tif (this._autoLoginEnabled) {\\n\\t\\t\\t// Immediately try to log in via local storage, so that any DDP\\n\\t\\t\\t// messages are sent after we have established our user account\\n\\t\\t\\tthis._unstoreLoginTokenIfExpiresSoon();\\n\\t\\t\\ttoken = this._storedLoginToken();\\n\\t\\t\\tif (token) {\\n\\t\\t\\t\\t// On startup, optimistically present us as logged in while the\\n\\t\\t\\t\\t// request is in flight. This reduces page flicker on startup.\\n\\t\\t\\t\\tconst userId = this._storedUserId();\\n\\t\\t\\t\\tuserId && this.connection.setUserId(userId);\\n\\t\\t\\t\\tthis.loginWithToken(token, (err) => {\\n\\t\\t\\t\\t\\tif (err) {\\n\\t\\t\\t\\t\\t\\tMeteor._debug(`Error logging in with token: ${err}`);\\n\\t\\t\\t\\t\\t\\tthis.makeClientLoggedOut();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis._pageLoadLogin({\\n\\t\\t\\t\\t\\t\\ttype: 'resume',\\n\\t\\t\\t\\t\\t\\tallowed: !err,\\n\\t\\t\\t\\t\\t\\terror: err,\\n\\t\\t\\t\\t\\t\\tmethodName: 'login',\\n\\t\\t\\t\\t\\t\\t// XXX This is duplicate code with loginWithToken, but\\n\\t\\t\\t\\t\\t\\t// loginWithToken can also be called at other times besides\\n\\t\\t\\t\\t\\t\\t// page load.\\n\\t\\t\\t\\t\\t\\tmethodArguments: [{ resume: token }],\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Poll local storage every 3 seconds to login if someone logged in in\\n\\t\\t// another tab\\n\\t\\tthis._lastLoginTokenWhenPolled = token;\\n\\n\\t\\tif (this._pollIntervalTimer) {\\n\\t\\t\\t// Unlikely that _initLocalStorage will be called more than once for\\n\\t\\t\\t// the same AccountsClient instance, but just in case...\\n\\t\\t\\tclearInterval(this._pollIntervalTimer);\\n\\t\\t}\\n\\n\\t\\tthis._pollIntervalTimer = setInterval(() => {\\n\\t\\t\\tthis._pollStoredLoginToken();\\n\\t\\t}, 3000);\\n\\t}\\n\\n\\t_pollStoredLoginToken() {\\n\\t\\tif (!this._autoLoginEnabled) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tconst currentLoginToken = this._storedLoginToken();\\n\\n\\t\\t// != instead of !== just to make sure undefined and null are treated the same\\n\\t\\tif (this._lastLoginTokenWhenPolled != currentLoginToken) {\\n\\t\\t\\tif (currentLoginToken) {\\n\\t\\t\\t\\tthis.loginWithToken(currentLoginToken, (err) => {\\n\\t\\t\\t\\t\\tif (err) {\\n\\t\\t\\t\\t\\t\\tthis.makeClientLoggedOut();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.logout();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis._lastLoginTokenWhenPolled = currentLoginToken;\\n\\t}\\n\\n\\t///\\n\\t/// URLS\\n\\t///\\n\\n\\t_initUrlMatching() {\\n\\t\\t// By default, allow the autologin process to happen.\\n\\t\\tthis._autoLoginEnabled = true;\\n\\n\\t\\t// We only support one callback per URL.\\n\\t\\tthis._accountsCallbacks = {};\\n\\n\\t\\t// Try to match the saved value of window.location.hash.\\n\\t\\tthis._attemptToMatchHash();\\n\\t}\\n\\n\\t// Separate out this functionality for testing\\n\\t_attemptToMatchHash() {\\n\\t\\tattemptToMatchHash(this, this.savedHash, defaultSuccessHandler);\\n\\t}\\n\\n\\t/**\\n\\t * @summary Register a function to call when a reset password link is clicked\\n\\t * in an email sent by\\n\\t * [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail).\\n\\t * This function should be called in top-level code, not inside\\n\\t * `Meteor.startup()`.\\n\\t * @memberof! Accounts\\n\\t * @name onResetPasswordLink\\n\\t * @param  {Function} callback The function to call. It is given two arguments:\\n\\t *\\n\\t * 1. `token`: A password reset token that can be passed to\\n\\t * [`Accounts.resetPassword`](#accounts_resetpassword).\\n\\t * 2. `done`: A function to call when the password reset UI flow is complete. The normal\\n\\t * login process is suspended until this function is called, so that the\\n\\t * password for user A can be reset even if user B was logged in.\\n\\t * @locus Client\\n\\t */\\n\\tonResetPasswordLink(callback) {\\n\\t\\tif (this._accountsCallbacks['reset-password']) {\\n\\t\\t\\tMeteor._debug('Accounts.onResetPasswordLink was called more than once. ' + 'Only one callback added will be executed.');\\n\\t\\t}\\n\\n\\t\\tthis._accountsCallbacks['reset-password'] = callback;\\n\\t}\\n\\n\\t/**\\n\\t * @summary Register a function to call when an email verification link is\\n\\t * clicked in an email sent by\\n\\t * [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail).\\n\\t * This function should be called in top-level code, not inside\\n\\t * `Meteor.startup()`.\\n\\t * @memberof! Accounts\\n\\t * @name onEmailVerificationLink\\n\\t * @param  {Function} callback The function to call. It is given two arguments:\\n\\t *\\n\\t * 1. `token`: An email verification token that can be passed to\\n\\t * [`Accounts.verifyEmail`](#accounts_verifyemail).\\n\\t * 2. `done`: A function to call when the email verification UI flow is complete.\\n\\t * The normal login process is suspended until this function is called, so\\n\\t * that the user can be notified that they are verifying their email before\\n\\t * being logged in.\\n\\t * @locus Client\\n\\t */\\n\\tonEmailVerificationLink(callback) {\\n\\t\\tif (this._accountsCallbacks['verify-email']) {\\n\\t\\t\\tMeteor._debug('Accounts.onEmailVerificationLink was called more than once. ' + 'Only one callback added will be executed.');\\n\\t\\t}\\n\\n\\t\\tthis._accountsCallbacks['verify-email'] = callback;\\n\\t}\\n\\n\\t/**\\n\\t * @summary Register a function to call when an account enrollment link is\\n\\t * clicked in an email sent by\\n\\t * [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).\\n\\t * This function should be called in top-level code, not inside\\n\\t * `Meteor.startup()`.\\n\\t * @memberof! Accounts\\n\\t * @name onEnrollmentLink\\n\\t * @param  {Function} callback The function to call. It is given two arguments:\\n\\t *\\n\\t * 1. `token`: A password reset token that can be passed to\\n\\t * [`Accounts.resetPassword`](#accounts_resetpassword) to give the newly\\n\\t * enrolled account a password.\\n\\t * 2. `done`: A function to call when the enrollment UI flow is complete.\\n\\t * The normal login process is suspended until this function is called, so that\\n\\t * user A can be enrolled even if user B was logged in.\\n\\t * @locus Client\\n\\t */\\n\\tonEnrollmentLink(callback) {\\n\\t\\tif (this._accountsCallbacks['enroll-account']) {\\n\\t\\t\\tMeteor._debug('Accounts.onEnrollmentLink was called more than once. ' + 'Only one callback added will be executed.');\\n\\t\\t}\\n\\n\\t\\tthis._accountsCallbacks['enroll-account'] = callback;\\n\\t}\\n}\\n\\n/**\\n * @summary True if a login method (such as `Meteor.loginWithPassword`,\\n * `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in\\n * progress. A reactive data source.\\n * @locus Client\\n * @importFromPackage meteor\\n */\\nMeteor.loggingIn = () => Accounts.loggingIn();\\n\\n/**\\n * @summary True if a logout method (such as `Meteor.logout`) is currently in\\n * progress. A reactive data source.\\n * @locus Client\\n * @importFromPackage meteor\\n */\\nMeteor.loggingOut = () => Accounts.loggingOut();\\n\\n/**\\n * @summary Log the user out.\\n * @locus Client\\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n * @importFromPackage meteor\\n */\\nMeteor.logout = (callback) => Accounts.logout(callback);\\n\\n/**\\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\\n * @locus Client\\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\\n * @importFromPackage meteor\\n */\\nMeteor.logoutOtherClients = (callback) => Accounts.logoutOtherClients(callback);\\n\\n/**\\n * @summary Login with a Meteor access token.\\n * @locus Client\\n * @param {Object} [token] Local storage token for use with login across\\n * multiple tabs in the same browser.\\n * @param {Function} [callback] Optional callback. Called with no arguments on\\n * success.\\n * @importFromPackage meteor\\n */\\nMeteor.loginWithToken = (token, callback) => Accounts.loginWithToken(token, callback);\\n\\n///\\n/// HANDLEBARS HELPERS\\n///\\n\\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\\n// global helpers.\\nif (Package.blaze) {\\n\\tconst { Template } = Package.blaze.Blaze;\\n\\n\\t/**\\n\\t * @global\\n\\t * @name  currentUser\\n\\t * @isHelper true\\n\\t * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\\n\\t */\\n\\tTemplate.registerHelper('currentUser', () => Meteor.user());\\n\\n\\t// TODO: the code above needs to be changed to Meteor.userAsync() when we have\\n\\t// a way to make it reactive using async.\\n\\t// Template.registerHelper('currentUserAsync',\\n\\t//  async () => await Meteor.userAsync());\\n\\n\\t/**\\n\\t * @global\\n\\t * @name  loggingIn\\n\\t * @isHelper true\\n\\t * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\\n\\t */\\n\\tTemplate.registerHelper('loggingIn', () => Meteor.loggingIn());\\n\\n\\t/**\\n\\t * @global\\n\\t * @name  loggingOut\\n\\t * @isHelper true\\n\\t * @summary Calls [Meteor.loggingOut()](#meteor_loggingout).\\n\\t */\\n\\tTemplate.registerHelper('loggingOut', () => Meteor.loggingOut());\\n\\n\\t/**\\n\\t * @global\\n\\t * @name  loggingInOrOut\\n\\t * @isHelper true\\n\\t * @summary Calls [Meteor.loggingIn()](#meteor_loggingin) or [Meteor.loggingOut()](#meteor_loggingout).\\n\\t */\\n\\tTemplate.registerHelper('loggingInOrOut', () => Meteor.loggingIn() || Meteor.loggingOut());\\n}\\n\\nconst defaultSuccessHandler = function (token, urlPart) {\\n\\t// put login in a suspended state to wait for the interaction to finish\\n\\tthis._autoLoginEnabled = false;\\n\\n\\t// wait for other packages to register callbacks\\n\\tMeteor.startup(() => {\\n\\t\\t// if a callback has been registered for this kind of token, call it\\n\\t\\tif (this._accountsCallbacks[urlPart]) {\\n\\t\\t\\tthis._accountsCallbacks[urlPart](token, () => this._enableAutoLogin());\\n\\t\\t}\\n\\t});\\n};\\n\\n// Note that both arguments are optional and are currently only passed by\\n// accounts_url_tests.js.\\nconst attemptToMatchHash = (accounts, hash, success) => {\\n\\t// All of the special hash URLs we support for accounts interactions\\n\\t['reset-password', 'verify-email', 'enroll-account'].forEach((urlPart) => {\\n\\t\\tlet token;\\n\\n\\t\\tconst tokenRegex = new RegExp(`^\\\\\\\\#\\\\\\\\/${urlPart}\\\\\\\\/(.*)$`);\\n\\t\\tconst match = hash.match(tokenRegex);\\n\\n\\t\\tif (match) {\\n\\t\\t\\ttoken = match[1];\\n\\n\\t\\t\\t// XXX COMPAT WITH 0.9.3\\n\\t\\t\\tif (urlPart === 'reset-password') {\\n\\t\\t\\t\\taccounts._resetPasswordToken = token;\\n\\t\\t\\t} else if (urlPart === 'verify-email') {\\n\\t\\t\\t\\taccounts._verifyEmailToken = token;\\n\\t\\t\\t} else if (urlPart === 'enroll-account') {\\n\\t\\t\\t\\taccounts._enrollAccountToken = token;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// If no handlers match the hash, then maybe it's meant to be consumed\\n\\t\\t// by some entirely different code, so we only clear it the first time\\n\\t\\t// a handler successfully matches. Note that later handlers reuse the\\n\\t\\t// savedHash, so clearing window.location.hash here will not interfere\\n\\t\\t// with their needs.\\n\\t\\twindow.location.hash = '';\\n\\n\\t\\t// Do some stuff with the token we matched\\n\\t\\tsuccess.call(accounts, token, urlPart);\\n\\t});\\n};\\n\\n// Export for testing\\nexport const AccountsTest = {\\n\\tattemptToMatchHash: (hash, success) => attemptToMatchHash(Accounts, hash, success),\\n};\\n\",\"import { Meteor } from 'meteor/meteor';\\n\\n// config option keys\\nconst VALID_CONFIG_KEYS = [\\n  'sendVerificationEmail',\\n  'forbidClientAccountCreation',\\n  'restrictCreationByEmailDomain',\\n  'loginExpiration',\\n  'loginExpirationInDays',\\n  'oauthSecretKey',\\n  'passwordResetTokenExpirationInDays',\\n  'passwordResetTokenExpiration',\\n  'passwordEnrollTokenExpirationInDays',\\n  'passwordEnrollTokenExpiration',\\n  'ambiguousErrorMessages',\\n  'bcryptRounds',\\n  'defaultFieldSelector',\\n  'collection',\\n  'loginTokenExpirationHours',\\n  'tokenSequenceLength',\\n  'clientStorage',\\n  'ddpUrl',\\n  'connection',\\n];\\n\\n/**\\n * @summary Super-constructor for AccountsClient and AccountsServer.\\n * @locus Anywhere\\n * @class AccountsCommon\\n * @instancename accountsClientOrServer\\n * @param options {Object} an object with fields:\\n * - connection {Object} Optional DDP connection to reuse.\\n * - ddpUrl {String} Optional URL for creating a new DDP connection.\\n * - collection {String|Mongo.Collection} The name of the Mongo.Collection\\n *     or the Mongo.Collection object to hold the users.\\n */\\nexport class AccountsCommon {\\n  constructor(options) {\\n    // Validate config options keys\\n    for (const key of Object.keys(options)) {\\n      if (!VALID_CONFIG_KEYS.includes(key)) {\\n        console.error(`Accounts.config: Invalid key: ${key}`);\\n      }\\n    }\\n\\n    // Currently this is read directly by packages like accounts-password\\n    // and accounts-ui-unstyled.\\n    this._options = options || {};\\n\\n    // Note that setting this.connection = null causes this.users to be a\\n    // LocalCollection, which is not what we want.\\n    this.connection = undefined;\\n    this._initConnection(options || {});\\n\\n    // There is an allow call in accounts_server.js that restricts writes to\\n    // this collection.\\n    this.users = this._initializeCollection(options || {});\\n\\n    // Callback exceptions are printed with Meteor._debug and ignored.\\n    this._onLoginHook = new Hook({\\n      bindEnvironment: false,\\n      debugPrintExceptions: 'onLogin callback',\\n    });\\n\\n    this._onLoginFailureHook = new Hook({\\n      bindEnvironment: false,\\n      debugPrintExceptions: 'onLoginFailure callback',\\n    });\\n\\n    this._onLogoutHook = new Hook({\\n      bindEnvironment: false,\\n      debugPrintExceptions: 'onLogout callback',\\n    });\\n\\n    // Expose for testing.\\n    this.DEFAULT_LOGIN_EXPIRATION_DAYS = DEFAULT_LOGIN_EXPIRATION_DAYS;\\n    this.LOGIN_UNEXPIRING_TOKEN_DAYS = LOGIN_UNEXPIRING_TOKEN_DAYS;\\n\\n    // Thrown when the user cancels the login process (eg, closes an oauth\\n    // popup, declines retina scan, etc)\\n    const lceName = 'Accounts.LoginCancelledError';\\n    this.LoginCancelledError = Meteor.makeErrorType(lceName, function(\\n      description\\n    ) {\\n      this.message = description;\\n    });\\n    this.LoginCancelledError.prototype.name = lceName;\\n\\n    // This is used to transmit specific subclass errors over the wire. We\\n    // should come up with a more generic way to do this (eg, with some sort of\\n    // symbolic error code rather than a number).\\n    this.LoginCancelledError.numericError = 0x8acdc2f;\\n  }\\n\\n  _initializeCollection(options) {\\n    if (options.collection && typeof options.collection !== 'string' && !(options.collection instanceof Mongo.Collection)) {\\n      throw new Meteor.Error('Collection parameter can be only of type string or \\\"Mongo.Collection\\\"');\\n    }\\n\\n    let collectionName = 'users';\\n    if (typeof options.collection === 'string') {\\n      collectionName = options.collection;\\n    }\\n\\n    let collection;\\n    if (options.collection instanceof Mongo.Collection) {\\n      collection = options.collection;\\n    } else {\\n      collection = new Mongo.Collection(collectionName, {\\n        _preventAutopublish: true,\\n        connection: this.connection,\\n      });\\n    }\\n\\n    return collection;\\n  }\\n\\n  /**\\n   * @summary Get the current user id, or `null` if no user is logged in. A reactive data source.\\n   * @locus Anywhere\\n   */\\n  userId() {\\n    throw new Error('userId method not implemented');\\n  }\\n\\n  // merge the defaultFieldSelector with an existing options object\\n  _addDefaultFieldSelector(options = {}) {\\n    // this will be the most common case for most people, so make it quick\\n    if (!this._options.defaultFieldSelector) return options;\\n\\n    // if no field selector then just use defaultFieldSelector\\n    if (!options.fields)\\n      return {\\n        ...options,\\n        fields: this._options.defaultFieldSelector,\\n      };\\n\\n    // if empty field selector then the full user object is explicitly requested, so obey\\n    const keys = Object.keys(options.fields);\\n    if (!keys.length) return options;\\n\\n    // if the requested fields are +ve then ignore defaultFieldSelector\\n    // assume they are all either +ve or -ve because Mongo doesn't like mixed\\n    if (!!options.fields[keys[0]]) return options;\\n\\n    // The requested fields are -ve.\\n    // If the defaultFieldSelector is +ve then use requested fields, otherwise merge them\\n    const keys2 = Object.keys(this._options.defaultFieldSelector);\\n    return this._options.defaultFieldSelector[keys2[0]]\\n      ? options\\n      : {\\n          ...options,\\n          fields: {\\n            ...options.fields,\\n            ...this._options.defaultFieldSelector,\\n          },\\n        };\\n  }\\n\\n  /**\\n   * @summary Get the current user record, or `null` if no user is logged in. A reactive data source. In the server this fuction returns a promise.\\n   * @locus Anywhere\\n   * @param {Object} [options]\\n   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\\n   */\\n  user(options) {\\n    if (Meteor.isServer) {\\n      console.warn([\\n        \\\"`Meteor.user()` is deprecated on the server side.\\\",\\n        \\\"    To fetch the current user record on the server,\\\",\\n        \\\"    use `Meteor.userAsync()` instead.\\\",\\n      ].join(\\\"\\\\n\\\"));\\n    }\\n\\n    const self = this;\\n    const userId = self.userId();\\n    const findOne = (...args) => Meteor.isClient\\n      ? self.users.findOne(...args)\\n      : self.users.findOneAsync(...args);\\n    return userId\\n      ? findOne(userId, this._addDefaultFieldSelector(options))\\n      : null;\\n  }\\n\\n  /**\\n   * @summary Get the current user record, or `null` if no user is logged in.\\n   * @locus Anywhere\\n   * @param {Object} [options]\\n   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\\n   */\\n  async userAsync(options) {\\n    const userId = this.userId();\\n    return userId\\n      ? this.users.findOneAsync(userId, this._addDefaultFieldSelector(options))\\n      : null;\\n  }\\n  // Set up config for the accounts system. Call this on both the client\\n  // and the server.\\n  //\\n  // Note that this method gets overridden on AccountsServer.prototype, but\\n  // the overriding method calls the overridden method.\\n  //\\n  // XXX we should add some enforcement that this is called on both the\\n  // client and the server. Otherwise, a user can\\n  // 'forbidClientAccountCreation' only on the client and while it looks\\n  // like their app is secure, the server will still accept createUser\\n  // calls. https://github.com/meteor/meteor/issues/828\\n  //\\n  // @param options {Object} an object with fields:\\n  // - sendVerificationEmail {Boolean}\\n  //     Send email address verification emails to new users created from\\n  //     client signups.\\n  // - forbidClientAccountCreation {Boolean}\\n  //     Do not allow clients to create accounts directly.\\n  // - restrictCreationByEmailDomain {Function or String}\\n  //     Require created users to have an email matching the function or\\n  //     having the string as domain.\\n  // - loginExpirationInDays {Number}\\n  //     Number of days since login until a user is logged out (login token\\n  //     expires).\\n  // - collection {String|Mongo.Collection}\\n  //     A collection name or a Mongo.Collection object to hold the users.\\n  // - passwordResetTokenExpirationInDays {Number}\\n  //     Number of days since password reset token creation until the\\n  //     token can't be used any longer (password reset token expires).\\n  // - ambiguousErrorMessages {Boolean}\\n  //     Return ambiguous error messages from login failures to prevent\\n  //     user enumeration.\\n  // - bcryptRounds {Number}\\n  //     Allows override of number of bcrypt rounds (aka work factor) used\\n  //     to store passwords.\\n\\n  /**\\n   * @summary Set global accounts options. You can also set these in `Meteor.settings.packages.accounts` without the need to call this function.\\n   * @locus Anywhere\\n   * @param {Object} options\\n   * @param {Boolean} options.sendVerificationEmail New users with an email address will receive an address verification email.\\n   * @param {Boolean} options.forbidClientAccountCreation Calls to [`createUser`](#accounts_createuser) from the client will be rejected. In addition, if you are using [accounts-ui](#accountsui), the \\\"Create account\\\" link will not be available.\\n   * @param {String | Function} options.restrictCreationByEmailDomain If set to a string, only allows new users if the domain part of their email address matches the string. If set to a function, only allows new users if the function returns true.  The function is passed the full email address of the proposed new user.  Works with password-based sign-in and external services that expose email addresses (Google, Facebook, GitHub). All existing users still can log in after enabling this option. Example: `Accounts.config({ restrictCreationByEmailDomain: 'school.edu' })`.\\n   * @param {Number} options.loginExpiration The number of milliseconds from when a user logs in until their token expires and they are logged out, for a more granular control. If `loginExpirationInDays` is set, it takes precedent.\\n   * @param {Number} options.loginExpirationInDays The number of days from when a user logs in until their token expires and they are logged out. Defaults to 90. Set to `null` to disable login expiration.\\n   * @param {String} options.oauthSecretKey When using the `oauth-encryption` package, the 16 byte key using to encrypt sensitive account credentials in the database, encoded in base64.  This option may only be specified on the server.  See packages/oauth-encryption/README.md for details.\\n   * @param {Number} options.passwordResetTokenExpirationInDays The number of days from when a link to reset password is sent until token expires and user can't reset password with the link anymore. Defaults to 3.\\n   * @param {Number} options.passwordResetTokenExpiration The number of milliseconds from when a link to reset password is sent until token expires and user can't reset password with the link anymore. If `passwordResetTokenExpirationInDays` is set, it takes precedent.\\n   * @param {Number} options.passwordEnrollTokenExpirationInDays The number of days from when a link to set initial password is sent until token expires and user can't set password with the link anymore. Defaults to 30.\\n   * @param {Number} options.passwordEnrollTokenExpiration The number of milliseconds from when a link to set initial password is sent until token expires and user can't set password with the link anymore. If `passwordEnrollTokenExpirationInDays` is set, it takes precedent.\\n   * @param {Boolean} options.ambiguousErrorMessages Return ambiguous error messages from login failures to prevent user enumeration. Defaults to `false`, but in production environments it is recommended it defaults to `true`.\\n   * @param {Number} options.bcryptRounds Allows override of number of bcrypt rounds (aka work factor) used to store passwords. The default is 10.\\n   * @param {MongoFieldSpecifier} options.defaultFieldSelector To exclude by default large custom fields from `Meteor.user()` and `Meteor.findUserBy...()` functions when called without a field selector, and all `onLogin`, `onLoginFailure` and `onLogout` callbacks.  Example: `Accounts.config({ defaultFieldSelector: { myBigArray: 0 }})`. Beware when using this. If, for instance, you do not include `email` when excluding the fields, you can have problems with functions like `forgotPassword` that will break because they won't have the required data available. It's recommend that you always keep the fields `_id`, `username`, and `email`.\\n   * @param {String|Mongo.Collection} options.collection A collection name or a Mongo.Collection object to hold the users.\\n   * @param {Number} options.loginTokenExpirationHours When using the package `accounts-2fa`, use this to set the amount of time a token sent is valid. As it's just a number, you can use, for example, 0.5 to make the token valid for just half hour. The default is 1 hour.\\n   * @param {Number} options.tokenSequenceLength When using the package `accounts-2fa`, use this to the size of the token sequence generated. The default is 6.\\n   * @param {'session' | 'local'} options.clientStorage By default login credentials are stored in local storage, setting this to true will switch to using session storage.\\n   */\\n  config(options) {\\n    // We don't want users to accidentally only call Accounts.config on the\\n    // client, where some of the options will have partial effects (eg removing\\n    // the \\\"create account\\\" button from accounts-ui if forbidClientAccountCreation\\n    // is set, or redirecting Google login to a specific-domain page) without\\n    // having their full effects.\\n    if (Meteor.isServer) {\\n      __meteor_runtime_config__.accountsConfigCalled = true;\\n    } else if (!__meteor_runtime_config__.accountsConfigCalled) {\\n      // XXX would be nice to \\\"crash\\\" the client and replace the UI with an error\\n      // message, but there's no trivial way to do this.\\n      Meteor._debug(\\n        'Accounts.config was called on the client but not on the ' +\\n          'server; some configuration options may not take effect.'\\n      );\\n    }\\n\\n    // We need to validate the oauthSecretKey option at the time\\n    // Accounts.config is called. We also deliberately don't store the\\n    // oauthSecretKey in Accounts._options.\\n    if (Object.prototype.hasOwnProperty.call(options, 'oauthSecretKey')) {\\n      if (Meteor.isClient) {\\n        throw new Error(\\n          'The oauthSecretKey option may only be specified on the server'\\n        );\\n      }\\n      if (!Package['oauth-encryption']) {\\n        throw new Error(\\n          'The oauth-encryption package must be loaded to set oauthSecretKey'\\n        );\\n      }\\n      Package['oauth-encryption'].OAuthEncryption.loadKey(\\n        options.oauthSecretKey\\n      );\\n      options = { ...options };\\n      delete options.oauthSecretKey;\\n    }\\n\\n    // Validate config options keys\\n    for (const key of Object.keys(options)) {\\n      if (!VALID_CONFIG_KEYS.includes(key)) {\\n        console.error(`Accounts.config: Invalid key: ${key}`);\\n      }\\n    }\\n\\n    // set values in Accounts._options\\n    for (const key of VALID_CONFIG_KEYS) {\\n      if (key in options) {\\n        if (key in this._options) {\\n          if (key !== 'collection' && (Meteor.isTest && key !== 'clientStorage')) {\\n            throw new Meteor.Error(`Can't set \\\\`${key}\\\\` more than once`);\\n          }\\n        }\\n        this._options[key] = options[key];\\n      }\\n    }\\n\\n    if (options.collection && options.collection !== this.users._name && options.collection !== this.users) {\\n      this.users = this._initializeCollection(options);\\n    }\\n  }\\n\\n  /**\\n   * @summary Register a callback to be called after a login attempt succeeds.\\n   * @locus Anywhere\\n   * @param {Function} func The callback to be called when login is successful.\\n   *                        The callback receives a single object that\\n   *                        holds login details. This object contains the login\\n   *                        result type (password, resume, etc.) on both the\\n   *                        client and server. `onLogin` callbacks registered\\n   *                        on the server also receive extra data, such\\n   *                        as user details, connection information, etc.\\n   */\\n  onLogin(func) {\\n    let ret = this._onLoginHook.register(func);\\n    // call the just registered callback if already logged in\\n    this._startupCallback(ret.callback);\\n    return ret;\\n  }\\n\\n  /**\\n   * @summary Register a callback to be called after a login attempt fails.\\n   * @locus Anywhere\\n   * @param {Function} func The callback to be called after the login has failed.\\n   */\\n  onLoginFailure(func) {\\n    return this._onLoginFailureHook.register(func);\\n  }\\n\\n  /**\\n   * @summary Register a callback to be called after a logout attempt succeeds.\\n   * @locus Anywhere\\n   * @param {Function} func The callback to be called when logout is successful.\\n   */\\n  onLogout(func) {\\n    return this._onLogoutHook.register(func);\\n  }\\n\\n  _initConnection(options) {\\n    if (!Meteor.isClient) {\\n      return;\\n    }\\n\\n    // The connection used by the Accounts system. This is the connection\\n    // that will get logged in by Meteor.login(), and this is the\\n    // connection whose login state will be reflected by Meteor.userId().\\n    //\\n    // It would be much preferable for this to be in accounts_client.js,\\n    // but it has to be here because it's needed to create the\\n    // Meteor.users collection.\\n    if (options.connection) {\\n      this.connection = options.connection;\\n    } else if (options.ddpUrl) {\\n      this.connection = DDP.connect(options.ddpUrl);\\n    } else if (\\n      typeof __meteor_runtime_config__ !== 'undefined' &&\\n      __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL\\n    ) {\\n      // Temporary, internal hook to allow the server to point the client\\n      // to a different authentication server. This is for a very\\n      // particular use case that comes up when implementing a oauth\\n      // server. Unsupported and may go away at any point in time.\\n      //\\n      // We will eventually provide a general way to use account-base\\n      // against any DDP connection, not just one special one.\\n      this.connection = DDP.connect(\\n        __meteor_runtime_config__.ACCOUNTS_CONNECTION_URL\\n      );\\n    } else {\\n      this.connection = Meteor.connection;\\n    }\\n  }\\n\\n  _getTokenLifetimeMs() {\\n    // When loginExpirationInDays is set to null, we'll use a really high\\n    // number of days (LOGIN_UNEXPIRABLE_TOKEN_DAYS) to simulate an\\n    // unexpiring token.\\n    const loginExpirationInDays =\\n      this._options.loginExpirationInDays === null\\n        ? LOGIN_UNEXPIRING_TOKEN_DAYS\\n        : this._options.loginExpirationInDays;\\n    return (\\n      this._options.loginExpiration ||\\n      (loginExpirationInDays || DEFAULT_LOGIN_EXPIRATION_DAYS) * 86400000\\n    );\\n  }\\n\\n  _getPasswordResetTokenLifetimeMs() {\\n    return (\\n      this._options.passwordResetTokenExpiration ||\\n      (this._options.passwordResetTokenExpirationInDays ||\\n        DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS) * 86400000\\n    );\\n  }\\n\\n  _getPasswordEnrollTokenLifetimeMs() {\\n    return (\\n      this._options.passwordEnrollTokenExpiration ||\\n      (this._options.passwordEnrollTokenExpirationInDays ||\\n        DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS) * 86400000\\n    );\\n  }\\n\\n  _tokenExpiration(when) {\\n    // We pass when through the Date constructor for backwards compatibility;\\n    // `when` used to be a number.\\n    return new Date(new Date(when).getTime() + this._getTokenLifetimeMs());\\n  }\\n\\n  _tokenExpiresSoon(when) {\\n    let minLifetimeMs = 0.1 * this._getTokenLifetimeMs();\\n    const minLifetimeCapMs = MIN_TOKEN_LIFETIME_CAP_SECS * 1000;\\n    if (minLifetimeMs > minLifetimeCapMs) {\\n      minLifetimeMs = minLifetimeCapMs;\\n    }\\n    return new Date() > new Date(when) - minLifetimeMs;\\n  }\\n\\n  // No-op on the server, overridden on the client.\\n  _startupCallback(callback) {}\\n}\\n\\n// Note that Accounts is defined separately in accounts_client.js and\\n// accounts_server.js.\\n\\n/**\\n * @summary Get the current user id, or `null` if no user is logged in. A reactive data source.\\n * @locus Anywhere\\n * @importFromPackage meteor\\n */\\nMeteor.userId = () => Accounts.userId();\\n\\n/**\\n * @summary Get the current user record, or `null` if no user is logged in. A reactive data source.\\n * @locus Anywhere\\n * @importFromPackage meteor\\n * @param {Object} [options]\\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\\n */\\nMeteor.user = options => Accounts.user(options);\\n\\n/**\\n * @summary Get the current user record, or `null` if no user is logged in. A reactive data source.\\n * @locus Anywhere\\n * @importFromPackage meteor\\n * @param {Object} [options]\\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\\n */\\nMeteor.userAsync = options => Accounts.userAsync(options);\\n\\n// how long (in days) until a login token expires\\nconst DEFAULT_LOGIN_EXPIRATION_DAYS = 90;\\n// how long (in days) until reset password token expires\\nconst DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS = 3;\\n// how long (in days) until enrol password token expires\\nconst DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS = 30;\\n// Clients don't try to auto-login with a token that is going to expire within\\n// .1 * DEFAULT_LOGIN_EXPIRATION_DAYS, capped at MIN_TOKEN_LIFETIME_CAP_SECS.\\n// Tries to avoid abrupt disconnects from expiring tokens.\\nconst MIN_TOKEN_LIFETIME_CAP_SECS = 3600; // one hour\\n// how often (in milliseconds) we check for expired tokens\\nexport const EXPIRE_TOKENS_INTERVAL_MS = 600 * 1000; // 10 minutes\\n// A large number of expiration days (approximately 100 years worth) that is\\n// used when creating unexpiring tokens.\\nconst LOGIN_UNEXPIRING_TOKEN_DAYS = 365 * 100;\\n\",null],\"names\":[\"AccountsClient\",\"AccountsTest\",\"module\",\"export\",\"Accounts\",\"default\",\"exports\",\"link\",\"v\",\"runSetters\",\"_Meteor$settings\",\"Meteor\",\"settings\",\"_Meteor$settings$publ\",\"public\",\"_Meteor$settings$publ2\",\"packages\",\"accounts\",\"users\",\"_objectSpread\",\"AccountsCommon\",\"constructor\",\"options\",\"_loggingIn\",\"ReactiveVar\",\"_loggingOut\",\"_loginServicesHandle\",\"connection\",\"subscribe\",\"_pageLoadLoginCallbacks\",\"_pageLoadLoginAttemptInfo\",\"savedHash\",\"window\",\"location\",\"hash\",\"_initUrlMatching\",\"initStorageLocation\",\"_initLocalStorage\",\"_loginFuncs\",\"_loginCallbacksCalled\",\"_Meteor$settings$publ3\",\"storageLocation\",\"clientStorage\",\"sessionStorage\",\"_localStorage\",\"config\",\"userId\",\"_setLoggingIn\",\"x\",\"set\",\"loggingIn\",\"get\",\"loggingOut\",\"registerClientLoginFunction\",\"funcName\",\"func\",\"Error\",\"concat\",\"callLoginFunction\",\"_len\",\"arguments\",\"length\",\"funcArgs\",\"Array\",\"_key\",\"apply\",\"applyLoginFunction\",\"logout\",\"callback\",\"applyAsync\",\"wait\",\"then\",\"result\",\"makeClientLoggedOut\",\"catch\",\"e\",\"logoutOtherClients\",\"err\",\"_storeLoginToken\",\"token\",\"tokenExpires\",\"callLoginMethod\",\"called\",\"methodName\",\"methodArguments\",\"_suppressLoggingIn\",\"forEach\",\"f\",\"loginCallbacks\",\"_ref\",\"error\",\"loginDetails\",\"_onLoginFailureHook\",\"_onLoginHook\",\"userCallback\",\"reconnected\",\"onResultReceived\",\"_reconnectStopper\",\"stop\",\"DDP\",\"onReconnect\",\"conn\",\"storedToken\",\"_storedLoginToken\",\"_storedLoginTokenExpires\",\"_tokenExpiration\",\"Date\",\"_tokenExpiresSoon\",\"resume\",\"storedTokenNow\",\"loggedInAndDataReadyCallback\",\"validateResult\",\"makeClientLoggedIn\",\"id\",\"Tracker\",\"autorun\",\"computation\",\"user\",\"withComputation\",\"userAsync\",\"_userId\",\"_onLogoutHook\",\"each\",\"_unstoreLoginToken\",\"setUserId\",\"loginServicesConfigured\",\"ready\",\"onPageLoadLogin\",\"push\",\"_pageLoadLogin\",\"attemptInfo\",\"_debug\",\"_startupCallback\",\"setTimeout\",\"type\",\"loginWithToken\",\"_enableAutoLogin\",\"_autoLoginEnabled\",\"_pollStoredLoginToken\",\"_isolateLoginTokenForTest\",\"LOGIN_TOKEN_KEY\",\"Random\",\"USER_ID_KEY\",\"setItem\",\"LOGIN_TOKEN_EXPIRES_KEY\",\"_lastLoginTokenWhenPolled\",\"removeItem\",\"getItem\",\"_storedUserId\",\"_unstoreLoginTokenIfExpiresSoon\",\"rootUrlPathPrefix\",\"__meteor_runtime_config__\",\"ROOT_URL_PATH_PREFIX\",\"namespace\",\"_stream\",\"rawUrl\",\"allowed\",\"_pollIntervalTimer\",\"clearInterval\",\"setInterval\",\"currentLoginToken\",\"_accountsCallbacks\",\"_attemptToMatchHash\",\"attemptToMatchHash\",\"defaultSuccessHandler\",\"onResetPasswordLink\",\"onEmailVerificationLink\",\"onEnrollmentLink\",\"Package\",\"blaze\",\"Template\",\"Blaze\",\"registerHelper\",\"urlPart\",\"startup\",\"success\",\"tokenRegex\",\"RegExp\",\"match\",\"_resetPasswordToken\",\"_verifyEmailToken\",\"_enrollAccountToken\",\"call\",\"EXPIRE_TOKENS_INTERVAL_MS\",\"VALID_CONFIG_KEYS\",\"key\",\"Object\",\"keys\",\"includes\",\"console\",\"_options\",\"undefined\",\"_initConnection\",\"_initializeCollection\",\"Hook\",\"bindEnvironment\",\"debugPrintExceptions\",\"DEFAULT_LOGIN_EXPIRATION_DAYS\",\"LOGIN_UNEXPIRING_TOKEN_DAYS\",\"lceName\",\"LoginCancelledError\",\"makeErrorType\",\"description\",\"message\",\"prototype\",\"name\",\"numericError\",\"collection\",\"Mongo\",\"Collection\",\"collectionName\",\"_preventAutopublish\",\"_addDefaultFieldSelector\",\"defaultFieldSelector\",\"fields\",\"keys2\",\"isServer\",\"warn\",\"self\",\"findOne\",\"isClient\",\"findOneAsync\",\"accountsConfigCalled\",\"hasOwnProperty\",\"OAuthEncryption\",\"loadKey\",\"oauthSecretKey\",\"isTest\",\"_name\",\"onLogin\",\"ret\",\"register\",\"onLoginFailure\",\"onLogout\",\"ddpUrl\",\"connect\",\"ACCOUNTS_CONNECTION_URL\",\"_getTokenLifetimeMs\",\"loginExpirationInDays\",\"loginExpiration\",\"_getPasswordResetTokenLifetimeMs\",\"passwordResetTokenExpiration\",\"passwordResetTokenExpirationInDays\",\"DEFAULT_PASSWORD_RESET_TOKEN_EXPIRATION_DAYS\",\"_getPasswordEnrollTokenLifetimeMs\",\"passwordEnrollTokenExpiration\",\"passwordEnrollTokenExpirationInDays\",\"DEFAULT_PASSWORD_ENROLL_TOKEN_EXPIRATION_DAYS\",\"when\",\"getTime\",\"minLifetimeMs\",\"minLifetimeCapMs\",\"MIN_TOKEN_LIFETIME_CAP_SECS\"],\"mappings\":\"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\"}"}