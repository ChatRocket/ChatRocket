{"code":"function module(o,e,s){let r,i,n,t;s.export({RoomContext:()=>u,useUserIsSubscribed:()=>m,useRoom:()=>l,useRoomSubscription:()=>a,useRoomMessages:()=>d,useOmnichannelRoom:()=>p,useVoipRoom:()=>h}),s.link(\"@rocket.chat/core-typings\",{isOmnichannelRoom(o){r=o},isVoipRoom(o){i=o}},0),s.link(\"react\",{createContext(o){n=o},useContext(o){t=o}},1);let u=n(null),m=()=>{let o=t(u);if(!o)throw Error(\"use useRoom only inside opened rooms\");return!!o.subscription},l=()=>{let o=t(u);if(!o)throw Error(\"use useRoom only inside opened rooms\");return o.room},a=()=>{let o=t(u);if(!o)throw Error(\"use useRoomSubscription only inside opened rooms\");return o.subscription},d=()=>{let o=t(u);if(!o)throw Error(\"use useRoomMessages only inside opened rooms\");return{hasMorePreviousMessages:o.hasMorePreviousMessages,hasMoreNextMessages:o.hasMoreNextMessages,isLoadingMoreMessages:o.isLoadingMoreMessages}},p=()=>{let{room:o}=t(u)||{};if(!o)throw Error(\"use useRoom only inside opened rooms\");if(!r(o))throw Error(\"invalid room type\");return o},h=()=>{let{room:o}=t(u)||{};if(!o)throw Error(\"use useRoom only inside opened rooms\");if(!i(o))throw Error(\"invalid room type\");return o}}","map":"{\"version\":3,\"sources\":[\"client/views/room/contexts/RoomContext.ts\",\"<anon>\"],\"sourcesContent\":[\"import type { IRoom, IOmnichannelRoom, IVoipRoom, ISubscription } from '@rocket.chat/core-typings';\\nimport { isOmnichannelRoom, isVoipRoom } from '@rocket.chat/core-typings';\\nimport { createContext, useContext } from 'react';\\n\\nexport interface IRoomWithFederationOriginalName extends IRoom {\\n\\tfederationOriginalName?: string;\\n}\\n\\ntype RoomContextValue = {\\n\\trid: IRoom['_id'];\\n\\troom: IRoomWithFederationOriginalName;\\n\\tsubscription?: ISubscription;\\n\\thasMorePreviousMessages: boolean;\\n\\thasMoreNextMessages: boolean;\\n\\tisLoadingMoreMessages: boolean;\\n};\\n\\nexport const RoomContext = createContext<RoomContextValue | null>(null);\\n\\nexport const useUserIsSubscribed = (): boolean => {\\n\\tconst context = useContext(RoomContext);\\n\\n\\tif (!context) {\\n\\t\\tthrow new Error('use useRoom only inside opened rooms');\\n\\t}\\n\\n\\treturn !!context.subscription;\\n};\\n\\nexport const useRoom = (): IRoom => {\\n\\tconst context = useContext(RoomContext);\\n\\n\\tif (!context) {\\n\\t\\tthrow new Error('use useRoom only inside opened rooms');\\n\\t}\\n\\n\\treturn context.room;\\n};\\n\\nexport const useRoomSubscription = (): ISubscription | undefined => {\\n\\tconst context = useContext(RoomContext);\\n\\n\\tif (!context) {\\n\\t\\tthrow new Error('use useRoomSubscription only inside opened rooms');\\n\\t}\\n\\n\\treturn context.subscription;\\n};\\n\\nexport const useRoomMessages = (): {\\n\\thasMorePreviousMessages: boolean;\\n\\thasMoreNextMessages: boolean;\\n\\tisLoadingMoreMessages: boolean;\\n} => {\\n\\tconst context = useContext(RoomContext);\\n\\n\\tif (!context) {\\n\\t\\tthrow new Error('use useRoomMessages only inside opened rooms');\\n\\t}\\n\\n\\treturn {\\n\\t\\thasMorePreviousMessages: context.hasMorePreviousMessages,\\n\\t\\thasMoreNextMessages: context.hasMoreNextMessages,\\n\\t\\tisLoadingMoreMessages: context.isLoadingMoreMessages,\\n\\t};\\n};\\n\\nexport const useOmnichannelRoom = (): IOmnichannelRoom => {\\n\\t// TODO: today if the user do not belong in the room, the room object will not update on new changes\\n\\t// for normal rooms this is OK, but for Omnichannel rooms,\\n\\t// there are cases where an agent can be outside of the room but need to see the room changes\\n\\t// A solution would be to use subscribeToRoom to get the room updates\\n\\n\\tconst { room } = useContext(RoomContext) || {};\\n\\n\\tif (!room) {\\n\\t\\tthrow new Error('use useRoom only inside opened rooms');\\n\\t}\\n\\n\\tif (!isOmnichannelRoom(room)) {\\n\\t\\tthrow new Error('invalid room type');\\n\\t}\\n\\n\\treturn room;\\n};\\n\\nexport const useVoipRoom = (): IVoipRoom => {\\n\\tconst { room } = useContext(RoomContext) || {};\\n\\n\\tif (!room) {\\n\\t\\tthrow new Error('use useRoom only inside opened rooms');\\n\\t}\\n\\n\\tif (!isVoipRoom(room)) {\\n\\t\\tthrow new Error('invalid room type');\\n\\t}\\n\\n\\treturn room;\\n};\\n\",null],\"names\":[\"isOmnichannelRoom\",\"isVoipRoom\",\"createContext\",\"useContext\",\"module\",\"export\",\"RoomContext\",\"useUserIsSubscribed\",\"useRoom\",\"useRoomSubscription\",\"useRoomMessages\",\"useOmnichannelRoom\",\"useVoipRoom\",\"link\",\"v\",\"context\",\"Error\",\"subscription\",\"room\",\"hasMorePreviousMessages\",\"hasMoreNextMessages\",\"isLoadingMoreMessages\"],\"mappings\":\"2BAC0EA,EAAAC,EAAAC,EAAAC,EAA1EC,EAAOC,MAAE,CAAA,CAAAC,YAAiBA,IAAEA,EAAYC,oBAAMA,IAAAA,EAA4BC,QAAAA,IAAAA,EAAAC,oBAAAA,IAAAA,EAAAC,gBAAAA,IAAAA,EAAAC,mBAAAA,IAAAA,EAAAC,YAAAA,IAAAA,CAAA,GAAAR,EAAAS,IAAA,CAAA,4BAAA,CAAAb,kBAAAc,CAAA,EAAAd,EAAAc,CAAA,EAAAb,WAAAa,CAAA,EAAAb,EAAAa,CAAA,CAAA,EAAA,GAAAV,EAAAS,IAAA,CAAA,QAAA,CAAAX,cAAAY,CAAA,EAAAZ,EAAAY,CAAA,EAAAX,WAAAW,CAAA,EAAAX,EAAAW,CAAA,CAAA,EAAA,GAgBnE,IAAMR,EAAcJ,EAAuC,MAErDK,EAAsBA,KAClC,IAAMQ,EAAUZ,EAAWG,GAE3B,GAAI,CAACS,EACJ,MAAM,AAAIC,MAAM,wCAGjB,MAAO,CAAC,CAACD,EAAQE,YAAY,AAC9B,EAEaT,EAAUA,KACtB,IAAMO,EAAUZ,EAAWG,GAE3B,GAAI,CAACS,EACJ,MAAM,AAAIC,MAAM,wCAGjB,OAAOD,EAAQG,IAAI,AACpB,EAEaT,EAAsBA,KAClC,IAAMM,EAAUZ,EAAWG,GAE3B,GAAI,CAACS,EACJ,MAAM,AAAIC,MAAM,oDAGjB,OAAOD,EAAQE,YAAY,AAC5B,EAEaP,EAAkBA,KAK9B,IAAMK,EAAUZ,EAAWG,GAE3B,GAAI,CAACS,EACJ,MAAM,AAAIC,MAAM,gDAGjB,MAAO,CACNG,wBAAyBJ,EAAQI,uBAAuB,CACxDC,oBAAqBL,EAAQK,mBAAmB,CAChDC,sBAAuBN,EAAQM,qBAAAA,CAEjC,EAEaV,EAAqBA,KAMjC,GAAM,CAAEO,KAAAA,CAAAA,CAAM,CAAGf,EAAWG,IAAgB,CAAA,EAE5C,GAAI,CAACY,EACJ,MAAM,AAAIF,MAAM,wCAGjB,GAAI,CAAChB,EAAkBkB,GACtB,MAAM,AAAIF,MAAM,qBAGjB,OAAOE,CACR,EAEaN,EAAcA,KAC1B,GAAM,CAAEM,KAAAA,CAAAA,CAAM,CAAGf,EAAWG,IAAgB,CAAA,EAE5C,GAAI,CAACY,EACJ,MAAM,AAAIF,MAAM,wCAGjB,GAAI,CAACf,EAAWiB,GACf,MAAM,AAAIF,MAAM,qBAGjB,OAAOE,CACR\"}"}