{"code":"Package[\"core-runtime\"].queue(\"check\",function(){var e,t,n=Package.meteor.Meteor;Package.meteor.global,Package.meteor.meteorEnv;var r=Package.ejson.EJSON,a=Package.modules.meteorInstall;return Package.promise.Promise,{export:function(){return{check:e,Match:t}},require:a({node_modules:{meteor:{check:{\"match.js\":function e(e,t,a){let o;a.export({check:()=>l,Match:()=>u}),a.link(\"./isPlainObject\",{isPlainObject(e){o=e}},0);let c=new n.EnvironmentVariable,i=Object.prototype.hasOwnProperty,s=e=>{let t=new u.Error(e.message);return e.path&&(t.message+=\" in field \".concat(e.path),t.path=e.path),t};function l(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{throwAllErrors:!1},r=c.getOrNullIfOutsideFiber();r&&r.checking(e);let a=O(e,t,n.throwAllErrors);if(a){if(n.throwAllErrors)throw Array.isArray(a)?a.map(e=>s(e)):[s(a)];throw s(a)}}let u={Optional:function(e){return new h(e)},Maybe:function(e){return new f(e)},OneOf:function(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return new p(t)},Any:[\"__any__\"],Where:function(e){return new g(e)},ObjectIncluding:function(e){return new m(e)},ObjectWithValues:function(e){return new y(e)},Integer:[\"__integer__\"],Error:n.makeErrorType(\"Match.Error\",function(e){this.message=\"Match error: \".concat(e),this.path=\"\",this.sanitizedError=new n.Error(400,\"Match failed\")}),test:(e,t)=>!O(e,t),_failIfArgumentsAreNotAllChecked(e,t,n,r){let a=new j(n,r),o=c.withValue(a,()=>e.apply(t,n));return a.throwUnlessAllArgumentsHaveBeenChecked(),o}};class h{constructor(e){this.pattern=e}}class f{constructor(e){this.pattern=e}}class p{constructor(e){if(!e||0===e.length)throw Error(\"Must provide at least one choice to Match.OneOf\");this.choices=e}}class g{constructor(e){this.condition=e}}class m{constructor(e){this.pattern=e}}class y{constructor(e){this.pattern=e}}let d=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null===e)return\"null\";if(t.onlyShowType)return typeof e;if(\"object\"!=typeof e)return r.stringify(e);try{JSON.stringify(e)}catch(t){if(\"TypeError\"===t.name)return typeof e}return r.stringify(e)},b=[[String,\"string\"],[Number,\"number\"],[Boolean,\"boolean\"],[Function,\"function\"],[void 0,\"undefined\"]],O=function(e,t){let n,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:\"\";if(t===u.Any)return!1;for(let n=0;n<b.length;++n)if(t===b[n][0]){if(typeof e===b[n][1])return!1;return{message:\"Expected \".concat(b[n][1],\", got \").concat(d(e,{onlyShowType:!0})),path:\"\"}}if(null===t)return null!==e&&{message:\"Expected null, got \".concat(d(e)),path:\"\"};if(\"string\"==typeof t||\"number\"==typeof t||\"boolean\"==typeof t)return e!==t&&{message:\"Expected \".concat(t,\", got \").concat(d(e)),path:\"\"};if(t===u.Integer)return(\"number\"!=typeof e||(0|e)!==e)&&{message:\"Expected Integer, got \".concat(d(e)),path:\"\"};if(t===Object&&(t=u.ObjectIncluding({})),t instanceof Array){if(1!==t.length)return{message:\"Bad pattern: arrays must have one type element \".concat(d(t)),path:\"\"};if(!Array.isArray(e)&&!A(e))return{message:\"Expected array, got \".concat(d(e)),path:\"\"};for(let n=0,o=e.length;n<o;n++){let o=\"\".concat(c,\"[\").concat(n,\"]\"),i=O(e[n],t[0],r,a,o);if(i){if(i.path=w(r?o:n,i.path),!r)return i;(\"object\"!=typeof e[n]||i.message)&&a.push(i)}}return!!r&&0!==a.length&&a}if(t instanceof g){let n;try{n=t.condition(e)}catch(e){if(!(e instanceof u.Error))throw e;return{message:e.message,path:e.path}}return!n&&{message:\"Failed Match.Where validation\",path:\"\"}}if(t instanceof f?t=u.OneOf(void 0,null,t.pattern):t instanceof h&&(t=u.OneOf(void 0,t.pattern)),t instanceof p){for(let n=0;n<t.choices.length;++n){let r=O(e,t.choices[n]);if(!r)return!1}return{message:\"Failed Match.OneOf, Match.Maybe or Match.Optional validation\",path:\"\"}}if(t instanceof Function)return!(e instanceof t)&&{message:\"Expected \".concat(t.name||\"particular constructor\"),path:\"\"};let s=!1;if(t instanceof m&&(s=!0,t=t.pattern),t instanceof y&&(s=!0,n=[t.pattern],t={}),\"object\"!=typeof t)return{message:\"Bad pattern: unknown pattern type\",path:\"\"};if(\"object\"!=typeof e)return{message:\"Expected object, got \".concat(typeof e),path:\"\"};if(null===e)return{message:\"Expected object, got null\",path:\"\"};if(!o(e))return{message:\"Expected plain object\",path:\"\"};let l=Object.create(null),j=Object.create(null);for(let o in Object.keys(t).forEach(e=>{let n=t[e];n instanceof h||n instanceof f?j[e]=n.pattern:l[e]=n}),Object(e)){let t=e[o],u=c?\"\".concat(c,\".\").concat(o):o;if(i.call(l,o)){let e=O(t,l[o],r,a,u);if(e){if(e.path=w(r?u:o,e.path),!r)return e;(\"object\"!=typeof t||e.message)&&a.push(e)}delete l[o]}else if(i.call(j,o)){let e=O(t,j[o],r,a,u);if(e){if(e.path=w(r?u:o,e.path),!r)return e;(\"object\"!=typeof t||e.message)&&a.push(e)}}else{if(!s){let e={message:\"Unknown key\",path:o};if(!r)return e;a.push(e)}if(n){let e=O(t,n[0],r,a,u);if(e){if(e.path=w(r?u:o,e.path),!r)return e;(\"object\"!=typeof t||e.message)&&a.push(e)}}}}let k=Object.keys(l);if(k.length){let e=e=>({message:\"Missing key '\".concat(e,\"'\"),path:r?c:\"\"});if(!r)return e(k[0]);for(let t of k)a.push(e(t))}return!!r&&0!==a.length&&a};class j{constructor(e,t){this.args=[...e],this.args.reverse(),this.description=t}checking(e){!this._checkingOneValue(e)&&(Array.isArray(e)||A(e))&&Array.prototype.forEach.call(e,this._checkingOneValue.bind(this))}_checkingOneValue(e){for(let t=0;t<this.args.length;++t)if(e===this.args[t]||Number.isNaN(e)&&Number.isNaN(this.args[t]))return this.args.splice(t,1),!0;return!1}throwUnlessAllArgumentsHaveBeenChecked(){if(this.args.length>0)throw Error(\"Did not check() all arguments during \".concat(this.description))}}let k=[\"do\",\"if\",\"in\",\"for\",\"let\",\"new\",\"try\",\"var\",\"case\",\"else\",\"enum\",\"eval\",\"false\",\"null\",\"this\",\"true\",\"void\",\"with\",\"break\",\"catch\",\"class\",\"const\",\"super\",\"throw\",\"while\",\"yield\",\"delete\",\"export\",\"import\",\"public\",\"return\",\"static\",\"switch\",\"typeof\",\"default\",\"extends\",\"finally\",\"package\",\"private\",\"continue\",\"debugger\",\"function\",\"arguments\",\"interface\",\"protected\",\"implements\",\"instanceof\"],w=(e,t)=>(\"number\"==typeof e||e.match(/^[0-9]+$/)?e=\"[\".concat(e,\"]\"):(!e.match(/^[a-z_$][0-9a-z_$.[\\]]*$/i)||k.indexOf(e)>=0)&&(e=JSON.stringify([e])),t&&\"[\"!==t[0])?\"\".concat(e,\".\").concat(t):e+t,E=e=>\"object\"==typeof e&&null!==e,v=e=>E(e)&&\"[object Arguments]\"===Object.prototype.toString.call(e),A=v(function(){return arguments}())?v:e=>E(e)&&\"function\"==typeof e.callee},\"isPlainObject.js\":function e(e,t,n){n.export({isPlainObject:()=>s});let r={}.toString,a=Object.prototype.hasOwnProperty,o=a.toString,c=o.call(Object),i=Object.getPrototypeOf,s=e=>{let t,n;return!!e&&\"[object Object]\"===r.call(e)&&(!(t=i(e))||\"function\"==typeof(n=a.call(t,\"constructor\")&&t.constructor)&&o.call(n)===c)}}}}}},{extensions:[\".js\",\".json\"]}),eagerModulePaths:[\"/node_modules/meteor/check/match.js\"],mainModulePath:\"/node_modules/meteor/check/match.js\"}});","map":"{\"version\":3,\"sources\":[\"packages/check/match.js\",\"packages/check/isPlainObject.js\",\"<anon>\"],\"sourcesContent\":[\"// XXX docs\\nimport { isPlainObject } from './isPlainObject';\\n\\n// Things we explicitly do NOT support:\\n//    - heterogenous arrays\\n\\nconst currentArgumentChecker = new Meteor.EnvironmentVariable;\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\nconst format = result => {\\n  const err = new Match.Error(result.message);\\n  if (result.path) {\\n    err.message += ` in field ${result.path}`;\\n    err.path = result.path;\\n  }\\n\\n  return err;\\n}\\n\\n/**\\n * @summary Check that a value matches a [pattern](#matchpatterns).\\n * If the value does not match the pattern, throw a `Match.Error`.\\n * By default, it will throw immediately at the first error encountered. Pass in { throwAllErrors: true } to throw all errors.\\n *\\n * Particularly useful to assert that arguments to a function have the right\\n * types and structure.\\n * @locus Anywhere\\n * @param {Any} value The value to check\\n * @param {MatchPattern} pattern The pattern to match `value` against\\n * @param {Object} [options={}] Additional options for check\\n * @param {Boolean} [options.throwAllErrors=false] If true, throw all errors\\n */\\nexport function check(value, pattern, options = { throwAllErrors: false }) {\\n  // Record that check got called, if somebody cared.\\n  //\\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()\\n  // from non-Fiber server contexts; the downside is that if you forget to\\n  // bindEnvironment on some random callback in your method/publisher,\\n  // it might not find the argumentChecker and you'll get an error about\\n  // not checking an argument that it looks like you're checking (instead\\n  // of just getting a \\\"Node code must run in a Fiber\\\" error).\\n  const argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\\n  if (argChecker) {\\n    argChecker.checking(value);\\n  }\\n\\n  const result = testSubtree(value, pattern, options.throwAllErrors);\\n\\n  if (result) {\\n    if (options.throwAllErrors) {\\n      throw Array.isArray(result) ? result.map(r => format(r)) : [format(result)]\\n    } else {\\n      throw format(result)\\n    }\\n  }\\n};\\n\\n/**\\n * @namespace Match\\n * @summary The namespace for all Match types and methods.\\n */\\nexport const Match = {\\n  Optional: function(pattern) {\\n    return new Optional(pattern);\\n  },\\n\\n  Maybe: function(pattern) {\\n    return new Maybe(pattern);\\n  },\\n\\n  OneOf: function(...args) {\\n    return new OneOf(args);\\n  },\\n\\n  Any: ['__any__'],\\n  Where: function(condition) {\\n    return new Where(condition);\\n  },\\n\\n  ObjectIncluding: function(pattern) {\\n    return new ObjectIncluding(pattern)\\n  },\\n\\n  ObjectWithValues: function(pattern) {\\n    return new ObjectWithValues(pattern);\\n  },\\n\\n  // Matches only signed 32-bit integers\\n  Integer: ['__integer__'],\\n\\n  // XXX matchers should know how to describe themselves for errors\\n  Error: Meteor.makeErrorType('Match.Error', function (msg) {\\n    this.message = `Match error: ${msg}`;\\n\\n    // The path of the value that failed to match. Initially empty, this gets\\n    // populated by catching and rethrowing the exception as it goes back up the\\n    // stack.\\n    // E.g.: \\\"vals[3].entity.created\\\"\\n    this.path = '';\\n\\n    // If this gets sent over DDP, don't give full internal details but at least\\n    // provide something better than 500 Internal server error.\\n    this.sanitizedError = new Meteor.Error(400, 'Match failed');\\n  }),\\n\\n  // Tests to see if value matches pattern. Unlike check, it merely returns true\\n  // or false (unless an error other than Match.Error was thrown). It does not\\n  // interact with _failIfArgumentsAreNotAllChecked.\\n  // XXX maybe also implement a Match.match which returns more information about\\n  //     failures but without using exception handling or doing what check()\\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\\n\\n  /**\\n   * @summary Returns true if the value matches the pattern.\\n   * @locus Anywhere\\n   * @param {Any} value The value to check\\n   * @param {MatchPattern} pattern The pattern to match `value` against\\n   */\\n  test(value, pattern) {\\n    return !testSubtree(value, pattern);\\n  },\\n\\n  // Runs `f.apply(context, args)`. If check() is not called on every element of\\n  // `args` (either directly or in the first level of an array), throws an error\\n  // (using `description` in the message).\\n  _failIfArgumentsAreNotAllChecked(f, context, args, description) {\\n    const argChecker = new ArgumentChecker(args, description);\\n    const result = currentArgumentChecker.withValue(\\n      argChecker,\\n      () => f.apply(context, args)\\n    );\\n\\n    // If f didn't itself throw, make sure it checked all of its arguments.\\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();\\n    return result;\\n  }\\n};\\n\\nclass Optional {\\n  constructor(pattern) {\\n    this.pattern = pattern;\\n  }\\n}\\n\\nclass Maybe {\\n  constructor(pattern) {\\n    this.pattern = pattern;\\n  }\\n}\\n\\nclass OneOf {\\n  constructor(choices) {\\n    if (!choices || choices.length === 0) {\\n      throw new Error('Must provide at least one choice to Match.OneOf');\\n    }\\n\\n    this.choices = choices;\\n  }\\n}\\n\\nclass Where {\\n  constructor(condition) {\\n    this.condition = condition;\\n  }\\n}\\n\\nclass ObjectIncluding {\\n  constructor(pattern) {\\n    this.pattern = pattern;\\n  }\\n}\\n\\nclass ObjectWithValues {\\n  constructor(pattern) {\\n    this.pattern = pattern;\\n  }\\n}\\n\\nconst stringForErrorMessage = (value, options = {}) => {\\n  if ( value === null ) {\\n    return 'null';\\n  }\\n\\n  if ( options.onlyShowType ) {\\n    return typeof value;\\n  }\\n\\n  // Your average non-object things.  Saves from doing the try/catch below for.\\n  if ( typeof value !== 'object' ) {\\n    return EJSON.stringify(value)\\n  }\\n\\n  try {\\n\\n    // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)\\n    // If the native stringify is going to choke, EJSON.stringify is going to choke too.\\n    JSON.stringify(value);\\n  } catch (stringifyError) {\\n    if ( stringifyError.name === 'TypeError' ) {\\n      return typeof value;\\n    }\\n  }\\n\\n  return EJSON.stringify(value);\\n};\\n\\nconst typeofChecks = [\\n  [String, 'string'],\\n  [Number, 'number'],\\n  [Boolean, 'boolean'],\\n\\n  // While we don't allow undefined/function in EJSON, this is good for optional\\n  // arguments with OneOf.\\n  [Function, 'function'],\\n  [undefined, 'undefined'],\\n];\\n\\n// Return `false` if it matches. Otherwise, returns an object with a `message` and a `path` field or an array of objects each with a `message` and a `path` field when collecting errors.\\nconst testSubtree = (value, pattern, collectErrors = false, errors = [], path = '') => {\\n  // Match anything!\\n  if (pattern === Match.Any) {\\n    return false;\\n  }\\n\\n  // Basic atomic types.\\n  // Do not match boxed objects (e.g. String, Boolean)\\n  for (let i = 0; i < typeofChecks.length; ++i) {\\n    if (pattern === typeofChecks[i][0]) {\\n      if (typeof value === typeofChecks[i][1]) {\\n        return false;\\n      }\\n\\n      return {\\n        message: `Expected ${typeofChecks[i][1]}, got ${stringForErrorMessage(value, { onlyShowType: true })}`,\\n        path: '',\\n      };\\n    }\\n  }\\n\\n  if (pattern === null) {\\n    if (value === null) {\\n      return false;\\n    }\\n\\n    return {\\n      message: `Expected null, got ${stringForErrorMessage(value)}`,\\n      path: '',\\n    };\\n  }\\n\\n  // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\\n  if (typeof pattern === 'string' || typeof pattern === 'number' || typeof pattern === 'boolean') {\\n    if (value === pattern) {\\n      return false;\\n    }\\n\\n    return {\\n      message: `Expected ${pattern}, got ${stringForErrorMessage(value)}`,\\n      path: '',\\n    };\\n  }\\n\\n  // Match.Integer is special type encoded with array\\n  if (pattern === Match.Integer) {\\n\\n    // There is no consistent and reliable way to check if variable is a 64-bit\\n    // integer. One of the popular solutions is to get reminder of division by 1\\n    // but this method fails on really large floats with big precision.\\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\\n    // Bitwise operators work consistantly but always cast variable to 32-bit\\n    // signed integer according to JavaScript specs.\\n    if (typeof value === 'number' && (value | 0) === value) {\\n      return false;\\n    }\\n\\n    return {\\n      message: `Expected Integer, got ${stringForErrorMessage(value)}`,\\n      path: '',\\n    };\\n  }\\n\\n  // 'Object' is shorthand for Match.ObjectIncluding({});\\n  if (pattern === Object) {\\n    pattern = Match.ObjectIncluding({});\\n  }\\n\\n  // Array (checked AFTER Any, which is implemented as an Array).\\n  if (pattern instanceof Array) {\\n    if (pattern.length !== 1) {\\n      return {\\n        message: `Bad pattern: arrays must have one type element ${stringForErrorMessage(pattern)}`,\\n        path: '',\\n      };\\n    }\\n\\n    if (!Array.isArray(value) && !isArguments(value)) {\\n      return {\\n        message: `Expected array, got ${stringForErrorMessage(value)}`,\\n        path: '',\\n      };\\n    }\\n\\n\\n    for (let i = 0, length = value.length; i < length; i++) {\\n      const arrPath = `${path}[${i}]`\\n      const result = testSubtree(value[i], pattern[0], collectErrors, errors, arrPath);\\n      if (result) {\\n        result.path = _prependPath(collectErrors ? arrPath : i, result.path)\\n        if (!collectErrors) return result;\\n        if (typeof value[i] !== 'object' || result.message) errors.push(result)\\n      }\\n    }\\n\\n    if (!collectErrors) return false;\\n    return errors.length === 0 ? false : errors;\\n  }\\n\\n  // Arbitrary validation checks. The condition can return false or throw a\\n  // Match.Error (ie, it can internally use check()) to fail.\\n  if (pattern instanceof Where) {\\n    let result;\\n    try {\\n      result = pattern.condition(value);\\n    } catch (err) {\\n      if (!(err instanceof Match.Error)) {\\n        throw err;\\n      }\\n\\n      return {\\n        message: err.message,\\n        path: err.path\\n      };\\n    }\\n\\n    if (result) {\\n      return false;\\n    }\\n\\n    // XXX this error is terrible\\n\\n    return {\\n      message: 'Failed Match.Where validation',\\n      path: '',\\n    };\\n  }\\n\\n  if (pattern instanceof Maybe) {\\n    pattern = Match.OneOf(undefined, null, pattern.pattern);\\n  } else if (pattern instanceof Optional) {\\n    pattern = Match.OneOf(undefined, pattern.pattern);\\n  }\\n\\n  if (pattern instanceof OneOf) {\\n    for (let i = 0; i < pattern.choices.length; ++i) {\\n      const result = testSubtree(value, pattern.choices[i]);\\n      if (!result) {\\n\\n        // No error? Yay, return.\\n        return false;\\n      }\\n\\n      // Match errors just mean try another choice.\\n    }\\n\\n    // XXX this error is terrible\\n    return {\\n      message: 'Failed Match.OneOf, Match.Maybe or Match.Optional validation',\\n      path: '',\\n    };\\n  }\\n\\n  // A function that isn't something we special-case is assumed to be a\\n  // constructor.\\n  if (pattern instanceof Function) {\\n    if (value instanceof pattern) {\\n      return false;\\n    }\\n\\n    return {\\n      message: `Expected ${pattern.name || 'particular constructor'}`,\\n      path: '',\\n    };\\n  }\\n\\n  let unknownKeysAllowed = false;\\n  let unknownKeyPattern;\\n  if (pattern instanceof ObjectIncluding) {\\n    unknownKeysAllowed = true;\\n    pattern = pattern.pattern;\\n  }\\n\\n  if (pattern instanceof ObjectWithValues) {\\n    unknownKeysAllowed = true;\\n    unknownKeyPattern = [pattern.pattern];\\n    pattern = {};  // no required keys\\n  }\\n\\n  if (typeof pattern !== 'object') {\\n    return {\\n      message: 'Bad pattern: unknown pattern type',\\n      path: '',\\n    };\\n  }\\n\\n  // An object, with required and optional keys. Note that this does NOT do\\n  // structural matches against objects of special types that happen to match\\n  // the pattern: this really needs to be a plain old {Object}!\\n  if (typeof value !== 'object') {\\n    return {\\n      message: `Expected object, got ${typeof value}`,\\n      path: '',\\n    };\\n  }\\n\\n  if (value === null) {\\n    return {\\n      message: `Expected object, got null`,\\n      path: '',\\n    };\\n  }\\n\\n  if (! isPlainObject(value)) {\\n    return {\\n      message: `Expected plain object`,\\n      path: '',\\n    };\\n  }\\n\\n  const requiredPatterns = Object.create(null);\\n  const optionalPatterns = Object.create(null);\\n\\n  Object.keys(pattern).forEach(key => {\\n    const subPattern = pattern[key];\\n    if (subPattern instanceof Optional ||\\n        subPattern instanceof Maybe) {\\n      optionalPatterns[key] = subPattern.pattern;\\n    } else {\\n      requiredPatterns[key] = subPattern;\\n    }\\n  });\\n\\n  for (let key in Object(value)) {\\n    const subValue = value[key];\\n    const objPath = path ? `${path}.${key}` : key;\\n    if (hasOwn.call(requiredPatterns, key)) {\\n      const result = testSubtree(subValue, requiredPatterns[key], collectErrors, errors, objPath);\\n      if (result) {\\n        result.path = _prependPath(collectErrors ? objPath : key, result.path)\\n        if (!collectErrors) return result;\\n        if (typeof subValue !== 'object' || result.message) errors.push(result);\\n      }\\n\\n      delete requiredPatterns[key];\\n    } else if (hasOwn.call(optionalPatterns, key)) {\\n      const result = testSubtree(subValue, optionalPatterns[key], collectErrors, errors, objPath);\\n      if (result) {\\n        result.path = _prependPath(collectErrors ? objPath : key, result.path)\\n        if (!collectErrors) return result;\\n        if (typeof subValue !== 'object' || result.message) errors.push(result);\\n      }\\n\\n    } else {\\n      if (!unknownKeysAllowed) {\\n        const result = {\\n          message: 'Unknown key',\\n          path: key,\\n        };\\n        if (!collectErrors) return result;\\n        errors.push(result);\\n      }\\n\\n      if (unknownKeyPattern) {\\n        const result = testSubtree(subValue, unknownKeyPattern[0], collectErrors, errors, objPath);\\n        if (result) {\\n          result.path = _prependPath(collectErrors ? objPath : key, result.path)\\n          if (!collectErrors) return result;\\n          if (typeof subValue !== 'object' || result.message) errors.push(result);\\n        }\\n      }\\n    }\\n  }\\n\\n  const keys = Object.keys(requiredPatterns);\\n  if (keys.length) {\\n    const createMissingError = key => ({\\n      message: `Missing key '${key}'`,\\n      path: collectErrors ? path : '',\\n    });\\n\\n    if (!collectErrors) {\\n      return createMissingError(keys[0]);\\n    }\\n\\n    for (const key of keys) {\\n      errors.push(createMissingError(key));\\n    }\\n  }\\n\\n  if (!collectErrors) return false;\\n  return errors.length === 0 ? false : errors;\\n};\\n\\nclass ArgumentChecker {\\n  constructor (args, description) {\\n\\n    // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\\n    // against its contents.)\\n    this.args = [...args];\\n\\n    // Since the common case will be to check arguments in order, and we splice\\n    // out arguments when we check them, make it so we splice out from the end\\n    // rather than the beginning.\\n    this.args.reverse();\\n    this.description = description;\\n  }\\n\\n  checking(value) {\\n    if (this._checkingOneValue(value)) {\\n      return;\\n    }\\n\\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\\n    // or check([foo, bar], [String]) to count... but only if value wasn't\\n    // itself an argument.\\n    if (Array.isArray(value) || isArguments(value)) {\\n      Array.prototype.forEach.call(value, this._checkingOneValue.bind(this));\\n    }\\n  }\\n\\n  _checkingOneValue(value) {\\n    for (let i = 0; i < this.args.length; ++i) {\\n\\n      // Is this value one of the arguments? (This can have a false positive if\\n      // the argument is an interned primitive, but it's still a good enough\\n      // check.)\\n      // (NaN is not === to itself, so we have to check specially.)\\n      if (value === this.args[i] ||\\n          (Number.isNaN(value) && Number.isNaN(this.args[i]))) {\\n        this.args.splice(i, 1);\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  throwUnlessAllArgumentsHaveBeenChecked() {\\n    if (this.args.length > 0)\\n      throw new Error(`Did not check() all arguments during ${this.description}`);\\n  }\\n}\\n\\nconst _jsKeywords = ['do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case',\\n  'else', 'enum', 'eval', 'false', 'null', 'this', 'true', 'void', 'with',\\n  'break', 'catch', 'class', 'const', 'super', 'throw', 'while', 'yield',\\n  'delete', 'export', 'import', 'public', 'return', 'static', 'switch',\\n  'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue',\\n  'debugger', 'function', 'arguments', 'interface', 'protected', 'implements',\\n  'instanceof'];\\n\\n// Assumes the base of path is already escaped properly\\n// returns key + base\\nconst _prependPath = (key, base) => {\\n  if ((typeof key) === 'number' || key.match(/^[0-9]+$/)) {\\n    key = `[${key}]`;\\n  } else if (!key.match(/^[a-z_$][0-9a-z_$.[\\\\]]*$/i) ||\\n             _jsKeywords.indexOf(key) >= 0) {\\n    key = JSON.stringify([key]);\\n  }\\n\\n  if (base && base[0] !== '[') {\\n    return `${key}.${base}`;\\n  }\\n\\n  return key + base;\\n}\\n\\nconst isObject = value => typeof value === 'object' && value !== null;\\n\\nconst baseIsArguments = item =>\\n  isObject(item) &&\\n  Object.prototype.toString.call(item) === '[object Arguments]';\\n\\nconst isArguments = baseIsArguments(function() { return arguments; }()) ?\\n  baseIsArguments :\\n  value => isObject(value) && typeof value.callee === 'function';\\n\",\"// Copy of jQuery.isPlainObject for the server side from jQuery v3.1.1.\\n\\nconst class2type = {};\\n\\nconst toString = class2type.toString;\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\nconst fnToString = hasOwn.toString;\\n\\nconst ObjectFunctionString = fnToString.call(Object);\\n\\nconst getProto = Object.getPrototypeOf;\\n\\nexport const isPlainObject = obj => {\\n  let proto;\\n  let Ctor;\\n\\n  // Detect obvious negatives\\n  // Use toString instead of jQuery.type to catch host objects\\n  if (!obj || toString.call(obj) !== '[object Object]') {\\n    return false;\\n  }\\n\\n  proto = getProto(obj);\\n\\n  // Objects with no prototype (e.g., `Object.create( null )`) are plain\\n  if (!proto) {\\n    return true;\\n  }\\n\\n  // Objects with prototype are plain iff they were constructed by a global Object function\\n  Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;\\n  return typeof Ctor === 'function' && \\n    fnToString.call(Ctor) === ObjectFunctionString;\\n};\\n\",null],\"names\":[\"isPlainObject\",\"module\",\"export\",\"check\",\"Match\",\"link\",\"v\",\"currentArgumentChecker\",\"Meteor\",\"EnvironmentVariable\",\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"format\",\"result\",\"err\",\"Error\",\"message\",\"path\",\"concat\",\"value\",\"pattern\",\"options\",\"arguments\",\"length\",\"undefined\",\"throwAllErrors\",\"argChecker\",\"getOrNullIfOutsideFiber\",\"checking\",\"testSubtree\",\"Array\",\"isArray\",\"map\",\"r\",\"Optional\",\"Maybe\",\"OneOf\",\"_len\",\"args\",\"_key\",\"Any\",\"Where\",\"condition\",\"ObjectIncluding\",\"ObjectWithValues\",\"Integer\",\"makeErrorType\",\"msg\",\"sanitizedError\",\"test\",\"_failIfArgumentsAreNotAllChecked\",\"f\",\"context\",\"description\",\"ArgumentChecker\",\"withValue\",\"apply\",\"throwUnlessAllArgumentsHaveBeenChecked\",\"constructor\",\"choices\",\"stringForErrorMessage\",\"onlyShowType\",\"EJSON\",\"stringify\",\"JSON\",\"stringifyError\",\"name\",\"typeofChecks\",\"String\",\"Number\",\"Boolean\",\"Function\",\"unknownKeyPattern\",\"collectErrors\",\"errors\",\"i\",\"isArguments\",\"arrPath\",\"_prependPath\",\"push\",\"unknownKeysAllowed\",\"requiredPatterns\",\"create\",\"optionalPatterns\",\"key\",\"keys\",\"forEach\",\"subPattern\",\"subValue\",\"objPath\",\"call\",\"createMissingError\",\"reverse\",\"_checkingOneValue\",\"bind\",\"isNaN\",\"splice\",\"_jsKeywords\",\"base\",\"match\",\"indexOf\",\"isObject\",\"baseIsArguments\",\"item\",\"toString\",\"callee\",\"class2type\",\"fnToString\",\"ObjectFunctionString\",\"getProto\",\"getPrototypeOf\",\"obj\",\"proto\",\"Ctor\"],\"mappings\":\"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\"}"}