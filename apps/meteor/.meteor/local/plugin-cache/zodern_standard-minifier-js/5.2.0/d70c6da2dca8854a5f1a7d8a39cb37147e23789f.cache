{"code":"Package[\"core-runtime\"].queue(\"callback-hook\",function(){var e,t=Package.meteor.Meteor;Package.meteor.global,Package.meteor.meteorEnv;var a=Package.modules.meteorInstall;return Package.promise.Promise,{export:function(){return{Hook:e}},require:a({node_modules:{meteor:{\"callback-hook\":{\"hook.js\":function e(e,a,n){n.export({Hook:()=>o});let c=Object.prototype.hasOwnProperty;class o{constructor(e){if(e=e||{},this.nextCallbackId=0,this.callbacks=Object.create(null),this.bindEnvironment=!0,!1===e.bindEnvironment&&(this.bindEnvironment=!1),this.wrapAsync=!0,!1===e.wrapAsync&&(this.wrapAsync=!1),e.exceptionHandler)this.exceptionHandler=e.exceptionHandler;else if(e.debugPrintExceptions){if(\"string\"!=typeof e.debugPrintExceptions)throw Error(\"Hook option debugPrintExceptions should be a string\");this.exceptionHandler=e.debugPrintExceptions}}register(e){let a=this.exceptionHandler||function(e){throw e};e=this.bindEnvironment?t.bindEnvironment(e,a):function(e,a,n){if(!a||\"string\"==typeof a){let e=a||\"callback of async function\";a=function(a){t._debug(\"Exception in \"+e,a)}}return function(){let t;try{for(var n=arguments.length,c=Array(n),o=0;o<n;o++)c[o]=arguments[o];t=e.apply(void 0,c)}catch(e){a(e)}return t}}(e,a),this.wrapAsync&&(e=t.wrapFn(e));let n=this.nextCallbackId++;return this.callbacks[n]=e,{callback:e,stop:()=>{delete this.callbacks[n]}}}clear(){this.nextCallbackId=0,this.callbacks=[]}forEach(e){let t=Object.keys(this.callbacks);for(let a=0;a<t.length;++a){let n=t[a];if(c.call(this.callbacks,n)){let t=this.callbacks[n];if(!e(t))break}}}async forEachAsync(e){let t=Object.keys(this.callbacks);for(let a=0;a<t.length;++a){let n=t[a];if(c.call(this.callbacks,n)){let t=this.callbacks[n];if(!await e(t))break}}}async forEachAsync(e){let t=Object.keys(this.callbacks);for(let a=0;a<t.length;++a){let n=t[a];if(c.call(this.callbacks,n)){let t=this.callbacks[n];if(!await e(t))break}}}each(e){return this.forEach(e)}}}}}}},{extensions:[\".js\",\".json\"]}),eagerModulePaths:[\"/node_modules/meteor/callback-hook/hook.js\"],mainModulePath:\"/node_modules/meteor/callback-hook/hook.js\"}});","map":"{\"version\":3,\"sources\":[\"packages/callback-hook/hook.js\",\"<anon>\"],\"sourcesContent\":[\"// XXX This pattern is under development. Do not add more callsites\\n// using this package for now. See:\\n// https://meteor.hackpad.com/Design-proposal-Hooks-YxvgEW06q6f\\n//\\n// Encapsulates the pattern of registering callbacks on a hook.\\n//\\n// The `each` method of the hook calls its iterator function argument\\n// with each registered callback.  This allows the hook to\\n// conditionally decide not to call the callback (if, for example, the\\n// observed object has been closed or terminated).\\n//\\n// By default, callbacks are bound with `Meteor.bindEnvironment`, so they will be\\n// called with the Meteor environment of the calling code that\\n// registered the callback. Override by passing { bindEnvironment: false }\\n// to the constructor.\\n//\\n// Registering a callback returns an object with a single `stop`\\n// method which unregisters the callback.\\n//\\n// The code is careful to allow a callback to be safely unregistered\\n// while the callbacks are being iterated over.\\n//\\n// If the hook is configured with the `exceptionHandler` option, the\\n// handler will be called if a called callback throws an exception.\\n// By default (if the exception handler doesn't itself throw an\\n// exception, or if the iterator function doesn't return a falsy value\\n// to terminate the calling of callbacks), the remaining callbacks\\n// will still be called.\\n//\\n// Alternatively, the `debugPrintExceptions` option can be specified\\n// as string describing the callback.  On an exception the string and\\n// the exception will be printed to the console log with\\n// `Meteor._debug`, and the exception otherwise ignored.\\n//\\n// If an exception handler isn't specified, exceptions thrown in the\\n// callback will propagate up to the iterator function, and will\\n// terminate calling the remaining callbacks if not caught.\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\nexport class Hook {\\n  constructor(options) {\\n    options = options || {};\\n    this.nextCallbackId = 0;\\n    this.callbacks = Object.create(null);\\n    // Whether to wrap callbacks with Meteor.bindEnvironment\\n    this.bindEnvironment = true;\\n    if (options.bindEnvironment === false) {\\n      this.bindEnvironment = false;\\n    }\\n\\n    this.wrapAsync = true;\\n    if (options.wrapAsync === false) {\\n      this.wrapAsync = false;\\n    }\\n\\n    if (options.exceptionHandler) {\\n      this.exceptionHandler = options.exceptionHandler;\\n    } else if (options.debugPrintExceptions) {\\n      if (typeof options.debugPrintExceptions !== \\\"string\\\") {\\n        throw new Error(\\\"Hook option debugPrintExceptions should be a string\\\");\\n      }\\n      this.exceptionHandler = options.debugPrintExceptions;\\n    }\\n  }\\n\\n  register(callback) {\\n    const exceptionHandler = this.exceptionHandler || function (exception) {\\n      // Note: this relies on the undocumented fact that if bindEnvironment's\\n      // onException throws, and you are invoking the callback either in the\\n      // browser or from within a Fiber in Node, the exception is propagated.\\n      throw exception;\\n    };\\n\\n    if (this.bindEnvironment) {\\n      callback = Meteor.bindEnvironment(callback, exceptionHandler);\\n    } else {\\n      callback = dontBindEnvironment(callback, exceptionHandler);\\n    }\\n\\n    if (this.wrapAsync) {\\n      callback = Meteor.wrapFn(callback);\\n    }\\n\\n    const id = this.nextCallbackId++;\\n    this.callbacks[id] = callback;\\n\\n    return {\\n      callback,\\n      stop: () => {\\n        delete this.callbacks[id];\\n      }\\n    };\\n  }\\n\\n  clear() {\\n    this.nextCallbackId = 0;\\n    this.callbacks = [];\\n  }\\n\\n  /**\\n   * For each registered callback, call the passed iterator function with the callback.\\n   *\\n   * The iterator function can choose whether or not to call the\\n   * callback.  (For example, it might not call the callback if the\\n   * observed object has been closed or terminated).\\n   * The iteration is stopped if the iterator function returns a falsy\\n   * value or throws an exception.\\n   *\\n   * @param iterator\\n   */\\n  forEach(iterator) {\\n\\n    const ids = Object.keys(this.callbacks);\\n    for (let i = 0;  i < ids.length;  ++i) {\\n      const id = ids[i];\\n      // check to see if the callback was removed during iteration\\n      if (hasOwn.call(this.callbacks, id)) {\\n        const callback = this.callbacks[id];\\n        if (! iterator(callback)) {\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n  async forEachAsync(iterator) {\\n    const ids = Object.keys(this.callbacks);\\n    for (let i = 0;  i < ids.length;  ++i) {\\n      const id = ids[i];\\n      // check to see if the callback was removed during iteration\\n      if (hasOwn.call(this.callbacks, id)) {\\n        const callback = this.callbacks[id];\\n        if (!await iterator(callback)) {\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * For each registered callback, call the passed iterator function with the callback.\\n   *\\n   * it is a counterpart of forEach, but it is async and returns a promise\\n   * @param iterator\\n   * @return {Promise<void>}\\n   * @see forEach\\n   */\\n  async forEachAsync(iterator) {\\n    const ids = Object.keys(this.callbacks);\\n    for (let i = 0;  i < ids.length;  ++i) {\\n      const id = ids[i];\\n      // check to see if the callback was removed during iteration\\n      if (hasOwn.call(this.callbacks, id)) {\\n        const callback = this.callbacks[id];\\n        if (!await iterator(callback)) {\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @deprecated use forEach\\n   * @param iterator\\n   */\\n  each(iterator) {\\n    return this.forEach(iterator);\\n  }\\n}\\n\\n// Copied from Meteor.bindEnvironment and removed all the env stuff.\\nfunction dontBindEnvironment(func, onException, _this) {\\n  if (!onException || typeof(onException) === 'string') {\\n    const description = onException || \\\"callback of async function\\\";\\n    onException = function (error) {\\n      Meteor._debug(\\n        \\\"Exception in \\\" + description,\\n        error\\n      );\\n    };\\n  }\\n\\n  return function (...args) {\\n    let ret;\\n    try {\\n      ret = func.apply(_this, args);\\n    } catch (e) {\\n      onException(e);\\n    }\\n    return ret;\\n  };\\n}\\n\",null],\"names\":[\"module\",\"export\",\"Hook\",\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"constructor\",\"options\",\"nextCallbackId\",\"callbacks\",\"create\",\"bindEnvironment\",\"wrapAsync\",\"exceptionHandler\",\"debugPrintExceptions\",\"Error\",\"register\",\"callback\",\"exception\",\"Meteor\",\"dontBindEnvironment\",\"func\",\"onException\",\"_this\",\"description\",\"error\",\"_debug\",\"ret\",\"_len\",\"arguments\",\"length\",\"args\",\"Array\",\"_key\",\"apply\",\"e\",\"wrapFn\",\"id\",\"stop\",\"clear\",\"forEach\",\"iterator\",\"ids\",\"keys\",\"i\",\"call\",\"forEachAsync\",\"each\"],\"mappings\":\"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\"}"}