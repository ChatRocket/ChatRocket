{"code":"Package[\"core-runtime\"].queue(\"reactive-var\",function(){Package.meteor.Meteor,Package.meteor.global,Package.meteor.meteorEnv;var e,t=Package.tracker.Tracker;return Package.tracker.Deps,(function(){(e=function(r,n){if(!(this instanceof e))return new e(r,n);this.curValue=r,this.equalsFunc=n,this.dep=new t.Dependency})._isEqual=function(e,t){return e===t&&(!e||\"number\"==typeof e||\"boolean\"==typeof e||\"string\"==typeof e)},e.prototype.get=function(){return t.active&&this.dep.depend(),this.curValue},e.prototype.set=function(t){var r=this.curValue;(this.equalsFunc||e._isEqual)(r,t)||(this.curValue=t,this.dep.changed())},e.prototype.toString=function(){return\"ReactiveVar{\"+this.get()+\"}\"},e.prototype._numListeners=function(){var e=0;for(var t in this.dep._dependentsById)e++;return e}}).call(this),{export:function(){return{ReactiveVar:e}}}});","map":"{\"version\":3,\"sources\":[\"packages/reactive-var/reactive-var.js\",\"<anon>\"],\"sourcesContent\":[\"/*\\n * ## [new] ReactiveVar(initialValue, [equalsFunc])\\n *\\n * A ReactiveVar holds a single value that can be get and set,\\n * such that calling `set` will invalidate any Computations that\\n * called `get`, according to the usual contract for reactive\\n * data sources.\\n *\\n * A ReactiveVar is much like a Session variable -- compare `foo.get()`\\n * to `Session.get(\\\"foo\\\")` -- but it doesn't have a global name and isn't\\n * automatically migrated across hot code pushes.  Also, while Session\\n * variables can only hold JSON or EJSON, ReactiveVars can hold any value.\\n *\\n * An important property of ReactiveVars, which is sometimes the reason\\n * to use one, is that setting the value to the same value as before has\\n * no effect, meaning ReactiveVars can be used to absorb extra\\n * invalidations that wouldn't serve a purpose.  However, by default,\\n * ReactiveVars are extremely conservative about what changes they\\n * absorb.  Calling `set` with an object argument will *always* trigger\\n * invalidations, because even if the new value is `===` the old value,\\n * the object may have been mutated.  You can change the default behavior\\n * by passing a function of two arguments, `oldValue` and `newValue`,\\n * to the constructor as `equalsFunc`.\\n *\\n * This class is extremely basic right now, but the idea is to evolve\\n * it into the ReactiveVar of Geoff's Lickable Forms proposal.\\n */\\n\\n/**\\n * @class \\n * @instanceName reactiveVar\\n * @summary Constructor for a ReactiveVar, which represents a single reactive variable.\\n * @locus Client\\n * @param {Any} initialValue The initial value to set.  `equalsFunc` is ignored when setting the initial value.\\n * @param {Function} [equalsFunc] Optional.  A function of two arguments, called on the old value and the new value whenever the ReactiveVar is set.  If it returns true, no set is performed.  If omitted, the default `equalsFunc` returns true if its arguments are `===` and are of type number, boolean, string, undefined, or null.\\n */\\nReactiveVar = function (initialValue, equalsFunc) {\\n  if (! (this instanceof ReactiveVar))\\n    // called without `new`\\n    return new ReactiveVar(initialValue, equalsFunc);\\n\\n  this.curValue = initialValue;\\n  this.equalsFunc = equalsFunc;\\n  this.dep = new Tracker.Dependency;\\n};\\n\\nReactiveVar._isEqual = function (oldValue, newValue) {\\n  var a = oldValue, b = newValue;\\n  // Two values are \\\"equal\\\" here if they are `===` and are\\n  // number, boolean, string, undefined, or null.\\n  if (a !== b)\\n    return false;\\n  else\\n    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||\\n            (typeof a === 'string'));\\n};\\n\\n/**\\n * @summary Returns the current value of the ReactiveVar, establishing a reactive dependency.\\n * @locus Client\\n */\\nReactiveVar.prototype.get = function () {\\n  if (Tracker.active)\\n    this.dep.depend();\\n\\n  return this.curValue;\\n};\\n\\n/**\\n * @summary Sets the current value of the ReactiveVar, invalidating the Computations that called `get` if `newValue` is different from the old value.\\n * @locus Client\\n * @param {Any} newValue\\n */\\nReactiveVar.prototype.set = function (newValue) {\\n  var oldValue = this.curValue;\\n\\n  if ((this.equalsFunc || ReactiveVar._isEqual)(oldValue, newValue))\\n    // value is same as last time\\n    return;\\n\\n  this.curValue = newValue;\\n  this.dep.changed();\\n};\\n\\nReactiveVar.prototype.toString = function () {\\n  return 'ReactiveVar{' + this.get() + '}';\\n};\\n\\nReactiveVar.prototype._numListeners = function() {\\n  // Tests want to know.\\n  // Accesses a private field of Tracker.Dependency.\\n  var count = 0;\\n  for (var id in this.dep._dependentsById)\\n    count++;\\n  return count;\\n};\\n\\n\",null],\"names\":[\"ReactiveVar\",\"initialValue\",\"equalsFunc\",\"curValue\",\"dep\",\"Tracker\",\"Dependency\",\"_isEqual\",\"oldValue\",\"newValue\",\"prototype\",\"get\",\"active\",\"depend\",\"set\",\"changed\",\"toString\",\"_numListeners\",\"count\",\"id\",\"_dependentsById\"],\"mappings\":\"qMA8CAA,AAVAA,CAAAA,EAAA,SAAAC,CAAA,CAAAC,CAAA,EACA,GAAA,CAAA,CAAA,IAAA,YAAAF,CAAA,EAEA,OAAA,IAAAA,EAAAC,EAAAC,EAEA,CAAA,IAAA,CAAAC,QAAA,CAAAF,EACA,IAAA,CAAAC,UAAA,CAAAA,EACA,IAAA,CAAAE,GAAA,CAAA,IAAAC,EAAAC,UAAA,AACA,CAAA,EAEAC,QAAA,CAAA,SAAAC,CAAA,CAAAC,CAAA,SAIA,AAHAD,IAAAC,GAMA,CAAA,CANAD,GAMA,UAAA,OANAA,GAMA,WAAA,OANAA,GAOA,UAAA,OAPAA,CAOA,CACA,EAMAR,EAAAU,SAAA,CAAAC,GAAA,CAAA,WAIA,OAHAN,EAAAO,MAAA,EACA,IAAA,CAAAR,GAAA,CAAAS,MAAA,GAEA,IAAA,CAAAV,QAAA,AACA,EAOAH,EAAAU,SAAA,CAAAI,GAAA,CAAA,SAAAL,CAAA,EACA,IAAAD,EAAA,IAAA,CAAAL,QAAA,CAEA,CAAA,IAAA,CAAAD,UAAA,EAAAF,EAAAO,QAAA,EAAAC,EAAAC,KAIA,IAAA,CAAAN,QAAA,CAAAM,EACA,IAAA,CAAAL,GAAA,CAAAW,OAAA,GACA,EAEAf,EAAAU,SAAA,CAAAM,QAAA,CAAA,WACA,MAAA,eAAA,IAAA,CAAAL,GAAA,GAAA,GACA,EAEAX,EAAAU,SAAA,CAAAO,aAAA,CAAA,WAGA,IAAAC,EAAA,EACA,IAAA,IAAAC,KAAA,IAAA,CAAAf,GAAA,CAAAgB,eAAA,CACAF,IACA,OAAAA,CACA\"}"}