{"code":"Package[\"core-runtime\"].queue(\"allow-deny\",function(){var e,t=Package.meteor.Meteor;Package.meteor.global,Package.meteor.meteorEnv;var r=Package.minimongo.LocalCollection;Package.minimongo.Minimongo;var n=Package.check.check,o=Package.check.Match,i=Package.ejson.EJSON,s=Package[\"ddp-client\"].DDP,l=Package.modules.meteorInstall;return Package.promise.Promise,{export:function(){return{AllowDeny:e}},require:l({node_modules:{meteor:{\"allow-deny\":{\"allow-deny.js\":function l(l,a,c){let d;c.link(\"@babel/runtime/helpers/objectSpread2\",{default(e){d=e}},0);let u=Object.prototype.hasOwnProperty;e={CollectionPrototype:{}};let h=e.CollectionPrototype;async function f(e,t){for(let r of e)if(await t(r))return!0;return!1}async function _(e,t){for(let r of e)if(!await t(r))return!1;return!0}h.allow=function(e){p(this,\"allow\",e)},h.deny=function(e){p(this,\"deny\",e)},h._defineMutationMethods=function(e){let r=this;if(e=e||{},r._restricted=!1,r._insecure=void 0,r._validators={insert:{allow:[],deny:[]},update:{allow:[],deny:[]},remove:{allow:[],deny:[]},insertAsync:{allow:[],deny:[]},updateAsync:{allow:[],deny:[]},removeAsync:{allow:[],deny:[]},upsertAsync:{allow:[],deny:[]},fetch:[],fetchAllFields:!1},r._name&&(r._prefix=\"/\"+r._name+\"/\",r._connection&&(r._connection===t.server||t.isClient))){let i={};[\"insertAsync\",\"updateAsync\",\"removeAsync\",\"insert\",\"update\",\"remove\"].forEach(s=>{let l=r._prefix+s;if(e.useExisting){let e=t.isClient?\"_methodHandlers\":\"method_handlers\";if(r._connection[e]&&\"function\"==typeof r._connection[e][l])return}let a=e=>e.includes(\"insert\");i[l]=function(){n(arguments,[o.Any]);let e=Array.from(arguments);try{let n=null;if(a(s)&&!u.call(e[0],\"_id\")&&(n=r._makeNewID()),this.isSimulation)return null!==n&&(e[0]._id=n),r._collection[s].apply(r._collection,e);if(a(s)||v(e[0],s),r._restricted){if(0===r._validators[s].allow.length)throw new t.Error(403,\"Access denied. No allow validators set on restricted collection for method '\"+s+\"'.\");let o=s.replace(\"Async\",\"\"),i=\"_validated\"+s.charAt(0).toUpperCase()+o.slice(1),l=t.isServer?i+\"Async\":i;return e.unshift(this.userId),a(s)&&e.push(n),r[l].apply(r,e)}if(r._isInsecure())return null!==n&&(e[0]._id=n),r._collection[({insert:\"insertAsync\",update:\"updateAsync\",remove:\"removeAsync\"})[s]||s].apply(r._collection,e);throw new t.Error(403,\"Access denied\")}catch(e){if(\"MongoError\"===e.name||\"BulkWriteError\"===e.name||\"MongoBulkWriteError\"===e.name||\"MinimongoError\"===e.name)throw new t.Error(409,e.toString());throw e}}}),r._connection.methods(i)}},h._updateFetch=function(e){if(!this._validators.fetchAllFields){if(e){let t=Object.create(null),r=e=>e&&e.forEach(e=>t[e]=1);r(this._validators.fetch),r(e),this._validators.fetch=Object.keys(t)}else this._validators.fetchAllFields=!0,this._validators.fetch=null}},h._isInsecure=function(){return void 0===this._insecure?!!Package.insecure:this._insecure},h._validatedInsertAsync=async function(e,r,n){if(await f(this._validators.insertAsync.deny,async o=>{let i=o(e,w(o,r,n));return t._isPromise(i)?await i:i})||await _(this._validators.insertAsync.allow,async o=>{let i=o(e,w(o,r,n));return!(t._isPromise(i)?await i:i)}))throw new t.Error(403,\"Access denied\");return null!==n&&(r._id=n),this._collection.insertAsync.call(this._collection,r)},h._validatedInsert=function(e,r,n){if(this._validators.insert.deny.some(t=>t(e,w(t,r,n)))||this._validators.insert.allow.every(t=>!t(e,w(t,r,n))))throw new t.Error(403,\"Access denied\");return null!==n&&(r._id=n),(t.isServer?this._collection.insertAsync:this._collection.insert).call(this._collection,r)},h._validatedUpdateAsync=async function(e,o,i,s){if(n(i,Object),s=Object.assign(Object.create(null),s),!r._selectorIsIdPerhapsAsObject(o))throw Error(\"validated update should be of a single ID\");if(s.upsert)throw new t.Error(403,\"Access denied. Upserts not allowed in a restricted collection.\");let l=\"Access denied. In a restricted collection you can only update documents, not replace them. Use a Mongo update operator, such as '$set'.\",a=Object.keys(i),c={};if(0===a.length)throw new t.Error(403,l);a.forEach(e=>{let r=i[e];if(\"$\"!==e.charAt(0))throw new t.Error(403,l);if(u.call(y,e))Object.keys(r).forEach(e=>{-1!==e.indexOf(\".\")&&(e=e.substring(0,e.indexOf(\".\"))),c[e]=!0});else throw new t.Error(403,\"Access denied. Operator \"+e+\" not allowed in a restricted collection.\")});let d=Object.keys(c),h={transform:null};this._validators.fetchAllFields||(h.fields={},this._validators.fetch.forEach(e=>{h.fields[e]=1}));let w=await this._collection.findOneAsync(o,h);if(!w)return 0;if(await f(this._validators.updateAsync.deny,async r=>{let n=m(r,w),o=r(e,n,d,i);return t._isPromise(o)?await o:o})||await _(this._validators.updateAsync.allow,async r=>{let n=m(r,w),o=r(e,n,d,i);return!(t._isPromise(o)?await o:o)}))throw new t.Error(403,\"Access denied\");return s._forbidReplace=!0,this._collection.updateAsync.call(this._collection,o,i,s)},h._validatedUpdate=function(e,o,i,s){if(n(i,Object),s=Object.assign(Object.create(null),s),!r._selectorIsIdPerhapsAsObject(o))throw Error(\"validated update should be of a single ID\");if(s.upsert)throw new t.Error(403,\"Access denied. Upserts not allowed in a restricted collection.\");let l=\"Access denied. In a restricted collection you can only update documents, not replace them. Use a Mongo update operator, such as '$set'.\",a=Object.keys(i),c={};if(0===a.length)throw new t.Error(403,l);a.forEach(e=>{let r=i[e];if(\"$\"!==e.charAt(0))throw new t.Error(403,l);if(u.call(y,e))Object.keys(r).forEach(e=>{-1!==e.indexOf(\".\")&&(e=e.substring(0,e.indexOf(\".\"))),c[e]=!0});else throw new t.Error(403,\"Access denied. Operator \"+e+\" not allowed in a restricted collection.\")});let d=Object.keys(c),h={transform:null};this._validators.fetchAllFields||(h.fields={},this._validators.fetch.forEach(e=>{h.fields[e]=1}));let f=this._collection.findOne(o,h);if(!f)return 0;if(this._validators.update.deny.some(t=>{let r=m(t,f);return t(e,r,d,i)})||this._validators.update.allow.every(t=>{let r=m(t,f);return!t(e,r,d,i)}))throw new t.Error(403,\"Access denied\");return s._forbidReplace=!0,this._collection.update.call(this._collection,o,i,s)};let y={$inc:1,$set:1,$unset:1,$addToSet:1,$pop:1,$pullAll:1,$pull:1,$pushAll:1,$push:1,$bit:1};function m(e,t){return e.transform?e.transform(t):t}function w(e,t,r){let n=t;return e.transform&&(n=i.clone(t),null!==r&&(n._id=r),n=e.transform(n)),n}function p(e,t,n){let o=/^(?:insertAsync|updateAsync|removeAsync|insert|update|remove|fetch|transform)$/;if(Object.keys(n).forEach(e=>{if(!o.test(e))throw Error(t+\": Invalid key: \"+e)}),e._restricted=!0,[\"insertAsync\",\"updateAsync\",\"removeAsync\",\"insert\",\"update\",\"remove\"].forEach(o=>{if(u.call(n,o)){if(!(n[o]instanceof Function))throw Error(t+\": Value for `\"+o+\"` must be a function\");void 0===n.transform?n[o].transform=e._transform:n[o].transform=r.wrapTransform(n.transform),e._validators[o][t].push(n[o])}}),n.updateAsync||n.removeAsync||n.fetch){if(n.fetch&&!(n.fetch instanceof Array))throw Error(t+\": Value for `fetch` must be an array\");e._updateFetch(n.fetch)}}function v(e,n){if(!r._selectorIsIdPerhapsAsObject(e))throw new t.Error(403,\"Not permitted. Untrusted code may only \"+n+\" documents by ID.\")}function A(){var e=s._CurrentMethodInvocation||s._CurrentInvocation;let t=e.get();return t&&t.isSimulation}h._validatedRemoveAsync=async function(e,r){let n={transform:null};this._validators.fetchAllFields||(n.fields={},this._validators.fetch.forEach(e=>{n.fields[e]=1}));let o=await this._collection.findOneAsync(r,n);if(!o)return 0;if(await f(this._validators.removeAsync.deny,async r=>{let n=r(e,m(r,o));return t._isPromise(n)?await n:n})||await _(this._validators.removeAsync.allow,async r=>{let n=r(e,m(r,o));return!(t._isPromise(n)?await n:n)}))throw new t.Error(403,\"Access denied\");return this._collection.removeAsync.call(this._collection,r)},h._validatedRemove=function(e,r){let n={transform:null};this._validators.fetchAllFields||(n.fields={},this._validators.fetch.forEach(e=>{n.fields[e]=1}));let o=this._collection.findOne(r,n);if(!o)return 0;if(this._validators.remove.deny.some(t=>t(e,m(t,o)))||this._validators.remove.allow.every(t=>!t(e,m(t,o))))throw new t.Error(403,\"Access denied\");return this._collection.remove.call(this._collection,r)},h._callMutatorMethodAsync=function e(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},n=\"updateAsync\"===e||\"removeAsync\"===e;n&&!A()&&v(t[0],e);let o=this._prefix+e;return this._connection.applyAsync(o,t,d({returnStubValue:\"stub\"===this.resolverType||null==this.resolverType,returnServerResultPromise:!this._connection._stream._isStub&&\"stub\"!==this.resolverType},r))},h._callMutatorMethod=function e(e,r,n){!t.isClient||n||A()||(n=function(r){r&&t._debug(e+\" failed\",r)});let o=\"update\"===e||\"remove\"===e;o&&!A()&&v(r[0],e);let i=this._prefix+e;return this._connection.apply(i,r,{returnStubValue:!0},n)}}}}}},{extensions:[\".js\",\".json\"]}),eagerModulePaths:[\"/node_modules/meteor/allow-deny/allow-deny.js\"]}});","map":"{\"version\":3,\"sources\":[\"packages/allow-deny/allow-deny.js\",\"<anon>\"],\"sourcesContent\":[\"///\\n/// Remote methods and access control.\\n///\\n\\nconst hasOwn = Object.prototype.hasOwnProperty;\\n\\n// Restrict default mutators on collection. allow() and deny() take the\\n// same options:\\n//\\n// options.insertAsync {Function(userId, doc)}\\n//   return true to allow/deny adding this document\\n//\\n// options.updateAsync {Function(userId, docs, fields, modifier)}\\n//   return true to allow/deny updating these documents.\\n//   `fields` is passed as an array of fields that are to be modified\\n//\\n// options.removeAsync {Function(userId, docs)}\\n//   return true to allow/deny removing these documents\\n//\\n// options.fetch {Array}\\n//   Fields to fetch for these validators. If any call to allow or deny\\n//   does not have this option then all fields are loaded.\\n//\\n// allow and deny can be called multiple times. The validators are\\n// evaluated as follows:\\n// - If neither deny() nor allow() has been called on the collection,\\n//   then the request is allowed if and only if the \\\"insecure\\\" smart\\n//   package is in use.\\n// - Otherwise, if any deny() function returns true, the request is denied.\\n// - Otherwise, if any allow() function returns true, the request is allowed.\\n// - Otherwise, the request is denied.\\n//\\n// Meteor may call your deny() and allow() functions in any order, and may not\\n// call all of them if it is able to make a decision without calling them all\\n// (so don't include side effects).\\n\\nAllowDeny = {\\n  CollectionPrototype: {}\\n};\\n\\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these\\n// methods\\nconst CollectionPrototype = AllowDeny.CollectionPrototype;\\n\\n/**\\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\\n * @locus Server\\n * @method allow\\n * @memberOf Mongo.Collection\\n * @instance\\n * @param {Object} options\\n * @param {Function} options.insertAsync,updateAsync,removeAsync Functions that look at a proposed modification to the database and return true if it should be allowed.\\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\\n */\\nCollectionPrototype.allow = function(options) {\\n  addValidator(this, 'allow', options);\\n};\\n\\n/**\\n * @summary Override `allow` rules.\\n * @locus Server\\n * @method deny\\n * @memberOf Mongo.Collection\\n * @instance\\n * @param {Object} options\\n * @param {Function} options.insertAsync,updateAsync,removeAsync Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\\n */\\nCollectionPrototype.deny = function(options) {\\n  addValidator(this, 'deny', options);\\n};\\n\\nCollectionPrototype._defineMutationMethods = function(options) {\\n  const self = this;\\n  options = options || {};\\n\\n  // set to true once we call any allow or deny methods. If true, use\\n  // allow/deny semantics. If false, use insecure mode semantics.\\n  self._restricted = false;\\n\\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which\\n  // means insecure iff the insecure package is loaded. This property can be\\n  // overriden by tests or packages wishing to change insecure mode behavior of\\n  // their collections.\\n  self._insecure = undefined;\\n\\n  self._validators = {\\n    insert: {allow: [], deny: []},\\n    update: {allow: [], deny: []},\\n    remove: {allow: [], deny: []},\\n    insertAsync: {allow: [], deny: []},\\n    updateAsync: {allow: [], deny: []},\\n    removeAsync: {allow: [], deny: []},\\n    upsertAsync: {allow: [], deny: []}, // dummy arrays; can't set these!\\n    fetch: [],\\n    fetchAllFields: false\\n  };\\n\\n  if (!self._name)\\n    return; // anonymous collection\\n\\n  // XXX Think about method namespacing. Maybe methods should be\\n  // \\\"Meteor:Mongo:insertAsync/NAME\\\"?\\n  self._prefix = '/' + self._name + '/';\\n\\n  // Mutation Methods\\n  // Minimongo on the server gets no stubs; instead, by default\\n  // it wait()s until its result is ready, yielding.\\n  // This matches the behavior of macromongo on the server better.\\n  // XXX see #MeteorServerNull\\n  if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {\\n    const m = {};\\n\\n    [\\n      'insertAsync',\\n      'updateAsync',\\n      'removeAsync',\\n      'insert',\\n      'update',\\n      'remove',\\n    ].forEach(method => {\\n      const methodName = self._prefix + method;\\n\\n      if (options.useExisting) {\\n        const handlerPropName = Meteor.isClient\\n          ? '_methodHandlers'\\n          : 'method_handlers';\\n        // Do not try to create additional methods if this has already been called.\\n        // (Otherwise the .methods() call below will throw an error.)\\n        if (\\n          self._connection[handlerPropName] &&\\n          typeof self._connection[handlerPropName][methodName] === 'function'\\n        )\\n          return;\\n      }\\n\\n      const isInsert = name => name.includes('insert');\\n\\n      m[methodName] = function (/* ... */) {\\n        // All the methods do their own validation, instead of using check().\\n        check(arguments, [Match.Any]);\\n        const args = Array.from(arguments);\\n        try {\\n          // For an insert/insertAsync, if the client didn't specify an _id, generate one\\n          // now; because this uses DDP.randomStream, it will be consistent with\\n          // what the client generated. We generate it now rather than later so\\n          // that if (eg) an allow/deny rule does an insert/insertAsync to the same\\n          // collection (not that it really should), the generated _id will\\n          // still be the first use of the stream and will be consistent.\\n          //\\n          // However, we don't actually stick the _id onto the document yet,\\n          // because we want allow/deny rules to be able to differentiate\\n          // between arbitrary client-specified _id fields and merely\\n          // client-controlled-via-randomSeed fields.\\n          let generatedId = null;\\n          if (isInsert(method) && !hasOwn.call(args[0], '_id')) {\\n            generatedId = self._makeNewID();\\n          }\\n\\n          if (this.isSimulation) {\\n            // In a client simulation, you can do any mutation (even with a\\n            // complex selector).\\n            if (generatedId !== null) {\\n              args[0]._id = generatedId;\\n            }\\n            return self._collection[method].apply(self._collection, args);\\n          }\\n\\n          // This is the server receiving a method call from the client.\\n\\n          // We don't allow arbitrary selectors in mutations from the client: only\\n          // single-ID selectors.\\n          if (!isInsert(method)) throwIfSelectorIsNotId(args[0], method);\\n\\n          if (self._restricted) {\\n            // short circuit if there is no way it will pass.\\n            if (self._validators[method].allow.length === 0) {\\n              throw new Meteor.Error(\\n                403,\\n                'Access denied. No allow validators set on restricted ' +\\n                  \\\"collection for method '\\\" +\\n                  method +\\n                  \\\"'.\\\"\\n              );\\n            }\\n\\n            const syncMethodName = method.replace('Async', '');\\n            const syncValidatedMethodName = '_validated' + method.charAt(0).toUpperCase() + syncMethodName.slice(1);\\n            // it forces to use async validated behavior on the server\\n            const validatedMethodName = Meteor.isServer ? syncValidatedMethodName + 'Async' : syncValidatedMethodName;\\n\\n            args.unshift(this.userId);\\n            isInsert(method) && args.push(generatedId);\\n            return self[validatedMethodName].apply(self, args);\\n          } else if (self._isInsecure()) {\\n            if (generatedId !== null) args[0]._id = generatedId;\\n            // In insecure mode we use the server _collection methods, and these sync methods\\n            // do not exist in the server anymore, so we have this mapper to call the async methods\\n            // instead.\\n            const syncMethodsMapper = {\\n              insert: \\\"insertAsync\\\",\\n              update: \\\"updateAsync\\\",\\n              remove: \\\"removeAsync\\\",\\n            };\\n\\n\\n            // In insecure mode, allow any mutation (with a simple selector).\\n            // XXX This is kind of bogus.  Instead of blindly passing whatever\\n            //     we get from the network to this function, we should actually\\n            //     know the correct arguments for the function and pass just\\n            //     them.  For example, if you have an extraneous extra null\\n            //     argument and this is Mongo on the server, the .wrapAsync'd\\n            //     functions like update will get confused and pass the\\n            //     \\\"fut.resolver()\\\" in the wrong slot, where _update will never\\n            //     invoke it. Bam, broken DDP connection.  Probably should just\\n            //     take this whole method and write it three times, invoking\\n            //     helpers for the common code.\\n            return self._collection[syncMethodsMapper[method] || method].apply(self._collection, args);\\n          } else {\\n            // In secure mode, if we haven't called allow or deny, then nothing\\n            // is permitted.\\n            throw new Meteor.Error(403, 'Access denied');\\n          }\\n        } catch (e) {\\n          if (\\n            e.name === 'MongoError' ||\\n            // for old versions of MongoDB (probably not necessary but it's here just in case)\\n            e.name === 'BulkWriteError' ||\\n            // for newer versions of MongoDB (https://docs.mongodb.com/drivers/node/current/whats-new/#bulkwriteerror---mongobulkwriteerror)\\n            e.name === 'MongoBulkWriteError' ||\\n            e.name === 'MinimongoError'\\n          ) {\\n            throw new Meteor.Error(409, e.toString());\\n          } else {\\n            throw e;\\n          }\\n        }\\n      };\\n    });\\n\\n    self._connection.methods(m);\\n  }\\n};\\n\\nCollectionPrototype._updateFetch = function (fields) {\\n  const self = this;\\n\\n  if (!self._validators.fetchAllFields) {\\n    if (fields) {\\n      const union = Object.create(null);\\n      const add = names => names && names.forEach(name => union[name] = 1);\\n      add(self._validators.fetch);\\n      add(fields);\\n      self._validators.fetch = Object.keys(union);\\n    } else {\\n      self._validators.fetchAllFields = true;\\n      // clear fetch just to make sure we don't accidentally read it\\n      self._validators.fetch = null;\\n    }\\n  }\\n};\\n\\nCollectionPrototype._isInsecure = function () {\\n  const self = this;\\n  if (self._insecure === undefined)\\n    return !!Package.insecure;\\n  return self._insecure;\\n};\\n\\nasync function asyncSome(array, predicate) {\\n  for (let item of array) {\\n    if (await predicate(item)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\n\\nasync function asyncEvery(array, predicate) {\\n  for (let item of array) {\\n    if (!await predicate(item)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\nCollectionPrototype._validatedInsertAsync = async function(userId, doc,\\n                                                           generatedId) {\\n  const self = this;\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (await asyncSome(self._validators.insertAsync.deny, async (validator) => {\\n    const result = validator(userId, docToValidate(validator, doc, generatedId));\\n    return Meteor._isPromise(result) ? await result : result;\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n\\n  if (await asyncEvery(self._validators.insertAsync.allow, async (validator) => {\\n    const result = validator(userId, docToValidate(validator, doc, generatedId));\\n    return !(Meteor._isPromise(result) ? await result : result);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  // If we generated an ID above, insertAsync it now: after the validation, but\\n  // before actually inserting.\\n  if (generatedId !== null)\\n    doc._id = generatedId;\\n\\n  return self._collection.insertAsync.call(self._collection, doc);\\n};\\n\\nCollectionPrototype._validatedInsert = function (userId, doc,\\n                                                         generatedId) {\\n  const self = this;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (self._validators.insert.deny.some((validator) => {\\n    return validator(userId, docToValidate(validator, doc, generatedId));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n\\n  if (self._validators.insert.allow.every((validator) => {\\n    return !validator(userId, docToValidate(validator, doc, generatedId));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  // If we generated an ID above, insert it now: after the validation, but\\n  // before actually inserting.\\n  if (generatedId !== null)\\n    doc._id = generatedId;\\n\\n  return (Meteor.isServer\\n    ? self._collection.insertAsync\\n    : self._collection.insert\\n  ).call(self._collection, doc);\\n};\\n\\n// Simulate a mongo `update` operation while validating that the access\\n// control rules set by calls to `allow/deny` are satisfied. If all\\n// pass, rewrite the mongo operation to use $in to set the list of\\n// document ids to change ##ValidatedChange\\nCollectionPrototype._validatedUpdateAsync = async function(\\n    userId, selector, mutator, options) {\\n  const self = this;\\n\\n  check(mutator, Object);\\n\\n  options = Object.assign(Object.create(null), options);\\n\\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))\\n    throw new Error(\\\"validated update should be of a single ID\\\");\\n\\n  // We don't support upserts because they don't fit nicely into allow/deny\\n  // rules.\\n  if (options.upsert)\\n    throw new Meteor.Error(403, \\\"Access denied. Upserts not \\\" +\\n                           \\\"allowed in a restricted collection.\\\");\\n\\n  const noReplaceError = \\\"Access denied. In a restricted collection you can only\\\" +\\n        \\\" update documents, not replace them. Use a Mongo update operator, such \\\" +\\n        \\\"as '$set'.\\\";\\n\\n  const mutatorKeys = Object.keys(mutator);\\n\\n  // compute modified fields\\n  const modifiedFields = {};\\n\\n  if (mutatorKeys.length === 0) {\\n    throw new Meteor.Error(403, noReplaceError);\\n  }\\n  mutatorKeys.forEach((op) => {\\n    const params = mutator[op];\\n    if (op.charAt(0) !== '$') {\\n      throw new Meteor.Error(403, noReplaceError);\\n    } else if (!hasOwn.call(ALLOWED_UPDATE_OPERATIONS, op)) {\\n      throw new Meteor.Error(\\n        403, \\\"Access denied. Operator \\\" + op + \\\" not allowed in a restricted collection.\\\");\\n    } else {\\n      Object.keys(params).forEach((field) => {\\n        // treat dotted fields as if they are replacing their\\n        // top-level part\\n        if (field.indexOf('.') !== -1)\\n          field = field.substring(0, field.indexOf('.'));\\n\\n        // record the field we are trying to change\\n        modifiedFields[field] = true;\\n      });\\n    }\\n  });\\n\\n  const fields = Object.keys(modifiedFields);\\n\\n  const findOptions = {transform: null};\\n  if (!self._validators.fetchAllFields) {\\n    findOptions.fields = {};\\n    self._validators.fetch.forEach((fieldName) => {\\n      findOptions.fields[fieldName] = 1;\\n    });\\n  }\\n\\n  const doc = await self._collection.findOneAsync(selector, findOptions);\\n  if (!doc)  // none satisfied!\\n    return 0;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (await asyncSome(self._validators.updateAsync.deny, async (validator) => {\\n    const factoriedDoc = transformDoc(validator, doc);\\n    const result = validator(userId,\\n      factoriedDoc,\\n      fields,\\n      mutator);\\n    return Meteor._isPromise(result) ? await result : result;\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (await asyncEvery(self._validators.updateAsync.allow, async (validator) => {\\n    const factoriedDoc = transformDoc(validator, doc);\\n    const result = validator(userId,\\n      factoriedDoc,\\n      fields,\\n      mutator);\\n    return !(Meteor._isPromise(result) ? await result : result);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  options._forbidReplace = true;\\n\\n  // Back when we supported arbitrary client-provided selectors, we actually\\n  // rewrote the selector to include an _id clause before passing to Mongo to\\n  // avoid races, but since selector is guaranteed to already just be an ID, we\\n  // don't have to any more.\\n\\n  return self._collection.updateAsync.call(\\n    self._collection, selector, mutator, options);\\n};\\n\\nCollectionPrototype._validatedUpdate = function(\\n    userId, selector, mutator, options) {\\n  const self = this;\\n\\n  check(mutator, Object);\\n\\n  options = Object.assign(Object.create(null), options);\\n\\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))\\n    throw new Error(\\\"validated update should be of a single ID\\\");\\n\\n  // We don't support upserts because they don't fit nicely into allow/deny\\n  // rules.\\n  if (options.upsert)\\n    throw new Meteor.Error(403, \\\"Access denied. Upserts not \\\" +\\n                           \\\"allowed in a restricted collection.\\\");\\n\\n  const noReplaceError = \\\"Access denied. In a restricted collection you can only\\\" +\\n        \\\" update documents, not replace them. Use a Mongo update operator, such \\\" +\\n        \\\"as '$set'.\\\";\\n\\n  const mutatorKeys = Object.keys(mutator);\\n\\n  // compute modified fields\\n  const modifiedFields = {};\\n\\n  if (mutatorKeys.length === 0) {\\n    throw new Meteor.Error(403, noReplaceError);\\n  }\\n  mutatorKeys.forEach((op) => {\\n    const params = mutator[op];\\n    if (op.charAt(0) !== '$') {\\n      throw new Meteor.Error(403, noReplaceError);\\n    } else if (!hasOwn.call(ALLOWED_UPDATE_OPERATIONS, op)) {\\n      throw new Meteor.Error(\\n        403, \\\"Access denied. Operator \\\" + op + \\\" not allowed in a restricted collection.\\\");\\n    } else {\\n      Object.keys(params).forEach((field) => {\\n        // treat dotted fields as if they are replacing their\\n        // top-level part\\n        if (field.indexOf('.') !== -1)\\n          field = field.substring(0, field.indexOf('.'));\\n\\n        // record the field we are trying to change\\n        modifiedFields[field] = true;\\n      });\\n    }\\n  });\\n\\n  const fields = Object.keys(modifiedFields);\\n\\n  const findOptions = {transform: null};\\n  if (!self._validators.fetchAllFields) {\\n    findOptions.fields = {};\\n    self._validators.fetch.forEach((fieldName) => {\\n      findOptions.fields[fieldName] = 1;\\n    });\\n  }\\n\\n  const doc = self._collection.findOne(selector, findOptions);\\n  if (!doc)  // none satisfied!\\n    return 0;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (self._validators.update.deny.some((validator) => {\\n    const factoriedDoc = transformDoc(validator, doc);\\n    return validator(userId,\\n                     factoriedDoc,\\n                     fields,\\n                     mutator);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (self._validators.update.allow.every((validator) => {\\n    const factoriedDoc = transformDoc(validator, doc);\\n    return !validator(userId,\\n                      factoriedDoc,\\n                      fields,\\n                      mutator);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  options._forbidReplace = true;\\n\\n  // Back when we supported arbitrary client-provided selectors, we actually\\n  // rewrote the selector to include an _id clause before passing to Mongo to\\n  // avoid races, but since selector is guaranteed to already just be an ID, we\\n  // don't have to any more.\\n\\n  return self._collection.update.call(\\n    self._collection, selector, mutator, options);\\n};\\n\\n// Only allow these operations in validated updates. Specifically\\n// whitelist operations, rather than blacklist, so new complex\\n// operations that are added aren't automatically allowed. A complex\\n// operation is one that does more than just modify its target\\n// field. For now this contains all update operations except '$rename'.\\n// http://docs.mongodb.org/manual/reference/operators/#update\\nconst ALLOWED_UPDATE_OPERATIONS = {\\n  $inc:1, $set:1, $unset:1, $addToSet:1, $pop:1, $pullAll:1, $pull:1,\\n  $pushAll:1, $push:1, $bit:1\\n};\\n\\n// Simulate a mongo `remove` operation while validating access control\\n// rules. See #ValidatedChange\\nCollectionPrototype._validatedRemoveAsync = async function(userId, selector) {\\n  const self = this;\\n\\n  const findOptions = {transform: null};\\n  if (!self._validators.fetchAllFields) {\\n    findOptions.fields = {};\\n    self._validators.fetch.forEach((fieldName) => {\\n      findOptions.fields[fieldName] = 1;\\n    });\\n  }\\n\\n  const doc = await self._collection.findOneAsync(selector, findOptions);\\n  if (!doc)\\n    return 0;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (await asyncSome(self._validators.removeAsync.deny, async (validator) => {\\n    const result = validator(userId, transformDoc(validator, doc));\\n    return Meteor._isPromise(result) ? await result : result;\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (await asyncEvery(self._validators.removeAsync.allow, async (validator) => {\\n    const result = validator(userId, transformDoc(validator, doc));\\n    return !(Meteor._isPromise(result) ? await result : result);\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  // Back when we supported arbitrary client-provided selectors, we actually\\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\\n  // Mongo to avoid races, but since selector is guaranteed to already just be\\n  // an ID, we don't have to any more.\\n\\n  return self._collection.removeAsync.call(self._collection, selector);\\n};\\n\\nCollectionPrototype._validatedRemove = function(userId, selector) {\\n  const self = this;\\n\\n  const findOptions = {transform: null};\\n  if (!self._validators.fetchAllFields) {\\n    findOptions.fields = {};\\n    self._validators.fetch.forEach((fieldName) => {\\n      findOptions.fields[fieldName] = 1;\\n    });\\n  }\\n\\n  const doc = self._collection.findOne(selector, findOptions);\\n  if (!doc)\\n    return 0;\\n\\n  // call user validators.\\n  // Any deny returns true means denied.\\n  if (self._validators.remove.deny.some((validator) => {\\n    return validator(userId, transformDoc(validator, doc));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n  // Any allow returns true means proceed. Throw error if they all fail.\\n  if (self._validators.remove.allow.every((validator) => {\\n    return !validator(userId, transformDoc(validator, doc));\\n  })) {\\n    throw new Meteor.Error(403, \\\"Access denied\\\");\\n  }\\n\\n  // Back when we supported arbitrary client-provided selectors, we actually\\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\\n  // Mongo to avoid races, but since selector is guaranteed to already just be\\n  // an ID, we don't have to any more.\\n\\n  return self._collection.remove.call(self._collection, selector);\\n};\\n\\nCollectionPrototype._callMutatorMethodAsync = function _callMutatorMethodAsync(name, args, options = {}) {\\n\\n  // For two out of three mutator methods, the first argument is a selector\\n  const firstArgIsSelector = name === \\\"updateAsync\\\" || name === \\\"removeAsync\\\";\\n  if (firstArgIsSelector && !alreadyInSimulation()) {\\n    // If we're about to actually send an RPC, we should throw an error if\\n    // this is a non-ID selector, because the mutation methods only allow\\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\\n    throwIfSelectorIsNotId(args[0], name);\\n  }\\n\\n  const mutatorMethodName = this._prefix + name;\\n  return this._connection.applyAsync(mutatorMethodName, args, {\\n    returnStubValue: this.resolverType === 'stub' || this.resolverType == null,\\n    // StubStream is only used for testing where you don't care about the server\\n    returnServerResultPromise: !this._connection._stream._isStub && this.resolverType !== 'stub',\\n    ...options,\\n  });\\n}\\n\\nCollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {\\n  if (Meteor.isClient && !callback && !alreadyInSimulation()) {\\n    // Client can't block, so it can't report errors by exception,\\n    // only by callback. If they forget the callback, give them a\\n    // default one that logs the error, so they aren't totally\\n    // baffled if their writes don't work because their database is\\n    // down.\\n    // Don't give a default callback in simulation, because inside stubs we\\n    // want to return the results from the local collection immediately and\\n    // not force a callback.\\n    callback = function (err) {\\n      if (err)\\n        Meteor._debug(name + \\\" failed\\\", err);\\n    };\\n  }\\n\\n  // For two out of three mutator methods, the first argument is a selector\\n  const firstArgIsSelector = name === \\\"update\\\" || name === \\\"remove\\\";\\n  if (firstArgIsSelector && !alreadyInSimulation()) {\\n    // If we're about to actually send an RPC, we should throw an error if\\n    // this is a non-ID selector, because the mutation methods only allow\\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\\n    throwIfSelectorIsNotId(args[0], name);\\n  }\\n\\n  const mutatorMethodName = this._prefix + name;\\n  return this._connection.apply(\\n    mutatorMethodName, args, { returnStubValue: true }, callback);\\n}\\n\\nfunction transformDoc(validator, doc) {\\n  if (validator.transform)\\n    return validator.transform(doc);\\n  return doc;\\n}\\n\\nfunction docToValidate(validator, doc, generatedId) {\\n  let ret = doc;\\n  if (validator.transform) {\\n    ret = EJSON.clone(doc);\\n    // If you set a server-side transform on your collection, then you don't get\\n    // to tell the difference between \\\"client specified the ID\\\" and \\\"server\\n    // generated the ID\\\", because transforms expect to get _id.  If you want to\\n    // do that check, you can do it with a specific\\n    // `C.allow({insertAsync: f, transform: null})` validator.\\n    if (generatedId !== null) {\\n      ret._id = generatedId;\\n    }\\n    ret = validator.transform(ret);\\n  }\\n  return ret;\\n}\\n\\nfunction addValidator(collection, allowOrDeny, options) {\\n  // validate keys\\n  const validKeysRegEx = /^(?:insertAsync|updateAsync|removeAsync|insert|update|remove|fetch|transform)$/;\\n  Object.keys(options).forEach((key) => {\\n    if (!validKeysRegEx.test(key))\\n      throw new Error(allowOrDeny + \\\": Invalid key: \\\" + key);\\n  });\\n\\n  collection._restricted = true;\\n\\n  [\\n    'insertAsync',\\n    'updateAsync',\\n    'removeAsync',\\n    'insert',\\n    'update',\\n    'remove',\\n  ].forEach(name => {\\n    if (hasOwn.call(options, name)) {\\n      if (!(options[name] instanceof Function)) {\\n        throw new Error(\\n          allowOrDeny + ': Value for `' + name + '` must be a function'\\n        );\\n      }\\n\\n      // If the transform is specified at all (including as 'null') in this\\n      // call, then take that; otherwise, take the transform from the\\n      // collection.\\n      if (options.transform === undefined) {\\n        options[name].transform = collection._transform; // already wrapped\\n      } else {\\n        options[name].transform = LocalCollection.wrapTransform(\\n          options.transform\\n        );\\n      }\\n      collection._validators[name][allowOrDeny].push(options[name]);\\n    }\\n  });\\n\\n  // Only updateAsync the fetch fields if we're passed things that affect\\n  // fetching. This way allow({}) and allow({insertAsync: f}) don't result in\\n  // setting fetchAllFields\\n  if (options.updateAsync || options.removeAsync || options.fetch) {\\n    if (options.fetch && !(options.fetch instanceof Array)) {\\n      throw new Error(allowOrDeny + \\\": Value for `fetch` must be an array\\\");\\n    }\\n    collection._updateFetch(options.fetch);\\n  }\\n}\\n\\nfunction throwIfSelectorIsNotId(selector, methodName) {\\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\\n    throw new Meteor.Error(\\n      403, \\\"Not permitted. Untrusted code may only \\\" + methodName +\\n        \\\" documents by ID.\\\");\\n  }\\n};\\n\\n// Determine if we are in a DDP method simulation\\nfunction alreadyInSimulation() {\\n  var CurrentInvocation =\\n    DDP._CurrentMethodInvocation ||\\n    // For backwards compatibility, as explained in this issue:\\n    // https://github.com/meteor/meteor/issues/8947\\n    DDP._CurrentInvocation;\\n\\n  const enclosing = CurrentInvocation.get();\\n  return enclosing && enclosing.isSimulation;\\n}\\n\",null],\"names\":[\"_objectSpread\",\"module\",\"link\",\"default\",\"v\",\"hasOwn\",\"Object\",\"prototype\",\"hasOwnProperty\",\"AllowDeny\",\"CollectionPrototype\",\"asyncSome\",\"array\",\"predicate\",\"item\",\"asyncEvery\",\"allow\",\"options\",\"addValidator\",\"deny\",\"_defineMutationMethods\",\"self\",\"_restricted\",\"_insecure\",\"undefined\",\"_validators\",\"insert\",\"update\",\"remove\",\"insertAsync\",\"updateAsync\",\"removeAsync\",\"upsertAsync\",\"fetch\",\"fetchAllFields\",\"_name\",\"_prefix\",\"_connection\",\"Meteor\",\"server\",\"isClient\",\"m\",\"forEach\",\"method\",\"methodName\",\"useExisting\",\"handlerPropName\",\"isInsert\",\"name\",\"includes\",\"check\",\"arguments\",\"Match\",\"Any\",\"args\",\"Array\",\"from\",\"generatedId\",\"call\",\"_makeNewID\",\"isSimulation\",\"_id\",\"_collection\",\"apply\",\"throwIfSelectorIsNotId\",\"length\",\"Error\",\"syncMethodName\",\"replace\",\"syncValidatedMethodName\",\"charAt\",\"toUpperCase\",\"slice\",\"validatedMethodName\",\"isServer\",\"unshift\",\"userId\",\"push\",\"_isInsecure\",\"syncMethodsMapper\",\"e\",\"toString\",\"methods\",\"_updateFetch\",\"fields\",\"union\",\"create\",\"add\",\"names\",\"keys\",\"Package\",\"insecure\",\"_validatedInsertAsync\",\"doc\",\"validator\",\"result\",\"docToValidate\",\"_isPromise\",\"_validatedInsert\",\"some\",\"every\",\"_validatedUpdateAsync\",\"selector\",\"mutator\",\"assign\",\"LocalCollection\",\"_selectorIsIdPerhapsAsObject\",\"upsert\",\"noReplaceError\",\"mutatorKeys\",\"modifiedFields\",\"op\",\"params\",\"ALLOWED_UPDATE_OPERATIONS\",\"field\",\"indexOf\",\"substring\",\"findOptions\",\"transform\",\"fieldName\",\"findOneAsync\",\"factoriedDoc\",\"transformDoc\",\"_forbidReplace\",\"_validatedUpdate\",\"findOne\",\"$inc\",\"$set\",\"$unset\",\"$addToSet\",\"$pop\",\"$pullAll\",\"$pull\",\"$pushAll\",\"$push\",\"$bit\",\"ret\",\"EJSON\",\"clone\",\"collection\",\"allowOrDeny\",\"validKeysRegEx\",\"key\",\"test\",\"Function\",\"_transform\",\"wrapTransform\",\"alreadyInSimulation\",\"CurrentInvocation\",\"DDP\",\"_CurrentMethodInvocation\",\"_CurrentInvocation\",\"enclosing\",\"get\",\"_validatedRemoveAsync\",\"_validatedRemove\",\"_callMutatorMethodAsync\",\"firstArgIsSelector\",\"mutatorMethodName\",\"applyAsync\",\"returnStubValue\",\"resolverType\",\"returnServerResultPromise\",\"_stream\",\"_isStub\",\"_callMutatorMethod\",\"callback\",\"err\",\"_debug\"],\"mappings\":\"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\"}"}